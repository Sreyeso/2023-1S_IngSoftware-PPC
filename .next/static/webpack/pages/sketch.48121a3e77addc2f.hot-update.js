"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/sketch",{

/***/ "./src/pages/classes/Level.tsx":
/*!*************************************!*\
  !*** ./src/pages/classes/Level.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Level; }\n/* harmony export */ });\n/* harmony import */ var _Tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tile */ \"./src/pages/classes/Tile.tsx\");\n\nconst DEBUG = true;\nclass Level {\n    createLayout() {\n        for(let i = 0; i < this.rows; i++){\n            let row = [];\n            for(let j = 0; j < this.cols; j++){\n                // get the code for the current tile\n                let code = this.rawLayout[i * this.cols + j];\n                let image;\n                // use the appropriate image for the tile based on its code\n                switch(code){\n                    case \"gra\":\n                        image = this.images[0];\n                        break;\n                    case \"dir\":\n                        image = this.images[1];\n                        break;\n                    case \"coi\":\n                        image = this.images[2];\n                        break;\n                    case \"gem\":\n                        image = this.images[3];\n                        break;\n                    case \"cll\":\n                        image = this.images[4];\n                        break;\n                    case \"clr\":\n                        image = this.images[5];\n                        break;\n                    case \"flo\":\n                        image = this.images[6];\n                        break;\n                    case \"psm\":\n                        image = this.images[7];\n                        break;\n                    case \"pbd\":\n                        image = this.images[8];\n                        break;\n                    case \"pbu\":\n                        image = this.images[9];\n                        break;\n                    case \"tsm\":\n                        image = this.images[10];\n                        break;\n                    case \"tbd\":\n                        image = this.images[11];\n                        break;\n                    case \"tbu\":\n                        image = this.images[12];\n                        break;\n                    case \"sto\":\n                        image = this.images[13];\n                        break;\n                    case \"spi\":\n                        image = this.images[14];\n                        break;\n                    case \"000\":\n                        image = this.images[15];\n                        break;\n                    default:\n                        image = this.images[16];\n                        break;\n                }\n                // create a new tile with the code and image\n                let tile = new _Tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"](code, image, this.p);\n                row.push(tile);\n            }\n            // add the row of tiles to the layout\n            this.layout.push(row);\n        }\n    }\n    draw(xOffset, yOffset, debug) {\n        this.p.push();\n        this.p.noStroke();\n        this.p.fill(\"lightskyblue\");\n        // draw the background of the level\n        this.p.rect(xOffset, yOffset, this.levelWidth, this.levelHeight);\n        this.p.pop();\n        // draw each tile in the layout\n        for(let i = 0; i < this.rows; i++){\n            for(let j = 0; j < this.cols; j++){\n                let x = xOffset + j * this.tile_size;\n                let y = yOffset + i * this.tile_size;\n                let tile = this.layout[i][j];\n                tile.draw(x, y, this.tile_size, debug);\n            }\n        }\n    }\n    constructor(rows, cols, rawlayout, tile_size, images, p){\n        this.handleCollisions = (player, xOffset, yOffset)=>{\n            // calculate the player's bounding box\n            let playerLeft = player.x;\n            let playerRight = player.x + player.width;\n            let playerTop = player.y;\n            let playerBottom = player.y + player.height;\n            // add the player's velocity to their position\n            let newPlayerLeft = playerLeft + player.vx;\n            let newPlayerRight = playerRight + player.vx;\n            let newPlayerTop = playerTop + player.vy;\n            let newPlayerBottom = playerBottom + player.vy;\n            let tileLeft;\n            let tileRight;\n            let tileTop;\n            let tileBottom;\n            // loop through the grid array and check for collisions\n            for(let i = 0; i < this.rows; i++){\n                for(let j = 0; j < this.cols; j++){\n                    switch(this.layout[i][j].code){\n                        case \"gra\":\n                        case \"sto\":\n                            // calculate the bounding box of the tile with a buffer \n                            tileLeft = xOffset + j * this.tile_size;\n                            tileRight = xOffset + (j + 1) * this.tile_size;\n                            tileTop = yOffset + i * this.tile_size;\n                            tileBottom = yOffset + (i + 1) * this.tile_size;\n                            // check if the player's bounding box overlaps with the tile's bounding box\n                            if (newPlayerLeft < tileRight && newPlayerRight > tileLeft && newPlayerTop < tileBottom && newPlayerBottom > tileTop) {\n                                let overlapLeft = Math.max(newPlayerLeft, tileLeft);\n                                let overlapRight = Math.min(newPlayerRight, tileRight);\n                                let overlapTop = Math.max(newPlayerTop, tileTop);\n                                let overlapBottom = Math.min(newPlayerBottom, tileBottom);\n                                let overlapWidth = overlapRight - overlapLeft;\n                                let overlapHeight = overlapBottom - overlapTop;\n                                // determine the direction of the collision\n                                let direction;\n                                //DEBUG\n                                if (DEBUG) console.log(\"OW: \" + overlapWidth);\n                                if (DEBUG) console.log(\"OH: \" + overlapHeight);\n                                if (DEBUG) console.log(\"Nya\");\n                                if (DEBUG) console.log(\"\");\n                                if (overlapWidth < overlapHeight) {\n                                    direction = overlapLeft < newPlayerLeft ? \"left\" : \"right\";\n                                } else {\n                                    direction = overlapTop < newPlayerTop ? \"up\" : \"down\";\n                                }\n                                // adjust the player's position based on the overlap and direction of the collision\n                                switch(direction){\n                                    case \"left\":\n                                        if (DEBUG) console.log(\"Nya\");\n                                        player.x += overlapWidth - player.vx;\n                                        break;\n                                    case \"right\":\n                                        if (DEBUG) console.log(\"Goode\");\n                                        player.x -= overlapWidth - player.vx;\n                                        break;\n                                    case \"up\":\n                                        if (DEBUG) console.log(\"Bure\");\n                                        player.y += overlapHeight - player.vy;\n                                        break;\n                                    case \"down\":\n                                        player.y -= overlapHeight - player.vy;\n                                        player.jumps = 2;\n                                        player.vy = 0; // reset the player's vertical velocity\n                                        break;\n                                }\n                            }\n                            break;\n                        case \"spi\":\n                            // calculate the bounding box of the tile\n                            tileLeft = xOffset + j * this.tile_size;\n                            tileRight = xOffset + (j + 1) * this.tile_size;\n                            tileTop = yOffset + i * this.tile_size + 0.28 * this.tile_size;\n                            tileBottom = yOffset + (i + 1) * this.tile_size;\n                            // check if the player's bounding box overlaps with the tile's bounding box\n                            if (newPlayerLeft < tileRight && newPlayerRight > tileLeft && newPlayerTop < tileBottom && newPlayerBottom > tileTop) {\n                                // there is a collision!\n                                // reset the player's position to their previous position\n                                let overlapLeft = Math.max(newPlayerLeft, tileLeft);\n                                let overlapRight = Math.min(newPlayerRight, tileRight);\n                                let overlapTop = Math.max(newPlayerTop, tileTop);\n                                let overlapBottom = Math.min(newPlayerBottom, tileBottom);\n                                let overlapWidth = overlapRight - overlapLeft;\n                                let overlapHeight = overlapBottom - overlapTop;\n                                // determine the direction of the collision\n                                let direction;\n                                if (overlapWidth < overlapHeight) {\n                                    direction = overlapLeft < newPlayerLeft ? \"left\" : \"right\";\n                                } else {\n                                    direction = overlapTop < newPlayerTop ? \"up\" : \"down\";\n                                }\n                                // adjust the player's position based on the overlap and direction of the collision\n                                switch(direction){\n                                    case \"left\":\n                                        player.x += overlapWidth - player.vx;\n                                        break;\n                                    case \"right\":\n                                        player.x -= overlapWidth - player.vx;\n                                        break;\n                                    case \"up\":\n                                        player.y += overlapHeight - player.vy;\n                                        break;\n                                    case \"down\":\n                                        player.y -= overlapHeight - player.vy;\n                                        player.vy = 0; // reset the player's vertical velocity\n                                        break;\n                                }\n                                /* Death triggers */ player.isAlive = false;\n                            }\n                            break;\n                        case \"coi\":\n                        case \"gem\":\n                            // calculate the center and radius of the ellipse\n                            let centerX = xOffset + j * this.tile_size + this.tile_size * 0.5;\n                            let centerY = yOffset + i * this.tile_size + this.tile_size * 0.5;\n                            let radiusX = this.tile_size * 0.35;\n                            let radiusY = this.tile_size * 0.35;\n                            // check if the player's bounding box overlaps with the tile's ellipse\n                            if (playerLeft < centerX + radiusX && playerRight > centerX - radiusX && playerTop < centerY + radiusY && playerBottom > centerY - radiusY) {\n                                this.layout[i][j].code = \"000\";\n                                this.layout[i][j].image = this.images[15];\n                            }\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n        };\n        this.rows = rows;\n        this.cols = cols;\n        this.rawLayout = rawlayout;\n        this.tile_size = tile_size;\n        this.layout = [];\n        this.p = p;\n        this.images = images;\n        this.levelWidth = this.cols * this.tile_size;\n        this.levelHeight = this.rows * this.tile_size;\n        // create the layout\n        this.createLayout();\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SSxDQUFDdUIsU0FBUztRQUU3QyxvQkFBb0I7UUFDcEIsSUFBSSxDQUFDekIsWUFBWTtJQUNuQjtBQWdORjtBQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9wYWdlcy9jbGFzc2VzL0xldmVsLnRzeD8zMzk3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwNSBmcm9tICdwNSc7XG5pbXBvcnQgVGlsZSBmcm9tICcuL1RpbGUnO1xuaW1wb3J0IFBsYXllciBmcm9tICcuL1BsYXllcic7XG5jb25zdCBERUJVRyA9IHRydWU7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZXZlbCB7XG4gIHJvd3M6IG51bWJlcjtcbiAgY29sczogbnVtYmVyO1xuICByYXdMYXlvdXQ6IHN0cmluZ1tdO1xuICB0aWxlX3NpemU6IG51bWJlcjtcbiAgbGF5b3V0OiBUaWxlW11bXTtcbiAgcDogcDU7XG4gIGltYWdlczogYW55W107XG4gIGxldmVsV2lkdGg6IG51bWJlcjtcbiAgbGV2ZWxIZWlnaHQ6IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihyb3dzOiBudW1iZXIsIGNvbHM6IG51bWJlciwgcmF3bGF5b3V0OiBzdHJpbmdbXSwgdGlsZV9zaXplOiBudW1iZXIsIGltYWdlczogYW55W10sIHA6IHA1KSB7XG4gICAgdGhpcy5yb3dzID0gcm93cztcbiAgICB0aGlzLmNvbHMgPSBjb2xzO1xuICAgIHRoaXMucmF3TGF5b3V0ID0gcmF3bGF5b3V0OyBcbiAgICB0aGlzLnRpbGVfc2l6ZSA9IHRpbGVfc2l6ZTtcbiAgICB0aGlzLmxheW91dCA9IFtdOyBcbiAgICB0aGlzLnAgPSBwO1xuICAgIHRoaXMuaW1hZ2VzID0gaW1hZ2VzO1xuICAgIHRoaXMubGV2ZWxXaWR0aCA9IHRoaXMuY29scyAqIHRoaXMudGlsZV9zaXplO1xuICAgIHRoaXMubGV2ZWxIZWlnaHQgPSB0aGlzLnJvd3MgKiB0aGlzLnRpbGVfc2l6ZTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgbGF5b3V0XG4gICAgdGhpcy5jcmVhdGVMYXlvdXQoKTtcbiAgfVxuXG4gIGNyZWF0ZUxheW91dCgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBsZXQgcm93ID0gW107XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sczsgaisrKSB7XG4gICAgICAgIC8vIGdldCB0aGUgY29kZSBmb3IgdGhlIGN1cnJlbnQgdGlsZVxuICAgICAgICBsZXQgY29kZSA9IHRoaXMucmF3TGF5b3V0W2kgKiB0aGlzLmNvbHMgKyBqXTtcbiAgICAgICAgbGV0IGltYWdlO1xuXG4gICAgICAgIC8vIHVzZSB0aGUgYXBwcm9wcmlhdGUgaW1hZ2UgZm9yIHRoZSB0aWxlIGJhc2VkIG9uIGl0cyBjb2RlXG4gICAgICAgIHN3aXRjaChjb2RlKXtcbiAgICAgICAgICBjYXNlKFwiZ3JhXCIpOiBpbWFnZT10aGlzLmltYWdlc1swXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZShcImRpclwiKTogaW1hZ2U9dGhpcy5pbWFnZXNbMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UoXCJjb2lcIik6IGltYWdlPXRoaXMuaW1hZ2VzWzJdOyBicmVhaztcbiAgICAgICAgICBjYXNlKFwiZ2VtXCIpOiBpbWFnZT10aGlzLmltYWdlc1szXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZShcImNsbFwiKTogaW1hZ2U9dGhpcy5pbWFnZXNbNF07IGJyZWFrO1xuICAgICAgICAgIGNhc2UoXCJjbHJcIik6IGltYWdlPXRoaXMuaW1hZ2VzWzVdOyBicmVhaztcbiAgICAgICAgICBjYXNlKFwiZmxvXCIpOiBpbWFnZT10aGlzLmltYWdlc1s2XTsgYnJlYWs7XG4gICAgICAgICAgY2FzZShcInBzbVwiKTogaW1hZ2U9dGhpcy5pbWFnZXNbN107IGJyZWFrO1xuICAgICAgICAgIGNhc2UoXCJwYmRcIik6IGltYWdlPXRoaXMuaW1hZ2VzWzhdOyBicmVhaztcbiAgICAgICAgICBjYXNlKFwicGJ1XCIpOiBpbWFnZT10aGlzLmltYWdlc1s5XTsgYnJlYWs7XG4gICAgICAgICAgY2FzZShcInRzbVwiKTogaW1hZ2U9dGhpcy5pbWFnZXNbMTBdOyBicmVhaztcbiAgICAgICAgICBjYXNlKFwidGJkXCIpOiBpbWFnZT10aGlzLmltYWdlc1sxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UoXCJ0YnVcIik6IGltYWdlPXRoaXMuaW1hZ2VzWzEyXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZShcInN0b1wiKTogaW1hZ2U9dGhpcy5pbWFnZXNbMTNdOyBicmVhaztcbiAgICAgICAgICBjYXNlKFwic3BpXCIpOiBpbWFnZT10aGlzLmltYWdlc1sxNF07IGJyZWFrO1xuICAgICAgICAgIGNhc2UoXCIwMDBcIik6IGltYWdlPXRoaXMuaW1hZ2VzWzE1XTsgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDogaW1hZ2U9dGhpcy5pbWFnZXNbMTZdOyBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IHRpbGUgd2l0aCB0aGUgY29kZSBhbmQgaW1hZ2VcbiAgICAgICAgbGV0IHRpbGUgPSBuZXcgVGlsZShjb2RlLCBpbWFnZSwgdGhpcy5wKTtcbiAgICAgICAgcm93LnB1c2godGlsZSk7XG4gICAgICB9XG4gICAgICAvLyBhZGQgdGhlIHJvdyBvZiB0aWxlcyB0byB0aGUgbGF5b3V0XG4gICAgICB0aGlzLmxheW91dC5wdXNoKHJvdyk7XG4gICAgfVxuICB9XG5cbiAgZHJhdyh4T2Zmc2V0OiBudW1iZXIsIHlPZmZzZXQ6IG51bWJlcixkZWJ1Zzpib29sZWFuKSB7XG4gICAgdGhpcy5wLnB1c2goKTtcbiAgICAgIHRoaXMucC5ub1N0cm9rZSgpO1xuICAgICAgdGhpcy5wLmZpbGwoXCJsaWdodHNreWJsdWVcIik7XG4gICAgLy8gZHJhdyB0aGUgYmFja2dyb3VuZCBvZiB0aGUgbGV2ZWxcbiAgICAgIHRoaXMucC5yZWN0KHhPZmZzZXQsIHlPZmZzZXQsIHRoaXMubGV2ZWxXaWR0aCwgdGhpcy5sZXZlbEhlaWdodCk7XG4gICAgdGhpcy5wLnBvcCgpO1xuICAgIC8vIGRyYXcgZWFjaCB0aWxlIGluIHRoZSBsYXlvdXRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sczsgaisrKSB7XG4gICAgICAgIGxldCB4ID0geE9mZnNldCArIChqICogdGhpcy50aWxlX3NpemUpO1xuICAgICAgICBsZXQgeSA9IHlPZmZzZXQgKyAoaSAqIHRoaXMudGlsZV9zaXplKTtcbiAgICAgICAgbGV0IHRpbGUgPSB0aGlzLmxheW91dFtpXVtqXTtcbiAgICAgICAgdGlsZS5kcmF3KHgsIHksIHRoaXMudGlsZV9zaXplLGRlYnVnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVDb2xsaXNpb25zPSAocGxheWVyOlBsYXllcix4T2Zmc2V0Om51bWJlcix5T2Zmc2V0Om51bWJlcikgPT4ge1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgcGxheWVyJ3MgYm91bmRpbmcgYm94XG4gICAgbGV0IHBsYXllckxlZnQgPSBwbGF5ZXIueDtcbiAgICBsZXQgcGxheWVyUmlnaHQgPSBwbGF5ZXIueCArIHBsYXllci53aWR0aDtcbiAgICBsZXQgcGxheWVyVG9wID0gcGxheWVyLnk7XG4gICAgbGV0IHBsYXllckJvdHRvbSA9IHBsYXllci55ICsgcGxheWVyLmhlaWdodDtcblxuICAgIC8vIGFkZCB0aGUgcGxheWVyJ3MgdmVsb2NpdHkgdG8gdGhlaXIgcG9zaXRpb25cbiAgICBsZXQgbmV3UGxheWVyTGVmdCA9IHBsYXllckxlZnQgKyBwbGF5ZXIudng7XG4gICAgbGV0IG5ld1BsYXllclJpZ2h0ID0gcGxheWVyUmlnaHQgKyBwbGF5ZXIudng7XG4gICAgbGV0IG5ld1BsYXllclRvcCA9IHBsYXllclRvcCArIHBsYXllci52eTtcbiAgICBsZXQgbmV3UGxheWVyQm90dG9tID0gcGxheWVyQm90dG9tICsgcGxheWVyLnZ5O1xuXG4gICAgbGV0IHRpbGVMZWZ0IDtcbiAgICBsZXQgdGlsZVJpZ2h0O1xuICAgIGxldCB0aWxlVG9wO1xuICAgIGxldCB0aWxlQm90dG9tO1xuICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgZ3JpZCBhcnJheSBhbmQgY2hlY2sgZm9yIGNvbGxpc2lvbnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sczsgaisrKSB7XG5cbiAgICAgICAgc3dpdGNoKHRoaXMubGF5b3V0W2ldW2pdLmNvZGUpe1xuXG4gICAgICAgICAgY2FzZShcImdyYVwiKTogXG4gICAgICAgICAgY2FzZShcInN0b1wiKTpcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSB0aWxlIHdpdGggYSBidWZmZXIgXG4gICAgICAgICAgICB0aWxlTGVmdCA9IHhPZmZzZXQgKyAoaiAqIHRoaXMudGlsZV9zaXplKTtcbiAgICAgICAgICAgIHRpbGVSaWdodCA9IHhPZmZzZXQgKygoaisxKSAqIHRoaXMudGlsZV9zaXplKTtcbiAgICAgICAgICAgIHRpbGVUb3AgPSB5T2Zmc2V0KyAoaSAqIHRoaXMudGlsZV9zaXplKTtcbiAgICAgICAgICAgIHRpbGVCb3R0b20gPSB5T2Zmc2V0KygoaSsxKSAqIHRoaXMudGlsZV9zaXplKTtcbiAgICBcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBwbGF5ZXIncyBib3VuZGluZyBib3ggb3ZlcmxhcHMgd2l0aCB0aGUgdGlsZSdzIGJvdW5kaW5nIGJveFxuICAgICAgICAgICAgaWYgKG5ld1BsYXllckxlZnQgPCB0aWxlUmlnaHQgJiYgbmV3UGxheWVyUmlnaHQgPiB0aWxlTGVmdCAmJiBuZXdQbGF5ZXJUb3AgPCB0aWxlQm90dG9tICYmIG5ld1BsYXllckJvdHRvbSA+IHRpbGVUb3ApIHtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICBsZXQgb3ZlcmxhcExlZnQgPSBNYXRoLm1heChuZXdQbGF5ZXJMZWZ0LCB0aWxlTGVmdCk7XG4gICAgICAgICAgICAgICAgICBsZXQgb3ZlcmxhcFJpZ2h0ID0gTWF0aC5taW4obmV3UGxheWVyUmlnaHQsIHRpbGVSaWdodCk7XG4gICAgICAgICAgICAgICAgICBsZXQgb3ZlcmxhcFRvcCA9IE1hdGgubWF4KG5ld1BsYXllclRvcCwgdGlsZVRvcCk7XG4gICAgICAgICAgICAgICAgICBsZXQgb3ZlcmxhcEJvdHRvbSA9IE1hdGgubWluKG5ld1BsYXllckJvdHRvbSwgdGlsZUJvdHRvbSk7XG4gICAgICAgICAgICAgICAgICBsZXQgb3ZlcmxhcFdpZHRoID0gb3ZlcmxhcFJpZ2h0IC0gb3ZlcmxhcExlZnQ7XG4gICAgICAgICAgICAgICAgICBsZXQgb3ZlcmxhcEhlaWdodCA9IG92ZXJsYXBCb3R0b20gLSBvdmVybGFwVG9wO1xuXG4gICAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIGRpcmVjdGlvbiBvZiB0aGUgY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgICBsZXQgZGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvL0RFQlVHXG4gICAgICAgICAgICAgICAgICBpZiAoREVCVUcpIGNvbnNvbGUubG9nKCdPVzogJytvdmVybGFwV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgaWYgKERFQlVHKSBjb25zb2xlLmxvZygnT0g6ICcrb3ZlcmxhcEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICBpZiAoREVCVUcpIGNvbnNvbGUubG9nKCdOeWEnKTtcbiAgICAgICAgICAgICAgICAgIGlmIChERUJVRykgY29uc29sZS5sb2coJycpO1xuXG5cbiAgICAgICAgICAgICAgICAgIGlmIChvdmVybGFwV2lkdGggPCBvdmVybGFwSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IG92ZXJsYXBMZWZ0IDwgbmV3UGxheWVyTGVmdCA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gb3ZlcmxhcFRvcCA8IG5ld1BsYXllclRvcCA/IFwidXBcIiA6IFwiZG93blwiO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWRqdXN0IHRoZSBwbGF5ZXIncyBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgb3ZlcmxhcCBhbmQgZGlyZWN0aW9uIG9mIHRoZSBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKERFQlVHKSBjb25zb2xlLmxvZygnTnlhJyk7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci54ICs9IG92ZXJsYXBXaWR0aCAtIHBsYXllci52eDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKERFQlVHKSBjb25zb2xlLmxvZygnR29vZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLnggLT0gb3ZlcmxhcFdpZHRoIC0gcGxheWVyLnZ4O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1cFwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoREVCVUcpIGNvbnNvbGUubG9nKCdCdXJlJyk7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci55ICs9IG92ZXJsYXBIZWlnaHQgLSBwbGF5ZXIudnk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImRvd25cIjpcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLnkgLT0gb3ZlcmxhcEhlaWdodCAtIHBsYXllci52eTtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLmp1bXBzPTI7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci52eSA9IDA7IC8vIHJlc2V0IHRoZSBwbGF5ZXIncyB2ZXJ0aWNhbCB2ZWxvY2l0eVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlKFwic3BpXCIpOlxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHRpbGVcbiAgICAgICAgICAgIHRpbGVMZWZ0ID0geE9mZnNldCArIChqICogdGhpcy50aWxlX3NpemUpO1xuICAgICAgICAgICAgdGlsZVJpZ2h0ID0gIHhPZmZzZXQgKygoaisxKSAqIHRoaXMudGlsZV9zaXplKTtcbiAgICAgICAgICAgIHRpbGVUb3AgPSB5T2Zmc2V0KyAoaSAqIHRoaXMudGlsZV9zaXplKSsoMC4yOCp0aGlzLnRpbGVfc2l6ZSk7XG4gICAgICAgICAgICB0aWxlQm90dG9tID0geU9mZnNldCsoKGkrMSkgKiB0aGlzLnRpbGVfc2l6ZSk7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBwbGF5ZXIncyBib3VuZGluZyBib3ggb3ZlcmxhcHMgd2l0aCB0aGUgdGlsZSdzIGJvdW5kaW5nIGJveFxuICAgICAgICAgICAgaWYgKG5ld1BsYXllckxlZnQgPCB0aWxlUmlnaHQgJiYgbmV3UGxheWVyUmlnaHQgPiB0aWxlTGVmdCAmJiBuZXdQbGF5ZXJUb3AgPCB0aWxlQm90dG9tICYmIG5ld1BsYXllckJvdHRvbSA+IHRpbGVUb3ApIHtcbiAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgYSBjb2xsaXNpb24hXG4gICAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBwbGF5ZXIncyBwb3NpdGlvbiB0byB0aGVpciBwcmV2aW91cyBwb3NpdGlvblxuICAgICAgICAgICAgICAgIGxldCBvdmVybGFwTGVmdCA9IE1hdGgubWF4KG5ld1BsYXllckxlZnQsIHRpbGVMZWZ0KTtcbiAgICAgICAgICAgICAgICBsZXQgb3ZlcmxhcFJpZ2h0ID0gTWF0aC5taW4obmV3UGxheWVyUmlnaHQsIHRpbGVSaWdodCk7XG4gICAgICAgICAgICAgICAgbGV0IG92ZXJsYXBUb3AgPSBNYXRoLm1heChuZXdQbGF5ZXJUb3AsIHRpbGVUb3ApO1xuICAgICAgICAgICAgICAgIGxldCBvdmVybGFwQm90dG9tID0gTWF0aC5taW4obmV3UGxheWVyQm90dG9tLCB0aWxlQm90dG9tKTtcbiAgICAgICAgICAgICAgICBsZXQgb3ZlcmxhcFdpZHRoID0gb3ZlcmxhcFJpZ2h0IC0gb3ZlcmxhcExlZnQ7XG4gICAgICAgICAgICAgICAgbGV0IG92ZXJsYXBIZWlnaHQgPSBvdmVybGFwQm90dG9tIC0gb3ZlcmxhcFRvcDtcbiAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICBsZXQgZGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChvdmVybGFwV2lkdGggPCBvdmVybGFwSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBvdmVybGFwTGVmdCA8IG5ld1BsYXllckxlZnQgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gb3ZlcmxhcFRvcCA8IG5ld1BsYXllclRvcCA/IFwidXBcIiA6IFwiZG93blwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFkanVzdCB0aGUgcGxheWVyJ3MgcG9zaXRpb24gYmFzZWQgb24gdGhlIG92ZXJsYXAgYW5kIGRpcmVjdGlvbiBvZiB0aGUgY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci54ICs9IG92ZXJsYXBXaWR0aCAtIHBsYXllci52eDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLnggLT0gb3ZlcmxhcFdpZHRoIC0gcGxheWVyLnZ4O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1cFwiOlxuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIueSArPSBvdmVybGFwSGVpZ2h0IC0gcGxheWVyLnZ5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkb3duXCI6XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci55IC09IG92ZXJsYXBIZWlnaHQgLSBwbGF5ZXIudnk7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci52eSA9IDA7IC8vIHJlc2V0IHRoZSBwbGF5ZXIncyB2ZXJ0aWNhbCB2ZWxvY2l0eVxuICBcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKiBEZWF0aCB0cmlnZ2VycyAqL1xuICAgICAgICAgICAgICBwbGF5ZXIuaXNBbGl2ZT1mYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICBcbiAgICAgICAgICBjYXNlKFwiY29pXCIpOlxuICAgICAgICAgIGNhc2UoXCJnZW1cIik6XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGNlbnRlciBhbmQgcmFkaXVzIG9mIHRoZSBlbGxpcHNlXG4gICAgICAgICAgICBsZXQgY2VudGVyWCA9IHhPZmZzZXQgKyAoaiAqIHRoaXMudGlsZV9zaXplKSArICh0aGlzLnRpbGVfc2l6ZSAqIDAuNSk7XG4gICAgICAgICAgICBsZXQgY2VudGVyWSA9IHlPZmZzZXQrIChpICogdGhpcy50aWxlX3NpemUpICsgKHRoaXMudGlsZV9zaXplICogMC41KTtcbiAgICAgICAgICAgIGxldCByYWRpdXNYID0gdGhpcy50aWxlX3NpemUgKiAwLjM1O1xuICAgICAgICAgICAgbGV0IHJhZGl1c1kgPSB0aGlzLnRpbGVfc2l6ZSAqIDAuMzU7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBwbGF5ZXIncyBib3VuZGluZyBib3ggb3ZlcmxhcHMgd2l0aCB0aGUgdGlsZSdzIGVsbGlwc2VcbiAgICAgICAgICAgIGlmIChwbGF5ZXJMZWZ0IDwgY2VudGVyWCArIHJhZGl1c1ggJiYgcGxheWVyUmlnaHQgPiBjZW50ZXJYIC0gcmFkaXVzWCAmJiBwbGF5ZXJUb3AgPCBjZW50ZXJZICsgcmFkaXVzWSAmJiBwbGF5ZXJCb3R0b20gPiBjZW50ZXJZIC0gcmFkaXVzWSkge1xuICAgICAgICAgICAgICB0aGlzLmxheW91dFtpXVtqXS5jb2RlPVwiMDAwXCI7XG4gICAgICAgICAgICAgIHRoaXMubGF5b3V0W2ldW2pdLmltYWdlPXRoaXMuaW1hZ2VzWzE1XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICBcbiAgICAgICAgICBkZWZhdWx0OiAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuIl0sIm5hbWVzIjpbIlRpbGUiLCJERUJVRyIsIkxldmVsIiwiY3JlYXRlTGF5b3V0IiwiaSIsInJvd3MiLCJyb3ciLCJqIiwiY29scyIsImNvZGUiLCJyYXdMYXlvdXQiLCJpbWFnZSIsImltYWdlcyIsInRpbGUiLCJwIiwicHVzaCIsImxheW91dCIsImRyYXciLCJ4T2Zmc2V0IiwieU9mZnNldCIsImRlYnVnIiwibm9TdHJva2UiLCJmaWxsIiwicmVjdCIsImxldmVsV2lkdGgiLCJsZXZlbEhlaWdodCIsInBvcCIsIngiLCJ0aWxlX3NpemUiLCJ5IiwiY29uc3RydWN0b3IiLCJyYXdsYXlvdXQiLCJoYW5kbGVDb2xsaXNpb25zIiwicGxheWVyIiwicGxheWVyTGVmdCIsInBsYXllclJpZ2h0Iiwid2lkdGgiLCJwbGF5ZXJUb3AiLCJwbGF5ZXJCb3R0b20iLCJoZWlnaHQiLCJuZXdQbGF5ZXJMZWZ0IiwidngiLCJuZXdQbGF5ZXJSaWdodCIsIm5ld1BsYXllclRvcCIsInZ5IiwibmV3UGxheWVyQm90dG9tIiwidGlsZUxlZnQiLCJ0aWxlUmlnaHQiLCJ0aWxlVG9wIiwidGlsZUJvdHRvbSIsIm92ZXJsYXBMZWZ0IiwiTWF0aCIsIm1heCIsIm92ZXJsYXBSaWdodCIsIm1pbiIsIm92ZXJsYXBUb3AiLCJvdmVybGFwQm90dG9tIiwib3ZlcmxhcFdpZHRoIiwib3ZlcmxhcEhlaWdodCIsImRpcmVjdGlvbiIsImNvbnNvbGUiLCJsb2ciLCJqdW1wcyIsImlzQWxpdmUiLCJjZW50ZXJYIiwiY2VudGVyWSIsInJhZGl1c1giLCJyYWRpdXNZIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pages/classes/Level.tsx\n"));

/***/ })

});