/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/sketch"],{

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Fmichelangelo%2FDocuments%2FIngesoft%2F2023-1S_IngSoftware-PPC%2Fsrc%2Fpages%2Fsketch.tsx&page=%2Fsketch!":
/*!**********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Fmichelangelo%2FDocuments%2FIngesoft%2F2023-1S_IngSoftware-PPC%2Fsrc%2Fpages%2Fsketch.tsx&page=%2Fsketch! ***!
  \**********************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/sketch\",\n      function () {\n        return __webpack_require__(/*! ./src/pages/sketch.tsx */ \"./src/pages/sketch.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/sketch\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD0lMkZob21lJTJGbWljaGVsYW5nZWxvJTJGRG9jdW1lbnRzJTJGSW5nZXNvZnQlMkYyMDIzLTFTX0luZ1NvZnR3YXJlLVBQQyUyRnNyYyUyRnBhZ2VzJTJGc2tldGNoLnRzeCZwYWdlPSUyRnNrZXRjaCEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxzREFBd0I7QUFDL0M7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvP2MwODMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9za2V0Y2hcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCIuL3NyYy9wYWdlcy9za2V0Y2gudHN4XCIpO1xuICAgICAgfVxuICAgIF0pO1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5wdXNoKFtcIi9za2V0Y2hcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Fmichelangelo%2FDocuments%2FIngesoft%2F2023-1S_IngSoftware-PPC%2Fsrc%2Fpages%2Fsketch.tsx&page=%2Fsketch!\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/dynamic.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/dynamic.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = dynamic;\nexports.noSSR = noSSR;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _loadable = _interop_require_default(__webpack_require__(/*! ./loadable */ \"./node_modules/next/dist/shared/lib/loadable.js\"));\nfunction dynamic(dynamicOptions, options) {\n    let loadableFn = _loadable.default;\n    let loadableOptions = {\n        // A loading component is not required, so we default it\n        loading: (param)=>{\n            let { error , isLoading , pastDelay  } = param;\n            if (!pastDelay) return null;\n            if (true) {\n                if (isLoading) {\n                    return null;\n                }\n                if (error) {\n                    return /*#__PURE__*/ _react.default.createElement(\"p\", null, error.message, /*#__PURE__*/ _react.default.createElement(\"br\", null), error.stack);\n                }\n            }\n            return null;\n        }\n    };\n    // Support for direct import(), eg: dynamic(import('../hello-world'))\n    // Note that this is only kept for the edge case where someone is passing in a promise as first argument\n    // The react-loadable babel plugin will turn dynamic(import('../hello-world')) into dynamic(() => import('../hello-world'))\n    // To make sure we don't execute the import without rendering first\n    if (dynamicOptions instanceof Promise) {\n        loadableOptions.loader = ()=>dynamicOptions;\n    // Support for having import as a function, eg: dynamic(() => import('../hello-world'))\n    } else if (typeof dynamicOptions === \"function\") {\n        loadableOptions.loader = dynamicOptions;\n    // Support for having first argument being options, eg: dynamic({loader: import('../hello-world')})\n    } else if (typeof dynamicOptions === \"object\") {\n        loadableOptions = _extends({}, loadableOptions, dynamicOptions);\n    }\n    // Support for passing options, eg: dynamic(import('../hello-world'), {loading: () => <p>Loading something</p>})\n    loadableOptions = _extends({}, loadableOptions, options);\n    const loaderFn = loadableOptions.loader;\n    const loader = ()=>loaderFn != null ? loaderFn().then(convertModule) : Promise.resolve(convertModule(()=>null));\n    // coming from build/babel/plugins/react-loadable-plugin.js\n    if (loadableOptions.loadableGenerated) {\n        loadableOptions = _extends({}, loadableOptions, loadableOptions.loadableGenerated);\n        delete loadableOptions.loadableGenerated;\n    }\n    // support for disabling server side rendering, eg: dynamic(() => import('../hello-world'), {ssr: false}).\n    if (typeof loadableOptions.ssr === \"boolean\" && !loadableOptions.ssr) {\n        delete loadableOptions.webpack;\n        delete loadableOptions.modules;\n        return noSSR(loadableFn, loadableOptions);\n    }\n    return loadableFn(_extends({}, loadableOptions, {\n        loader: loader\n    }));\n}\nconst isServerSide = \"object\" === \"undefined\";\n// Normalize loader to return the module as form { default: Component } for `React.lazy`.\n// Also for backward compatible since next/dynamic allows to resolve a component directly with loader\n// Client component reference proxy need to be converted to a module.\nfunction convertModule(mod) {\n    var ref;\n    return {\n        default: ((ref = mod) == null ? void 0 : ref.default) || mod\n    };\n}\nfunction noSSR(LoadableInitializer, loadableOptions) {\n    // Removing webpack and modules means react-loadable won't try preloading\n    delete loadableOptions.webpack;\n    delete loadableOptions.modules;\n    // This check is necessary to prevent react-loadable from initializing on the server\n    if (!isServerSide) {\n        return LoadableInitializer(loadableOptions);\n    }\n    const Loading = loadableOptions.loading;\n    // This will only be rendered on the server side\n    return ()=>/*#__PURE__*/ _react.default.createElement(Loading, {\n            error: null,\n            isLoading: true,\n            pastDelay: false,\n            timedOut: false\n        });\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvZHluYW1pYy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHRztBQUNsQkgsYUFBYSxHQUFHSTtBQUNoQixJQUFJQyxXQUFXQyxtSEFBK0M7QUFDOUQsSUFBSUMsMkJBQTJCRCxtSkFBK0Q7QUFDOUYsSUFBSUUsU0FBU0QseUJBQXlCRCxtQkFBT0EsQ0FBQyw0Q0FBTztBQUNyRCxJQUFJRyxZQUFZRix5QkFBeUJELG1CQUFPQSxDQUFDLG1FQUFZO0FBQzdELFNBQVNILFFBQVFPLGNBQWMsRUFBRUMsT0FBTyxFQUFFO0lBQ3RDLElBQUlDLGFBQWFILFVBQVVQLE9BQU87SUFDbEMsSUFBSVcsa0JBQWtCO1FBQ2xCLHdEQUF3RDtRQUN4REMsU0FBUyxTQUFzQztnQkFBckMsRUFBRUMsTUFBSyxFQUFHQyxVQUFTLEVBQUdDLFVBQVMsRUFBRztZQUN4QyxJQUFJLENBQUNBLFdBQVcsT0FBTyxJQUFJO1lBQzNCLElBQUlDLElBQXlCLEVBQWM7Z0JBQ3ZDLElBQUlGLFdBQVc7b0JBQ1gsT0FBTyxJQUFJO2dCQUNmLENBQUM7Z0JBQ0QsSUFBSUQsT0FBTztvQkFDUCxPQUFPLFdBQVcsR0FBR1AsT0FBT04sT0FBTyxDQUFDaUIsYUFBYSxDQUFDLEtBQUssSUFBSSxFQUFFSixNQUFNSyxPQUFPLEVBQUUsV0FBVyxHQUFHWixPQUFPTixPQUFPLENBQUNpQixhQUFhLENBQUMsTUFBTSxJQUFJLEdBQUdKLE1BQU1NLEtBQUs7Z0JBQ25KLENBQUM7WUFDTCxDQUFDO1lBQ0QsT0FBTyxJQUFJO1FBQ2Y7SUFDSjtJQUNBLHFFQUFxRTtJQUNyRSx3R0FBd0c7SUFDeEcsMkhBQTJIO0lBQzNILG1FQUFtRTtJQUNuRSxJQUFJWCwwQkFBMEJZLFNBQVM7UUFDbkNULGdCQUFnQlUsTUFBTSxHQUFHLElBQUliO0lBQ2pDLHVGQUF1RjtJQUN2RixPQUFPLElBQUksT0FBT0EsbUJBQW1CLFlBQVk7UUFDN0NHLGdCQUFnQlUsTUFBTSxHQUFHYjtJQUM3QixtR0FBbUc7SUFDbkcsT0FBTyxJQUFJLE9BQU9BLG1CQUFtQixVQUFVO1FBQzNDRyxrQkFBa0JSLFNBQVMsQ0FBQyxHQUFHUSxpQkFBaUJIO0lBQ3BELENBQUM7SUFDRCxnSEFBZ0g7SUFDaEhHLGtCQUFrQlIsU0FBUyxDQUFDLEdBQUdRLGlCQUFpQkY7SUFDaEQsTUFBTWEsV0FBV1gsZ0JBQWdCVSxNQUFNO0lBQ3ZDLE1BQU1BLFNBQVMsSUFBSUMsWUFBWSxJQUFJLEdBQUdBLFdBQVdDLElBQUksQ0FBQ0MsaUJBQWlCSixRQUFRSyxPQUFPLENBQUNELGNBQWMsSUFBSSxJQUFJLEVBQUU7SUFDL0csMkRBQTJEO0lBQzNELElBQUliLGdCQUFnQmUsaUJBQWlCLEVBQUU7UUFDbkNmLGtCQUFrQlIsU0FBUyxDQUFDLEdBQUdRLGlCQUFpQkEsZ0JBQWdCZSxpQkFBaUI7UUFDakYsT0FBT2YsZ0JBQWdCZSxpQkFBaUI7SUFDNUMsQ0FBQztJQUNELDBHQUEwRztJQUMxRyxJQUFJLE9BQU9mLGdCQUFnQmdCLEdBQUcsS0FBSyxhQUFhLENBQUNoQixnQkFBZ0JnQixHQUFHLEVBQUU7UUFDbEUsT0FBT2hCLGdCQUFnQmlCLE9BQU87UUFDOUIsT0FBT2pCLGdCQUFnQmtCLE9BQU87UUFDOUIsT0FBTzNCLE1BQU1RLFlBQVlDO0lBQzdCLENBQUM7SUFDRCxPQUFPRCxXQUFXUCxTQUFTLENBQUMsR0FBR1EsaUJBQWlCO1FBQzVDVSxRQUFRQTtJQUNaO0FBQ0o7QUFDQSxNQUFNUyxlQUFlLGFBQWtCO0FBQ3ZDLHlGQUF5RjtBQUN6RixxR0FBcUc7QUFDckcscUVBQXFFO0FBQ3JFLFNBQVNOLGNBQWNPLEdBQUcsRUFBRTtJQUN4QixJQUFJQztJQUNKLE9BQU87UUFDSGhDLFNBQVMsQ0FBQyxDQUFDZ0MsTUFBTUQsR0FBRSxLQUFNLElBQUksR0FBRyxLQUFLLElBQUlDLElBQUloQyxPQUFPLEtBQUsrQjtJQUM3RDtBQUNKO0FBQ0EsU0FBUzdCLE1BQU0rQixtQkFBbUIsRUFBRXRCLGVBQWUsRUFBRTtJQUNqRCx5RUFBeUU7SUFDekUsT0FBT0EsZ0JBQWdCaUIsT0FBTztJQUM5QixPQUFPakIsZ0JBQWdCa0IsT0FBTztJQUM5QixvRkFBb0Y7SUFDcEYsSUFBSSxDQUFDQyxjQUFjO1FBQ2YsT0FBT0csb0JBQW9CdEI7SUFDL0IsQ0FBQztJQUNELE1BQU11QixVQUFVdkIsZ0JBQWdCQyxPQUFPO0lBQ3ZDLGdEQUFnRDtJQUNoRCxPQUFPLElBQUksV0FBVyxHQUFHTixPQUFPTixPQUFPLENBQUNpQixhQUFhLENBQUNpQixTQUFTO1lBQ3ZEckIsT0FBTyxJQUFJO1lBQ1hDLFdBQVcsSUFBSTtZQUNmQyxXQUFXLEtBQUs7WUFDaEJvQixVQUFVLEtBQUs7UUFDbkI7QUFDUjtBQUVBLElBQUksQ0FBQyxPQUFPckMsUUFBUUUsT0FBTyxLQUFLLGNBQWUsT0FBT0YsUUFBUUUsT0FBTyxLQUFLLFlBQVlGLFFBQVFFLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0YsUUFBUUUsT0FBTyxDQUFDb0MsVUFBVSxLQUFLLGFBQWE7SUFDckt4QyxPQUFPQyxjQUFjLENBQUNDLFFBQVFFLE9BQU8sRUFBRSxjQUFjO1FBQUVELE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPeUMsTUFBTSxDQUFDdkMsUUFBUUUsT0FBTyxFQUFFRjtJQUMvQndDLE9BQU94QyxPQUFPLEdBQUdBLFFBQVFFLE9BQU87QUFDbEMsQ0FBQyxDQUVELG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvZHluYW1pYy5qcz9lMjVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZHluYW1pYztcbmV4cG9ydHMubm9TU1IgPSBub1NTUjtcbnZhciBfZXh0ZW5kcyA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19leHRlbmRzLmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2xvYWRhYmxlID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCIuL2xvYWRhYmxlXCIpKTtcbmZ1bmN0aW9uIGR5bmFtaWMoZHluYW1pY09wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBsZXQgbG9hZGFibGVGbiA9IF9sb2FkYWJsZS5kZWZhdWx0O1xuICAgIGxldCBsb2FkYWJsZU9wdGlvbnMgPSB7XG4gICAgICAgIC8vIEEgbG9hZGluZyBjb21wb25lbnQgaXMgbm90IHJlcXVpcmVkLCBzbyB3ZSBkZWZhdWx0IGl0XG4gICAgICAgIGxvYWRpbmc6ICh7IGVycm9yICwgaXNMb2FkaW5nICwgcGFzdERlbGF5ICB9KT0+e1xuICAgICAgICAgICAgaWYgKCFwYXN0RGVsYXkpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInBcIiwgbnVsbCwgZXJyb3IubWVzc2FnZSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYnJcIiwgbnVsbCksIGVycm9yLnN0YWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gU3VwcG9ydCBmb3IgZGlyZWN0IGltcG9ydCgpLCBlZzogZHluYW1pYyhpbXBvcnQoJy4uL2hlbGxvLXdvcmxkJykpXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgb25seSBrZXB0IGZvciB0aGUgZWRnZSBjYXNlIHdoZXJlIHNvbWVvbmUgaXMgcGFzc2luZyBpbiBhIHByb21pc2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICAvLyBUaGUgcmVhY3QtbG9hZGFibGUgYmFiZWwgcGx1Z2luIHdpbGwgdHVybiBkeW5hbWljKGltcG9ydCgnLi4vaGVsbG8td29ybGQnKSkgaW50byBkeW5hbWljKCgpID0+IGltcG9ydCgnLi4vaGVsbG8td29ybGQnKSlcbiAgICAvLyBUbyBtYWtlIHN1cmUgd2UgZG9uJ3QgZXhlY3V0ZSB0aGUgaW1wb3J0IHdpdGhvdXQgcmVuZGVyaW5nIGZpcnN0XG4gICAgaWYgKGR5bmFtaWNPcHRpb25zIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBsb2FkYWJsZU9wdGlvbnMubG9hZGVyID0gKCk9PmR5bmFtaWNPcHRpb25zO1xuICAgIC8vIFN1cHBvcnQgZm9yIGhhdmluZyBpbXBvcnQgYXMgYSBmdW5jdGlvbiwgZWc6IGR5bmFtaWMoKCkgPT4gaW1wb3J0KCcuLi9oZWxsby13b3JsZCcpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGR5bmFtaWNPcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxvYWRhYmxlT3B0aW9ucy5sb2FkZXIgPSBkeW5hbWljT3B0aW9ucztcbiAgICAvLyBTdXBwb3J0IGZvciBoYXZpbmcgZmlyc3QgYXJndW1lbnQgYmVpbmcgb3B0aW9ucywgZWc6IGR5bmFtaWMoe2xvYWRlcjogaW1wb3J0KCcuLi9oZWxsby13b3JsZCcpfSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkeW5hbWljT3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbG9hZGFibGVPcHRpb25zID0gX2V4dGVuZHMoe30sIGxvYWRhYmxlT3B0aW9ucywgZHluYW1pY09wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBTdXBwb3J0IGZvciBwYXNzaW5nIG9wdGlvbnMsIGVnOiBkeW5hbWljKGltcG9ydCgnLi4vaGVsbG8td29ybGQnKSwge2xvYWRpbmc6ICgpID0+IDxwPkxvYWRpbmcgc29tZXRoaW5nPC9wPn0pXG4gICAgbG9hZGFibGVPcHRpb25zID0gX2V4dGVuZHMoe30sIGxvYWRhYmxlT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgbG9hZGVyRm4gPSBsb2FkYWJsZU9wdGlvbnMubG9hZGVyO1xuICAgIGNvbnN0IGxvYWRlciA9ICgpPT5sb2FkZXJGbiAhPSBudWxsID8gbG9hZGVyRm4oKS50aGVuKGNvbnZlcnRNb2R1bGUpIDogUHJvbWlzZS5yZXNvbHZlKGNvbnZlcnRNb2R1bGUoKCk9Pm51bGwpKTtcbiAgICAvLyBjb21pbmcgZnJvbSBidWlsZC9iYWJlbC9wbHVnaW5zL3JlYWN0LWxvYWRhYmxlLXBsdWdpbi5qc1xuICAgIGlmIChsb2FkYWJsZU9wdGlvbnMubG9hZGFibGVHZW5lcmF0ZWQpIHtcbiAgICAgICAgbG9hZGFibGVPcHRpb25zID0gX2V4dGVuZHMoe30sIGxvYWRhYmxlT3B0aW9ucywgbG9hZGFibGVPcHRpb25zLmxvYWRhYmxlR2VuZXJhdGVkKTtcbiAgICAgICAgZGVsZXRlIGxvYWRhYmxlT3B0aW9ucy5sb2FkYWJsZUdlbmVyYXRlZDtcbiAgICB9XG4gICAgLy8gc3VwcG9ydCBmb3IgZGlzYWJsaW5nIHNlcnZlciBzaWRlIHJlbmRlcmluZywgZWc6IGR5bmFtaWMoKCkgPT4gaW1wb3J0KCcuLi9oZWxsby13b3JsZCcpLCB7c3NyOiBmYWxzZX0pLlxuICAgIGlmICh0eXBlb2YgbG9hZGFibGVPcHRpb25zLnNzciA9PT0gJ2Jvb2xlYW4nICYmICFsb2FkYWJsZU9wdGlvbnMuc3NyKSB7XG4gICAgICAgIGRlbGV0ZSBsb2FkYWJsZU9wdGlvbnMud2VicGFjaztcbiAgICAgICAgZGVsZXRlIGxvYWRhYmxlT3B0aW9ucy5tb2R1bGVzO1xuICAgICAgICByZXR1cm4gbm9TU1IobG9hZGFibGVGbiwgbG9hZGFibGVPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvYWRhYmxlRm4oX2V4dGVuZHMoe30sIGxvYWRhYmxlT3B0aW9ucywge1xuICAgICAgICBsb2FkZXI6IGxvYWRlclxuICAgIH0pKTtcbn1cbmNvbnN0IGlzU2VydmVyU2lkZSA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuLy8gTm9ybWFsaXplIGxvYWRlciB0byByZXR1cm4gdGhlIG1vZHVsZSBhcyBmb3JtIHsgZGVmYXVsdDogQ29tcG9uZW50IH0gZm9yIGBSZWFjdC5sYXp5YC5cbi8vIEFsc28gZm9yIGJhY2t3YXJkIGNvbXBhdGlibGUgc2luY2UgbmV4dC9keW5hbWljIGFsbG93cyB0byByZXNvbHZlIGEgY29tcG9uZW50IGRpcmVjdGx5IHdpdGggbG9hZGVyXG4vLyBDbGllbnQgY29tcG9uZW50IHJlZmVyZW5jZSBwcm94eSBuZWVkIHRvIGJlIGNvbnZlcnRlZCB0byBhIG1vZHVsZS5cbmZ1bmN0aW9uIGNvbnZlcnRNb2R1bGUobW9kKSB7XG4gICAgdmFyIHJlZjtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZhdWx0OiAoKHJlZiA9IG1vZCkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5kZWZhdWx0KSB8fCBtb2RcbiAgICB9O1xufVxuZnVuY3Rpb24gbm9TU1IoTG9hZGFibGVJbml0aWFsaXplciwgbG9hZGFibGVPcHRpb25zKSB7XG4gICAgLy8gUmVtb3Zpbmcgd2VicGFjayBhbmQgbW9kdWxlcyBtZWFucyByZWFjdC1sb2FkYWJsZSB3b24ndCB0cnkgcHJlbG9hZGluZ1xuICAgIGRlbGV0ZSBsb2FkYWJsZU9wdGlvbnMud2VicGFjaztcbiAgICBkZWxldGUgbG9hZGFibGVPcHRpb25zLm1vZHVsZXM7XG4gICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gcHJldmVudCByZWFjdC1sb2FkYWJsZSBmcm9tIGluaXRpYWxpemluZyBvbiB0aGUgc2VydmVyXG4gICAgaWYgKCFpc1NlcnZlclNpZGUpIHtcbiAgICAgICAgcmV0dXJuIExvYWRhYmxlSW5pdGlhbGl6ZXIobG9hZGFibGVPcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgTG9hZGluZyA9IGxvYWRhYmxlT3B0aW9ucy5sb2FkaW5nO1xuICAgIC8vIFRoaXMgd2lsbCBvbmx5IGJlIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIgc2lkZVxuICAgIHJldHVybiAoKT0+LyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KExvYWRpbmcsIHtcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgaXNMb2FkaW5nOiB0cnVlLFxuICAgICAgICAgICAgcGFzdERlbGF5OiBmYWxzZSxcbiAgICAgICAgICAgIHRpbWVkT3V0OiBmYWxzZVxuICAgICAgICB9KTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHluYW1pYy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiZHluYW1pYyIsIm5vU1NSIiwiX2V4dGVuZHMiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX3JlYWN0IiwiX2xvYWRhYmxlIiwiZHluYW1pY09wdGlvbnMiLCJvcHRpb25zIiwibG9hZGFibGVGbiIsImxvYWRhYmxlT3B0aW9ucyIsImxvYWRpbmciLCJlcnJvciIsImlzTG9hZGluZyIsInBhc3REZWxheSIsInByb2Nlc3MiLCJjcmVhdGVFbGVtZW50IiwibWVzc2FnZSIsInN0YWNrIiwiUHJvbWlzZSIsImxvYWRlciIsImxvYWRlckZuIiwidGhlbiIsImNvbnZlcnRNb2R1bGUiLCJyZXNvbHZlIiwibG9hZGFibGVHZW5lcmF0ZWQiLCJzc3IiLCJ3ZWJwYWNrIiwibW9kdWxlcyIsImlzU2VydmVyU2lkZSIsIm1vZCIsInJlZiIsIkxvYWRhYmxlSW5pdGlhbGl6ZXIiLCJMb2FkaW5nIiwidGltZWRPdXQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/dynamic.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/loadable-context.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/loadable-context.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\"use client\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LoadableContext = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nconst LoadableContext = _react.default.createContext(null);\nexports.LoadableContext = LoadableContext;\nif (true) {\n    LoadableContext.displayName = \"LoadableContext\";\n} //# sourceMappingURL=loadable-context.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbG9hZGFibGUtY29udGV4dC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTtBQURiO0FBRUFBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHVCQUF1QixHQUFHLEtBQUs7QUFDL0IsSUFBSUcsMkJBQTJCQyxtSkFBK0Q7QUFDOUYsSUFBSUUsU0FBU0gseUJBQXlCQyxtQkFBT0EsQ0FBQyw0Q0FBTztBQUVyRCxNQUFNRixrQkFBa0JJLE9BQU9ELE9BQU8sQ0FBQ0UsYUFBYSxDQUFDLElBQUk7QUFDekRQLHVCQUF1QixHQUFHRTtBQUMxQixJQUFJTSxJQUF5QixFQUFjO0lBQ3ZDTixnQkFBZ0JPLFdBQVcsR0FBRztBQUNsQyxDQUFDLENBRUQsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9sb2FkYWJsZS1jb250ZXh0LmpzP2VjMjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTG9hZGFibGVDb250ZXh0ID0gdm9pZCAwO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG5jb25zdCBMb2FkYWJsZUNvbnRleHQgPSBfcmVhY3QuZGVmYXVsdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuZXhwb3J0cy5Mb2FkYWJsZUNvbnRleHQgPSBMb2FkYWJsZUNvbnRleHQ7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIExvYWRhYmxlQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdMb2FkYWJsZUNvbnRleHQnO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkYWJsZS1jb250ZXh0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkxvYWRhYmxlQ29udGV4dCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJkZWZhdWx0IiwiX3JlYWN0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/loadable-context.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/loadable.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/loadable.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _loadableContext = __webpack_require__(/*! ./loadable-context */ \"./node_modules/next/dist/shared/lib/loadable-context.js\");\nfunction resolve(obj) {\n    return obj && obj.default ? obj.default : obj;\n}\nconst ALL_INITIALIZERS = [];\nconst READY_INITIALIZERS = [];\nlet initialized = false;\nfunction load(loader) {\n    let promise = loader();\n    let state = {\n        loading: true,\n        loaded: null,\n        error: null\n    };\n    state.promise = promise.then((loaded)=>{\n        state.loading = false;\n        state.loaded = loaded;\n        return loaded;\n    }).catch((err)=>{\n        state.loading = false;\n        state.error = err;\n        throw err;\n    });\n    return state;\n}\nfunction createLoadableComponent(loadFn, options) {\n    var _s = $RefreshSig$(), _s1 = $RefreshSig$();\n    let opts = Object.assign({\n        loader: null,\n        loading: null,\n        delay: 200,\n        timeout: null,\n        webpack: null,\n        modules: null\n    }, options);\n    /** @type LoadableSubscription */ let subscription = null;\n    function init() {\n        if (!subscription) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            const sub = new LoadableSubscription(loadFn, opts);\n            subscription = {\n                getCurrentValue: sub.getCurrentValue.bind(sub),\n                subscribe: sub.subscribe.bind(sub),\n                retry: sub.retry.bind(sub),\n                promise: sub.promise.bind(sub)\n            };\n        }\n        return subscription.promise();\n    }\n    // Server only\n    if (false) {}\n    // Client only\n    if (!initialized && \"object\" !== \"undefined\") {\n        // require.resolveWeak check is needed for environments that don't have it available like Jest\n        const moduleIds = opts.webpack && \"function\" === \"function\" ? opts.webpack() : opts.modules;\n        if (moduleIds) {\n            READY_INITIALIZERS.push((ids)=>{\n                for (const moduleId of moduleIds){\n                    if (ids.indexOf(moduleId) !== -1) {\n                        return init();\n                    }\n                }\n            });\n        }\n    }\n    function useLoadableModule() {\n        _s();\n        init();\n        const context = _react.default.useContext(_loadableContext.LoadableContext);\n        if (context && Array.isArray(opts.modules)) {\n            opts.modules.forEach((moduleName)=>{\n                context(moduleName);\n            });\n        }\n    }\n    _s(useLoadableModule, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n    function LoadableComponent(props, ref) {\n        _s1();\n        useLoadableModule();\n        const state = _react.default.useSyncExternalStore(subscription.subscribe, subscription.getCurrentValue, subscription.getCurrentValue);\n        _react.default.useImperativeHandle(ref, ()=>({\n                retry: subscription.retry\n            }), []);\n        return _react.default.useMemo(()=>{\n            if (state.loading || state.error) {\n                return /*#__PURE__*/ _react.default.createElement(opts.loading, {\n                    isLoading: state.loading,\n                    pastDelay: state.pastDelay,\n                    timedOut: state.timedOut,\n                    error: state.error,\n                    retry: subscription.retry\n                });\n            } else if (state.loaded) {\n                return /*#__PURE__*/ _react.default.createElement(resolve(state.loaded), props);\n            } else {\n                return null;\n            }\n        }, [\n            props,\n            state\n        ]);\n    }\n    _s1(LoadableComponent, \"FetqI339RA+IfltT8VNzX8RMZ2Q=\", false, function() {\n        return [\n            useLoadableModule\n        ];\n    });\n    LoadableComponent.preload = ()=>init();\n    LoadableComponent.displayName = \"LoadableComponent\";\n    return /*#__PURE__*/ _react.default.forwardRef(LoadableComponent);\n}\nclass LoadableSubscription {\n    promise() {\n        return this._res.promise;\n    }\n    retry() {\n        this._clearTimeouts();\n        this._res = this._loadFn(this._opts.loader);\n        this._state = {\n            pastDelay: false,\n            timedOut: false\n        };\n        const { _res: res , _opts: opts  } = this;\n        if (res.loading) {\n            if (typeof opts.delay === \"number\") {\n                if (opts.delay === 0) {\n                    this._state.pastDelay = true;\n                } else {\n                    this._delay = setTimeout(()=>{\n                        this._update({\n                            pastDelay: true\n                        });\n                    }, opts.delay);\n                }\n            }\n            if (typeof opts.timeout === \"number\") {\n                this._timeout = setTimeout(()=>{\n                    this._update({\n                        timedOut: true\n                    });\n                }, opts.timeout);\n            }\n        }\n        this._res.promise.then(()=>{\n            this._update({});\n            this._clearTimeouts();\n        }).catch((_err)=>{\n            this._update({});\n            this._clearTimeouts();\n        });\n        this._update({});\n    }\n    _update(partial) {\n        this._state = _extends({}, this._state, {\n            error: this._res.error,\n            loaded: this._res.loaded,\n            loading: this._res.loading\n        }, partial);\n        this._callbacks.forEach((callback)=>callback());\n    }\n    _clearTimeouts() {\n        clearTimeout(this._delay);\n        clearTimeout(this._timeout);\n    }\n    getCurrentValue() {\n        return this._state;\n    }\n    subscribe(callback) {\n        this._callbacks.add(callback);\n        return ()=>{\n            this._callbacks.delete(callback);\n        };\n    }\n    constructor(loadFn, opts){\n        this._loadFn = loadFn;\n        this._opts = opts;\n        this._callbacks = new Set();\n        this._delay = null;\n        this._timeout = null;\n        this.retry();\n    }\n}\nfunction Loadable(opts) {\n    return createLoadableComponent(load, opts);\n}\n_c = Loadable;\nfunction flushInitializers(initializers, ids) {\n    let promises = [];\n    while(initializers.length){\n        let init = initializers.pop();\n        promises.push(init(ids));\n    }\n    return Promise.all(promises).then(()=>{\n        if (initializers.length) {\n            return flushInitializers(initializers, ids);\n        }\n    });\n}\nLoadable.preloadAll = ()=>{\n    return new Promise((resolveInitializers, reject)=>{\n        flushInitializers(ALL_INITIALIZERS).then(resolveInitializers, reject);\n    });\n};\nLoadable.preloadReady = function() {\n    let ids = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    return new Promise((resolvePreload)=>{\n        const res = ()=>{\n            initialized = true;\n            return resolvePreload();\n        };\n        // We always will resolve, errors should be handled within loading UIs.\n        flushInitializers(READY_INITIALIZERS, ids).then(res, res);\n    });\n};\nif (true) {\n    window.__NEXT_PRELOADREADY = Loadable.preloadReady;\n}\nvar _default = Loadable;\nexports[\"default\"] = _default; //# sourceMappingURL=loadable.js.map\nvar _c;\n$RefreshReg$(_c, \"Loadable\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbG9hZGFibGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBRyxLQUFLO0FBQ3ZCLElBQUlHLFdBQVdDLG1IQUErQztBQUM5RCxJQUFJQywyQkFBMkJELG1KQUErRDtBQUM5RixJQUFJRSxTQUFTRCx5QkFBeUJELG1CQUFPQSxDQUFDLDRDQUFPO0FBQ3JELElBQUlHLG1CQUFtQkgsbUJBQU9BLENBQUMsbUZBQW9CO0FBQ25ELFNBQVNJLFFBQVFDLEdBQUcsRUFBRTtJQUNsQixPQUFPQSxPQUFPQSxJQUFJUCxPQUFPLEdBQUdPLElBQUlQLE9BQU8sR0FBR08sR0FBRztBQUNqRDtBQUNBLE1BQU1DLG1CQUFtQixFQUFFO0FBQzNCLE1BQU1DLHFCQUFxQixFQUFFO0FBQzdCLElBQUlDLGNBQWMsS0FBSztBQUN2QixTQUFTQyxLQUFLQyxNQUFNLEVBQUU7SUFDbEIsSUFBSUMsVUFBVUQ7SUFDZCxJQUFJRSxRQUFRO1FBQ1JDLFNBQVMsSUFBSTtRQUNiQyxRQUFRLElBQUk7UUFDWkMsT0FBTyxJQUFJO0lBQ2Y7SUFDQUgsTUFBTUQsT0FBTyxHQUFHQSxRQUFRSyxJQUFJLENBQUMsQ0FBQ0YsU0FBUztRQUNuQ0YsTUFBTUMsT0FBTyxHQUFHLEtBQUs7UUFDckJELE1BQU1FLE1BQU0sR0FBR0E7UUFDZixPQUFPQTtJQUNYLEdBQUdHLEtBQUssQ0FBQyxDQUFDQyxNQUFNO1FBQ1pOLE1BQU1DLE9BQU8sR0FBRyxLQUFLO1FBQ3JCRCxNQUFNRyxLQUFLLEdBQUdHO1FBQ2QsTUFBTUEsSUFBSTtJQUNkO0lBQ0EsT0FBT047QUFDWDtBQUNBLFNBQVNPLHdCQUF3QkMsTUFBTSxFQUFFQyxPQUFPLEVBQUU7O0lBQzlDLElBQUlDLE9BQU81QixPQUFPNkIsTUFBTSxDQUFDO1FBQ3JCYixRQUFRLElBQUk7UUFDWkcs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Yi9sb2FkYWJsZS5qcz81MTA3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9leHRlbmRzID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2V4dGVuZHMuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfbG9hZGFibGVDb250ZXh0ID0gcmVxdWlyZShcIi4vbG9hZGFibGUtY29udGV4dFwiKTtcbmZ1bmN0aW9uIHJlc29sdmUob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouZGVmYXVsdCA/IG9iai5kZWZhdWx0IDogb2JqO1xufVxuY29uc3QgQUxMX0lOSVRJQUxJWkVSUyA9IFtdO1xuY29uc3QgUkVBRFlfSU5JVElBTElaRVJTID0gW107XG5sZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGxvYWQobG9hZGVyKSB7XG4gICAgbGV0IHByb21pc2UgPSBsb2FkZXIoKTtcbiAgICBsZXQgc3RhdGUgPSB7XG4gICAgICAgIGxvYWRpbmc6IHRydWUsXG4gICAgICAgIGxvYWRlZDogbnVsbCxcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICB9O1xuICAgIHN0YXRlLnByb21pc2UgPSBwcm9taXNlLnRoZW4oKGxvYWRlZCk9PntcbiAgICAgICAgc3RhdGUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5sb2FkZWQgPSBsb2FkZWQ7XG4gICAgICAgIHJldHVybiBsb2FkZWQ7XG4gICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgc3RhdGUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5lcnJvciA9IGVycjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICAgIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvYWRhYmxlQ29tcG9uZW50KGxvYWRGbiwgb3B0aW9ucykge1xuICAgIGxldCBvcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGxvYWRlcjogbnVsbCxcbiAgICAgICAgbG9hZGluZzogbnVsbCxcbiAgICAgICAgZGVsYXk6IDIwMCxcbiAgICAgICAgdGltZW91dDogbnVsbCxcbiAgICAgICAgd2VicGFjazogbnVsbCxcbiAgICAgICAgbW9kdWxlczogbnVsbFxuICAgIH0sIG9wdGlvbnMpO1xuICAgIC8qKiBAdHlwZSBMb2FkYWJsZVN1YnNjcmlwdGlvbiAqLyBsZXQgc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgY29uc3Qgc3ViID0gbmV3IExvYWRhYmxlU3Vic2NyaXB0aW9uKGxvYWRGbiwgb3B0cyk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICAgICAgZ2V0Q3VycmVudFZhbHVlOiBzdWIuZ2V0Q3VycmVudFZhbHVlLmJpbmQoc3ViKSxcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmU6IHN1Yi5zdWJzY3JpYmUuYmluZChzdWIpLFxuICAgICAgICAgICAgICAgIHJldHJ5OiBzdWIucmV0cnkuYmluZChzdWIpLFxuICAgICAgICAgICAgICAgIHByb21pc2U6IHN1Yi5wcm9taXNlLmJpbmQoc3ViKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uLnByb21pc2UoKTtcbiAgICB9XG4gICAgLy8gU2VydmVyIG9ubHlcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgQUxMX0lOSVRJQUxJWkVSUy5wdXNoKGluaXQpO1xuICAgIH1cbiAgICAvLyBDbGllbnQgb25seVxuICAgIGlmICghaW5pdGlhbGl6ZWQgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gcmVxdWlyZS5yZXNvbHZlV2VhayBjaGVjayBpcyBuZWVkZWQgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvbid0IGhhdmUgaXQgYXZhaWxhYmxlIGxpa2UgSmVzdFxuICAgICAgICBjb25zdCBtb2R1bGVJZHMgPSBvcHRzLndlYnBhY2sgJiYgdHlwZW9mIHJlcXVpcmUucmVzb2x2ZVdlYWsgPT09ICdmdW5jdGlvbicgPyBvcHRzLndlYnBhY2soKSA6IG9wdHMubW9kdWxlcztcbiAgICAgICAgaWYgKG1vZHVsZUlkcykge1xuICAgICAgICAgICAgUkVBRFlfSU5JVElBTElaRVJTLnB1c2goKGlkcyk9PntcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZUlkIG9mIG1vZHVsZUlkcyl7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHMuaW5kZXhPZihtb2R1bGVJZCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXNlTG9hZGFibGVNb2R1bGUoKSB7XG4gICAgICAgIGluaXQoKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IF9yZWFjdC5kZWZhdWx0LnVzZUNvbnRleHQoX2xvYWRhYmxlQ29udGV4dC5Mb2FkYWJsZUNvbnRleHQpO1xuICAgICAgICBpZiAoY29udGV4dCAmJiBBcnJheS5pc0FycmF5KG9wdHMubW9kdWxlcykpIHtcbiAgICAgICAgICAgIG9wdHMubW9kdWxlcy5mb3JFYWNoKChtb2R1bGVOYW1lKT0+e1xuICAgICAgICAgICAgICAgIGNvbnRleHQobW9kdWxlTmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBMb2FkYWJsZUNvbXBvbmVudChwcm9wcywgcmVmKSB7XG4gICAgICAgIHVzZUxvYWRhYmxlTW9kdWxlKCk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gX3JlYWN0LmRlZmF1bHQudXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaXB0aW9uLnN1YnNjcmliZSwgc3Vic2NyaXB0aW9uLmdldEN1cnJlbnRWYWx1ZSwgc3Vic2NyaXB0aW9uLmdldEN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIF9yZWFjdC5kZWZhdWx0LnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKT0+KHtcbiAgICAgICAgICAgICAgICByZXRyeTogc3Vic2NyaXB0aW9uLnJldHJ5XG4gICAgICAgICAgICB9KSwgW10pO1xuICAgICAgICByZXR1cm4gX3JlYWN0LmRlZmF1bHQudXNlTWVtbygoKT0+e1xuICAgICAgICAgICAgaWYgKHN0YXRlLmxvYWRpbmcgfHwgc3RhdGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KG9wdHMubG9hZGluZywge1xuICAgICAgICAgICAgICAgICAgICBpc0xvYWRpbmc6IHN0YXRlLmxvYWRpbmcsXG4gICAgICAgICAgICAgICAgICAgIHBhc3REZWxheTogc3RhdGUucGFzdERlbGF5LFxuICAgICAgICAgICAgICAgICAgICB0aW1lZE91dDogc3RhdGUudGltZWRPdXQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBzdGF0ZS5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgcmV0cnk6IHN1YnNjcmlwdGlvbi5yZXRyeVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHJlc29sdmUoc3RhdGUubG9hZGVkKSwgcHJvcHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW1xuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgTG9hZGFibGVDb21wb25lbnQucHJlbG9hZCA9ICgpPT5pbml0KCk7XG4gICAgTG9hZGFibGVDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnTG9hZGFibGVDb21wb25lbnQnO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmZvcndhcmRSZWYoTG9hZGFibGVDb21wb25lbnQpO1xufVxuY2xhc3MgTG9hZGFibGVTdWJzY3JpcHRpb24ge1xuICAgIHByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXMucHJvbWlzZTtcbiAgICB9XG4gICAgcmV0cnkoKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyVGltZW91dHMoKTtcbiAgICAgICAgdGhpcy5fcmVzID0gdGhpcy5fbG9hZEZuKHRoaXMuX29wdHMubG9hZGVyKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSB7XG4gICAgICAgICAgICBwYXN0RGVsYXk6IGZhbHNlLFxuICAgICAgICAgICAgdGltZWRPdXQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgX3JlczogcmVzICwgX29wdHM6IG9wdHMgIH0gPSB0aGlzO1xuICAgICAgICBpZiAocmVzLmxvYWRpbmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5kZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZS5wYXN0RGVsYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlbGF5ID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXN0RGVsYXk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBvcHRzLmRlbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdHMudGltZW91dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWRPdXQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgb3B0cy50aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXMucHJvbWlzZS50aGVuKCgpPT57XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoe30pO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0cygpO1xuICAgICAgICB9KS5jYXRjaCgoX2Vycik9PntcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSh7fSk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXRzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl91cGRhdGUoe30pO1xuICAgIH1cbiAgICBfdXBkYXRlKHBhcnRpYWwpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBfZXh0ZW5kcyh7fSwgdGhpcy5fc3RhdGUsIHtcbiAgICAgICAgICAgIGVycm9yOiB0aGlzLl9yZXMuZXJyb3IsXG4gICAgICAgICAgICBsb2FkZWQ6IHRoaXMuX3Jlcy5sb2FkZWQsXG4gICAgICAgICAgICBsb2FkaW5nOiB0aGlzLl9yZXMubG9hZGluZ1xuICAgICAgICB9LCBwYXJ0aWFsKTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKT0+Y2FsbGJhY2soKSk7XG4gICAgfVxuICAgIF9jbGVhclRpbWVvdXRzKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fZGVsYXkpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgfVxuICAgIGdldEN1cnJlbnRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGxvYWRGbiwgb3B0cyl7XG4gICAgICAgIHRoaXMuX2xvYWRGbiA9IGxvYWRGbjtcbiAgICAgICAgdGhpcy5fb3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fZGVsYXkgPSBudWxsO1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXRyeSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIExvYWRhYmxlKG9wdHMpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9hZGFibGVDb21wb25lbnQobG9hZCwgb3B0cyk7XG59XG5mdW5jdGlvbiBmbHVzaEluaXRpYWxpemVycyhpbml0aWFsaXplcnMsIGlkcykge1xuICAgIGxldCBwcm9taXNlcyA9IFtdO1xuICAgIHdoaWxlKGluaXRpYWxpemVycy5sZW5ndGgpe1xuICAgICAgICBsZXQgaW5pdCA9IGluaXRpYWxpemVycy5wb3AoKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChpbml0KGlkcykpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCk9PntcbiAgICAgICAgaWYgKGluaXRpYWxpemVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmbHVzaEluaXRpYWxpemVycyhpbml0aWFsaXplcnMsIGlkcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbkxvYWRhYmxlLnByZWxvYWRBbGwgPSAoKT0+e1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZUluaXRpYWxpemVycywgcmVqZWN0KT0+e1xuICAgICAgICBmbHVzaEluaXRpYWxpemVycyhBTExfSU5JVElBTElaRVJTKS50aGVuKHJlc29sdmVJbml0aWFsaXplcnMsIHJlamVjdCk7XG4gICAgfSk7XG59O1xuTG9hZGFibGUucHJlbG9hZFJlYWR5ID0gKGlkcyA9IFtdKT0+e1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZVByZWxvYWQpPT57XG4gICAgICAgIGNvbnN0IHJlcyA9ICgpPT57XG4gICAgICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVByZWxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gV2UgYWx3YXlzIHdpbGwgcmVzb2x2ZSwgZXJyb3JzIHNob3VsZCBiZSBoYW5kbGVkIHdpdGhpbiBsb2FkaW5nIFVJcy5cbiAgICAgICAgZmx1c2hJbml0aWFsaXplcnMoUkVBRFlfSU5JVElBTElaRVJTLCBpZHMpLnRoZW4ocmVzLCByZXMpO1xuICAgIH0pO1xufTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5fX05FWFRfUFJFTE9BRFJFQURZID0gTG9hZGFibGUucHJlbG9hZFJlYWR5O1xufVxudmFyIF9kZWZhdWx0ID0gTG9hZGFibGU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZGFibGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIl9leHRlbmRzIiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsIl9yZWFjdCIsIl9sb2FkYWJsZUNvbnRleHQiLCJyZXNvbHZlIiwib2JqIiwiQUxMX0lOSVRJQUxJWkVSUyIsIlJFQURZX0lOSVRJQUxJWkVSUyIsImluaXRpYWxpemVkIiwibG9hZCIsImxvYWRlciIsInByb21pc2UiLCJzdGF0ZSIsImxvYWRpbmciLCJsb2FkZWQiLCJlcnJvciIsInRoZW4iLCJjYXRjaCIsImVyciIsImNyZWF0ZUxvYWRhYmxlQ29tcG9uZW50IiwibG9hZEZuIiwib3B0aW9ucyIsIm9wdHMiLCJhc3NpZ24iLCJkZWxheSIsInRpbWVvdXQiLCJ3ZWJwYWNrIiwibW9kdWxlcyIsInN1YnNjcmlwdGlvbiIsImluaXQiLCJzdWIiLCJMb2FkYWJsZVN1YnNjcmlwdGlvbiIsImdldEN1cnJlbnRWYWx1ZSIsImJpbmQiLCJzdWJzY3JpYmUiLCJyZXRyeSIsInB1c2giLCJtb2R1bGVJZHMiLCJyZXNvbHZlV2VhayIsImlkcyIsIm1vZHVsZUlkIiwiaW5kZXhPZiIsInVzZUxvYWRhYmxlTW9kdWxlIiwiY29udGV4dCIsInVzZUNvbnRleHQiLCJMb2FkYWJsZUNvbnRleHQiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwibW9kdWxlTmFtZSIsIkxvYWRhYmxlQ29tcG9uZW50IiwicHJvcHMiLCJyZWYiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VNZW1vIiwiY3JlYXRlRWxlbWVudCIsImlzTG9hZGluZyIsInBhc3REZWxheSIsInRpbWVkT3V0IiwicHJlbG9hZCIsImRpc3BsYXlOYW1lIiwiZm9yd2FyZFJlZiIsIl9yZXMiLCJfY2xlYXJUaW1lb3V0cyIsIl9sb2FkRm4iLCJfb3B0cyIsIl9zdGF0ZSIsInJlcyIsIl9kZWxheSIsInNldFRpbWVvdXQiLCJfdXBkYXRlIiwiX3RpbWVvdXQiLCJfZXJyIiwicGFydGlhbCIsIl9jYWxsYmFja3MiLCJjYWxsYmFjayIsImNsZWFyVGltZW91dCIsImFkZCIsImRlbGV0ZSIsImNvbnN0cnVjdG9yIiwiU2V0IiwiTG9hZGFibGUiLCJmbHVzaEluaXRpYWxpemVycyIsImluaXRpYWxpemVycyIsInByb21pc2VzIiwibGVuZ3RoIiwicG9wIiwiUHJvbWlzZSIsImFsbCIsInByZWxvYWRBbGwiLCJyZXNvbHZlSW5pdGlhbGl6ZXJzIiwicmVqZWN0IiwicHJlbG9hZFJlYWR5IiwicmVzb2x2ZVByZWxvYWQiLCJ3aW5kb3ciLCJfX05FWFRfUFJFTE9BRFJFQURZIiwiX2RlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/loadable.js\n"));

/***/ }),

/***/ "./src/pages/classes/Level.tsx":
/*!*************************************!*\
  !*** ./src/pages/classes/Level.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Level; }\n/* harmony export */ });\n/* harmony import */ var _Tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tile */ \"./src/pages/classes/Tile.tsx\");\n\nconst DEBUG = true;\nclass Level {\n    createLayout() {\n        for(let i = 0; i < this.rows; i++){\n            let row = [];\n            for(let j = 0; j < this.cols; j++){\n                // get the code for the current tile\n                let code = this.rawLayout[i * this.cols + j];\n                let image;\n                // use the appropriate image for the tile based on its code\n                switch(code){\n                    case \"gra\":\n                        image = this.images[0];\n                        break;\n                    case \"dir\":\n                        image = this.images[1];\n                        break;\n                    case \"coi\":\n                        image = this.images[2];\n                        break;\n                    case \"gem\":\n                        image = this.images[3];\n                        break;\n                    case \"cll\":\n                        image = this.images[4];\n                        break;\n                    case \"clr\":\n                        image = this.images[5];\n                        break;\n                    case \"flo\":\n                        image = this.images[6];\n                        break;\n                    case \"psm\":\n                        image = this.images[7];\n                        break;\n                    case \"pbd\":\n                        image = this.images[8];\n                        break;\n                    case \"pbu\":\n                        image = this.images[9];\n                        break;\n                    case \"tsm\":\n                        image = this.images[10];\n                        break;\n                    case \"tbd\":\n                        image = this.images[11];\n                        break;\n                    case \"tbu\":\n                        image = this.images[12];\n                        break;\n                    case \"sto\":\n                        image = this.images[13];\n                        break;\n                    case \"spi\":\n                        image = this.images[14];\n                        break;\n                    case \"000\":\n                        image = this.images[15];\n                        break;\n                    default:\n                        image = this.images[16];\n                        break;\n                }\n                // create a new tile with the code and image\n                let tile = new _Tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"](code, image, this.p);\n                row.push(tile);\n            }\n            // add the row of tiles to the layout\n            this.layout.push(row);\n        }\n    }\n    draw(xOffset, yOffset, debug) {\n        this.p.push();\n        this.p.noStroke();\n        this.p.fill(\"lightskyblue\");\n        // draw the background of the level\n        this.p.rect(xOffset, yOffset, this.levelWidth, this.levelHeight);\n        this.p.pop();\n        // draw each tile in the layout\n        for(let i = 0; i < this.rows; i++){\n            for(let j = 0; j < this.cols; j++){\n                let x = xOffset + j * this.tile_size;\n                let y = yOffset + i * this.tile_size;\n                let tile = this.layout[i][j];\n                tile.draw(x, y, this.tile_size, debug);\n            }\n        }\n    }\n    constructor(rows, cols, rawlayout, tile_size, images, p){\n        this.handleCollisions = (player, xOffset, yOffset)=>{\n            // calculate the player's bounding box\n            let playerLeft = player.x;\n            let playerRight = player.x + player.width;\n            let playerTop = player.y;\n            let playerBottom = player.y + player.height;\n            // add the player's velocity to their position\n            let newPlayerLeft = playerLeft + player.vx;\n            let newPlayerRight = playerRight + player.vx;\n            let newPlayerTop = playerTop + player.vy;\n            let newPlayerBottom = playerBottom + player.vy;\n            let tileLeft;\n            let tileRight;\n            let tileTop;\n            let tileBottom;\n            // loop through the grid array and check for collisions\n            for(let i = 0; i < this.rows; i++){\n                for(let j = 0; j < this.cols; j++){\n                    switch(this.layout[i][j].code){\n                        case \"gra\":\n                        case \"sto\":\n                            // calculate the bounding box of the tile with a buffer \n                            tileLeft = xOffset + j * this.tile_size;\n                            tileRight = xOffset + (j + 1) * this.tile_size;\n                            tileTop = yOffset + i * this.tile_size;\n                            tileBottom = yOffset + (i + 1) * this.tile_size;\n                            // check if the player's bounding box overlaps with the tile's bounding box\n                            if (newPlayerLeft < tileRight && newPlayerRight > tileLeft && newPlayerTop < tileBottom && newPlayerBottom > tileTop) {\n                                let overlapLeft = Math.max(newPlayerLeft, tileLeft);\n                                let overlapRight = Math.min(newPlayerRight, tileRight);\n                                let overlapTop = Math.max(newPlayerTop, tileTop);\n                                let overlapBottom = Math.min(newPlayerBottom, tileBottom);\n                                let overlapWidth = overlapRight - overlapLeft;\n                                let overlapHeight = overlapBottom - overlapTop;\n                                // determine the direction of the collision\n                                let direction;\n                                //DEBUG\n                                if (DEBUG) console.log(\"OW: \" + overlapWidth);\n                                if (DEBUG) console.log(\"OH: \" + overlapHeight);\n                                if (DEBUG) console.log(\"Nya\");\n                                if (DEBUG) console.log(\"\");\n                                if (overlapWidth < overlapHeight) {\n                                    //Esas const son el bandaid al bugazo, cambiar a un porcentaje basado en las tiles\n                                    direction = overlapLeft - 10 < newPlayerLeft ? \"left\" : \"right\";\n                                } else {\n                                    direction = overlapTop < newPlayerTop + 10 ? \"up\" : \"down\";\n                                }\n                                // adjust the player's position based on the overlap and direction of the collision\n                                switch(direction){\n                                    case \"left\":\n                                        if (DEBUG) console.log(\"Nya\");\n                                        player.x += overlapWidth - player.vx;\n                                        break;\n                                    case \"right\":\n                                        if (DEBUG) console.log(\"Goode\");\n                                        player.x -= overlapWidth - player.vx;\n                                        break;\n                                    case \"up\":\n                                        if (DEBUG) console.log(\"Bure\");\n                                        player.y += overlapHeight - player.vy;\n                                        player.vy = 0;\n                                        break;\n                                    case \"down\":\n                                        player.y -= overlapHeight - player.vy;\n                                        player.jumps = 2;\n                                        player.vy = 0; // reset the player's vertical velocity\n                                        break;\n                                }\n                            }\n                            break;\n                        case \"spi\":\n                            // calculate the bounding box of the tile\n                            tileLeft = xOffset + j * this.tile_size;\n                            tileRight = xOffset + (j + 1) * this.tile_size;\n                            tileTop = yOffset + i * this.tile_size + 0.28 * this.tile_size;\n                            tileBottom = yOffset + (i + 1) * this.tile_size;\n                            // check if the player's bounding box overlaps with the tile's bounding box\n                            if (newPlayerLeft < tileRight && newPlayerRight > tileLeft && newPlayerTop < tileBottom && newPlayerBottom > tileTop) {\n                                // there is a collision!\n                                // reset the player's position to their previous position\n                                let overlapLeft = Math.max(newPlayerLeft, tileLeft);\n                                let overlapRight = Math.min(newPlayerRight, tileRight);\n                                let overlapTop = Math.max(newPlayerTop, tileTop);\n                                let overlapBottom = Math.min(newPlayerBottom, tileBottom);\n                                let overlapWidth = overlapRight - overlapLeft;\n                                let overlapHeight = overlapBottom - overlapTop;\n                                // determine the direction of the collision\n                                let direction;\n                                if (overlapWidth < overlapHeight) {\n                                    direction = overlapLeft < newPlayerLeft ? \"left\" : \"right\";\n                                } else {\n                                    direction = overlapTop < newPlayerTop ? \"up\" : \"down\";\n                                }\n                                // adjust the player's position based on the overlap and direction of the collision\n                                switch(direction){\n                                    case \"left\":\n                                        player.x += overlapWidth - player.vx;\n                                        break;\n                                    case \"right\":\n                                        player.x -= overlapWidth - player.vx;\n                                        break;\n                                    case \"up\":\n                                        player.y += overlapHeight - player.vy;\n                                        break;\n                                    case \"down\":\n                                        player.y -= overlapHeight - player.vy;\n                                        player.vy = 0; // reset the player's vertical velocity\n                                        break;\n                                }\n                                /* Death triggers */ player.isAlive = false;\n                            }\n                            break;\n                        case \"coi\":\n                        case \"gem\":\n                            // calculate the center and radius of the ellipse\n                            let centerX = xOffset + j * this.tile_size + this.tile_size * 0.5;\n                            let centerY = yOffset + i * this.tile_size + this.tile_size * 0.5;\n                            let radiusX = this.tile_size * 0.35;\n                            let radiusY = this.tile_size * 0.35;\n                            // check if the player's bounding box overlaps with the tile's ellipse\n                            if (playerLeft < centerX + radiusX && playerRight > centerX - radiusX && playerTop < centerY + radiusY && playerBottom > centerY - radiusY) {\n                                this.layout[i][j].code = \"000\";\n                                this.layout[i][j].image = this.images[15];\n                            }\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n        };\n        this.rows = rows;\n        this.cols = cols;\n        this.rawLayout = rawlayout;\n        this.tile_size = tile_size;\n        this.layout = [];\n        this.p = p;\n        this.images = images;\n        this.levelWidth = this.cols * this.tile_size;\n        this.levelHeight = this.rows * this.tile_size;\n        // create the layout\n        this.createLayout();\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUksQ0FBQ0gsV0FBVyxHQUFHLElBQUksQ0FBQ3BCLElBQUksR0FBRyxJQUFJLENBQUN1QixTQUFTO1FBRTdDLG9CQUFvQjtRQUNwQixJQUFJLENBQUN6QixZQUFZO0lBQ25CO0FBa05GO0FBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3BhZ2VzL2NsYXNzZXMvTGV2ZWwudHN4PzMzOTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHA1IGZyb20gJ3A1JztcbmltcG9ydCBUaWxlIGZyb20gJy4vVGlsZSc7XG5pbXBvcnQgUGxheWVyIGZyb20gJy4vUGxheWVyJztcbmNvbnN0IERFQlVHID0gdHJ1ZTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExldmVsIHtcbiAgcm93czogbnVtYmVyO1xuICBjb2xzOiBudW1iZXI7XG4gIHJhd0xheW91dDogc3RyaW5nW107XG4gIHRpbGVfc2l6ZTogbnVtYmVyO1xuICBsYXlvdXQ6IFRpbGVbXVtdO1xuICBwOiBwNTtcbiAgaW1hZ2VzOiBhbnlbXTtcbiAgbGV2ZWxXaWR0aDogbnVtYmVyO1xuICBsZXZlbEhlaWdodDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHJvd3M6IG51bWJlciwgY29sczogbnVtYmVyLCByYXdsYXlvdXQ6IHN0cmluZ1tdLCB0aWxlX3NpemU6IG51bWJlciwgaW1hZ2VzOiBhbnlbXSwgcDogcDUpIHtcbiAgICB0aGlzLnJvd3MgPSByb3dzO1xuICAgIHRoaXMuY29scyA9IGNvbHM7XG4gICAgdGhpcy5yYXdMYXlvdXQgPSByYXdsYXlvdXQ7IFxuICAgIHRoaXMudGlsZV9zaXplID0gdGlsZV9zaXplO1xuICAgIHRoaXMubGF5b3V0ID0gW107IFxuICAgIHRoaXMucCA9IHA7XG4gICAgdGhpcy5pbWFnZXMgPSBpbWFnZXM7XG4gICAgdGhpcy5sZXZlbFdpZHRoID0gdGhpcy5jb2xzICogdGhpcy50aWxlX3NpemU7XG4gICAgdGhpcy5sZXZlbEhlaWdodCA9IHRoaXMucm93cyAqIHRoaXMudGlsZV9zaXplO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBsYXlvdXRcbiAgICB0aGlzLmNyZWF0ZUxheW91dCgpO1xuICB9XG5cbiAgY3JlYXRlTGF5b3V0KCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGxldCByb3cgPSBbXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2xzOyBqKyspIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBjb2RlIGZvciB0aGUgY3VycmVudCB0aWxlXG4gICAgICAgIGxldCBjb2RlID0gdGhpcy5yYXdMYXlvdXRbaSAqIHRoaXMuY29scyArIGpdO1xuICAgICAgICBsZXQgaW1hZ2U7XG5cbiAgICAgICAgLy8gdXNlIHRoZSBhcHByb3ByaWF0ZSBpbWFnZSBmb3IgdGhlIHRpbGUgYmFzZWQgb24gaXRzIGNvZGVcbiAgICAgICAgc3dpdGNoKGNvZGUpe1xuICAgICAgICAgIGNhc2UoXCJncmFcIik6IGltYWdlPXRoaXMuaW1hZ2VzWzBdOyBicmVhaztcbiAgICAgICAgICBjYXNlKFwiZGlyXCIpOiBpbWFnZT10aGlzLmltYWdlc1sxXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZShcImNvaVwiKTogaW1hZ2U9dGhpcy5pbWFnZXNbMl07IGJyZWFrO1xuICAgICAgICAgIGNhc2UoXCJnZW1cIik6IGltYWdlPXRoaXMuaW1hZ2VzWzNdOyBicmVhaztcbiAgICAgICAgICBjYXNlKFwiY2xsXCIpOiBpbWFnZT10aGlzLmltYWdlc1s0XTsgYnJlYWs7XG4gICAgICAgICAgY2FzZShcImNsclwiKTogaW1hZ2U9dGhpcy5pbWFnZXNbNV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UoXCJmbG9cIik6IGltYWdlPXRoaXMuaW1hZ2VzWzZdOyBicmVhaztcbiAgICAgICAgICBjYXNlKFwicHNtXCIpOiBpbWFnZT10aGlzLmltYWdlc1s3XTsgYnJlYWs7XG4gICAgICAgICAgY2FzZShcInBiZFwiKTogaW1hZ2U9dGhpcy5pbWFnZXNbOF07IGJyZWFrO1xuICAgICAgICAgIGNhc2UoXCJwYnVcIik6IGltYWdlPXRoaXMuaW1hZ2VzWzldOyBicmVhaztcbiAgICAgICAgICBjYXNlKFwidHNtXCIpOiBpbWFnZT10aGlzLmltYWdlc1sxMF07IGJyZWFrO1xuICAgICAgICAgIGNhc2UoXCJ0YmRcIik6IGltYWdlPXRoaXMuaW1hZ2VzWzExXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZShcInRidVwiKTogaW1hZ2U9dGhpcy5pbWFnZXNbMTJdOyBicmVhaztcbiAgICAgICAgICBjYXNlKFwic3RvXCIpOiBpbWFnZT10aGlzLmltYWdlc1sxM107IGJyZWFrO1xuICAgICAgICAgIGNhc2UoXCJzcGlcIik6IGltYWdlPXRoaXMuaW1hZ2VzWzE0XTsgYnJlYWs7XG4gICAgICAgICAgY2FzZShcIjAwMFwiKTogaW1hZ2U9dGhpcy5pbWFnZXNbMTVdOyBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OiBpbWFnZT10aGlzLmltYWdlc1sxNl07IGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgdGlsZSB3aXRoIHRoZSBjb2RlIGFuZCBpbWFnZVxuICAgICAgICBsZXQgdGlsZSA9IG5ldyBUaWxlKGNvZGUsIGltYWdlLCB0aGlzLnApO1xuICAgICAgICByb3cucHVzaCh0aWxlKTtcbiAgICAgIH1cbiAgICAgIC8vIGFkZCB0aGUgcm93IG9mIHRpbGVzIHRvIHRoZSBsYXlvdXRcbiAgICAgIHRoaXMubGF5b3V0LnB1c2gocm93KTtcbiAgICB9XG4gIH1cblxuICBkcmF3KHhPZmZzZXQ6IG51bWJlciwgeU9mZnNldDogbnVtYmVyLGRlYnVnOmJvb2xlYW4pIHtcbiAgICB0aGlzLnAucHVzaCgpO1xuICAgICAgdGhpcy5wLm5vU3Ryb2tlKCk7XG4gICAgICB0aGlzLnAuZmlsbChcImxpZ2h0c2t5Ymx1ZVwiKTtcbiAgICAvLyBkcmF3IHRoZSBiYWNrZ3JvdW5kIG9mIHRoZSBsZXZlbFxuICAgICAgdGhpcy5wLnJlY3QoeE9mZnNldCwgeU9mZnNldCwgdGhpcy5sZXZlbFdpZHRoLCB0aGlzLmxldmVsSGVpZ2h0KTtcbiAgICB0aGlzLnAucG9wKCk7XG4gICAgLy8gZHJhdyBlYWNoIHRpbGUgaW4gdGhlIGxheW91dFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2xzOyBqKyspIHtcbiAgICAgICAgbGV0IHggPSB4T2Zmc2V0ICsgKGogKiB0aGlzLnRpbGVfc2l6ZSk7XG4gICAgICAgIGxldCB5ID0geU9mZnNldCArIChpICogdGhpcy50aWxlX3NpemUpO1xuICAgICAgICBsZXQgdGlsZSA9IHRoaXMubGF5b3V0W2ldW2pdO1xuICAgICAgICB0aWxlLmRyYXcoeCwgeSwgdGhpcy50aWxlX3NpemUsZGVidWcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUNvbGxpc2lvbnM9IChwbGF5ZXI6UGxheWVyLHhPZmZzZXQ6bnVtYmVyLHlPZmZzZXQ6bnVtYmVyKSA9PiB7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBwbGF5ZXIncyBib3VuZGluZyBib3hcbiAgICBsZXQgcGxheWVyTGVmdCA9IHBsYXllci54O1xuICAgIGxldCBwbGF5ZXJSaWdodCA9IHBsYXllci54ICsgcGxheWVyLndpZHRoO1xuICAgIGxldCBwbGF5ZXJUb3AgPSBwbGF5ZXIueTtcbiAgICBsZXQgcGxheWVyQm90dG9tID0gcGxheWVyLnkgKyBwbGF5ZXIuaGVpZ2h0O1xuXG4gICAgLy8gYWRkIHRoZSBwbGF5ZXIncyB2ZWxvY2l0eSB0byB0aGVpciBwb3NpdGlvblxuICAgIGxldCBuZXdQbGF5ZXJMZWZ0ID0gcGxheWVyTGVmdCArIHBsYXllci52eDtcbiAgICBsZXQgbmV3UGxheWVyUmlnaHQgPSBwbGF5ZXJSaWdodCArIHBsYXllci52eDtcbiAgICBsZXQgbmV3UGxheWVyVG9wID0gcGxheWVyVG9wICsgcGxheWVyLnZ5O1xuICAgIGxldCBuZXdQbGF5ZXJCb3R0b20gPSBwbGF5ZXJCb3R0b20gKyBwbGF5ZXIudnk7XG5cbiAgICBsZXQgdGlsZUxlZnQgO1xuICAgIGxldCB0aWxlUmlnaHQ7XG4gICAgbGV0IHRpbGVUb3A7XG4gICAgbGV0IHRpbGVCb3R0b207XG4gICAgLy8gbG9vcCB0aHJvdWdoIHRoZSBncmlkIGFycmF5IGFuZCBjaGVjayBmb3IgY29sbGlzaW9uc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2xzOyBqKyspIHtcblxuICAgICAgICBzd2l0Y2godGhpcy5sYXlvdXRbaV1bal0uY29kZSl7XG5cbiAgICAgICAgICBjYXNlKFwiZ3JhXCIpOiBcbiAgICAgICAgICBjYXNlKFwic3RvXCIpOlxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHRpbGUgd2l0aCBhIGJ1ZmZlciBcbiAgICAgICAgICAgIHRpbGVMZWZ0ID0geE9mZnNldCArIChqICogdGhpcy50aWxlX3NpemUpO1xuICAgICAgICAgICAgdGlsZVJpZ2h0ID0geE9mZnNldCArKChqKzEpICogdGhpcy50aWxlX3NpemUpO1xuICAgICAgICAgICAgdGlsZVRvcCA9IHlPZmZzZXQrIChpICogdGhpcy50aWxlX3NpemUpO1xuICAgICAgICAgICAgdGlsZUJvdHRvbSA9IHlPZmZzZXQrKChpKzEpICogdGhpcy50aWxlX3NpemUpO1xuICAgIFxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHBsYXllcidzIGJvdW5kaW5nIGJveCBvdmVybGFwcyB3aXRoIHRoZSB0aWxlJ3MgYm91bmRpbmcgYm94XG4gICAgICAgICAgICBpZiAobmV3UGxheWVyTGVmdCA8IHRpbGVSaWdodCAmJiBuZXdQbGF5ZXJSaWdodCA+IHRpbGVMZWZ0ICYmIG5ld1BsYXllclRvcCA8IHRpbGVCb3R0b20gJiYgbmV3UGxheWVyQm90dG9tID4gdGlsZVRvcCkge1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIGxldCBvdmVybGFwTGVmdCA9IE1hdGgubWF4KG5ld1BsYXllckxlZnQsIHRpbGVMZWZ0KTtcbiAgICAgICAgICAgICAgICAgIGxldCBvdmVybGFwUmlnaHQgPSBNYXRoLm1pbihuZXdQbGF5ZXJSaWdodCwgdGlsZVJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgIGxldCBvdmVybGFwVG9wID0gTWF0aC5tYXgobmV3UGxheWVyVG9wLCB0aWxlVG9wKTtcbiAgICAgICAgICAgICAgICAgIGxldCBvdmVybGFwQm90dG9tID0gTWF0aC5taW4obmV3UGxheWVyQm90dG9tLCB0aWxlQm90dG9tKTtcbiAgICAgICAgICAgICAgICAgIGxldCBvdmVybGFwV2lkdGggPSBvdmVybGFwUmlnaHQgLSBvdmVybGFwTGVmdDtcbiAgICAgICAgICAgICAgICAgIGxldCBvdmVybGFwSGVpZ2h0ID0gb3ZlcmxhcEJvdHRvbSAtIG92ZXJsYXBUb3A7XG5cbiAgICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICAgIGxldCBkaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vREVCVUdcbiAgICAgICAgICAgICAgICAgIGlmIChERUJVRykgY29uc29sZS5sb2coJ09XOiAnK292ZXJsYXBXaWR0aCk7XG4gICAgICAgICAgICAgICAgICBpZiAoREVCVUcpIGNvbnNvbGUubG9nKCdPSDogJytvdmVybGFwSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgIGlmIChERUJVRykgY29uc29sZS5sb2coJ055YScpO1xuICAgICAgICAgICAgICAgICAgaWYgKERFQlVHKSBjb25zb2xlLmxvZygnJyk7XG5cblxuICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBXaWR0aCA8IG92ZXJsYXBIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9Fc2FzIGNvbnN0IHNvbiBlbCBiYW5kYWlkIGFsIGJ1Z2F6bywgY2FtYmlhciBhIHVuIHBvcmNlbnRhamUgYmFzYWRvIGVuIGxhcyB0aWxlc1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBvdmVybGFwTGVmdC0xMCA8IG5ld1BsYXllckxlZnQgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IG92ZXJsYXBUb3AgPCBuZXdQbGF5ZXJUb3ArMTAgPyBcInVwXCIgOiBcImRvd25cIjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFkanVzdCB0aGUgcGxheWVyJ3MgcG9zaXRpb24gYmFzZWQgb24gdGhlIG92ZXJsYXAgYW5kIGRpcmVjdGlvbiBvZiB0aGUgY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChERUJVRykgY29uc29sZS5sb2coJ055YScpO1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIueCArPSBvdmVybGFwV2lkdGggLSBwbGF5ZXIudng7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChERUJVRykgY29uc29sZS5sb2coJ0dvb2RlJyk7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci54IC09IG92ZXJsYXBXaWR0aCAtIHBsYXllci52eDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidXBcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKERFQlVHKSBjb25zb2xlLmxvZygnQnVyZScpO1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIueSArPSBvdmVybGFwSGVpZ2h0IC0gcGxheWVyLnZ5O1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIudnkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJkb3duXCI6XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci55IC09IG92ZXJsYXBIZWlnaHQgLSBwbGF5ZXIudnk7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5qdW1wcz0yO1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIudnkgPSAwOyAvLyByZXNldCB0aGUgcGxheWVyJ3MgdmVydGljYWwgdmVsb2NpdHlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZShcInNwaVwiKTpcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSB0aWxlXG4gICAgICAgICAgICB0aWxlTGVmdCA9IHhPZmZzZXQgKyAoaiAqIHRoaXMudGlsZV9zaXplKTtcbiAgICAgICAgICAgIHRpbGVSaWdodCA9ICB4T2Zmc2V0ICsoKGorMSkgKiB0aGlzLnRpbGVfc2l6ZSk7XG4gICAgICAgICAgICB0aWxlVG9wID0geU9mZnNldCsgKGkgKiB0aGlzLnRpbGVfc2l6ZSkrKDAuMjgqdGhpcy50aWxlX3NpemUpO1xuICAgICAgICAgICAgdGlsZUJvdHRvbSA9IHlPZmZzZXQrKChpKzEpICogdGhpcy50aWxlX3NpemUpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgcGxheWVyJ3MgYm91bmRpbmcgYm94IG92ZXJsYXBzIHdpdGggdGhlIHRpbGUncyBib3VuZGluZyBib3hcbiAgICAgICAgICAgIGlmIChuZXdQbGF5ZXJMZWZ0IDwgdGlsZVJpZ2h0ICYmIG5ld1BsYXllclJpZ2h0ID4gdGlsZUxlZnQgJiYgbmV3UGxheWVyVG9wIDwgdGlsZUJvdHRvbSAmJiBuZXdQbGF5ZXJCb3R0b20gPiB0aWxlVG9wKSB7XG4gICAgICAgICAgICAgIC8vIHRoZXJlIGlzIGEgY29sbGlzaW9uIVxuICAgICAgICAgICAgICAvLyByZXNldCB0aGUgcGxheWVyJ3MgcG9zaXRpb24gdG8gdGhlaXIgcHJldmlvdXMgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBsZXQgb3ZlcmxhcExlZnQgPSBNYXRoLm1heChuZXdQbGF5ZXJMZWZ0LCB0aWxlTGVmdCk7XG4gICAgICAgICAgICAgICAgbGV0IG92ZXJsYXBSaWdodCA9IE1hdGgubWluKG5ld1BsYXllclJpZ2h0LCB0aWxlUmlnaHQpO1xuICAgICAgICAgICAgICAgIGxldCBvdmVybGFwVG9wID0gTWF0aC5tYXgobmV3UGxheWVyVG9wLCB0aWxlVG9wKTtcbiAgICAgICAgICAgICAgICBsZXQgb3ZlcmxhcEJvdHRvbSA9IE1hdGgubWluKG5ld1BsYXllckJvdHRvbSwgdGlsZUJvdHRvbSk7XG4gICAgICAgICAgICAgICAgbGV0IG92ZXJsYXBXaWR0aCA9IG92ZXJsYXBSaWdodCAtIG92ZXJsYXBMZWZ0O1xuICAgICAgICAgICAgICAgIGxldCBvdmVybGFwSGVpZ2h0ID0gb3ZlcmxhcEJvdHRvbSAtIG92ZXJsYXBUb3A7XG4gICAgICBcbiAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIGRpcmVjdGlvbiBvZiB0aGUgY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgbGV0IGRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcFdpZHRoIDwgb3ZlcmxhcEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gb3ZlcmxhcExlZnQgPCBuZXdQbGF5ZXJMZWZ0ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IG92ZXJsYXBUb3AgPCBuZXdQbGF5ZXJUb3AgPyBcInVwXCIgOiBcImRvd25cIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhZGp1c3QgdGhlIHBsYXllcidzIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBvdmVybGFwIGFuZCBkaXJlY3Rpb24gb2YgdGhlIGNvbGxpc2lvblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIueCArPSBvdmVybGFwV2lkdGggLSBwbGF5ZXIudng7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci54IC09IG92ZXJsYXBXaWR0aCAtIHBsYXllci52eDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidXBcIjpcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLnkgKz0gb3ZlcmxhcEhlaWdodCAtIHBsYXllci52eTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZG93blwiOlxuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIueSAtPSBvdmVybGFwSGVpZ2h0IC0gcGxheWVyLnZ5O1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIudnkgPSAwOyAvLyByZXNldCB0aGUgcGxheWVyJ3MgdmVydGljYWwgdmVsb2NpdHlcbiAgXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyogRGVhdGggdHJpZ2dlcnMgKi9cbiAgICAgICAgICAgICAgcGxheWVyLmlzQWxpdmU9ZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgXG4gICAgICAgICAgY2FzZShcImNvaVwiKTpcbiAgICAgICAgICBjYXNlKFwiZ2VtXCIpOlxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBjZW50ZXIgYW5kIHJhZGl1cyBvZiB0aGUgZWxsaXBzZVxuICAgICAgICAgICAgbGV0IGNlbnRlclggPSB4T2Zmc2V0ICsgKGogKiB0aGlzLnRpbGVfc2l6ZSkgKyAodGhpcy50aWxlX3NpemUgKiAwLjUpO1xuICAgICAgICAgICAgbGV0IGNlbnRlclkgPSB5T2Zmc2V0KyAoaSAqIHRoaXMudGlsZV9zaXplKSArICh0aGlzLnRpbGVfc2l6ZSAqIDAuNSk7XG4gICAgICAgICAgICBsZXQgcmFkaXVzWCA9IHRoaXMudGlsZV9zaXplICogMC4zNTtcbiAgICAgICAgICAgIGxldCByYWRpdXNZID0gdGhpcy50aWxlX3NpemUgKiAwLjM1O1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgcGxheWVyJ3MgYm91bmRpbmcgYm94IG92ZXJsYXBzIHdpdGggdGhlIHRpbGUncyBlbGxpcHNlXG4gICAgICAgICAgICBpZiAocGxheWVyTGVmdCA8IGNlbnRlclggKyByYWRpdXNYICYmIHBsYXllclJpZ2h0ID4gY2VudGVyWCAtIHJhZGl1c1ggJiYgcGxheWVyVG9wIDwgY2VudGVyWSArIHJhZGl1c1kgJiYgcGxheWVyQm90dG9tID4gY2VudGVyWSAtIHJhZGl1c1kpIHtcbiAgICAgICAgICAgICAgdGhpcy5sYXlvdXRbaV1bal0uY29kZT1cIjAwMFwiO1xuICAgICAgICAgICAgICB0aGlzLmxheW91dFtpXVtqXS5pbWFnZT10aGlzLmltYWdlc1sxNV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgXG4gICAgICAgICAgZGVmYXVsdDogIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cbiJdLCJuYW1lcyI6WyJUaWxlIiwiREVCVUciLCJMZXZlbCIsImNyZWF0ZUxheW91dCIsImkiLCJyb3dzIiwicm93IiwiaiIsImNvbHMiLCJjb2RlIiwicmF3TGF5b3V0IiwiaW1hZ2UiLCJpbWFnZXMiLCJ0aWxlIiwicCIsInB1c2giLCJsYXlvdXQiLCJkcmF3IiwieE9mZnNldCIsInlPZmZzZXQiLCJkZWJ1ZyIsIm5vU3Ryb2tlIiwiZmlsbCIsInJlY3QiLCJsZXZlbFdpZHRoIiwibGV2ZWxIZWlnaHQiLCJwb3AiLCJ4IiwidGlsZV9zaXplIiwieSIsImNvbnN0cnVjdG9yIiwicmF3bGF5b3V0IiwiaGFuZGxlQ29sbGlzaW9ucyIsInBsYXllciIsInBsYXllckxlZnQiLCJwbGF5ZXJSaWdodCIsIndpZHRoIiwicGxheWVyVG9wIiwicGxheWVyQm90dG9tIiwiaGVpZ2h0IiwibmV3UGxheWVyTGVmdCIsInZ4IiwibmV3UGxheWVyUmlnaHQiLCJuZXdQbGF5ZXJUb3AiLCJ2eSIsIm5ld1BsYXllckJvdHRvbSIsInRpbGVMZWZ0IiwidGlsZVJpZ2h0IiwidGlsZVRvcCIsInRpbGVCb3R0b20iLCJvdmVybGFwTGVmdCIsIk1hdGgiLCJtYXgiLCJvdmVybGFwUmlnaHQiLCJtaW4iLCJvdmVybGFwVG9wIiwib3ZlcmxhcEJvdHRvbSIsIm92ZXJsYXBXaWR0aCIsIm92ZXJsYXBIZWlnaHQiLCJkaXJlY3Rpb24iLCJjb25zb2xlIiwibG9nIiwianVtcHMiLCJpc0FsaXZlIiwiY2VudGVyWCIsImNlbnRlclkiLCJyYWRpdXNYIiwicmFkaXVzWSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/classes/Level.tsx\n"));

/***/ }),

/***/ "./src/pages/classes/Player.tsx":
/*!**************************************!*\
  !*** ./src/pages/classes/Player.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Player; }\n/* harmony export */ });\nconst gravity = 0.15;\nconst jumpVelocity = -5;\nclass Player {\n    // move the player by dx and dy\n    movePlayer(dx, dy) {\n        // update the player's previous position\n        this.prevX = this.x;\n        this.prevY = this.y;\n        // update the player's current position\n        this.x += dx;\n        this.y += dy;\n    }\n    // move the player by the means of gravity\n    update() {\n        // update the player's previous position\n        this.prevX = this.x;\n        this.prevY = this.y;\n        this.vy += gravity;\n        this.jump();\n        // update the player's current position\n        this.x += this.vx;\n        this.y += this.vy;\n    }\n    jump() {\n        if (this.isJumping && this.jumps != 0) {\n            this.vy = jumpVelocity;\n            this.jumps -= 1;\n            this.isJumping = false;\n        }\n    }\n    // draw the player as a red rectangle (temporal)\n    draw() {\n        this.p.push();\n        this.p.fill(\"red\");\n        this.p.rect(this.x, this.y, this.width, this.height);\n        this.p.image(this.image, this.x, this.y, this.width, this.height);\n        this.p.pop();\n    }\n    keyMovement() {\n        if (this.p.keyIsDown(this.p.LEFT_ARROW)) {\n            this.movePlayer(-3, 0);\n        }\n        if (this.p.keyIsDown(this.p.RIGHT_ARROW)) {\n            this.movePlayer(3, 0);\n        }\n    }\n    constructor(width, height, x, y, image, p){\n        this.vx = 0;\n        this.vy = 0;\n        this.isAlive = true;\n        this.isJumping = false;\n        this.jumps = 2;\n        // initialize position and size\n        this.width = width;\n        this.height = height;\n        this.x = this.prevX = x;\n        this.y = this.prevY = y;\n        this.image = image;\n        // store the p5 instance\n        this.p = p;\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDLEdBQUdBO0lBQ1g7QUFpREY7QUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvcGFnZXMvY2xhc3Nlcy9QbGF5ZXIudHN4P2VmOGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdHlwZSB9IGZyb20gJ29zJztcbmltcG9ydCBwNSBmcm9tICdwNSc7XG5cbmNvbnN0IGdyYXZpdHk9MC4xNTtcbmNvbnN0IGp1bXBWZWxvY2l0eSA9IC01O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGF5ZXIge1xuICAvLyBjdXJyZW50IHBvc2l0aW9uIGFuZCBzaXplIG9mIHRoZSBwbGF5ZXJcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIHZ4Om51bWJlcj0wO1xuICB2eTpudW1iZXI9MDtcbiAgd2lkdGg6IG51bWJlcjtcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIGlzQWxpdmU6Ym9vbGVhbj10cnVlO1xuICBpbWFnZTpwNS5JbWFnZTtcbiAgcHJldlg6IG51bWJlcjtcbiAgcHJldlk6IG51bWJlcjtcbiAgaXNKdW1waW5nOiBib29sZWFuID0gZmFsc2U7XG4gIGp1bXBzOm51bWJlcj0yO1xuICAvLyB0aGUgcDUgaW5zdGFuY2UgdXNlZCBmb3IgZHJhd2luZ1xuICBwOiBwNTtcblxuICBjb25zdHJ1Y3Rvcih3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgeDogbnVtYmVyLCB5OiBudW1iZXIsaW1hZ2U6cDUuSW1hZ2UsIHA6IHA1KSB7XG4gICAgLy8gaW5pdGlhbGl6ZSBwb3NpdGlvbiBhbmQgc2l6ZVxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnggPSB0aGlzLnByZXZYID0geDtcbiAgICB0aGlzLnkgPSB0aGlzLnByZXZZID0geTtcbiAgICB0aGlzLmltYWdlPWltYWdlO1xuICAgIC8vIHN0b3JlIHRoZSBwNSBpbnN0YW5jZVxuICAgIHRoaXMucCA9IHA7XG4gIH1cblxuICAvLyBtb3ZlIHRoZSBwbGF5ZXIgYnkgZHggYW5kIGR5XG4gIG1vdmVQbGF5ZXIoZHg6IG51bWJlciwgZHk6IG51bWJlcikge1xuICAgIC8vIHVwZGF0ZSB0aGUgcGxheWVyJ3MgcHJldmlvdXMgcG9zaXRpb25cbiAgICB0aGlzLnByZXZYID0gdGhpcy54O1xuICAgIHRoaXMucHJldlkgPSB0aGlzLnk7XG4gICAgLy8gdXBkYXRlIHRoZSBwbGF5ZXIncyBjdXJyZW50IHBvc2l0aW9uXG4gICAgdGhpcy54ICs9IGR4O1xuICAgIHRoaXMueSArPSBkeTtcbiAgfVxuXG4gIC8vIG1vdmUgdGhlIHBsYXllciBieSB0aGUgbWVhbnMgb2YgZ3Jhdml0eVxuICB1cGRhdGUoKSB7XG4gICAgLy8gdXBkYXRlIHRoZSBwbGF5ZXIncyBwcmV2aW91cyBwb3NpdGlvblxuICAgIHRoaXMucHJldlggPSB0aGlzLng7XG4gICAgdGhpcy5wcmV2WSA9IHRoaXMueTtcbiAgICB0aGlzLnZ5ICs9IGdyYXZpdHk7XG4gICAgdGhpcy5qdW1wKCk7XG4gICAgLy8gdXBkYXRlIHRoZSBwbGF5ZXIncyBjdXJyZW50IHBvc2l0aW9uXG4gICAgdGhpcy54ICs9IHRoaXMudng7XG4gICAgdGhpcy55ICs9IHRoaXMudnk7XG4gIH1cblxuICBqdW1wKCl7XG4gICAgaWYgKHRoaXMuaXNKdW1waW5nICYmIHRoaXMuanVtcHMhPTApIHtcbiAgICAgIHRoaXMudnkgPSBqdW1wVmVsb2NpdHk7XG4gICAgICB0aGlzLmp1bXBzLT0xO1xuICAgICAgdGhpcy5pc0p1bXBpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBkcmF3IHRoZSBwbGF5ZXIgYXMgYSByZWQgcmVjdGFuZ2xlICh0ZW1wb3JhbClcbiAgZHJhdygpIHtcbiAgICB0aGlzLnAucHVzaCgpO1xuICAgICAgdGhpcy5wLmZpbGwoJ3JlZCcpO1xuICAgICAgdGhpcy5wLnJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMucC5pbWFnZSh0aGlzLmltYWdlLHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgdGhpcy5wLnBvcCgpO1xuICB9XG5cbiAga2V5TW92ZW1lbnQoKXtcbiAgICAgIGlmKHRoaXMucC5rZXlJc0Rvd24odGhpcy5wLkxFRlRfQVJST1cpKXtcbiAgICAgICAgdGhpcy5tb3ZlUGxheWVyKC0zLDApO1xuICAgICAgfVxuICAgICAgaWYodGhpcy5wLmtleUlzRG93bih0aGlzLnAuUklHSFRfQVJST1cpKXtcbiAgICAgICAgdGhpcy5tb3ZlUGxheWVyKDMsMCk7XG4gICAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJncmF2aXR5IiwianVtcFZlbG9jaXR5IiwiUGxheWVyIiwibW92ZVBsYXllciIsImR4IiwiZHkiLCJwcmV2WCIsIngiLCJwcmV2WSIsInkiLCJ1cGRhdGUiLCJ2eSIsImp1bXAiLCJ2eCIsImlzSnVtcGluZyIsImp1bXBzIiwiZHJhdyIsInAiLCJwdXNoIiwiZmlsbCIsInJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImltYWdlIiwicG9wIiwia2V5TW92ZW1lbnQiLCJrZXlJc0Rvd24iLCJMRUZUX0FSUk9XIiwiUklHSFRfQVJST1ciLCJjb25zdHJ1Y3RvciIsImlzQWxpdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/pages/classes/Player.tsx\n"));

/***/ }),

/***/ "./src/pages/classes/Tile.tsx":
/*!************************************!*\
  !*** ./src/pages/classes/Tile.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Tile; }\n/* harmony export */ });\nclass Tile {\n    // Method to draw the tile at a given position and size\n    draw(x, y, tile_size, debug) {\n        this.p.image(this.image, x, y, tile_size, tile_size); // Draw the tile image at the given position and size\n        // show hitboxes \n        if (debug) {\n            this.p.push();\n            this.p.noStroke();\n            this.p.fill(255, 0, 0, 125);\n            switch(this.code){\n                case \"gra\":\n                case \"sto\":\n                    this.p.rect(x, y, tile_size, tile_size);\n                    break;\n                case \"spi\":\n                    let ajustey = tile_size * 0.27;\n                    this.p.rect(x, y + ajustey, tile_size, tile_size - ajustey);\n                    break;\n                case \"coi\":\n                case \"gem\":\n                    this.p.ellipseMode(this.p.CENTER);\n                    let middle = tile_size * 0.5;\n                    this.p.ellipse(x + middle, y + middle, tile_size * 0.8, tile_size * 0.8);\n                    break;\n                default:\n                    break;\n            }\n            this.p.pop();\n        }\n    }\n    // Constructor for the Tile class\n    constructor(code, image, p5){\n        this.code = code; // Each tile has a unique code to identify it\n        this.image = image; // The image used to display the tile\n        this.p = p5; // The p5 instance used to draw the tile\n    }\n}\n// Define a class for each tile\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvY2xhc3Nlcy9UaWxlLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBR2UsTUFBTUE7SUFZbkIsdURBQXVEO0lBQ3ZEQyxLQUFLQyxDQUFTLEVBQUVDLENBQVMsRUFBRUMsU0FBaUIsRUFBQ0MsS0FBYSxFQUFFO1FBQzFELElBQUksQ0FBQ0MsQ0FBQyxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDQSxLQUFLLEVBQUVMLEdBQUdDLEdBQUdDLFdBQVdBLFlBQVkscURBQXFEO1FBRzNHLGlCQUFpQjtRQUNqQixJQUFHQyxPQUFNO1lBQ1AsSUFBSSxDQUFDQyxDQUFDLENBQUNFLElBQUk7WUFDWCxJQUFJLENBQUNGLENBQUMsQ0FBQ0csUUFBUTtZQUNmLElBQUksQ0FBQ0gsQ0FBQyxDQUFDSSxJQUFJLENBQUMsS0FBSSxHQUFFLEdBQUU7WUFDcEIsT0FBTyxJQUFJLENBQUNDLElBQUk7Z0JBRWQsS0FBSztnQkFDTCxLQUFLO29CQUNILElBQUksQ0FBQ0wsQ0FBQyxDQUFDTSxJQUFJLENBQUNWLEdBQUVDLEdBQUVDLFdBQVVBO29CQUM1QixLQUFNO2dCQUVOLEtBQUs7b0JBQ0gsSUFBSVMsVUFBU1QsWUFBVTtvQkFDdkIsSUFBSSxDQUFDRSxDQUFDLENBQUNNLElBQUksQ0FBQ1YsR0FBRUMsSUFBRVUsU0FBUVQsV0FBVUEsWUFBVVM7b0JBQzlDLEtBQU07Z0JBRU4sS0FBSztnQkFDTCxLQUFLO29CQUNILElBQUksQ0FBQ1AsQ0FBQyxDQUFDUSxXQUFXLENBQUMsSUFBSSxDQUFDUixDQUFDLENBQUNTLE1BQU07b0JBQ2hDLElBQUlDLFNBQU9aLFlBQVU7b0JBQ3JCLElBQUksQ0FBQ0UsQ0FBQyxDQUFDVyxPQUFPLENBQUNmLElBQUVjLFFBQU9iLElBQUVhLFFBQU9aLFlBQVUsS0FBSUEsWUFBVTtvQkFDM0QsS0FBTTtnQkFFTjtvQkFBVSxLQUFNO1lBQ2xCO1lBQ0EsSUFBSSxDQUFDRSxDQUFDLENBQUNZLEdBQUc7UUFDWixDQUFDO0lBRUg7SUF6Q0EsaUNBQWlDO0lBQ2pDQyxZQUFZUixJQUFZLEVBQUVKLEtBQWUsRUFBRWEsRUFBTSxDQUFFO1FBQ2pELElBQUksQ0FBQ1QsSUFBSSxHQUFHQSxNQUFNLDZDQUE2QztRQUMvRCxJQUFJLENBQUNKLEtBQUssR0FBR0EsT0FBTyxxQ0FBcUM7UUFDekQsSUFBSSxDQUFDRCxDQUFDLEdBQUdjLElBQUksd0NBQXdDO0lBQ3ZEO0FBcUNGO0FBaERBLCtCQUErQjtBQWdEOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3BhZ2VzL2NsYXNzZXMvVGlsZS50c3g/YzYyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcDUgZnJvbSAncDUnO1xuXG4vLyBEZWZpbmUgYSBjbGFzcyBmb3IgZWFjaCB0aWxlXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWxlIHtcbiAgY29kZTogc3RyaW5nO1xuICBpbWFnZTogcDUuSW1hZ2U7XG4gIHA6IHA1O1xuXG4gIC8vIENvbnN0cnVjdG9yIGZvciB0aGUgVGlsZSBjbGFzc1xuICBjb25zdHJ1Y3Rvcihjb2RlOiBzdHJpbmcsIGltYWdlOiBwNS5JbWFnZSwgcDU6IHA1KSB7XG4gICAgdGhpcy5jb2RlID0gY29kZTsgLy8gRWFjaCB0aWxlIGhhcyBhIHVuaXF1ZSBjb2RlIHRvIGlkZW50aWZ5IGl0XG4gICAgdGhpcy5pbWFnZSA9IGltYWdlOyAvLyBUaGUgaW1hZ2UgdXNlZCB0byBkaXNwbGF5IHRoZSB0aWxlXG4gICAgdGhpcy5wID0gcDU7IC8vIFRoZSBwNSBpbnN0YW5jZSB1c2VkIHRvIGRyYXcgdGhlIHRpbGVcbiAgfVxuICBcbiAgLy8gTWV0aG9kIHRvIGRyYXcgdGhlIHRpbGUgYXQgYSBnaXZlbiBwb3NpdGlvbiBhbmQgc2l6ZVxuICBkcmF3KHg6IG51bWJlciwgeTogbnVtYmVyLCB0aWxlX3NpemU6IG51bWJlcixkZWJ1Zzpib29sZWFuKSB7XG4gICAgdGhpcy5wLmltYWdlKHRoaXMuaW1hZ2UsIHgsIHksIHRpbGVfc2l6ZSwgdGlsZV9zaXplKTsgLy8gRHJhdyB0aGUgdGlsZSBpbWFnZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHNpemVcblxuXG4gICAgLy8gc2hvdyBoaXRib3hlcyBcbiAgICBpZihkZWJ1Zyl7XG4gICAgICB0aGlzLnAucHVzaCgpO1xuICAgICAgdGhpcy5wLm5vU3Ryb2tlKCk7XG4gICAgICB0aGlzLnAuZmlsbCgyNTUsMCwwLDEyNSk7XG4gICAgICBzd2l0Y2godGhpcy5jb2RlKXtcbiAgXG4gICAgICAgIGNhc2UoXCJncmFcIik6IFxuICAgICAgICBjYXNlKFwic3RvXCIpOlxuICAgICAgICAgIHRoaXMucC5yZWN0KHgseSx0aWxlX3NpemUsdGlsZV9zaXplKTsgIFxuICAgICAgICBicmVhaztcbiAgXG4gICAgICAgIGNhc2UoXCJzcGlcIik6XG4gICAgICAgICAgbGV0IGFqdXN0ZXk9KHRpbGVfc2l6ZSowLjI3KTtcbiAgICAgICAgICB0aGlzLnAucmVjdCh4LHkrYWp1c3RleSx0aWxlX3NpemUsdGlsZV9zaXplLWFqdXN0ZXkpOyAgXG4gICAgICAgIGJyZWFrO1xuICBcbiAgICAgICAgY2FzZShcImNvaVwiKTpcbiAgICAgICAgY2FzZShcImdlbVwiKTpcbiAgICAgICAgICB0aGlzLnAuZWxsaXBzZU1vZGUodGhpcy5wLkNFTlRFUik7XG4gICAgICAgICAgbGV0IG1pZGRsZT10aWxlX3NpemUqMC41O1xuICAgICAgICAgIHRoaXMucC5lbGxpcHNlKHgrbWlkZGxlLHkrbWlkZGxlLHRpbGVfc2l6ZSowLjgsdGlsZV9zaXplKjAuOCk7ICBcbiAgICAgICAgYnJlYWs7XG4gIFxuICAgICAgICBkZWZhdWx0OiAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLnAucG9wKCk7XG4gICAgfVxuICAgIFxuICB9XG59XG4iXSwibmFtZXMiOlsiVGlsZSIsImRyYXciLCJ4IiwieSIsInRpbGVfc2l6ZSIsImRlYnVnIiwicCIsImltYWdlIiwicHVzaCIsIm5vU3Ryb2tlIiwiZmlsbCIsImNvZGUiLCJyZWN0IiwiYWp1c3RleSIsImVsbGlwc2VNb2RlIiwiQ0VOVEVSIiwibWlkZGxlIiwiZWxsaXBzZSIsInBvcCIsImNvbnN0cnVjdG9yIiwicDUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/pages/classes/Tile.tsx\n"));

/***/ }),

/***/ "./src/pages/sketch.tsx":
/*!******************************!*\
  !*** ./src/pages/sketch.tsx ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ App; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _classes_Level__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./classes/Level */ \"./src/pages/classes/Level.tsx\");\n/* harmony import */ var _classes_Player__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./classes/Player */ \"./src/pages/classes/Player.tsx\");\n// Framework Imports\n\n\n\n//Class imports\n\n\nconst Sketch = next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(()=>__webpack_require__.e(/*! import() */ \"node_modules_react-p5_build_index_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! react-p5 */ \"./node_modules/react-p5/build/index.js\", 23)).then((mod)=>{\n        __webpack_require__(/*! p5/lib/addons/p5.sound */ \"./node_modules/p5/lib/addons/p5.sound.js\"); // Sound library imported after react-p5 is loaded\n        return mod.default // returning react-p5 default export\n        ;\n    }), {\n    loadableGenerated: {\n        modules: [\n            \"sketch.tsx -> \" + \"react-p5\"\n        ]\n    },\n    ssr: false //Disable server side rendering\n});\n_c = Sketch;\n//import Sketch from \"react-p5\";\n// Graphic assets\nconst graphicnames = [\n    \"grass.png\",\n    \"dirt.png\",\n    \"coin.gif\",\n    \"gem.gif\",\n    \"cloud_l.png\",\n    \"cloud_r.png\",\n    \"flowers.gif\",\n    \"pine_small.png\",\n    \"pine_big_down.png\",\n    \"pine_big_up.png\",\n    \"tree_small.png\",\n    \"tree_big_down.png\",\n    \"tree_big_up.png\",\n    \"stone.png\",\n    \"spikes.png\",\n    \"empty.png\",\n    \"error.png\",\n    \"pro.gif\"\n];\nconst graphics = []; // Array where all the game-related graphical assets are stored\n//Graphical control variables\nlet xOffset;\nlet yOffset;\nlet prevxOffset;\nlet prevyOffset;\n//Main game objects\nlet lvl;\nlet player;\n//Debug control\nconst debug = false;\nclass App extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n    render() {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Sketch, {\n            preload: this.preload,\n            windowResized: this.windowResized,\n            setup: this.setup,\n            keyPressed: this.keyPressed,\n            draw: this.draw\n        }, void 0, false, {\n            fileName: \"/home/michelangelo/Documents/Ingesoft/2023-1S_IngSoftware-PPC/src/pages/sketch.tsx\",\n            lineNumber: 127,\n            columnNumber: 16\n        }, this);\n    }\n    constructor(...args){\n        super(...args);\n        this.preload = (p5)=>{\n            for(let i = 0; i < graphicnames.length; i++){\n                //Load all of the sprites into the graphics \n                graphics[i] = p5.loadImage(\"/sprites/\".concat(graphicnames[i]));\n            }\n        };\n        this.windowResized = (p5)=>{\n            //Calculate new centering adjustment for the current level based on its size\n            xOffset = (p5.windowWidth - lvl.levelWidth) / 2;\n            yOffset = (p5.windowHeight - lvl.levelHeight) / 2;\n            //Adjust the player accordingly based on the size changes\n            player.movePlayer(xOffset - prevxOffset, yOffset - prevyOffset);\n            //Resize the canvas\n            p5.resizeCanvas(p5.windowWidth, p5.windowHeight);\n            //Save the new value of the offset\n            prevxOffset = xOffset;\n            prevyOffset = yOffset;\n        };\n        this.setup = (p5, canvasParentRef)=>{\n            p5.createCanvas(p5.windowWidth, p5.windowHeight).parent(canvasParentRef);\n            p5.background(\"tomato\");\n            //Initial declaration of a template level\n            lvl = new _classes_Level__WEBPACK_IMPORTED_MODULE_3__[\"default\"](10, 20, [\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"cll\",\n                \"clr\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"cll\",\n                \"clr\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"sto\",\n                \"sto\",\n                \"sto\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"tbu\",\n                \"coi\",\n                \"gem\",\n                \"pbu\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"tbd\",\n                \"000\",\n                \"000\",\n                \"pbd\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"tbu\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"gra\",\n                \"gra\",\n                \"gra\",\n                \"gra\",\n                \"gra\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"flo\",\n                \"000\",\n                \"psm\",\n                \"tbd\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"000\",\n                \"spi\",\n                \"000\",\n                \"gra\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"gra\",\n                \"000\",\n                \"flo\",\n                \"gra\",\n                \"gra\",\n                \"gra\",\n                \"gra\",\n                \"gra\",\n                \"gra\",\n                \"gra\",\n                \"gra\",\n                \"gra\",\n                \"gra\",\n                \"gra\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"gra\",\n                \"gra\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\",\n                \"dir\"\n            ], 40, graphics, p5);\n            //Initialize offset for this template level\n            xOffset = (p5.windowWidth - lvl.levelWidth) / 2;\n            yOffset = (p5.windowHeight - lvl.levelHeight) / 2;\n            prevxOffset = xOffset;\n            prevyOffset = yOffset;\n            //Position the player in the template level\n            player = new _classes_Player__WEBPACK_IMPORTED_MODULE_4__[\"default\"](20, 20, xOffset + 9 * lvl.tile_size, yOffset, graphics[17], p5);\n        };\n        this.draw = (p5)=>{\n            p5.background(\"tomato\");\n            //Draw the elements of the game\n            lvl.draw(xOffset, yOffset, debug);\n            player.draw();\n            lvl.handleCollisions(player, xOffset, yOffset);\n            //Enable pllayer movement\n            if (player.isAlive) {\n                player.update();\n                player.keyMovement();\n            } else {\n                p5.push();\n                p5.noStroke();\n                p5.fill(200, 125); //Gray out the screen\n                p5.rect(xOffset, yOffset, lvl.levelWidth, lvl.levelHeight);\n                p5.pop();\n            }\n        };\n        this.keyPressed = (p5)=>{\n            if (p5.keyCode == p5.UP_ARROW) {\n                player.isJumping = true;\n            }\n        };\n    }\n}\n/*\nThings that the debug does:\n- Show hitboxes\n- \n*/ \nvar _c;\n$RefreshReg$(_c, \"Sketch\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQ2xIO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUNsSDtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFDbEg7Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQ2xIO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUNsSDtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFBTTtnQkFDbEg7Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQU07Z0JBQ2xIO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2FBQU0sRUFDNUgsSUFDQVMsVUFDQWU7WUFHRiwyQ0FBMkM7WUFDM0NkLFVBQVUsQ0FBQ2MsR0FBR0ksV0FBVyxHQUFHZCxJQUFJZSxVQUFVLElBQUk7WUFDOUNsQixVQUFVLENBQUNhLEdBQUdNLFlBQVksR0FBR2hCLElBQUlpQixXQUFXLElBQUk7WUFDaERuQixjQUFZRjtZQUNaRyxjQUFZRjtZQUNaLDJDQUEyQztZQUMzQ0ksU0FBUyxJQUFJZCx1REFBTUEsQ0FBQyxJQUFHLElBQUdTLFVBQVUsSUFBTUksSUFBSXdCLFNBQVMsRUFBQzNCLFNBQVFGLFFBQVEsQ0FBQyxHQUFHLEVBQUNlO1FBQ2pGO2FBRUFELE9BQU8sQ0FBQ0MsS0FBVTtZQUNkQSxHQUFHYSxVQUFVLENBQUM7WUFDZCwrQkFBK0I7WUFDL0J2QixJQUFJUyxJQUFJLENBQUNiLFNBQVFDLFNBQVFLO1lBQ3pCRCxPQUFPUSxJQUFJO1lBQ1hULElBQUl5QixnQkFBZ0IsQ0FBQ3hCLFFBQU9MLFNBQVFDO1lBQ3BDLHlCQUF5QjtZQUN6QixJQUFHSSxPQUFPeUIsT0FBTyxFQUFDO2dCQUNoQnpCLE9BQU8wQixNQUFNO2dCQUNiMUIsT0FBTzJCLFdBQVc7WUFDcEIsT0FBSztnQkFDSGxCLEdBQUdtQixJQUFJO2dCQUNMbkIsR0FBR29CLFFBQVE7Z0JBQ1hwQixHQUFHcUIsSUFBSSxDQUFDLEtBQUksTUFBSyxxQkFBcUI7Z0JBQ3RDckIsR0FBR3NCLElBQUksQ0FBQ3BDLFNBQVNDLFNBQVNHLElBQUllLFVBQVUsRUFBRWYsSUFBSWlCLFdBQVc7Z0JBQzNEUCxHQUFHdUIsR0FBRztZQUNSLENBQUM7UUFFTDthQUVBekIsYUFBYSxDQUFDRSxLQUFVO1lBQ3RCLElBQUlBLEdBQUd3QixPQUFPLElBQUl4QixHQUFHeUIsUUFBUSxFQUFFO2dCQUM3QmxDLE9BQU9tQyxTQUFTLEdBQUMsSUFBSTtZQUN2QixDQUFDO1FBQ0g7O0FBS0o7QUEzRkE7Ozs7QUFJQSxHQXVGQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvcGFnZXMvc2tldGNoLnRzeD8wOTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZyYW1ld29yayBJbXBvcnRzXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgZHluYW1pYyBmcm9tICduZXh0L2R5bmFtaWMnO1xuaW1wb3J0IHA1VHlwZXMgZnJvbSBcInA1XCI7IC8vIEltcG9ydCB0aGlzIGZvciB0eXBlY2hlY2tpbmcgYW5kIGludGVsbGlzZW5zZVxuaW1wb3J0IHA1IGZyb20gJ3A1JztcblxuLy9DbGFzcyBpbXBvcnRzXG5pbXBvcnQgTGV2ZWwgZnJvbSBcIi4vY2xhc3Nlcy9MZXZlbFwiO1xuaW1wb3J0IFBsYXllciBmcm9tIFwiLi9jbGFzc2VzL1BsYXllclwiO1xuXG5jb25zdCBTa2V0Y2ggPSBkeW5hbWljKCgpID0+IGltcG9ydChcInJlYWN0LXA1XCIpLnRoZW4oKG1vZCkgPT4geyAgIC8vIFNrZXRjaCBvYmplY3RcbiAgICByZXF1aXJlKCdwNS9saWIvYWRkb25zL3A1LnNvdW5kJyk7IC8vIFNvdW5kIGxpYnJhcnkgaW1wb3J0ZWQgYWZ0ZXIgcmVhY3QtcDUgaXMgbG9hZGVkXG4gICAgcmV0dXJuIG1vZC5kZWZhdWx0IC8vIHJldHVybmluZyByZWFjdC1wNSBkZWZhdWx0IGV4cG9ydFxufSkse1xuICAgIHNzcjogZmFsc2UgICAgLy9EaXNhYmxlIHNlcnZlciBzaWRlIHJlbmRlcmluZ1xufSk7XG4vL2ltcG9ydCBTa2V0Y2ggZnJvbSBcInJlYWN0LXA1XCI7XG5cbi8vIEdyYXBoaWMgYXNzZXRzXG5jb25zdCBncmFwaGljbmFtZXM6IHN0cmluZ1tdID0gW1wiZ3Jhc3MucG5nXCIsIFwiZGlydC5wbmdcIiwgXCJjb2luLmdpZlwiLCBcImdlbS5naWZcIiwgXCJjbG91ZF9sLnBuZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNsb3VkX3IucG5nXCIsIFwiZmxvd2Vycy5naWZcIiwgXCJwaW5lX3NtYWxsLnBuZ1wiLCBcInBpbmVfYmlnX2Rvd24ucG5nXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBpbmVfYmlnX3VwLnBuZ1wiLCBcInRyZWVfc21hbGwucG5nXCIsIFwidHJlZV9iaWdfZG93bi5wbmdcIiwgXCJ0cmVlX2JpZ191cC5wbmdcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3RvbmUucG5nXCIsIFwic3Bpa2VzLnBuZ1wiLFwiZW1wdHkucG5nXCIsIFwiZXJyb3IucG5nXCIsXCJwcm8uZ2lmXCJdO1xuY29uc3QgZ3JhcGhpY3M6IHA1LkltYWdlW10gPSBbXTsgLy8gQXJyYXkgd2hlcmUgYWxsIHRoZSBnYW1lLXJlbGF0ZWQgZ3JhcGhpY2FsIGFzc2V0cyBhcmUgc3RvcmVkXG5cbi8vR3JhcGhpY2FsIGNvbnRyb2wgdmFyaWFibGVzXG5sZXQgeE9mZnNldDpudW1iZXI7XG5sZXQgeU9mZnNldDpudW1iZXI7XG5sZXQgcHJldnhPZmZzZXQ6bnVtYmVyO1xubGV0IHByZXZ5T2Zmc2V0Om51bWJlcjtcblxuLy9NYWluIGdhbWUgb2JqZWN0c1xubGV0IGx2bDpMZXZlbDtcbmxldCBwbGF5ZXI6UGxheWVyO1xuXG4vL0RlYnVnIGNvbnRyb2xcbmNvbnN0IGRlYnVnOmJvb2xlYW49ZmFsc2U7XG4vKlxuVGhpbmdzIHRoYXQgdGhlIGRlYnVnIGRvZXM6XG4tIFNob3cgaGl0Ym94ZXNcbi0gXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcHAgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gICAgICBwcmVsb2FkID0gKHA1OnA1KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhcGhpY25hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy9Mb2FkIGFsbCBvZiB0aGUgc3ByaXRlcyBpbnRvIHRoZSBncmFwaGljcyBcbiAgICAgICAgICBncmFwaGljc1tpXSA9IHA1LmxvYWRJbWFnZShgL3Nwcml0ZXMvJHtncmFwaGljbmFtZXNbaV19YCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHdpbmRvd1Jlc2l6ZWQgPSAocDU6cDUpID0+ICB7XG4gICAgICAgIC8vQ2FsY3VsYXRlIG5ldyBjZW50ZXJpbmcgYWRqdXN0bWVudCBmb3IgdGhlIGN1cnJlbnQgbGV2ZWwgYmFzZWQgb24gaXRzIHNpemVcbiAgICAgICAgeE9mZnNldCA9IChwNS53aW5kb3dXaWR0aCAtIGx2bC5sZXZlbFdpZHRoKSAvIDI7XG4gICAgICAgIHlPZmZzZXQgPSAocDUud2luZG93SGVpZ2h0IC0gbHZsLmxldmVsSGVpZ2h0KSAvIDI7XG5cbiAgICAgICAgLy9BZGp1c3QgdGhlIHBsYXllciBhY2NvcmRpbmdseSBiYXNlZCBvbiB0aGUgc2l6ZSBjaGFuZ2VzXG4gICAgICAgIHBsYXllci5tb3ZlUGxheWVyKHhPZmZzZXQtcHJldnhPZmZzZXQseU9mZnNldC1wcmV2eU9mZnNldCk7XG5cbiAgICAgICAgLy9SZXNpemUgdGhlIGNhbnZhc1xuICAgICAgICBwNS5yZXNpemVDYW52YXMocDUud2luZG93V2lkdGgscDUud2luZG93SGVpZ2h0KTtcblxuICAgICAgICAvL1NhdmUgdGhlIG5ldyB2YWx1ZSBvZiB0aGUgb2Zmc2V0XG4gICAgICAgIHByZXZ4T2Zmc2V0PXhPZmZzZXQ7XG4gICAgICAgIHByZXZ5T2Zmc2V0PXlPZmZzZXQ7XG4gICAgICB9O1xuXG4gICAgICBzZXR1cCA9IChwNTpwNSwgY2FudmFzUGFyZW50UmVmOkVsZW1lbnQpID0+IHtcbiAgICAgICAgcDUuY3JlYXRlQ2FudmFzKHA1LndpbmRvd1dpZHRoLCBwNS53aW5kb3dIZWlnaHQpLnBhcmVudChjYW52YXNQYXJlbnRSZWYpO1xuICAgICAgICBwNS5iYWNrZ3JvdW5kKFwidG9tYXRvXCIpO1xuXG4gICAgICAgIC8vSW5pdGlhbCBkZWNsYXJhdGlvbiBvZiBhIHRlbXBsYXRlIGxldmVsXG4gICAgICAgIGx2bCA9IG5ldyBMZXZlbChcbiAgICAgICAgICAxMCwyMCxcbiAgICAgICAgICBbICAgXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFxuICAgICAgICAgICAgICBcIjAwMFwiLFwiMDAwXCIsXCJjbGxcIixcImNsclwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXG4gICAgICAgICAgICAgIFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcbiAgICAgICAgICAgICAgXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcImNsbFwiLFwiY2xyXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFxuICAgICAgICAgICAgICBcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcInN0b1wiLFwic3RvXCIsXCJzdG9cIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwidGJ1XCIsXCJjb2lcIixcImdlbVwiLFwicGJ1XCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXG4gICAgICAgICAgICAgIFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCJ0YmRcIixcIjAwMFwiLFwiMDAwXCIsXCJwYmRcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcbiAgICAgICAgICAgICAgXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcInRidVwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCJncmFcIixcImdyYVwiLFwiZ3JhXCIsXCJncmFcIixcImdyYVwiLFwiMDAwXCIsXCIwMDBcIixcIjAwMFwiLFxuICAgICAgICAgICAgICBcIjAwMFwiLFwiZmxvXCIsXCIwMDBcIixcInBzbVwiLFwidGJkXCIsXCIwMDBcIixcIjAwMFwiLFwiMDAwXCIsXCIwMDBcIixcInNwaVwiLFwiMDAwXCIsXCJncmFcIixcImRpclwiLFwiZGlyXCIsXCJkaXJcIixcImRpclwiLFwiZGlyXCIsXCJncmFcIixcIjAwMFwiLFwiZmxvXCIsXG4gICAgICAgICAgICAgIFwiZ3JhXCIsXCJncmFcIixcImdyYVwiLFwiZ3JhXCIsXCJncmFcIixcImdyYVwiLFwiZ3JhXCIsXCJncmFcIixcImdyYVwiLFwiZ3JhXCIsXCJncmFcIixcImRpclwiLFwiZGlyXCIsXCJkaXJcIixcImRpclwiLFwiZGlyXCIsXCJkaXJcIixcImRpclwiLFwiZ3JhXCIsXCJncmFcIixcbiAgICAgICAgICAgICAgXCJkaXJcIixcImRpclwiLFwiZGlyXCIsXCJkaXJcIixcImRpclwiLFwiZGlyXCIsXCJkaXJcIixcImRpclwiLFwiZGlyXCIsXCJkaXJcIixcImRpclwiLFwiZGlyXCIsXCJkaXJcIixcImRpclwiLFwiZGlyXCIsXCJkaXJcIixcImRpclwiLFwiZGlyXCIsXCJkaXJcIixcImRpclwiXSxcbiAgICAgICAgICA0MCxcbiAgICAgICAgICBncmFwaGljcyxcbiAgICAgICAgICBwNVxuICAgICAgICApO1xuXG4gICAgICAgIC8vSW5pdGlhbGl6ZSBvZmZzZXQgZm9yIHRoaXMgdGVtcGxhdGUgbGV2ZWxcbiAgICAgICAgeE9mZnNldCA9IChwNS53aW5kb3dXaWR0aCAtIGx2bC5sZXZlbFdpZHRoKSAvIDI7XG4gICAgICAgIHlPZmZzZXQgPSAocDUud2luZG93SGVpZ2h0IC0gbHZsLmxldmVsSGVpZ2h0KSAvIDI7XG4gICAgICAgIHByZXZ4T2Zmc2V0PXhPZmZzZXQ7XG4gICAgICAgIHByZXZ5T2Zmc2V0PXlPZmZzZXQ7XG4gICAgICAgIC8vUG9zaXRpb24gdGhlIHBsYXllciBpbiB0aGUgdGVtcGxhdGUgbGV2ZWxcbiAgICAgICAgcGxheWVyID0gbmV3IFBsYXllcigyMCwyMCx4T2Zmc2V0ICsgKDkpICogbHZsLnRpbGVfc2l6ZSx5T2Zmc2V0LGdyYXBoaWNzWzE3XSxwNSk7XG4gICAgfTtcblxuICAgIGRyYXcgPSAocDU6cDUpID0+IHtcbiAgICAgICAgcDUuYmFja2dyb3VuZCgndG9tYXRvJyk7XG4gICAgICAgIC8vRHJhdyB0aGUgZWxlbWVudHMgb2YgdGhlIGdhbWVcbiAgICAgICAgbHZsLmRyYXcoeE9mZnNldCx5T2Zmc2V0LGRlYnVnKTtcbiAgICAgICAgcGxheWVyLmRyYXcoKTtcbiAgICAgICAgbHZsLmhhbmRsZUNvbGxpc2lvbnMocGxheWVyLHhPZmZzZXQseU9mZnNldCk7XG4gICAgICAgIC8vRW5hYmxlIHBsbGF5ZXIgbW92ZW1lbnRcbiAgICAgICAgaWYocGxheWVyLmlzQWxpdmUpe1xuICAgICAgICAgIHBsYXllci51cGRhdGUoKTtcbiAgICAgICAgICBwbGF5ZXIua2V5TW92ZW1lbnQoKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgcDUucHVzaCgpO1xuICAgICAgICAgICAgcDUubm9TdHJva2UoKTtcbiAgICAgICAgICAgIHA1LmZpbGwoMjAwLDEyNSk7Ly9HcmF5IG91dCB0aGUgc2NyZWVuXG4gICAgICAgICAgICBwNS5yZWN0KHhPZmZzZXQsIHlPZmZzZXQsIGx2bC5sZXZlbFdpZHRoLCBsdmwubGV2ZWxIZWlnaHQpOyBcbiAgICAgICAgICBwNS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9O1xuXG4gICAga2V5UHJlc3NlZCA9IChwNTpwNSkgPT4ge1xuICAgICAgaWYgKHA1LmtleUNvZGUgPT0gcDUuVVBfQVJST1cpIHtcbiAgICAgICAgcGxheWVyLmlzSnVtcGluZz10cnVlO1xuICAgICAgfSBcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiA8U2tldGNoIHByZWxvYWQ9e3RoaXMucHJlbG9hZH0gd2luZG93UmVzaXplZD17dGhpcy53aW5kb3dSZXNpemVkfSBzZXR1cD17IHRoaXMuc2V0dXAgfSBrZXlQcmVzc2VkPXt0aGlzLmtleVByZXNzZWR9IGRyYXcgPSB7IHRoaXMuZHJhdyB9IC8+O1xuICAgIH07XG59Il0sIm5hbWVzIjpbIlJlYWN0IiwiQ29tcG9uZW50IiwiZHluYW1pYyIsIkxldmVsIiwiUGxheWVyIiwiU2tldGNoIiwidGhlbiIsIm1vZCIsInJlcXVpcmUiLCJkZWZhdWx0Iiwic3NyIiwiZ3JhcGhpY25hbWVzIiwiZ3JhcGhpY3MiLCJ4T2Zmc2V0IiwieU9mZnNldCIsInByZXZ4T2Zmc2V0IiwicHJldnlPZmZzZXQiLCJsdmwiLCJwbGF5ZXIiLCJkZWJ1ZyIsIkFwcCIsInJlbmRlciIsInByZWxvYWQiLCJ3aW5kb3dSZXNpemVkIiwic2V0dXAiLCJrZXlQcmVzc2VkIiwiZHJhdyIsInA1IiwiaSIsImxlbmd0aCIsImxvYWRJbWFnZSIsIndpbmRvd1dpZHRoIiwibGV2ZWxXaWR0aCIsIndpbmRvd0hlaWdodCIsImxldmVsSGVpZ2h0IiwibW92ZVBsYXllciIsInJlc2l6ZUNhbnZhcyIsImNhbnZhc1BhcmVudFJlZiIsImNyZWF0ZUNhbnZhcyIsInBhcmVudCIsImJhY2tncm91bmQiLCJ0aWxlX3NpemUiLCJoYW5kbGVDb2xsaXNpb25zIiwiaXNBbGl2ZSIsInVwZGF0ZSIsImtleU1vdmVtZW50IiwicHVzaCIsIm5vU3Ryb2tlIiwiZmlsbCIsInJlY3QiLCJwb3AiLCJrZXlDb2RlIiwiVVBfQVJST1ciLCJpc0p1bXBpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/pages/sketch.tsx\n"));

/***/ }),

/***/ "./node_modules/next/dynamic.js":
/*!**************************************!*\
  !*** ./node_modules/next/dynamic.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/dynamic */ \"./node_modules/next/dist/shared/lib/dynamic.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9keW5hbWljLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHVIQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9keW5hbWljLmpzPzczZDQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9keW5hbWljJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dynamic.js\n"));

/***/ }),

/***/ "./node_modules/p5/lib/addons/p5.sound.js":
/*!************************************************!*\
  !*** ./node_modules/p5/lib/addons/p5.sound.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/** [p5.sound]  Version: 0.3.12 - 2020-01-06 */ \n /**\n *  <p>p5.sound extends p5 with <a href=\"http://caniuse.com/audio-api\"\n *  target=\"_blank\">Web Audio</a> functionality including audio input,\n *  playback, analysis and synthesis.\n *  </p>\n *  <ul>\n *  <li><a href=\"#/p5.SoundFile\"><b>p5.SoundFile</b></a>: Load and play sound files.</li>\n *  <li><a href=\"#/p5.Amplitude\"><b>p5.Amplitude</b></a>: Get the current volume of a sound.</li>\n *  <li><a href=\"#/p5.AudioIn\"><b>p5.AudioIn</b></a>: Get sound from an input source, typically\n *    a computer microphone.</li>\n *  <li><a href=\"#/p5.FFT\"><b>p5.FFT</b></a>: Analyze the frequency of sound. Returns\n *    results from the frequency spectrum or time domain (waveform).</li>\n *  <li><a href=\"#/p5.Oscillator\"><b>p5.Oscillator</b></a>: Generate Sine,\n *    Triangle, Square and Sawtooth waveforms. Base class of\n *    <li><a href=\"#/p5.Noise\">p5.Noise</a> and <a href=\"#/p5.Pulse\">p5.Pulse</a>.\n *    </li>\n *  <li>\n *    <a href=\"#/p5.MonoSynth\">p5.MonoSynth</a> and <a href=\"#/p5.PolySynth\">p5.PolySynth</a>: Play musical notes\n *  </li>\n *  <li><a href=\"#/p5.Envelope\"><b>p5.Envelope</b></a>: An Envelope is a series\n *    of fades over time. Often used to control an object's\n *    output gain level as an \"ADSR Envelope\" (Attack, Decay,\n *    Sustain, Release). Can also modulate other parameters.</li>\n *  <li><a href=\"#/p5.Delay\"><b>p5.Delay</b></a>: A delay effect with\n *    parameters for feedback, delayTime, and lowpass filter.</li>\n *  <li><a href=\"#/p5.Filter\"><b>p5.Filter</b></a>: Filter the frequency range of a\n *    sound.\n *  </li>\n *  <li><a href=\"#/p5.Reverb\"><b>p5.Reverb</b></a>: Add reverb to a sound by specifying\n *    duration and decay. </li>\n *  <b><li><a href=\"#/p5.Convolver\">p5.Convolver</a>:</b> Extends\n *  <a href=\"#/p5.Reverb\">p5.Reverb</a> to simulate the sound of real\n *    physical spaces through convolution.</li>\n *  <b><li><a href=\"#/p5.SoundRecorder\">p5.SoundRecorder</a></b>: Record sound for playback\n *    / save the .wav file.\n *  <b><li><a href=\"#/p5.SoundLoop\">p5.SoundLoop</a>, <a href=\"#/p5.Phrase\">p5.Phrase</a></b>, <b><a href=\"#/p5.Part\">p5.Part</a></b> and\n *  <b><a href=\"#/p5.Score\">p5.Score</a></b>: Compose musical sequences.\n *  </li>\n *  <li><a href=\"#/p5/userStartAudio\">userStartAudio</a>: Enable audio in a\n *  browser- and user-friendly way.</a>\n *  <p>p5.sound is on <a href=\"https://github.com/therewasaguy/p5.sound/\">GitHub</a>.\n *  Download the latest version\n *  <a href=\"https://github.com/therewasaguy/p5.sound/blob/master/lib/p5.sound.js\">here</a>.</p>\n *\n *  @module p5.sound\n *  @submodule p5.sound\n *  @for p5.sound\n *  @main\n */\n\n/**\n *  p5.sound \n *  https://p5js.org/reference/#/libraries/p5.sound\n *\n *  From the Processing Foundation and contributors\n *  https://github.com/processing/p5.js-sound/graphs/contributors\n *\n *  MIT License (MIT)\n *  https://github.com/processing/p5.js-sound/blob/master/LICENSE\n *\n *  Some of the many audio libraries & resources that inspire p5.sound:\n *   - TONE.js (c) Yotam Mann. Licensed under The MIT License (MIT). https://github.com/TONEnoTONE/Tone.js\n *   - buzz.js (c) Jay Salvat. Licensed under The MIT License (MIT). http://buzz.jaysalvat.com/\n *   - Boris Smus Web Audio API book, 2013. Licensed under the Apache License http://www.apache.org/licenses/LICENSE-2.0\n *   - wavesurfer.js https://github.com/katspaugh/wavesurfer.js\n *   - Web Audio Components by Jordan Santell https://github.com/web-audio-components\n *   - Wilm Thoben's Sound library for Processing https://github.com/processing/processing/tree/master/java/libraries/sound\n *\n *   Web Audio API: http://w3.org/TR/webaudio/\n */\n\n (function(modules) { \n \tvar installedModules = {};\n \tfunction __nested_webpack_require_3727__(moduleId) {\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_3727__);\n \t\tmodule.l = true;\n \t\treturn module.exports;\n \t}\n \t__nested_webpack_require_3727__.m = modules;\n \t__nested_webpack_require_3727__.c = installedModules;\n \t__nested_webpack_require_3727__.d = function(exports, name, getter) {\n \t\tif(!__nested_webpack_require_3727__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n \t__nested_webpack_require_3727__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n \t__nested_webpack_require_3727__.t = function(value, mode) {\n \t\tif(mode & 1) value = __nested_webpack_require_3727__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__nested_webpack_require_3727__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_3727__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n \t__nested_webpack_require_3727__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__nested_webpack_require_3727__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n \t__nested_webpack_require_3727__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n \t__nested_webpack_require_3727__.p = \"\";\n \treturn __nested_webpack_require_3727__(__nested_webpack_require_3727__.s = 31);\n })\n ([\n (function(module, exports, __nested_webpack_require_5676__) {\n\nvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){\"use strict\";function a(t,e){this.isUndef(t)||1===t?this.input=this.context.createGain():1<t&&(this.input=new Array(t)),this.isUndef(e)||1===e?this.output=this.context.createGain():1<e&&(this.output=new Array(t))}var e;return a.prototype.set=function(t,e,n){if(this.isObject(t))n=e;else if(this.isString(t)){var o={};o[t]=e,t=o}t:for(var i in t){e=t[i];var r=this;if(-1!==i.indexOf(\".\")){for(var s=i.split(\".\"),u=0;u<s.length-1;u++)if((r=r[s[u]])instanceof a){s.splice(0,u+1);var p=s.join(\".\");r.set(p,e);continue t}i=s[s.length-1]}var c=r[i];this.isUndef(c)||(a.Signal&&c instanceof a.Signal||a.Param&&c instanceof a.Param?c.value!==e&&(this.isUndef(n)?c.value=e:c.rampTo(e,n)):c instanceof AudioParam?c.value!==e&&(c.value=e):c instanceof a?c.set(e):c!==e&&(r[i]=e))}return this},a.prototype.get=function(t){this.isUndef(t)?t=this._collectDefaults(this.constructor):this.isString(t)&&(t=[t]);for(var e={},n=0;n<t.length;n++){var o=t[n],i=this,r=e;if(-1!==o.indexOf(\".\")){for(var s=o.split(\".\"),u=0;u<s.length-1;u++){var p=s[u];r[p]=r[p]||{},r=r[p],i=i[p]}o=s[s.length-1]}var c=i[o];this.isObject(t[o])?r[o]=c.get():a.Signal&&c instanceof a.Signal?r[o]=c.value:a.Param&&c instanceof a.Param?r[o]=c.value:c instanceof AudioParam?r[o]=c.value:c instanceof a?r[o]=c.get():this.isFunction(c)||this.isUndef(c)||(r[o]=c)}return e},a.prototype._collectDefaults=function(t){var e=[];if(this.isUndef(t.defaults)||(e=Object.keys(t.defaults)),!this.isUndef(t._super))for(var n=this._collectDefaults(t._super),o=0;o<n.length;o++)-1===e.indexOf(n[o])&&e.push(n[o]);return e},a.prototype.toString=function(){for(var t in a){var e=t[0].match(/^[A-Z]$/),n=a[t]===this.constructor;if(this.isFunction(a[t])&&e&&n)return t}return\"Tone\"},Object.defineProperty(a.prototype,\"numberOfInputs\",{get:function(){return this.input?this.isArray(this.input)?this.input.length:1:0}}),Object.defineProperty(a.prototype,\"numberOfOutputs\",{get:function(){return this.output?this.isArray(this.output)?this.output.length:1:0}}),a.prototype.dispose=function(){return this.isUndef(this.input)||(this.input instanceof AudioNode&&this.input.disconnect(),this.input=null),this.isUndef(this.output)||(this.output instanceof AudioNode&&this.output.disconnect(),this.output=null),this},a.prototype.connect=function(t,e,n){return Array.isArray(this.output)?(e=this.defaultArg(e,0),this.output[e].connect(t,0,n)):this.output.connect(t,e,n),this},a.prototype.disconnect=function(t,e,n){this.isArray(this.output)?this.isNumber(t)?this.output[t].disconnect():(e=this.defaultArg(e,0),this.output[e].disconnect(t,0,n)):this.output.disconnect.apply(this.output,arguments)},a.prototype.connectSeries=function(){if(1<arguments.length)for(var t=arguments[0],e=1;e<arguments.length;e++){var n=arguments[e];t.connect(n),t=n}return this},a.prototype.chain=function(){if(0<arguments.length)for(var t=this,e=0;e<arguments.length;e++){var n=arguments[e];t.connect(n),t=n}return this},a.prototype.fan=function(){if(0<arguments.length)for(var t=0;t<arguments.length;t++)this.connect(arguments[t]);return this},AudioNode.prototype.chain=a.prototype.chain,AudioNode.prototype.fan=a.prototype.fan,a.prototype.defaultArg=function(t,e){if(this.isObject(t)&&this.isObject(e)){var n={};for(var o in t)n[o]=this.defaultArg(e[o],t[o]);for(var i in e)n[i]=this.defaultArg(t[i],e[i]);return n}return this.isUndef(t)?e:t},a.prototype.optionsObject=function(t,e,n){var o={};if(1===t.length&&this.isObject(t[0]))o=t[0];else for(var i=0;i<e.length;i++)o[e[i]]=t[i];return this.isUndef(n)?o:this.defaultArg(o,n)},a.prototype.isUndef=function(t){return void 0===t},a.prototype.isFunction=function(t){return\"function\"==typeof t},a.prototype.isNumber=function(t){return\"number\"==typeof t},a.prototype.isObject=function(t){return\"[object Object]\"===Object.prototype.toString.call(t)&&t.constructor===Object},a.prototype.isBoolean=function(t){return\"boolean\"==typeof t},a.prototype.isArray=function(t){return Array.isArray(t)},a.prototype.isString=function(t){return\"string\"==typeof t},a.noOp=function(){},a.prototype._readOnly=function(t){if(Array.isArray(t))for(var e=0;e<t.length;e++)this._readOnly(t[e]);else Object.defineProperty(this,t,{writable:!1,enumerable:!0})},a.prototype._writable=function(t){if(Array.isArray(t))for(var e=0;e<t.length;e++)this._writable(t[e]);else Object.defineProperty(this,t,{writable:!0})},a.State={Started:\"started\",Stopped:\"stopped\",Paused:\"paused\"},a.prototype.equalPowerScale=function(t){var e=.5*Math.PI;return Math.sin(t*e)},a.prototype.dbToGain=function(t){return Math.pow(2,t/6)},a.prototype.gainToDb=function(t){return Math.log(t)/Math.LN10*20},a.prototype.intervalToFrequencyRatio=function(t){return Math.pow(2,t/12)},a.prototype.now=function(){return a.context.now()},a.now=function(){return a.context.now()},a.extend=function(t,e){function n(){}a.prototype.isUndef(e)&&(e=a),n.prototype=e.prototype,t.prototype=new n,(t.prototype.constructor=t)._super=e},Object.defineProperty(a,\"context\",{get:function(){return e},set:function(t){e=a.Context&&t instanceof a.Context?t:new a.Context(t),a.Context&&a.Context.emit(\"init\",e)}}),Object.defineProperty(a.prototype,\"context\",{get:function(){return a.context}}),a.setContext=function(t){a.context=t},Object.defineProperty(a.prototype,\"blockTime\",{get:function(){return 128/this.context.sampleRate}}),Object.defineProperty(a.prototype,\"sampleTime\",{get:function(){return 1/this.context.sampleRate}}),Object.defineProperty(a,\"supported\",{get:function(){var t=window.hasOwnProperty(\"AudioContext\")||window.hasOwnProperty(\"webkitAudioContext\"),e=window.hasOwnProperty(\"Promise\"),n=window.hasOwnProperty(\"Worker\");return t&&e&&n}}),a.version=\"r10\",window.TONE_SILENCE_VERSION_LOGGING||console.log(\"%c * Tone.js \"+a.version+\" * \",\"background: #000; color: #fff\"),a}).call(exports, __nested_webpack_require_5676__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_11736__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_11736__(17)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (audiocontext) {\n  var Master = function Master() {\n    this.input = audiocontext.createGain();\n    this.output = audiocontext.createGain(); \n\n    this.limiter = audiocontext.createDynamicsCompressor();\n    this.limiter.threshold.value = -3;\n    this.limiter.ratio.value = 20;\n    this.limiter.knee.value = 1;\n    this.audiocontext = audiocontext;\n    this.output.disconnect(); \n\n    this.input.connect(this.limiter); \n\n    this.limiter.connect(this.output); \n\n    this.meter = audiocontext.createGain();\n    this.fftMeter = audiocontext.createGain();\n    this.output.connect(this.meter);\n    this.output.connect(this.fftMeter); \n\n    this.output.connect(this.audiocontext.destination); \n\n    this.soundArray = []; \n\n    this.parts = []; \n\n    this.extensions = [];\n  }; \n\n\n  var p5sound = new Master();\n  /**\n   * Returns a number representing the master amplitude (volume) for sound\n   * in this sketch.\n   *\n   * @method getMasterVolume\n   * @return {Number} Master amplitude (volume) for sound in this sketch.\n   *                  Should be between 0.0 (silence) and 1.0.\n   */\n\n  p5.prototype.getMasterVolume = function () {\n    return p5sound.output.gain.value;\n  };\n  /**\n   *  <p>Scale the output of all sound in this sketch</p>\n   *  Scaled between 0.0 (silence) and 1.0 (full volume).\n   *  1.0 is the maximum amplitude of a digital sound, so multiplying\n   *  by greater than 1.0 may cause digital distortion. To\n   *  fade, provide a <code>rampTime</code> parameter. For more\n   *  complex fades, see the Envelope class.\n   *\n   *  Alternately, you can pass in a signal source such as an\n   *  oscillator to modulate the amplitude with an audio signal.\n   *\n   *  <p><b>How This Works</b>: When you load the p5.sound module, it\n   *  creates a single instance of p5sound. All sound objects in this\n   *  module output to p5sound before reaching your computer's output.\n   *  So if you change the amplitude of p5sound, it impacts all of the\n   *  sound in this module.</p>\n   *\n   *  <p>If no value is provided, returns a Web Audio API Gain Node</p>\n   *\n   *  @method  masterVolume\n   *  @param {Number|Object} volume  Volume (amplitude) between 0.0\n   *                                     and 1.0 or modulating signal/oscillator\n   *  @param {Number} [rampTime]  Fade for t seconds\n   *  @param {Number} [timeFromNow]  Schedule this event to happen at\n   *                                 t seconds in the future\n   */\n\n\n  p5.prototype.masterVolume = function (vol, rampTime, tFromNow) {\n    if (typeof vol === 'number') {\n      var rampTime = rampTime || 0;\n      var tFromNow = tFromNow || 0;\n      var now = p5sound.audiocontext.currentTime;\n      var currentVol = p5sound.output.gain.value;\n      p5sound.output.gain.cancelScheduledValues(now + tFromNow);\n      p5sound.output.gain.linearRampToValueAtTime(currentVol, now + tFromNow);\n      p5sound.output.gain.linearRampToValueAtTime(vol, now + tFromNow + rampTime);\n    } else if (vol) {\n      vol.connect(p5sound.output.gain);\n    } else {\n      return p5sound.output.gain;\n    }\n  };\n  /**\n   *  `p5.soundOut` is the p5.sound master output. It sends output to\n   *  the destination of this window's web audio context. It contains\n   *  Web Audio API nodes including a dyanmicsCompressor (<code>.limiter</code>),\n   *  and Gain Nodes for <code>.input</code> and <code>.output</code>.\n   *\n   *  @property {Object} soundOut\n   */\n\n\n  p5.prototype.soundOut = p5.soundOut = p5sound; \n\n  p5.soundOut._silentNode = p5sound.audiocontext.createGain();\n  p5.soundOut._silentNode.gain.value = 0;\n\n  p5.soundOut._silentNode.connect(p5sound.audiocontext.destination);\n\n  return p5sound;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_15775__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_15775__(0),__nested_webpack_require_15775__(5),__nested_webpack_require_15775__(8),__nested_webpack_require_15775__(22),__nested_webpack_require_15775__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(n){\"use strict\";return n.Signal=function(){var t=this.optionsObject(arguments,[\"value\",\"units\"],n.Signal.defaults);this.output=this._gain=this.context.createGain(),t.param=this._gain.gain,n.Param.call(this,t),this.input=this._param=this._gain.gain,this.context.getConstant(1).chain(this._gain)},n.extend(n.Signal,n.Param),n.Signal.defaults={value:0,units:n.Type.Default,convert:!0},n.Signal.prototype.connect=n.SignalBase.prototype.connect,n.Signal.prototype.dispose=function(){return n.Param.prototype.dispose.call(this),this._param=null,this._gain.disconnect(),this._gain=null,this},n.Signal}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_16835__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_16835__(0),__nested_webpack_require_16835__(2),__nested_webpack_require_16835__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(i){\"use strict\";return i.Multiply=function(t){this.createInsOuts(2,0),this._mult=this.input[0]=this.output=new i.Gain,this._param=this.input[1]=this.output.gain,this._param.value=this.defaultArg(t,0)},i.extend(i.Multiply,i.Signal),i.Multiply.prototype.dispose=function(){return i.prototype.dispose.call(this),this._mult.dispose(),this._mult=null,this._param=null,this},i.Multiply}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_17634__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_17634__(1);\n\n  var CrossFade = __nested_webpack_require_17634__(51);\n  /**\n   * Effect is a base class for audio effects in p5. <br>\n   * This module handles the nodes and methods that are\n   * common and useful for current and future effects.\n   *\n   *\n   * This class is extended by <a href=\"/reference/#/p5.Distortion\">p5.Distortion</a>,\n   * <a href=\"/reference/#/p5.Compressor\">p5.Compressor</a>,\n   * <a href=\"/reference/#/p5.Delay\">p5.Delay</a>,\n   * <a href=\"/reference/#/p5.Filter\">p5.Filter</a>,\n   * <a href=\"/reference/#/p5.Reverb\">p5.Reverb</a>.\n   *\n   * @class  p5.Effect\n   * @constructor\n   *\n   * @param {Object} [ac]   Reference to the audio context of the p5 object\n   * @param {AudioNode} [input]  Gain Node effect wrapper\n   * @param {AudioNode} [output] Gain Node effect wrapper\n   * @param {Object} [_drywet]   Tone.JS CrossFade node (defaults to value: 1)\n   * @param {AudioNode} [wet]  Effects that extend this class should connect\n   *                              to the wet signal to this gain node, so that dry and wet\n   *                              signals are mixed properly.\n   */\n\n\n  p5.Effect = function () {\n    this.ac = p5sound.audiocontext;\n    this.input = this.ac.createGain();\n    this.output = this.ac.createGain();\n    /**\n     *\tThe p5.Effect class is built\n     * \tusing Tone.js CrossFade\n     * \t@private\n     */\n\n    this._drywet = new CrossFade(1);\n    /**\n     *\tIn classes that extend\n     *\tp5.Effect, connect effect nodes\n     *\tto the wet parameter\n     */\n\n    this.wet = this.ac.createGain();\n    this.input.connect(this._drywet.a);\n    this.wet.connect(this._drywet.b);\n\n    this._drywet.connect(this.output);\n\n    this.connect(); \n\n    p5sound.soundArray.push(this);\n  };\n  /**\n   *  Set the output volume of the filter.\n   *\n   *  @method  amp\n   *  @for p5.Effect\n   *  @param {Number} [vol] amplitude between 0 and 1.0\n   *  @param {Number} [rampTime] create a fade that lasts until rampTime\n   *  @param {Number} [tFromNow] schedule this event to happen in tFromNow seconds\n   */\n\n\n  p5.Effect.prototype.amp = function (vol, rampTime, tFromNow) {\n    var rampTime = rampTime || 0;\n    var tFromNow = tFromNow || 0;\n    var now = p5sound.audiocontext.currentTime;\n    var currentVol = this.output.gain.value;\n    this.output.gain.cancelScheduledValues(now);\n    this.output.gain.linearRampToValueAtTime(currentVol, now + tFromNow + .001);\n    this.output.gain.linearRampToValueAtTime(vol, now + tFromNow + rampTime + .001);\n  };\n  /**\n   *  Link effects together in a chain\n   *  Example usage: filter.chain(reverb, delay, panner);\n   *  May be used with an open-ended number of arguments\n   *\n   *  @method chain\n   *  @for p5.Effect\n   *  @param {Object} [arguments]  Chain together multiple sound objects\n   */\n\n\n  p5.Effect.prototype.chain = function () {\n    if (arguments.length > 0) {\n      this.connect(arguments[0]);\n\n      for (var i = 1; i < arguments.length; i += 1) {\n        arguments[i - 1].connect(arguments[i]);\n      }\n    }\n\n    return this;\n  };\n  /**\n   *  Adjust the dry/wet value.\n   *\n   *  @method drywet\n   *  @for p5.Effect\n   *  @param {Number} [fade] The desired drywet value (0 - 1.0)\n   */\n\n\n  p5.Effect.prototype.drywet = function (fade) {\n    if (typeof fade !== \"undefined\") {\n      this._drywet.fade.value = fade;\n    }\n\n    return this._drywet.fade.value;\n  };\n  /**\n   *  Send output to a p5.js-sound, Web Audio Node, or use signal to\n   *  control an AudioParam\n   *\n   *  @method connect\n   *  @for p5.Effect\n   *  @param {Object} unit\n   */\n\n\n  p5.Effect.prototype.connect = function (unit) {\n    var u = unit || p5.soundOut.input;\n    this.output.connect(u.input ? u.input : u);\n  };\n  /**\n   * Disconnect all output.\n   * @method disconnect\n   * @for p5.Effect\n   */\n\n\n  p5.Effect.prototype.disconnect = function () {\n    if (this.output) {\n      this.output.disconnect();\n    }\n  };\n\n  p5.Effect.prototype.dispose = function () {\n    var index = p5sound.soundArray.indexOf(this);\n    p5sound.soundArray.splice(index, 1);\n\n    if (this.input) {\n      this.input.disconnect();\n      delete this.input;\n    }\n\n    if (this.output) {\n      this.output.disconnect();\n      delete this.output;\n    }\n\n    if (this._drywet) {\n      this._drywet.disconnect();\n\n      delete this._drywet;\n    }\n\n    if (this.wet) {\n      this.wet.disconnect();\n      delete this.wet;\n    }\n\n    this.ac = undefined;\n  };\n\n  return p5.Effect;\n}).call(exports, __nested_webpack_require_17634__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_22395__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_22395__(0),__nested_webpack_require_22395__(19)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(e){\"use strict\";return e.WaveShaper=function(e,t){this._shaper=this.input=this.output=this.context.createWaveShaper(),this._curve=null,Array.isArray(e)?this.curve=e:isFinite(e)||this.isUndef(e)?this._curve=new Float32Array(this.defaultArg(e,1024)):this.isFunction(e)&&(this._curve=new Float32Array(this.defaultArg(t,1024)),this.setMap(e))},e.extend(e.WaveShaper,e.SignalBase),e.WaveShaper.prototype.setMap=function(e){for(var t=0,r=this._curve.length;t<r;t++){var s=t/(r-1)*2-1;this._curve[t]=e(s,t)}return this._shaper.curve=this._curve,this},Object.defineProperty(e.WaveShaper.prototype,\"curve\",{get:function(){return this._shaper.curve},set:function(e){this._curve=new Float32Array(e),this._shaper.curve=this._curve}}),Object.defineProperty(e.WaveShaper.prototype,\"oversample\",{get:function(){return this._shaper.oversample},set:function(e){if(-1===[\"none\",\"2x\",\"4x\"].indexOf(e))throw new RangeError(\"Tone.WaveShaper: oversampling must be either 'none', '2x', or '4x'\");this._shaper.oversample=e}}),e.WaveShaper.prototype.dispose=function(){return e.prototype.dispose.call(this),this._shaper.disconnect(),this._shaper=null,this._curve=null,this},e.WaveShaper}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_23954__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_23954__(1);\n\n  var processorNames = __nested_webpack_require_23954__(10);\n  /**\n   * @for p5\n   */\n\n  /**\n   * Returns a number representing the sample rate, in samples per second,\n   * of all sound objects in this audio context. It is determined by the\n   * sampling rate of your operating system's sound card, and it is not\n   * currently possile to change.\n   * It is often 44100, or twice the range of human hearing.\n   *\n   * @method sampleRate\n   * @return {Number} samplerate samples per second\n   */\n\n\n  p5.prototype.sampleRate = function () {\n    return p5sound.audiocontext.sampleRate;\n  };\n  /**\n   *  Returns the closest MIDI note value for\n   *  a given frequency.\n   *\n   *  @method freqToMidi\n   *  @param  {Number} frequency A freqeuncy, for example, the \"A\"\n   *                             above Middle C is 440Hz\n   *  @return {Number}   MIDI note value\n   */\n\n\n  p5.prototype.freqToMidi = function (f) {\n    var mathlog2 = Math.log(f / 440) / Math.log(2);\n    var m = Math.round(12 * mathlog2) + 69;\n    return m;\n  };\n  /**\n   *  Returns the frequency value of a MIDI note value.\n   *  General MIDI treats notes as integers where middle C\n   *  is 60, C# is 61, D is 62 etc. Useful for generating\n   *  musical frequencies with oscillators.\n   *\n   *  @method  midiToFreq\n   *  @param  {Number} midiNote The number of a MIDI note\n   *  @return {Number} Frequency value of the given MIDI note\n   *  @example\n   *  <div><code>\n   *  let midiNotes = [60, 64, 67, 72];\n   *  let noteIndex = 0;\n   *  let midiVal, freq;\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(startSound);\n   *    osc = new p5.TriOsc();\n   *    env = new p5.Envelope();\n   *  }\n   *\n   *  function draw() {\n   *    background(220);\n   *    text('tap to play', 10, 20);\n   *    if (midiVal) {\n   *      text('MIDI: ' + midiVal, 10, 40);\n   *      text('Freq: ' + freq, 10, 60);\n   *    }\n   *  }\n   *\n   *  function startSound() {\n   *    // see also: userStartAudio();\n   *    osc.start();\n   *\n   *    midiVal = midiNotes[noteIndex % midiNotes.length];\n   *    freq = midiToFreq(midiVal);\n   *    osc.freq(freq);\n   *    env.ramp(osc, 0, 1.0, 0);\n   *\n   *    noteIndex++;\n   *  }\n   *  </code></div>\n   */\n\n\n  var midiToFreq = p5.prototype.midiToFreq = function (m) {\n    return 440 * Math.pow(2, (m - 69) / 12.0);\n  }; \n\n\n  var noteToFreq = function noteToFreq(note) {\n    if (typeof note !== 'string') {\n      return note;\n    }\n\n    var wholeNotes = {\n      A: 21,\n      B: 23,\n      C: 24,\n      D: 26,\n      E: 28,\n      F: 29,\n      G: 31\n    };\n    var value = wholeNotes[note[0].toUpperCase()];\n    var octave = ~~note.slice(-1);\n    value += 12 * (octave - 1);\n\n    switch (note[1]) {\n      case '#':\n        value += 1;\n        break;\n\n      case 'b':\n        value -= 1;\n        break;\n\n      default:\n        break;\n    }\n\n    return midiToFreq(value);\n  };\n  /**\n   *  List the SoundFile formats that you will include. LoadSound\n   *  will search your directory for these extensions, and will pick\n   *  a format that is compatable with the client's web browser.\n   *  <a href=\"http://media.io/\">Here</a> is a free online file\n   *  converter.\n   *\n   *  @method soundFormats\n   *  @param {String} [...formats] i.e. 'mp3', 'wav', 'ogg'\n   *  @example\n   *  <div><code>\n   *  function preload() {\n   *    // set the global sound formats\n   *    soundFormats('mp3', 'ogg');\n   *\n   *    // load either beatbox.mp3, or .ogg, depending on browser\n   *    mySound = loadSound('assets/beatbox.mp3');\n   *  }\n   *\n   *  function setup() {\n   *       let cnv = createCanvas(100, 100);\n   *       background(220);\n   *       text('sound loaded! tap to play', 10, 20, width - 20);\n   *       cnv.mousePressed(function() {\n   *         mySound.play();\n   *       });\n   *     }\n   *  </code></div>\n   */\n\n\n  p5.prototype.soundFormats = function () {\n    p5sound.extensions = []; \n\n    for (var i = 0; i < arguments.length; i++) {\n      arguments[i] = arguments[i].toLowerCase();\n\n      if (['mp3', 'wav', 'ogg', 'm4a', 'aac'].indexOf(arguments[i]) > -1) {\n        p5sound.extensions.push(arguments[i]);\n      } else {\n        throw arguments[i] + ' is not a valid sound format!';\n      }\n    }\n  };\n\n  p5.prototype.disposeSound = function () {\n    for (var i = 0; i < p5sound.soundArray.length; i++) {\n      p5sound.soundArray[i].dispose();\n    }\n  }; \n\n\n  p5.prototype.registerMethod('remove', p5.prototype.disposeSound);\n\n  p5.prototype._checkFileFormats = function (paths) {\n    var path; \n\n    if (typeof paths === 'string') {\n      path = paths; \n\n      var extTest = path.split('.').pop(); \n\n      if (['mp3', 'wav', 'ogg', 'm4a', 'aac'].indexOf(extTest) > -1) {\n        if (p5.prototype.isFileSupported(extTest)) {\n          path = path;\n        } else {\n          var pathSplit = path.split('.');\n          var pathCore = pathSplit[pathSplit.length - 1];\n\n          for (var i = 0; i < p5sound.extensions.length; i++) {\n            var extension = p5sound.extensions[i];\n            var supported = p5.prototype.isFileSupported(extension);\n\n            if (supported) {\n              pathCore = '';\n\n              if (pathSplit.length === 2) {\n                pathCore += pathSplit[0];\n              }\n\n              for (var i = 1; i <= pathSplit.length - 2; i++) {\n                var p = pathSplit[i];\n                pathCore += '.' + p;\n              }\n\n              path = pathCore += '.';\n              path = path += extension;\n              break;\n            }\n          }\n        }\n      } \n      else {\n          for (var i = 0; i < p5sound.extensions.length; i++) {\n            var extension = p5sound.extensions[i];\n            var supported = p5.prototype.isFileSupported(extension);\n\n            if (supported) {\n              path = path + '.' + extension;\n              break;\n            }\n          }\n        }\n    } \n    else if (_typeof(paths) === 'object') {\n        for (var i = 0; i < paths.length; i++) {\n          var extension = paths[i].split('.').pop();\n          var supported = p5.prototype.isFileSupported(extension);\n\n          if (supported) {\n            path = paths[i];\n            break;\n          }\n        }\n      }\n\n    return path;\n  };\n  /**\n   *  Used by Osc and Envelope to chain signal math\n   */\n\n\n  p5.prototype._mathChain = function (o, math, thisChain, nextChain, type) {\n    for (var i in o.mathOps) {\n      if (o.mathOps[i] instanceof type) {\n        o.mathOps[i].dispose();\n        thisChain = i;\n\n        if (thisChain < o.mathOps.length - 1) {\n          nextChain = o.mathOps[i + 1];\n        }\n      }\n    }\n\n    o.mathOps[thisChain - 1].disconnect();\n    o.mathOps[thisChain - 1].connect(math);\n    math.connect(nextChain);\n    o.mathOps[thisChain] = math;\n    return o;\n  }; \n\n\n  function convertToWav(audioBuffer) {\n    var leftChannel, rightChannel;\n    leftChannel = audioBuffer.getChannelData(0); \n\n    if (audioBuffer.numberOfChannels > 1) {\n      rightChannel = audioBuffer.getChannelData(1);\n    } else {\n      rightChannel = leftChannel;\n    }\n\n    var interleaved = interleave(leftChannel, rightChannel); \n\n    var buffer = new window.ArrayBuffer(44 + interleaved.length * 2);\n    var view = new window.DataView(buffer); \n\n    writeUTFBytes(view, 0, 'RIFF');\n    view.setUint32(4, 36 + interleaved.length * 2, true);\n    writeUTFBytes(view, 8, 'WAVE'); \n\n    writeUTFBytes(view, 12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true); \n\n    view.setUint16(22, 2, true);\n    view.setUint32(24, p5sound.audiocontext.sampleRate, true);\n    view.setUint32(28, p5sound.audiocontext.sampleRate * 4, true);\n    view.setUint16(32, 4, true);\n    view.setUint16(34, 16, true); \n\n    writeUTFBytes(view, 36, 'data');\n    view.setUint32(40, interleaved.length * 2, true); \n\n    var lng = interleaved.length;\n    var index = 44;\n    var volume = 1;\n\n    for (var i = 0; i < lng; i++) {\n      view.setInt16(index, interleaved[i] * (0x7FFF * volume), true);\n      index += 2;\n    }\n\n    return view;\n  } \n\n\n  function interleave(leftChannel, rightChannel) {\n    var length = leftChannel.length + rightChannel.length;\n    var result = new Float32Array(length);\n    var inputIndex = 0;\n\n    for (var index = 0; index < length;) {\n      result[index++] = leftChannel[inputIndex];\n      result[index++] = rightChannel[inputIndex];\n      inputIndex++;\n    }\n\n    return result;\n  }\n\n  function writeUTFBytes(view, offset, string) {\n    var lng = string.length;\n\n    for (var i = 0; i < lng; i++) {\n      view.setUint8(offset + i, string.charCodeAt(i));\n    }\n  }\n\n  function safeBufferSize(idealBufferSize) {\n    var bufferSize = idealBufferSize; \n\n    var tempAudioWorkletNode = new AudioWorkletNode(p5sound.audiocontext, processorNames.soundFileProcessor);\n\n    if (tempAudioWorkletNode instanceof ScriptProcessorNode) {\n      bufferSize = tempAudioWorkletNode.bufferSize;\n    }\n\n    tempAudioWorkletNode.disconnect();\n    tempAudioWorkletNode = null;\n    return bufferSize;\n  }\n\n  return {\n    convertToWav: convertToWav,\n    midiToFreq: midiToFreq,\n    noteToFreq: noteToFreq,\n    safeBufferSize: safeBufferSize\n  };\n}).call(exports, __nested_webpack_require_23954__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_33789__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_33789__(0),__nested_webpack_require_33789__(2),__nested_webpack_require_33789__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(i){\"use strict\";return i.Add=function(t){this.createInsOuts(2,0),this._sum=this.input[0]=this.input[1]=this.output=new i.Gain,this._param=this.input[1]=new i.Signal(t),this._param.connect(this._sum)},i.extend(i.Add,i.Signal),i.Add.prototype.dispose=function(){return i.prototype.dispose.call(this),this._sum.dispose(),this._sum=null,this._param.dispose(),this._param=null,this},i.Add}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_34592__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_34592__(0),__nested_webpack_require_34592__(20),__nested_webpack_require_34592__(45),__nested_webpack_require_34592__(46),__nested_webpack_require_34592__(12)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(t){return t.Type={Default:\"number\",Time:\"time\",Frequency:\"frequency\",TransportTime:\"transportTime\",Ticks:\"ticks\",NormalRange:\"normalRange\",AudioRange:\"audioRange\",Decibels:\"db\",Interval:\"interval\",BPM:\"bpm\",Positive:\"positive\",Cents:\"cents\",Degrees:\"degrees\",MIDI:\"midi\",BarsBeatsSixteenths:\"barsBeatsSixteenths\",Samples:\"samples\",Hertz:\"hertz\",Note:\"note\",Milliseconds:\"milliseconds\",Seconds:\"seconds\",Notation:\"notation\"},t.prototype.toSeconds=function(e){return this.isNumber(e)?e:this.isUndef(e)?this.now():this.isString(e)?new t.Time(e).toSeconds():e instanceof t.TimeBase?e.toSeconds():void 0},t.prototype.toFrequency=function(e){return this.isNumber(e)?e:this.isString(e)||this.isUndef(e)?new t.Frequency(e).valueOf():e instanceof t.TimeBase?e.toFrequency():void 0},t.prototype.toTicks=function(e){return this.isNumber(e)||this.isString(e)?new t.TransportTime(e).toTicks():this.isUndef(e)?t.Transport.ticks:e instanceof t.TimeBase?e.toTicks():void 0},t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_36021__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_36021__(0),__nested_webpack_require_36021__(22),__nested_webpack_require_36021__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(i){\"use strict\";return window.GainNode&&!AudioContext.prototype.createGain&&(AudioContext.prototype.createGain=AudioContext.prototype.createGainNode),i.Gain=function(){var t=this.optionsObject(arguments,[\"gain\",\"units\"],i.Gain.defaults);this.input=this.output=this._gainNode=this.context.createGain(),this.gain=new i.Param({param:this._gainNode.gain,units:t.units,value:t.gain,convert:t.convert}),this._readOnly(\"gain\")},i.extend(i.Gain),i.Gain.defaults={gain:1,convert:!0},i.Gain.prototype.dispose=function(){i.Param.prototype.dispose.call(this),this._gainNode.disconnect(),this._gainNode=null,this._writable(\"gain\"),this.gain.dispose(),this.gain=null},i.prototype.createInsOuts=function(t,n){1===t?this.input=new i.Gain:1<t&&(this.input=new Array(t)),1===n?this.output=new i.Gain:1<n&&(this.output=new Array(t))},i.Gain}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports) {\n\nmodule.exports = {\n  recorderProcessor: 'recorder-processor',\n  soundFileProcessor: 'sound-file-processor',\n  amplitudeProcessor: 'amplitude-processor'\n};\n\n }),\n (function(module, exports, __nested_webpack_require_37455__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  var CustomError = function CustomError(name, errorTrace, failedPath) {\n    var err = new Error();\n    var tempStack, splitStack;\n    err.name = name;\n    err.originalStack = err.stack + errorTrace;\n    tempStack = err.stack + errorTrace;\n    err.failedPath = failedPath; \n\n    var splitStack = tempStack.split('\\n');\n    splitStack = splitStack.filter(function (ln) {\n      return !ln.match(/(p5.|native code|globalInit)/g);\n    });\n    err.stack = splitStack.join('\\n');\n    return err; \n  };\n\n  return CustomError;\n}).call(exports, __nested_webpack_require_37455__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_38289__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_38289__(0),__nested_webpack_require_38289__(18)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(o){function t(e,t,n){if(e.input)Array.isArray(e.input)?(o.prototype.isUndef(n)&&(n=0),this.connect(e.input[n])):this.connect(e.input,t,n);else try{e instanceof AudioNode?i.call(this,e,t,n):i.call(this,e,t)}catch(t){throw new Error(\"error connecting to node: \"+e+\"\\n\"+t)}}var i,r;return!window.hasOwnProperty(\"AudioContext\")&&window.hasOwnProperty(\"webkitAudioContext\")&&(window.AudioContext=window.webkitAudioContext),o.Context=function(t){for(var e in o.Emitter.call(this),t=t||new window.AudioContext,this._context=t,this._context)this._defineProperty(this._context,e);this._latencyHint=\"interactive\",this._lookAhead=.1,this._updateInterval=this._lookAhead/3,this._computedUpdateInterval=0,this._worker=this._createWorker(),this._constants={}},o.extend(o.Context,o.Emitter),o.Emitter.mixin(o.Context),o.Context.prototype._defineProperty=function(e,n){this.isUndef(this[n])&&Object.defineProperty(this,n,{get:function(){return\"function\"==typeof e[n]?e[n].bind(e):e[n]},set:function(t){e[n]=t}})},o.Context.prototype.now=function(){return this._context.currentTime},o.Context.prototype._createWorker=function(){window.URL=window.URL||window.webkitURL;var t=new Blob([\"var timeoutTime = \"+(1e3*this._updateInterval).toFixed(1)+\";self.onmessage = function(msg){\\ttimeoutTime = parseInt(msg.data);};function tick(){\\tsetTimeout(tick, timeoutTime);\\tself.postMessage('tick');}tick();\"]),e=URL.createObjectURL(t),n=new Worker(e);return n.addEventListener(\"message\",function(){this.emit(\"tick\")}.bind(this)),n.addEventListener(\"message\",function(){var t=this.now();if(this.isNumber(this._lastUpdate)){var e=t-this._lastUpdate;this._computedUpdateInterval=Math.max(e,.97*this._computedUpdateInterval)}this._lastUpdate=t}.bind(this)),n},o.Context.prototype.getConstant=function(t){if(this._constants[t])return this._constants[t];for(var e=this._context.createBuffer(1,128,this._context.sampleRate),n=e.getChannelData(0),o=0;o<n.length;o++)n[o]=t;var i=this._context.createBufferSource();return i.channelCount=1,i.channelCountMode=\"explicit\",i.buffer=e,i.loop=!0,i.start(0),this._constants[t]=i},Object.defineProperty(o.Context.prototype,\"lag\",{get:function(){var t=this._computedUpdateInterval-this._updateInterval;return t=Math.max(t,0)}}),Object.defineProperty(o.Context.prototype,\"lookAhead\",{get:function(){return this._lookAhead},set:function(t){this._lookAhead=t}}),Object.defineProperty(o.Context.prototype,\"updateInterval\",{get:function(){return this._updateInterval},set:function(t){this._updateInterval=Math.max(t,o.prototype.blockTime),this._worker.postMessage(Math.max(1e3*t,1))}}),Object.defineProperty(o.Context.prototype,\"latencyHint\",{get:function(){return this._latencyHint},set:function(t){var e=t;if(this._latencyHint=t,this.isString(t))switch(t){case\"interactive\":e=.1,this._context.latencyHint=t;break;case\"playback\":e=.8,this._context.latencyHint=t;break;case\"balanced\":e=.25,this._context.latencyHint=t;break;case\"fastest\":e=.01}this.lookAhead=e,this.updateInterval=e/3}}),o.supported?(i=AudioNode.prototype.connect,r=AudioNode.prototype.disconnect,AudioNode.prototype.connect!==t&&(AudioNode.prototype.connect=t,AudioNode.prototype.disconnect=function(e,t,n){if(e&&e.input&&Array.isArray(e.input))o.prototype.isUndef(n)&&(n=0),this.disconnect(e.input[n],t,n);else if(e&&e.input)this.disconnect(e.input,t,n);else try{r.apply(this,arguments)}catch(t){throw new Error(\"error disconnecting node: \"+e+\"\\n\"+t)}}),o.context=new o.Context):console.warn(\"This browser does not support Tone.js\"),o.Context}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_42198__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_42198__(0),__nested_webpack_require_42198__(7),__nested_webpack_require_42198__(3),__nested_webpack_require_42198__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(i){\"use strict\";return i.Scale=function(t,e){this._outputMin=this.defaultArg(t,0),this._outputMax=this.defaultArg(e,1),this._scale=this.input=new i.Multiply(1),this._add=this.output=new i.Add(0),this._scale.connect(this._add),this._setRange()},i.extend(i.Scale,i.SignalBase),Object.defineProperty(i.Scale.prototype,\"min\",{get:function(){return this._outputMin},set:function(t){this._outputMin=t,this._setRange()}}),Object.defineProperty(i.Scale.prototype,\"max\",{get:function(){return this._outputMax},set:function(t){this._outputMax=t,this._setRange()}}),i.Scale.prototype._setRange=function(){this._add.value=this._outputMin,this._scale.value=this._outputMax-this._outputMin},i.Scale.prototype.dispose=function(){return i.prototype.dispose.call(this),this._add.dispose(),this._add=null,this._scale.dispose(),this._scale=null,this},i.Scale}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_43480__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_43480__(0),__nested_webpack_require_43480__(2),__nested_webpack_require_43480__(24)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(o){\"use strict\";return o.TimelineSignal=function(){var e=this.optionsObject(arguments,[\"value\",\"units\"],o.Signal.defaults);this._events=new o.Timeline(10),o.Signal.apply(this,e),e.param=this._param,o.Param.call(this,e),this._initial=this._fromUnits(this._param.value)},o.extend(o.TimelineSignal,o.Param),o.TimelineSignal.Type={Linear:\"linear\",Exponential:\"exponential\",Target:\"target\",Curve:\"curve\",Set:\"set\"},Object.defineProperty(o.TimelineSignal.prototype,\"value\",{get:function(){var e=this.now(),t=this.getValueAtTime(e);return this._toUnits(t)},set:function(e){var t=this._fromUnits(e);this._initial=t,this.cancelScheduledValues(),this._param.value=t}}),o.TimelineSignal.prototype.setValueAtTime=function(e,t){return e=this._fromUnits(e),t=this.toSeconds(t),this._events.add({type:o.TimelineSignal.Type.Set,value:e,time:t}),this._param.setValueAtTime(e,t),this},o.TimelineSignal.prototype.linearRampToValueAtTime=function(e,t){return e=this._fromUnits(e),t=this.toSeconds(t),this._events.add({type:o.TimelineSignal.Type.Linear,value:e,time:t}),this._param.linearRampToValueAtTime(e,t),this},o.TimelineSignal.prototype.exponentialRampToValueAtTime=function(e,t){t=this.toSeconds(t);var i=this._searchBefore(t);i&&0===i.value&&this.setValueAtTime(this._minOutput,i.time),e=this._fromUnits(e);var n=Math.max(e,this._minOutput);return this._events.add({type:o.TimelineSignal.Type.Exponential,value:n,time:t}),e<this._minOutput?(this._param.exponentialRampToValueAtTime(this._minOutput,t-this.sampleTime),this.setValueAtTime(0,t)):this._param.exponentialRampToValueAtTime(e,t),this},o.TimelineSignal.prototype.setTargetAtTime=function(e,t,i){return e=this._fromUnits(e),e=Math.max(this._minOutput,e),i=Math.max(this._minOutput,i),t=this.toSeconds(t),this._events.add({type:o.TimelineSignal.Type.Target,value:e,time:t,constant:i}),this._param.setTargetAtTime(e,t,i),this},o.TimelineSignal.prototype.setValueCurveAtTime=function(e,t,i,n){n=this.defaultArg(n,1);for(var a=new Array(e.length),l=0;l<a.length;l++)a[l]=this._fromUnits(e[l])*n;t=this.toSeconds(t),i=this.toSeconds(i),this._events.add({type:o.TimelineSignal.Type.Curve,value:a,time:t,duration:i}),this._param.setValueAtTime(a[0],t);for(var s=1;s<a.length;s++){var r=t+s/(a.length-1)*i;this._param.linearRampToValueAtTime(a[s],r)}return this},o.TimelineSignal.prototype.cancelScheduledValues=function(e){return e=this.toSeconds(e),this._events.cancel(e),this._param.cancelScheduledValues(e),this},o.TimelineSignal.prototype.setRampPoint=function(e){e=this.toSeconds(e);var t=this._toUnits(this.getValueAtTime(e)),i=this._searchBefore(e);if(i&&i.time===e)this.cancelScheduledValues(e+this.sampleTime);else if(i&&i.type===o.TimelineSignal.Type.Curve&&i.time+i.duration>e)this.cancelScheduledValues(e),this.linearRampToValueAtTime(t,e);else{var n=this._searchAfter(e);n&&(this.cancelScheduledValues(e),n.type===o.TimelineSignal.Type.Linear?this.linearRampToValueAtTime(t,e):n.type===o.TimelineSignal.Type.Exponential&&this.exponentialRampToValueAtTime(t,e)),this.setValueAtTime(t,e)}return this},o.TimelineSignal.prototype.linearRampToValueBetween=function(e,t,i){return this.setRampPoint(t),this.linearRampToValueAtTime(e,i),this},o.TimelineSignal.prototype.exponentialRampToValueBetween=function(e,t,i){return this.setRampPoint(t),this.exponentialRampToValueAtTime(e,i),this},o.TimelineSignal.prototype._searchBefore=function(e){return this._events.get(e)},o.TimelineSignal.prototype._searchAfter=function(e){return this._events.getAfter(e)},o.TimelineSignal.prototype.getValueAtTime=function(e){e=this.toSeconds(e);var t=this._searchAfter(e),i=this._searchBefore(e),n=this._initial;if(null===i)n=this._initial;else if(i.type===o.TimelineSignal.Type.Target){var a,l=this._events.getBefore(i.time);a=null===l?this._initial:l.value,n=this._exponentialApproach(i.time,a,i.value,i.constant,e)}else n=i.type===o.TimelineSignal.Type.Curve?this._curveInterpolate(i.time,i.value,i.duration,e):null===t?i.value:t.type===o.TimelineSignal.Type.Linear?this._linearInterpolate(i.time,i.value,t.time,t.value,e):t.type===o.TimelineSignal.Type.Exponential?this._exponentialInterpolate(i.time,i.value,t.time,t.value,e):i.value;return n},o.TimelineSignal.prototype.connect=o.SignalBase.prototype.connect,o.TimelineSignal.prototype._exponentialApproach=function(e,t,i,n,a){return i+(t-i)*Math.exp(-(a-e)/n)},o.TimelineSignal.prototype._linearInterpolate=function(e,t,i,n,a){return t+(a-e)/(i-e)*(n-t)},o.TimelineSignal.prototype._exponentialInterpolate=function(e,t,i,n,a){return(t=Math.max(this._minOutput,t))*Math.pow(n/t,(a-e)/(i-e))},o.TimelineSignal.prototype._curveInterpolate=function(e,t,i,n){var a=t.length;if(e+i<=n)return t[a-1];if(n<=e)return t[0];var l=(n-e)/i,s=Math.floor((a-1)*l),r=Math.ceil((a-1)*l),o=t[s],p=t[r];return r===s?o:this._linearInterpolate(s,o,r,p,l*(a-1))},o.TimelineSignal.prototype.dispose=function(){o.Signal.prototype.dispose.call(this),o.Param.prototype.dispose.call(this),this._events.dispose(),this._events=null},o.TimelineSignal}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_48906__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var Effect = __nested_webpack_require_48906__(4);\n  /**\n   *  <p>A p5.Filter uses a Web Audio Biquad Filter to filter\n   *  the frequency response of an input source. Subclasses\n   *  include:</p>\n   *  <a href=\"/reference/#/p5.LowPass\"><code>p5.LowPass</code></a>:\n   *  Allows frequencies below the cutoff frequency to pass through,\n   *  and attenuates frequencies above the cutoff.<br/>\n   *  <a href=\"/reference/#/p5.HighPass\"><code>p5.HighPass</code></a>:\n   *  The opposite of a lowpass filter. <br/>\n   *  <a href=\"/reference/#/p5.BandPass\"><code>p5.BandPass</code></a>:\n   *  Allows a range of frequencies to pass through and attenuates\n   *  the frequencies below and above this frequency range.<br/>\n   *\n   *  The <code>.res()</code> method controls either width of the\n   *  bandpass, or resonance of the low/highpass cutoff frequency.\n   *\n   *  This class extends <a href = \"/reference/#/p5.Effect\">p5.Effect</a>.\n   *  Methods <a href = \"/reference/#/p5.Effect/amp\">amp()</a>, <a href = \"/reference/#/p5.Effect/chain\">chain()</a>,\n   *  <a href = \"/reference/#/p5.Effect/drywet\">drywet()</a>, <a href = \"/reference/#/p5.Effect/connect\">connect()</a>, and\n   *  <a href = \"/reference/#/p5.Effect/disconnect\">disconnect()</a> are available.\n   *\n   *  @class p5.Filter\n   *  @extends p5.Effect\n   *  @constructor\n   *  @param {String} [type] 'lowpass' (default), 'highpass', 'bandpass'\n   *  @example\n   *  <div><code>\n  *  let fft, noise, filter;\n  *\n  *  function setup() {\n  *    let cnv = createCanvas(100,100);\n  *    cnv.mousePressed(makeNoise);\n  *    fill(255, 0, 255);\n  *\n  *    filter = new p5.BandPass();\n  *    noise = new p5.Noise();\n  *    noise.disconnect();\n  *    noise.connect(filter);\n  *\n  *    fft = new p5.FFT();\n  *  }\n  *\n  *  function draw() {\n  *    background(220);\n  *\n  *    // set the BandPass frequency based on mouseX\n  *    let freq = map(mouseX, 0, width, 20, 10000);\n  *    freq = constrain(freq, 0, 22050);\n  *    filter.freq(freq);\n  *    // give the filter a narrow band (lower res = wider bandpass)\n  *    filter.res(50);\n  *\n  *    // draw filtered spectrum\n  *    let spectrum = fft.analyze();\n  *    noStroke();\n  *    for (let i = 0; i < spectrum.length; i++) {\n  *      let x = map(i, 0, spectrum.length, 0, width);\n  *      let h = -height + map(spectrum[i], 0, 255, height, 0);\n  *      rect(x, height, width/spectrum.length, h);\n  *    }\n  *    if (!noise.started) {\n  *      text('tap here and drag to change frequency', 10, 20, width - 20);\n  *    } else {\n  *      text('Frequency: ' + round(freq)+'Hz', 20, 20, width - 20);\n  *    }\n  *  }\n  *\n  *  function makeNoise() {\n  *    // see also: `userStartAudio()`\n  *    noise.start();\n  *    noise.amp(0.5, 0.2);\n  *  }\n  *\n  *  function mouseReleased() {\n  *    noise.amp(0, 0.2);\n  *  }\n  *\n   *  </code></div>\n   */\n\n\n  p5.Filter = function (type) {\n    Effect.call(this); \n\n    /**\n      *  The p5.Filter is built with a\n      *  <a href=\"http://www.w3.org/TR/webaudio/#BiquadFilterNode\">\n      *  Web Audio BiquadFilter Node</a>.\n      *\n      *  @property {DelayNode} biquadFilter\n    */\n\n    this.biquad = this.ac.createBiquadFilter();\n    this.input.connect(this.biquad);\n    this.biquad.connect(this.wet);\n\n    if (type) {\n      this.setType(type);\n    } \n\n\n    this._on = true;\n    this._untoggledType = this.biquad.type;\n  };\n\n  p5.Filter.prototype = Object.create(Effect.prototype);\n  /**\n   *  Filter an audio signal according to a set\n   *  of filter parameters.\n   *\n   *  @method  process\n   *  @param  {Object} Signal  An object that outputs audio\n   *  @param {Number} [freq] Frequency in Hz, from 10 to 22050\n   *  @param {Number} [res] Resonance/Width of the filter frequency\n   *                        from 0.001 to 1000\n   */\n\n  p5.Filter.prototype.process = function (src, freq, res, time) {\n    src.connect(this.input);\n    this.set(freq, res, time);\n  };\n  /**\n   *  Set the frequency and the resonance of the filter.\n   *\n   *  @method  set\n   *  @param {Number} [freq] Frequency in Hz, from 10 to 22050\n   *  @param {Number} [res]  Resonance (Q) from 0.001 to 1000\n   *  @param {Number} [timeFromNow] schedule this event to happen\n   *                                seconds from now\n   */\n\n\n  p5.Filter.prototype.set = function (freq, res, time) {\n    if (freq) {\n      this.freq(freq, time);\n    }\n\n    if (res) {\n      this.res(res, time);\n    }\n  };\n  /**\n   *  Set the filter frequency, in Hz, from 10 to 22050 (the range of\n   *  human hearing, although in reality most people hear in a narrower\n   *  range).\n   *\n   *  @method  freq\n   *  @param  {Number} freq Filter Frequency\n   *  @param {Number} [timeFromNow] schedule this event to happen\n   *                                seconds from now\n   *  @return {Number} value  Returns the current frequency value\n   */\n\n\n  p5.Filter.prototype.freq = function (freq, time) {\n    var t = time || 0;\n\n    if (freq <= 0) {\n      freq = 1;\n    }\n\n    if (typeof freq === 'number') {\n      this.biquad.frequency.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.biquad.frequency.exponentialRampToValueAtTime(freq, this.ac.currentTime + 0.02 + t);\n    } else if (freq) {\n      freq.connect(this.biquad.frequency);\n    }\n\n    return this.biquad.frequency.value;\n  };\n  /**\n   *  Controls either width of a bandpass frequency,\n   *  or the resonance of a low/highpass cutoff frequency.\n   *\n   *  @method  res\n   *  @param {Number} res  Resonance/Width of filter freq\n   *                       from 0.001 to 1000\n   *  @param {Number} [timeFromNow] schedule this event to happen\n   *                                seconds from now\n   *  @return {Number} value Returns the current res value\n   */\n\n\n  p5.Filter.prototype.res = function (res, time) {\n    var t = time || 0;\n\n    if (typeof res === 'number') {\n      this.biquad.Q.value = res;\n      this.biquad.Q.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.biquad.Q.linearRampToValueAtTime(res, this.ac.currentTime + 0.02 + t);\n    } else if (res) {\n      res.connect(this.biquad.Q);\n    }\n\n    return this.biquad.Q.value;\n  };\n  /**\n   * Controls the gain attribute of a Biquad Filter.\n   * This is distinctly different from .amp() which is inherited from p5.Effect\n   * .amp() controls the volume via the output gain node\n   * p5.Filter.gain() controls the gain parameter of a Biquad Filter node.\n   *\n   * @method gain\n   * @param  {Number} gain\n   * @return {Number} Returns the current or updated gain value\n   */\n\n\n  p5.Filter.prototype.gain = function (gain, time) {\n    var t = time || 0;\n\n    if (typeof gain === 'number') {\n      this.biquad.gain.value = gain;\n      this.biquad.gain.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.biquad.gain.linearRampToValueAtTime(gain, this.ac.currentTime + 0.02 + t);\n    } else if (gain) {\n      gain.connect(this.biquad.gain);\n    }\n\n    return this.biquad.gain.value;\n  };\n  /**\n   * Toggle function. Switches between the specified type and allpass\n   *\n   * @method toggle\n   * @return {boolean} [Toggle value]\n   */\n\n\n  p5.Filter.prototype.toggle = function () {\n    this._on = !this._on;\n\n    if (this._on === true) {\n      this.biquad.type = this._untoggledType;\n    } else if (this._on === false) {\n      this.biquad.type = 'allpass';\n    }\n\n    return this._on;\n  };\n  /**\n   *  Set the type of a p5.Filter. Possible types include:\n   *  \"lowpass\" (default), \"highpass\", \"bandpass\",\n   *  \"lowshelf\", \"highshelf\", \"peaking\", \"notch\",\n   *  \"allpass\".\n   *\n   *  @method  setType\n   *  @param {String} t\n   */\n\n\n  p5.Filter.prototype.setType = function (t) {\n    this.biquad.type = t;\n    this._untoggledType = this.biquad.type;\n  };\n\n  p5.Filter.prototype.dispose = function () {\n    Effect.prototype.dispose.apply(this);\n\n    if (this.biquad) {\n      this.biquad.disconnect();\n      delete this.biquad;\n    }\n  };\n  /**\n   *  Constructor: <code>new p5.LowPass()</code> Filter.\n   *  This is the same as creating a p5.Filter and then calling\n   *  its method <code>setType('lowpass')</code>.\n   *  See p5.Filter for methods.\n   *\n   *  @class p5.LowPass\n   *  @constructor\n   *  @extends p5.Filter\n   */\n\n\n  p5.LowPass = function () {\n    p5.Filter.call(this, 'lowpass');\n  };\n\n  p5.LowPass.prototype = Object.create(p5.Filter.prototype);\n  /**\n   *  Constructor: <code>new p5.HighPass()</code> Filter.\n   *  This is the same as creating a p5.Filter and then calling\n   *  its method <code>setType('highpass')</code>.\n   *  See p5.Filter for methods.\n   *\n   *  @class p5.HighPass\n   *  @constructor\n   *  @extends p5.Filter\n   */\n\n  p5.HighPass = function () {\n    p5.Filter.call(this, 'highpass');\n  };\n\n  p5.HighPass.prototype = Object.create(p5.Filter.prototype);\n  /**\n   *  Constructor: <code>new p5.BandPass()</code> Filter.\n   *  This is the same as creating a p5.Filter and then calling\n   *  its method <code>setType('bandpass')</code>.\n   *  See p5.Filter for methods.\n   *\n   *  @class p5.BandPass\n   *  @constructor\n   *  @extends p5.Filter\n   */\n\n  p5.BandPass = function () {\n    p5.Filter.call(this, 'bandpass');\n  };\n\n  p5.BandPass.prototype = Object.create(p5.Filter.prototype);\n  return p5.Filter;\n}).call(exports, __nested_webpack_require_48906__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_58389__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_58389__(0),__nested_webpack_require_58389__(7),__nested_webpack_require_58389__(25),__nested_webpack_require_58389__(2),__nested_webpack_require_58389__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(n){\"use strict\";return n.Subtract=function(t){this.createInsOuts(2,0),this._sum=this.input[0]=this.output=new n.Gain,this._neg=new n.Negate,this._param=this.input[1]=new n.Signal(t),this._param.chain(this._neg,this._sum)},n.extend(n.Subtract,n.Signal),n.Subtract.prototype.dispose=function(){return n.prototype.dispose.call(this),this._neg.dispose(),this._neg=null,this._sum.disconnect(),this._sum=null,this._param.dispose(),this._param=null,this},n.Subtract}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_59314__) {\n\n\"use strict\";\n(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nglobal.TONE_SILENCE_VERSION_LOGGING = true;\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_59314__(35), __nested_webpack_require_59314__(12), __nested_webpack_require_59314__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (StartAudioContext, Context, Tone) {\n  var audiocontext = new window.AudioContext(); \n\n  Tone.context.dispose();\n  Tone.setContext(audiocontext);\n  /**\n   * <p>Returns the Audio Context for this sketch. Useful for users\n   * who would like to dig deeper into the <a target='_blank' href=\n   * 'http://webaudio.github.io/web-audio-api/'>Web Audio API\n   * </a>.</p>\n   *\n   * <p>Some browsers require users to startAudioContext\n   * with a user gesture, such as touchStarted in the example below.</p>\n   *\n   * @for p5\n   * @method getAudioContext\n   * @return {Object}    AudioContext for this sketch\n   * @example\n   * <div><code>\n   *  function draw() {\n   *    background(255);\n   *    textAlign(CENTER);\n   *\n   *    if (getAudioContext().state !== 'running') {\n   *      text('click to start audio', width/2, height/2);\n   *    } else {\n   *      text('audio is enabled', width/2, height/2);\n   *    }\n   *  }\n   *\n   *  function touchStarted() {\n   *    if (getAudioContext().state !== 'running') {\n   *      getAudioContext().resume();\n   *    }\n   *    var synth = new p5.MonoSynth();\n   *    synth.play('A4', 0.5, 0, 0.2);\n   *  }\n   *\n   * </div></code>\n   */\n\n  p5.prototype.getAudioContext = function () {\n    return audiocontext;\n  };\n  /**\n   *  <p>It is not only a good practice to give users control over starting\n   *  audio. This policy is enforced by many web browsers, including iOS and\n   *  <a href=\"https://goo.gl/7K7WLu\" title=\"Google Chrome's autoplay\n   *  policy\">Google Chrome</a>, which create the Web Audio API's\n   *  <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/AudioContext\"\n   *  title=\"Audio Context @ MDN\">Audio Context</a>\n   *  in a suspended state.</p>\n   *\n   *  <p>In these browser-specific policies, sound will not play until a user\n   *  interaction event (i.e. <code>mousePressed()</code>) explicitly resumes\n   *  the AudioContext, or starts an audio node. This can be accomplished by\n   *  calling <code>start()</code> on a <code>p5.Oscillator</code>,\n   *  <code> play()</code> on a <code>p5.SoundFile</code>, or simply\n   *  <code>userStartAudio()</code>.</p>\n   *\n   *  <p><code>userStartAudio()</code> starts the AudioContext on a user\n   *  gesture. The default behavior will enable audio on any\n   *  mouseUp or touchEnd event. It can also be placed in a specific\n   *  interaction function, such as <code>mousePressed()</code> as in the\n   *  example below. This method utilizes\n   *  <a href=\"https://github.com/tambien/StartAudioContext\">StartAudioContext\n   *  </a>, a library by Yotam Mann (MIT Licence, 2016).</p>\n   *  @param  {Element|Array}   [element(s)] This argument can be an Element,\n   *                                Selector String, NodeList, p5.Element,\n   *                                jQuery Element, or an Array of any of those.\n   *  @param  {Function} [callback] Callback to invoke when the AudioContext\n   *                                has started\n   *  @return {Promise}            Returns a Promise that resolves when\n   *                                       the AudioContext state is 'running'\n   *  @method userStartAudio\n   *  @for p5\n   *  @example\n   *  <div><code>\n   *  function setup() {\n   *    // mimics the autoplay policy\n   *    getAudioContext().suspend();\n   *\n   *    let mySynth = new p5.MonoSynth();\n   *\n   *    // This won't play until the context has resumed\n   *    mySynth.play('A6');\n   *  }\n   *  function draw() {\n   *    background(220);\n   *    textAlign(CENTER, CENTER);\n   *    text(getAudioContext().state, width/2, height/2);\n   *  }\n   *  function mousePressed() {\n   *    userStartAudio();\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.prototype.userStartAudio = function (elements, callback) {\n    var elt = elements;\n\n    if (elements instanceof p5.Element) {\n      elt = elements.elt;\n    } else if (elements instanceof Array && elements[0] instanceof p5.Element) {\n      elt = elements.map(function (e) {\n        return e.elt;\n      });\n    }\n\n    return StartAudioContext(audiocontext, elt, callback);\n  };\n\n  return audiocontext;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}.call(this, __nested_webpack_require_59314__(34)))\n\n }),\n (function(module, exports, __nested_webpack_require_63921__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_63921__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(o){\"use strict\";return o.Emitter=function(){this._events={}},o.extend(o.Emitter),o.Emitter.prototype.on=function(t,e){for(var i=t.split(/\\W+/),r=0;r<i.length;r++){var n=i[r];this._events.hasOwnProperty(n)||(this._events[n]=[]),this._events[n].push(e)}return this},o.Emitter.prototype.off=function(t,e){for(var i=t.split(/\\W+/),r=0;r<i.length;r++)if(t=i[r],this._events.hasOwnProperty(t))if(o.prototype.isUndef(e))this._events[t]=[];else for(var n=this._events[t],s=0;s<n.length;s++)n[s]===e&&n.splice(s,1);return this},o.Emitter.prototype.emit=function(t){if(this._events){var e=Array.apply(null,arguments).slice(1);if(this._events.hasOwnProperty(t))for(var i=this._events[t],r=0,n=i.length;r<n;r++)i[r].apply(this,e)}return this},o.Emitter.mixin=function(t){var e=[\"on\",\"off\",\"emit\"];t._events={};for(var i=0;i<e.length;i++){var r=e[i],n=o.Emitter.prototype[r];t[r]=n}},o.Emitter.prototype.dispose=function(){return o.prototype.dispose.call(this),this._events=null,this},o.Emitter}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_65276__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_65276__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(c){\"use strict\";return c.SignalBase=function(){},c.extend(c.SignalBase),c.SignalBase.prototype.connect=function(e,n,a){return c.Signal&&c.Signal===e.constructor||c.Param&&c.Param===e.constructor||c.TimelineSignal&&c.TimelineSignal===e.constructor?(e._param.cancelScheduledValues(0),e._param.value=0,e.overridden=!0):e instanceof AudioParam&&(e.cancelScheduledValues(0),e.value=0),c.prototype.connect.call(this,e,n,a),this},c.SignalBase}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_66085__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_66085__(0),__nested_webpack_require_66085__(21)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(o){return o.Time=function(t,e){if(!(this instanceof o.Time))return new o.Time(t,e);this._plusNow=!1,o.TimeBase.call(this,t,e)},o.extend(o.Time,o.TimeBase),o.Time.prototype._unaryExpressions=Object.create(o.TimeBase.prototype._unaryExpressions),o.Time.prototype._unaryExpressions.quantize={regexp:/^@/,method:function(t){return o.Transport.nextSubdivision(t())}},o.Time.prototype._unaryExpressions.now={regexp:/^\\+/,method:function(t){return this._plusNow=!0,t()}},o.Time.prototype.quantize=function(t,e){return e=this.defaultArg(e,1),this._expr=function(t,e,o){return t=t(),e=e.toSeconds(),t+(Math.round(t/e)*e-t)*o}.bind(this,this._expr,new this.constructor(t),e),this},o.Time.prototype.addNow=function(){return this._plusNow=!0,this},o.Time.prototype._defaultExpr=function(){return this._plusNow=!0,this._noOp},o.Time.prototype.copy=function(t){return o.TimeBase.prototype.copy.call(this,t),this._plusNow=t._plusNow,this},o.Time.prototype.toNotation=function(){var t=this.toSeconds(),e=this._toNotationHelper(t,[\"1m\",\"2n\",\"4n\",\"8n\",\"16n\",\"32n\",\"64n\",\"128n\"]),o=this._toNotationHelper(t,[\"1m\",\"2n\",\"2t\",\"4n\",\"4t\",\"8n\",\"8t\",\"16n\",\"16t\",\"32n\",\"32t\",\"64n\",\"64t\",\"128n\"]);return o.split(\"+\").length<e.split(\"+\").length?o:e},o.Time.prototype._toNotationHelper=function(t,e){for(var o=this._notationToUnits(e[e.length-1]),n=\"\",i=0;i<e.length;i++){var r=this._notationToUnits(e[i]),s=t/r;if(1-s%1<1e-6&&(s+=1e-6),0<(s=Math.floor(s))){if(n+=1===s?e[i]:s.toString()+\"*\"+e[i],(t-=s*r)<o)break;n+=\" + \"}}return\"\"===n&&(n=\"0\"),n},o.Time.prototype._notationToUnits=function(t){for(var e=this._primaryExpressions,o=[e.n,e.t,e.m],n=0;n<o.length;n++){var i=o[n],r=t.match(i.regexp);if(r)return i.method.call(this,r[1])}},o.Time.prototype.toBarsBeatsSixteenths=function(){var t=this._beatsToUnits(1),e=this.toSeconds()/t,o=Math.floor(e/this._timeSignature()),n=e%1*4;return e=Math.floor(e)%this._timeSignature(),3<(n=n.toString()).length&&(n=parseFloat(n).toFixed(3)),[o,e,n].join(\":\")},o.Time.prototype.toTicks=function(){var t=this._beatsToUnits(1),e=this.valueOf()/t;return Math.floor(e*o.Transport.PPQ)},o.Time.prototype.toSamples=function(){return this.toSeconds()*this.context.sampleRate},o.Time.prototype.toFrequency=function(){return 1/this.toSeconds()},o.Time.prototype.toSeconds=function(){return this.valueOf()},o.Time.prototype.toMilliseconds=function(){return 1e3*this.toSeconds()},o.Time.prototype.valueOf=function(){return this._expr()+(this._plusNow?this.now():0)},o.Time}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_68954__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_68954__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(n){return n.TimeBase=function(e,t){if(!(this instanceof n.TimeBase))return new n.TimeBase(e,t);if(this._expr=this._noOp,e instanceof n.TimeBase)this.copy(e);else if(!this.isUndef(t)||this.isNumber(e)){t=this.defaultArg(t,this._defaultUnits);var r=this._primaryExpressions[t].method;this._expr=r.bind(this,e)}else this.isString(e)?this.set(e):this.isUndef(e)&&(this._expr=this._defaultExpr())},n.extend(n.TimeBase),n.TimeBase.prototype.set=function(e){return this._expr=this._parseExprString(e),this},n.TimeBase.prototype.clone=function(){var e=new this.constructor;return e.copy(this),e},n.TimeBase.prototype.copy=function(e){var t=e._expr();return this.set(t)},n.TimeBase.prototype._primaryExpressions={n:{regexp:/^(\\d+)n/i,method:function(e){return 1===(e=parseInt(e))?this._beatsToUnits(this._timeSignature()):this._beatsToUnits(4/e)}},t:{regexp:/^(\\d+)t/i,method:function(e){return e=parseInt(e),this._beatsToUnits(8/(3*parseInt(e)))}},m:{regexp:/^(\\d+)m/i,method:function(e){return this._beatsToUnits(parseInt(e)*this._timeSignature())}},i:{regexp:/^(\\d+)i/i,method:function(e){return this._ticksToUnits(parseInt(e))}},hz:{regexp:/^(\\d+(?:\\.\\d+)?)hz/i,method:function(e){return this._frequencyToUnits(parseFloat(e))}},tr:{regexp:/^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,method:function(e,t,r){var n=0;return e&&\"0\"!==e&&(n+=this._beatsToUnits(this._timeSignature()*parseFloat(e))),t&&\"0\"!==t&&(n+=this._beatsToUnits(parseFloat(t))),r&&\"0\"!==r&&(n+=this._beatsToUnits(parseFloat(r)/4)),n}},s:{regexp:/^(\\d+(?:\\.\\d+)?s)/,method:function(e){return this._secondsToUnits(parseFloat(e))}},samples:{regexp:/^(\\d+)samples/,method:function(e){return parseInt(e)/this.context.sampleRate}},default:{regexp:/^(\\d+(?:\\.\\d+)?)/,method:function(e){return this._primaryExpressions[this._defaultUnits].method.call(this,e)}}},n.TimeBase.prototype._binaryExpressions={\"+\":{regexp:/^\\+/,precedence:2,method:function(e,t){return e()+t()}},\"-\":{regexp:/^\\-/,precedence:2,method:function(e,t){return e()-t()}},\"*\":{regexp:/^\\*/,precedence:1,method:function(e,t){return e()*t()}},\"/\":{regexp:/^\\//,precedence:1,method:function(e,t){return e()/t()}}},n.TimeBase.prototype._unaryExpressions={neg:{regexp:/^\\-/,method:function(e){return-e()}}},n.TimeBase.prototype._syntaxGlue={\"(\":{regexp:/^\\(/},\")\":{regexp:/^\\)/}},n.TimeBase.prototype._tokenize=function(e){for(var t=-1,r=[];0<e.length;){var n=i(e=e.trim(),this);r.push(n),e=e.substr(n.value.length)}function i(e,t){for(var r=[\"_binaryExpressions\",\"_unaryExpressions\",\"_primaryExpressions\",\"_syntaxGlue\"],n=0;n<r.length;n++){var i=t[r[n]];for(var s in i){var o=i[s],p=o.regexp,a=e.match(p);if(null!==a)return{method:o.method,precedence:o.precedence,regexp:o.regexp,value:a[0]}}}throw new SyntaxError(\"Tone.TimeBase: Unexpected token \"+e)}return{next:function(){return r[++t]},peek:function(){return r[t+1]}}},n.TimeBase.prototype._matchGroup=function(e,t,r){if(!this.isUndef(e))for(var n in t){var i=t[n];if(i.regexp.test(e.value)){if(this.isUndef(r))return i;if(i.precedence===r)return i}}return!1},n.TimeBase.prototype._parseBinary=function(e,t){var r;this.isUndef(t)&&(t=2),r=t<0?this._parseUnary(e):this._parseBinary(e,t-1);for(var n=e.peek();n&&this._matchGroup(n,this._binaryExpressions,t);)r=(n=e.next()).method.bind(this,r,this._parseBinary(e,t-1)),n=e.peek();return r},n.TimeBase.prototype._parseUnary=function(e){var t,r;t=e.peek();var n=this._matchGroup(t,this._unaryExpressions);return n?(t=e.next(),r=this._parseUnary(e),n.method.bind(this,r)):this._parsePrimary(e)},n.TimeBase.prototype._parsePrimary=function(e){var t,r;if(t=e.peek(),this.isUndef(t))throw new SyntaxError(\"Tone.TimeBase: Unexpected end of expression\");if(this._matchGroup(t,this._primaryExpressions)){var n=(t=e.next()).value.match(t.regexp);return t.method.bind(this,n[1],n[2],n[3])}if(t&&\"(\"===t.value){if(e.next(),r=this._parseBinary(e),!(t=e.next())||\")\"!==t.value)throw new SyntaxError(\"Expected )\");return r}throw new SyntaxError(\"Tone.TimeBase: Cannot process token \"+t.value)},n.TimeBase.prototype._parseExprString=function(e){this.isString(e)||(e=e.toString());var t=this._tokenize(e);return this._parseBinary(t)},n.TimeBase.prototype._noOp=function(){return 0},n.TimeBase.prototype._defaultExpr=function(){return this._noOp},n.TimeBase.prototype._defaultUnits=\"s\",n.TimeBase.prototype._frequencyToUnits=function(e){return 1/e},n.TimeBase.prototype._beatsToUnits=function(e){return 60/n.Transport.bpm.value*e},n.TimeBase.prototype._secondsToUnits=function(e){return e},n.TimeBase.prototype._ticksToUnits=function(e){return e*(this._beatsToUnits(1)/n.Transport.PPQ)},n.TimeBase.prototype._timeSignature=function(){return n.Transport.timeSignature},n.TimeBase.prototype._pushExpr=function(e,t,r){return e instanceof n.TimeBase||(e=new this.constructor(e,r)),this._expr=this._binaryExpressions[t].method.bind(this,this._expr,e._expr),this},n.TimeBase.prototype.add=function(e,t){return this._pushExpr(e,\"+\",t)},n.TimeBase.prototype.sub=function(e,t){return this._pushExpr(e,\"-\",t)},n.TimeBase.prototype.mult=function(e,t){return this._pushExpr(e,\"*\",t)},n.TimeBase.prototype.div=function(e,t){return this._pushExpr(e,\"/\",t)},n.TimeBase.prototype.valueOf=function(){return this._expr()},n.TimeBase.prototype.dispose=function(){this._expr=null},n.TimeBase}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_74612__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_74612__(0),__nested_webpack_require_74612__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(a){\"use strict\";return a.Param=function(){var t=this.optionsObject(arguments,[\"param\",\"units\",\"convert\"],a.Param.defaults);this._param=this.input=t.param,this.units=t.units,this.convert=t.convert,this.overridden=!1,this._lfo=null,this.isObject(t.lfo)?this.value=t.lfo:this.isUndef(t.value)||(this.value=t.value)},a.extend(a.Param),a.Param.defaults={units:a.Type.Default,convert:!0,param:void 0},Object.defineProperty(a.Param.prototype,\"value\",{get:function(){return this._toUnits(this._param.value)},set:function(t){if(this.isObject(t)){if(this.isUndef(a.LFO))throw new Error(\"Include 'Tone.LFO' to use an LFO as a Param value.\");this._lfo&&this._lfo.dispose(),this._lfo=new a.LFO(t).start(),this._lfo.connect(this.input)}else{var e=this._fromUnits(t);this._param.cancelScheduledValues(0),this._param.value=e}}}),a.Param.prototype._fromUnits=function(t){if(!this.convert&&!this.isUndef(this.convert))return t;switch(this.units){case a.Type.Time:return this.toSeconds(t);case a.Type.Frequency:return this.toFrequency(t);case a.Type.Decibels:return this.dbToGain(t);case a.Type.NormalRange:return Math.min(Math.max(t,0),1);case a.Type.AudioRange:return Math.min(Math.max(t,-1),1);case a.Type.Positive:return Math.max(t,0);default:return t}},a.Param.prototype._toUnits=function(t){if(!this.convert&&!this.isUndef(this.convert))return t;switch(this.units){case a.Type.Decibels:return this.gainToDb(t);default:return t}},a.Param.prototype._minOutput=1e-5,a.Param.prototype.setValueAtTime=function(t,e){return t=this._fromUnits(t),(e=this.toSeconds(e))<=this.now()+this.blockTime?this._param.value=t:this._param.setValueAtTime(t,e),this},a.Param.prototype.setRampPoint=function(t){t=this.defaultArg(t,this.now());var e=this._param.value;return 0===e&&(e=this._minOutput),this._param.setValueAtTime(e,t),this},a.Param.prototype.linearRampToValueAtTime=function(t,e){return t=this._fromUnits(t),this._param.linearRampToValueAtTime(t,this.toSeconds(e)),this},a.Param.prototype.exponentialRampToValueAtTime=function(t,e){return t=this._fromUnits(t),t=Math.max(this._minOutput,t),this._param.exponentialRampToValueAtTime(t,this.toSeconds(e)),this},a.Param.prototype.exponentialRampToValue=function(t,e,i){return i=this.toSeconds(i),this.setRampPoint(i),this.exponentialRampToValueAtTime(t,i+this.toSeconds(e)),this},a.Param.prototype.linearRampToValue=function(t,e,i){return i=this.toSeconds(i),this.setRampPoint(i),this.linearRampToValueAtTime(t,i+this.toSeconds(e)),this},a.Param.prototype.setTargetAtTime=function(t,e,i){return t=this._fromUnits(t),t=Math.max(this._minOutput,t),i=Math.max(this._minOutput,i),this._param.setTargetAtTime(t,this.toSeconds(e),i),this},a.Param.prototype.setValueCurveAtTime=function(t,e,i){for(var a=0;a<t.length;a++)t[a]=this._fromUnits(t[a]);return this._param.setValueCurveAtTime(t,this.toSeconds(e),this.toSeconds(i)),this},a.Param.prototype.cancelScheduledValues=function(t){return this._param.cancelScheduledValues(this.toSeconds(t)),this},a.Param.prototype.rampTo=function(t,e,i){return e=this.defaultArg(e,0),this.units===a.Type.Frequency||this.units===a.Type.BPM||this.units===a.Type.Decibels?this.exponentialRampToValue(t,e,i):this.linearRampToValue(t,e,i),this},Object.defineProperty(a.Param.prototype,\"lfo\",{get:function(){return this._lfo}}),a.Param.prototype.dispose=function(){return a.prototype.dispose.call(this),this._param=null,this._lfo&&(this._lfo.dispose(),this._lfo=null),this},a.Param}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_78439__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_78439__(1);\n\n  var Add = __nested_webpack_require_78439__(7);\n\n  var Mult = __nested_webpack_require_78439__(3);\n\n  var Scale = __nested_webpack_require_78439__(13);\n  /**\n   *  <p>Creates a signal that oscillates between -1.0 and 1.0.\n   *  By default, the oscillation takes the form of a sinusoidal\n   *  shape ('sine'). Additional types include 'triangle',\n   *  'sawtooth' and 'square'. The frequency defaults to\n   *  440 oscillations per second (440Hz, equal to the pitch of an\n   *  'A' note).</p>\n   *\n   *  <p>Set the type of oscillation with setType(), or by instantiating a\n   *  specific oscillator: <a href=\"/reference/#/p5.SinOsc\">p5.SinOsc</a>, <a\n   *  href=\"/reference/#/p5.TriOsc\">p5.TriOsc</a>, <a\n   *  href=\"/reference/#/p5.SqrOsc\">p5.SqrOsc</a>, or <a\n   *  href=\"/reference/#/p5.SawOsc\">p5.SawOsc</a>.\n   *  </p>\n   *\n   *  @class p5.Oscillator\n   *  @constructor\n   *  @param {Number} [freq] frequency defaults to 440Hz\n   *  @param {String} [type] type of oscillator. Options:\n   *                         'sine' (default), 'triangle',\n   *                         'sawtooth', 'square'\n   *  @example\n   *  <div><code>\n   *  let osc, playing, freq, amp;\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(playOscillator);\n   *    osc = new p5.Oscillator('sine');\n   *  }\n   *\n   *  function draw() {\n   *    background(220)\n   *    freq = constrain(map(mouseX, 0, width, 100, 500), 100, 500);\n   *    amp = constrain(map(mouseY, height, 0, 0, 1), 0, 1);\n   *\n   *    text('tap to play', 20, 20);\n   *    text('freq: ' + freq, 20, 40);\n   *    text('amp: ' + amp, 20, 60);\n   *\n   *    if (playing) {\n   *      // smooth the transitions by 0.1 seconds\n   *      osc.freq(freq, 0.1);\n   *      osc.amp(amp, 0.1);\n   *    }\n   *  }\n   *\n   *  function playOscillator() {\n   *    // starting an oscillator on a user gesture will enable audio\n   *    // in browsers that have a strict autoplay policy.\n   *    // See also: userStartAudio();\n   *    osc.start();\n   *    playing = true;\n   *  }\n   *\n   *  function mouseReleased() {\n   *    // ramp amplitude to 0 over 0.5 seconds\n   *    osc.amp(0, 0.5);\n   *    playing = false;\n   *  }\n   *  </code> </div>\n   */\n\n\n  p5.Oscillator = function (freq, type) {\n    if (typeof freq === 'string') {\n      var f = type;\n      type = freq;\n      freq = f;\n    }\n\n    if (typeof type === 'number') {\n      var f = type;\n      type = freq;\n      freq = f;\n    }\n\n    this.started = false; \n\n    this.phaseAmount = undefined;\n    this.oscillator = p5sound.audiocontext.createOscillator();\n    this.f = freq || 440.0; \n\n    this.oscillator.type = type || 'sine';\n    this.oscillator.frequency.setValueAtTime(this.f, p5sound.audiocontext.currentTime); \n\n    this.output = p5sound.audiocontext.createGain();\n    this._freqMods = []; \n\n    this.output.gain.value = 0.5;\n    this.output.gain.setValueAtTime(0.5, p5sound.audiocontext.currentTime);\n    this.oscillator.connect(this.output); \n\n    this.panPosition = 0.0;\n    this.connection = p5sound.input; \n\n    this.panner = new p5.Panner(this.output, this.connection, 1); \n\n    this.mathOps = [this.output]; \n\n    p5sound.soundArray.push(this);\n  };\n  /**\n   *  Start an oscillator.\n   *\n   *  Starting an oscillator on a user gesture will enable audio in browsers\n   *  that have a strict autoplay policy, including Chrome and most mobile\n   *  devices. See also: `userStartAudio()`.\n   *\n   *  @method  start\n   *  @for p5.Oscillator\n   *  @param  {Number} [time] startTime in seconds from now.\n   *  @param  {Number} [frequency] frequency in Hz.\n   */\n\n\n  p5.Oscillator.prototype.start = function (time, f) {\n    if (this.started) {\n      var now = p5sound.audiocontext.currentTime;\n      this.stop(now);\n    }\n\n    if (!this.started) {\n      var freq = f || this.f;\n      var type = this.oscillator.type; \n\n      if (this.oscillator) {\n        this.oscillator.disconnect();\n        delete this.oscillator;\n      } \n\n\n      this.oscillator = p5sound.audiocontext.createOscillator();\n      this.oscillator.frequency.value = Math.abs(freq);\n      this.oscillator.type = type; \n\n      this.oscillator.connect(this.output);\n      time = time || 0;\n      this.oscillator.start(time + p5sound.audiocontext.currentTime);\n      this.freqNode = this.oscillator.frequency; \n\n      for (var i in this._freqMods) {\n        if (typeof this._freqMods[i].connect !== 'undefined') {\n          this._freqMods[i].connect(this.oscillator.frequency);\n        }\n      }\n\n      this.started = true;\n    }\n  };\n  /**\n   *  Stop an oscillator. Accepts an optional parameter\n   *  to determine how long (in seconds from now) until the\n   *  oscillator stops.\n   *\n   *  @method  stop\n   *  @for p5.Oscillator\n   *  @param  {Number} secondsFromNow Time, in seconds from now.\n   */\n\n\n  p5.Oscillator.prototype.stop = function (time) {\n    if (this.started) {\n      var t = time || 0;\n      var now = p5sound.audiocontext.currentTime;\n      this.oscillator.stop(t + now);\n      this.started = false;\n    }\n  };\n  /**\n   *  Set the amplitude between 0 and 1.0. Or, pass in an object\n   *  such as an oscillator to modulate amplitude with an audio signal.\n   *\n   *  @method  amp\n   *  @for p5.Oscillator\n   *  @param  {Number|Object} vol between 0 and 1.0\n   *                              or a modulating signal/oscillator\n   *  @param {Number} [rampTime] create a fade that lasts rampTime\n   *  @param {Number} [timeFromNow] schedule this event to happen\n   *                                seconds from now\n   *  @return  {AudioParam} gain  If no value is provided,\n   *                              returns the Web Audio API\n   *                              AudioParam that controls\n   *                              this oscillator's\n   *                              gain/amplitude/volume)\n   */\n\n\n  p5.Oscillator.prototype.amp = function (vol, rampTime, tFromNow) {\n    var self = this;\n\n    if (typeof vol === 'number') {\n      var rampTime = rampTime || 0;\n      var tFromNow = tFromNow || 0;\n      var now = p5sound.audiocontext.currentTime;\n      this.output.gain.linearRampToValueAtTime(vol, now + tFromNow + rampTime);\n    } else if (vol) {\n      vol.connect(self.output.gain);\n    } else {\n      return this.output.gain;\n    }\n  }; \n\n\n  p5.Oscillator.prototype.fade = p5.Oscillator.prototype.amp;\n\n  p5.Oscillator.prototype.getAmp = function () {\n    return this.output.gain.value;\n  };\n  /**\n   *  Set frequency of an oscillator to a value. Or, pass in an object\n   *  such as an oscillator to modulate the frequency with an audio signal.\n   *\n   *  @method  freq\n   *  @for p5.Oscillator\n   *  @param  {Number|Object} Frequency Frequency in Hz\n   *                                        or modulating signal/oscillator\n   *  @param  {Number} [rampTime] Ramp time (in seconds)\n   *  @param  {Number} [timeFromNow] Schedule this event to happen\n   *                                   at x seconds from now\n   *  @return  {AudioParam} Frequency If no value is provided,\n   *                                  returns the Web Audio API\n   *                                  AudioParam that controls\n   *                                  this oscillator's frequency\n   *  @example\n   *  <div><code>\n   *  let osc;\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(playOscillator);\n   *    osc = new p5.Oscillator(300);\n   *    background(220);\n   *    text('tap to play', 20, 20);\n   *  }\n   *\n   *  function playOscillator() {\n   *    osc.start();\n   *    osc.amp(0.5);\n   *    // start at 700Hz\n   *    osc.freq(700);\n   *    // ramp to 60Hz over 0.7 seconds\n   *    osc.freq(60, 0.7);\n   *    osc.amp(0, 0.1, 0.7);\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.Oscillator.prototype.freq = function (val, rampTime, tFromNow) {\n    if (typeof val === 'number' && !isNaN(val)) {\n      this.f = val;\n      var now = p5sound.audiocontext.currentTime;\n      var rampTime = rampTime || 0;\n      var tFromNow = tFromNow || 0;\n      var t = now + tFromNow + rampTime; \n\n      if (rampTime === 0) {\n        this.oscillator.frequency.setValueAtTime(val, tFromNow + now);\n      } else {\n        if (val > 0) {\n          this.oscillator.frequency.exponentialRampToValueAtTime(val, tFromNow + rampTime + now);\n        } else {\n          this.oscillator.frequency.linearRampToValueAtTime(val, tFromNow + rampTime + now);\n        }\n      } \n\n\n      if (this.phaseAmount) {\n        this.phase(this.phaseAmount);\n      }\n    } else if (val) {\n      if (val.output) {\n        val = val.output;\n      }\n\n      val.connect(this.oscillator.frequency); \n\n      this._freqMods.push(val);\n    } else {\n      return this.oscillator.frequency;\n    }\n  };\n\n  p5.Oscillator.prototype.getFreq = function () {\n    return this.oscillator.frequency.value;\n  };\n  /**\n   *  Set type to 'sine', 'triangle', 'sawtooth' or 'square'.\n   *\n   *  @method  setType\n   *  @for p5.Oscillator\n   *  @param {String} type 'sine', 'triangle', 'sawtooth' or 'square'.\n   */\n\n\n  p5.Oscillator.prototype.setType = function (type) {\n    this.oscillator.type = type;\n  };\n\n  p5.Oscillator.prototype.getType = function () {\n    return this.oscillator.type;\n  };\n  /**\n   *  Connect to a p5.sound / Web Audio object.\n   *\n   *  @method  connect\n   *  @for p5.Oscillator\n   *  @param  {Object} unit A p5.sound or Web Audio object\n   */\n\n\n  p5.Oscillator.prototype.connect = function (unit) {\n    if (!unit) {\n      this.panner.connect(p5sound.input);\n    } else if (unit.hasOwnProperty('input')) {\n      this.panner.connect(unit.input);\n      this.connection = unit.input;\n    } else {\n      this.panner.connect(unit);\n      this.connection = unit;\n    }\n  };\n  /**\n   *  Disconnect all outputs\n   *\n   *  @method  disconnect\n   *  @for p5.Oscillator\n   */\n\n\n  p5.Oscillator.prototype.disconnect = function () {\n    if (this.output) {\n      this.output.disconnect();\n    }\n\n    if (this.panner) {\n      this.panner.disconnect();\n\n      if (this.output) {\n        this.output.connect(this.panner);\n      }\n    }\n\n    this.oscMods = [];\n  };\n  /**\n   *  Pan between Left (-1) and Right (1)\n   *\n   *  @method  pan\n   *  @for p5.Oscillator\n   *  @param  {Number} panning Number between -1 and 1\n   *  @param  {Number} timeFromNow schedule this event to happen\n   *                                seconds from now\n   */\n\n\n  p5.Oscillator.prototype.pan = function (pval, tFromNow) {\n    this.panPosition = pval;\n    this.panner.pan(pval, tFromNow);\n  };\n\n  p5.Oscillator.prototype.getPan = function () {\n    return this.panPosition;\n  }; \n\n\n  p5.Oscillator.prototype.dispose = function () {\n    var index = p5sound.soundArray.indexOf(this);\n    p5sound.soundArray.splice(index, 1);\n\n    if (this.oscillator) {\n      var now = p5sound.audiocontext.currentTime;\n      this.stop(now);\n      this.disconnect();\n      this.panner = null;\n      this.oscillator = null;\n    } \n\n\n    if (this.osc2) {\n      this.osc2.dispose();\n    }\n  };\n  /**\n   *  Set the phase of an oscillator between 0.0 and 1.0.\n   *  In this implementation, phase is a delay time\n   *  based on the oscillator's current frequency.\n   *\n   *  @method  phase\n   *  @for p5.Oscillator\n   *  @param  {Number} phase float between 0.0 and 1.0\n   */\n\n\n  p5.Oscillator.prototype.phase = function (p) {\n    var delayAmt = p5.prototype.map(p, 0, 1.0, 0, 1 / this.f);\n    var now = p5sound.audiocontext.currentTime;\n    this.phaseAmount = p;\n\n    if (!this.dNode) {\n      this.dNode = p5sound.audiocontext.createDelay(); \n\n      this.oscillator.disconnect();\n      this.oscillator.connect(this.dNode);\n      this.dNode.connect(this.output);\n    } \n\n\n    this.dNode.delayTime.setValueAtTime(delayAmt, now);\n  }; \n\n\n  var sigChain = function sigChain(o, mathObj, thisChain, nextChain, type) {\n    var chainSource = o.oscillator; \n\n    for (var i in o.mathOps) {\n      if (o.mathOps[i] instanceof type) {\n        chainSource.disconnect();\n        o.mathOps[i].dispose();\n        thisChain = i; \n\n        if (thisChain < o.mathOps.length - 2) {\n          nextChain = o.mathOps[i + 1];\n        }\n      }\n    }\n\n    if (thisChain === o.mathOps.length - 1) {\n      o.mathOps.push(nextChain);\n    } \n\n\n    if (i > 0) {\n      chainSource = o.mathOps[i - 1];\n    }\n\n    chainSource.disconnect();\n    chainSource.connect(mathObj);\n    mathObj.connect(nextChain);\n    o.mathOps[thisChain] = mathObj;\n    return o;\n  };\n  /**\n   *  Add a value to the p5.Oscillator's output amplitude,\n   *  and return the oscillator. Calling this method again\n   *  will override the initial add() with a new value.\n   *\n   *  @method  add\n   *  @for p5.Oscillator\n   *  @param {Number} number Constant number to add\n   *  @return {p5.Oscillator} Oscillator Returns this oscillator\n   *                                     with scaled output\n   *\n   */\n\n\n  p5.Oscillator.prototype.add = function (num) {\n    var add = new Add(num);\n    var thisChain = this.mathOps.length - 1;\n    var nextChain = this.output;\n    return sigChain(this, add, thisChain, nextChain, Add);\n  };\n  /**\n   *  Multiply the p5.Oscillator's output amplitude\n   *  by a fixed value (i.e. turn it up!). Calling this method\n   *  again will override the initial mult() with a new value.\n   *\n   *  @method  mult\n   *  @for p5.Oscillator\n   *  @param {Number} number Constant number to multiply\n   *  @return {p5.Oscillator} Oscillator Returns this oscillator\n   *                                     with multiplied output\n   */\n\n\n  p5.Oscillator.prototype.mult = function (num) {\n    var mult = new Mult(num);\n    var thisChain = this.mathOps.length - 1;\n    var nextChain = this.output;\n    return sigChain(this, mult, thisChain, nextChain, Mult);\n  };\n  /**\n   *  Scale this oscillator's amplitude values to a given\n   *  range, and return the oscillator. Calling this method\n   *  again will override the initial scale() with new values.\n   *\n   *  @method  scale\n   *  @for p5.Oscillator\n   *  @param  {Number} inMin  input range minumum\n   *  @param  {Number} inMax  input range maximum\n   *  @param  {Number} outMin input range minumum\n   *  @param  {Number} outMax input range maximum\n   *  @return {p5.Oscillator} Oscillator Returns this oscillator\n   *                                     with scaled output\n   */\n\n\n  p5.Oscillator.prototype.scale = function (inMin, inMax, outMin, outMax) {\n    var mapOutMin, mapOutMax;\n\n    if (arguments.length === 4) {\n      mapOutMin = p5.prototype.map(outMin, inMin, inMax, 0, 1) - 0.5;\n      mapOutMax = p5.prototype.map(outMax, inMin, inMax, 0, 1) - 0.5;\n    } else {\n      mapOutMin = arguments[0];\n      mapOutMax = arguments[1];\n    }\n\n    var scale = new Scale(mapOutMin, mapOutMax);\n    var thisChain = this.mathOps.length - 1;\n    var nextChain = this.output;\n    return sigChain(this, scale, thisChain, nextChain, Scale); \n  }; \n\n  /**\n   *  Constructor: <code>new p5.SinOsc()</code>.\n   *  This creates a Sine Wave Oscillator and is\n   *  equivalent to <code> new p5.Oscillator('sine')\n   *  </code> or creating a p5.Oscillator and then calling\n   *  its method <code>setType('sine')</code>.\n   *  See p5.Oscillator for methods.\n   *\n   *  @class  p5.SinOsc\n   *  @constructor\n   *  @extends p5.Oscillator\n   *  @param {Number} [freq] Set the frequency\n   */\n\n\n  p5.SinOsc = function (freq) {\n    p5.Oscillator.call(this, freq, 'sine');\n  };\n\n  p5.SinOsc.prototype = Object.create(p5.Oscillator.prototype);\n  /**\n   *  Constructor: <code>new p5.TriOsc()</code>.\n   *  This creates a Triangle Wave Oscillator and is\n   *  equivalent to <code>new p5.Oscillator('triangle')\n   *  </code> or creating a p5.Oscillator and then calling\n   *  its method <code>setType('triangle')</code>.\n   *  See p5.Oscillator for methods.\n   *\n   *  @class  p5.TriOsc\n   *  @constructor\n   *  @extends p5.Oscillator\n   *  @param {Number} [freq] Set the frequency\n   */\n\n  p5.TriOsc = function (freq) {\n    p5.Oscillator.call(this, freq, 'triangle');\n  };\n\n  p5.TriOsc.prototype = Object.create(p5.Oscillator.prototype);\n  /**\n   *  Constructor: <code>new p5.SawOsc()</code>.\n   *  This creates a SawTooth Wave Oscillator and is\n   *  equivalent to <code> new p5.Oscillator('sawtooth')\n   *  </code> or creating a p5.Oscillator and then calling\n   *  its method <code>setType('sawtooth')</code>.\n   *  See p5.Oscillator for methods.\n   *\n   *  @class  p5.SawOsc\n   *  @constructor\n   *  @extends p5.Oscillator\n   *  @param {Number} [freq] Set the frequency\n   */\n\n  p5.SawOsc = function (freq) {\n    p5.Oscillator.call(this, freq, 'sawtooth');\n  };\n\n  p5.SawOsc.prototype = Object.create(p5.Oscillator.prototype);\n  /**\n   *  Constructor: <code>new p5.SqrOsc()</code>.\n   *  This creates a Square Wave Oscillator and is\n   *  equivalent to <code> new p5.Oscillator('square')\n   *  </code> or creating a p5.Oscillator and then calling\n   *  its method <code>setType('square')</code>.\n   *  See p5.Oscillator for methods.\n   *\n   *  @class  p5.SqrOsc\n   *  @constructor\n   *  @extends p5.Oscillator\n   *  @param {Number} [freq] Set the frequency\n   */\n\n  p5.SqrOsc = function (freq) {\n    p5.Oscillator.call(this, freq, 'square');\n  };\n\n  p5.SqrOsc.prototype = Object.create(p5.Oscillator.prototype);\n}).call(exports, __nested_webpack_require_78439__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_95910__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_95910__(0),__nested_webpack_require_95910__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(i){\"use strict\";return i.Timeline=function(){var e=this.optionsObject(arguments,[\"memory\"],i.Timeline.defaults);this._timeline=[],this._toRemove=[],this._iterating=!1,this.memory=e.memory},i.extend(i.Timeline),i.Timeline.defaults={memory:1/0},Object.defineProperty(i.Timeline.prototype,\"length\",{get:function(){return this._timeline.length}}),i.Timeline.prototype.add=function(e){if(this.isUndef(e.time))throw new Error(\"Tone.Timeline: events must have a time attribute\");if(this._timeline.length){var i=this._search(e.time);this._timeline.splice(i+1,0,e)}else this._timeline.push(e);if(this.length>this.memory){var t=this.length-this.memory;this._timeline.splice(0,t)}return this},i.Timeline.prototype.remove=function(e){if(this._iterating)this._toRemove.push(e);else{var i=this._timeline.indexOf(e);-1!==i&&this._timeline.splice(i,1)}return this},i.Timeline.prototype.get=function(e){var i=this._search(e);return-1!==i?this._timeline[i]:null},i.Timeline.prototype.peek=function(){return this._timeline[0]},i.Timeline.prototype.shift=function(){return this._timeline.shift()},i.Timeline.prototype.getAfter=function(e){var i=this._search(e);return i+1<this._timeline.length?this._timeline[i+1]:null},i.Timeline.prototype.getBefore=function(e){var i=this._timeline.length;if(0<i&&this._timeline[i-1].time<e)return this._timeline[i-1];var t=this._search(e);return 0<=t-1?this._timeline[t-1]:null},i.Timeline.prototype.cancel=function(e){if(1<this._timeline.length){var i=this._search(e);if(0<=i)if(this._timeline[i].time===e){for(var t=i;0<=t&&this._timeline[t].time===e;t--)i=t;this._timeline=this._timeline.slice(0,i)}else this._timeline=this._timeline.slice(0,i+1);else this._timeline=[]}else 1===this._timeline.length&&this._timeline[0].time>=e&&(this._timeline=[]);return this},i.Timeline.prototype.cancelBefore=function(e){if(this._timeline.length){var i=this._search(e);0<=i&&(this._timeline=this._timeline.slice(i+1))}return this},i.Timeline.prototype._search=function(e){var i=0,t=this._timeline.length,n=t;if(0<t&&this._timeline[t-1].time<=e)return t-1;for(;i<n;){var r=Math.floor(i+(n-i)/2),s=this._timeline[r],h=this._timeline[r+1];if(s.time===e){for(var l=r;l<this._timeline.length;l++){this._timeline[l].time===e&&(r=l)}return r}if(s.time<e&&h.time>e)return r;s.time>e?n=r:s.time<e&&(i=r+1)}return-1},i.Timeline.prototype._iterate=function(e,i,t){this._iterating=!0,i=this.defaultArg(i,0),t=this.defaultArg(t,this._timeline.length-1);for(var n=i;n<=t;n++)e(this._timeline[n]);if(this._iterating=!1,0<this._toRemove.length){for(var r=0;r<this._toRemove.length;r++){var s=this._timeline.indexOf(this._toRemove[r]);-1!==s&&this._timeline.splice(s,1)}this._toRemove=[]}},i.Timeline.prototype.forEach=function(e){return this._iterate(e),this},i.Timeline.prototype.forEachBefore=function(e,i){var t=this._search(e);return-1!==t&&this._iterate(i,0,t),this},i.Timeline.prototype.forEachAfter=function(e,i){var t=this._search(e);return this._iterate(i,t+1),this},i.Timeline.prototype.forEachFrom=function(e,i){for(var t=this._search(e);0<=t&&this._timeline[t].time>=e;)t--;return this._iterate(i,t+1),this},i.Timeline.prototype.forEachAtTime=function(i,t){var e=this._search(i);return-1!==e&&this._iterate(function(e){e.time===i&&t(e)},0,e),this},i.Timeline.prototype.dispose=function(){i.prototype.dispose.call(this),this._timeline=null,this._toRemove=null},i.Timeline}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_99679__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_99679__(0),__nested_webpack_require_99679__(3),__nested_webpack_require_99679__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(t){\"use strict\";return t.Negate=function(){this._multiply=this.input=this.output=new t.Multiply(-1)},t.extend(t.Negate,t.SignalBase),t.Negate.prototype.dispose=function(){return t.prototype.dispose.call(this),this._multiply.dispose(),this._multiply=null,this},t.Negate}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_100367__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_100367__(0),__nested_webpack_require_100367__(2),__nested_webpack_require_100367__(3),__nested_webpack_require_100367__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(e){\"use strict\";return e.GreaterThanZero=function(){this._thresh=this.output=new e.WaveShaper(function(e){return e<=0?0:1},127),this._scale=this.input=new e.Multiply(1e4),this._scale.connect(this._thresh)},e.extend(e.GreaterThanZero,e.SignalBase),e.GreaterThanZero.prototype.dispose=function(){return e.prototype.dispose.call(this),this._scale.dispose(),this._scale=null,this._thresh.dispose(),this._thresh=null,this},e.GreaterThanZero}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_101245__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_101245__(0),__nested_webpack_require_101245__(14),__nested_webpack_require_101245__(66),__nested_webpack_require_101245__(18),__nested_webpack_require_101245__(12)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(o){\"use strict\";return o.Clock=function(){o.Emitter.call(this);var t=this.optionsObject(arguments,[\"callback\",\"frequency\"],o.Clock.defaults);this.callback=t.callback,this._nextTick=0,this._lastState=o.State.Stopped,this.frequency=new o.TimelineSignal(t.frequency,o.Type.Frequency),this._readOnly(\"frequency\"),this.ticks=0,this._state=new o.TimelineState(o.State.Stopped),this._boundLoop=this._loop.bind(this),this.context.on(\"tick\",this._boundLoop)},o.extend(o.Clock,o.Emitter),o.Clock.defaults={callback:o.noOp,frequency:1,lookAhead:\"auto\"},Object.defineProperty(o.Clock.prototype,\"state\",{get:function(){return this._state.getValueAtTime(this.now())}}),o.Clock.prototype.start=function(t,e){return t=this.toSeconds(t),this._state.getValueAtTime(t)!==o.State.Started&&this._state.add({state:o.State.Started,time:t,offset:e}),this},o.Clock.prototype.stop=function(t){return t=this.toSeconds(t),this._state.cancel(t),this._state.setStateAtTime(o.State.Stopped,t),this},o.Clock.prototype.pause=function(t){return t=this.toSeconds(t),this._state.getValueAtTime(t)===o.State.Started&&this._state.setStateAtTime(o.State.Paused,t),this},o.Clock.prototype._loop=function(){for(var t=this.now()+this.context.lookAhead+this.context.updateInterval+2*this.context.lag;t>this._nextTick&&this._state;){var e=this._state.getValueAtTime(this._nextTick);if(e!==this._lastState){this._lastState=e;var i=this._state.get(this._nextTick);e===o.State.Started?(this._nextTick=i.time,this.isUndef(i.offset)||(this.ticks=i.offset),this.emit(\"start\",i.time,this.ticks)):e===o.State.Stopped?(this.ticks=0,this.emit(\"stop\",i.time)):e===o.State.Paused&&this.emit(\"pause\",i.time)}var s=this._nextTick;this.frequency&&(this._nextTick+=1/this.frequency.getValueAtTime(this._nextTick),e===o.State.Started&&(this.callback(s),this.ticks++))}},o.Clock.prototype.getStateAtTime=function(t){return t=this.toSeconds(t),this._state.getValueAtTime(t)},o.Clock.prototype.dispose=function(){o.Emitter.prototype.dispose.call(this),this.context.off(\"tick\",this._boundLoop),this._writable(\"frequency\"),this.frequency.dispose(),this.frequency=null,this._boundLoop=null,this._nextTick=1/0,this.callback=null,this._state.dispose(),this._state=null},o.Clock}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_103923__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_103923__(1);\n\n  var AudioVoice = __nested_webpack_require_103923__(29);\n\n  var noteToFreq = __nested_webpack_require_103923__(6).noteToFreq;\n\n  var DEFAULT_SUSTAIN = 0.15;\n  /**\n    *  A MonoSynth is used as a single voice for sound synthesis.\n    *  This is a class to be used in conjunction with the PolySynth\n    *  class. Custom synthetisers should be built inheriting from\n    *  this class.\n    *\n    *  @class p5.MonoSynth\n    *  @constructor\n    *  @example\n    *  <div><code>\n    *  let monoSynth;\n    *\n    *  function setup() {\n    *    let cnv = createCanvas(100, 100);\n    *    cnv.mousePressed(playSynth);\n    *    background(220);\n    *    textAlign(CENTER);\n    *    text('tap to play', width/2, height/2);\n    *\n    *    monoSynth = new p5.MonoSynth();\n    *  }\n    *\n    *  function playSynth() {\n    *    userStartAudio();\n    *\n    *    let note = random(['Fb4', 'G4']);\n    *    // note velocity (volume, from 0 to 1)\n    *    let velocity = random();\n    *    // time from now (in seconds)\n    *    let time = 0;\n    *    // note duration (in seconds)\n    *    let dur = 1/6;\n    *\n    *    monoSynth.play(note, velocity, time, dur);\n    *  }\n    *  </code></div>\n    **/\n\n  p5.MonoSynth = function () {\n    AudioVoice.call(this);\n    this.oscillator = new p5.Oscillator();\n    this.env = new p5.Envelope();\n    this.env.setRange(1, 0);\n    this.env.setExp(true); \n\n    this.setADSR(0.02, 0.25, 0.05, 0.35); \n\n    this.oscillator.disconnect();\n    this.oscillator.connect(this.output);\n    this.env.disconnect();\n    this.env.setInput(this.output.gain); \n\n    this.oscillator.output.gain.value = 1.0;\n    this.oscillator.start();\n    this.connect();\n    p5sound.soundArray.push(this);\n  };\n\n  p5.MonoSynth.prototype = Object.create(p5.AudioVoice.prototype);\n  /**\n    *  Play tells the MonoSynth to start playing a note. This method schedules\n    *  the calling of .triggerAttack and .triggerRelease.\n    *\n    *  @method play\n    *  @for p5.MonoSynth\n    *  @param {String | Number} note the note you want to play, specified as a\n    *                                 frequency in Hertz (Number) or as a midi\n    *                                 value in Note/Octave format (\"C4\", \"Eb3\"...etc\")\n    *                                 See <a href = \"https://github.com/Tonejs/Tone.js/wiki/Instruments\">\n    *                                 Tone</a>. Defaults to 440 hz.\n    *  @param  {Number} [velocity] velocity of the note to play (ranging from 0 to 1)\n    *  @param  {Number} [secondsFromNow]  time from now (in seconds) at which to play\n    *  @param  {Number} [sustainTime] time to sustain before releasing the envelope. Defaults to 0.15 seconds.\n    *  @example\n    *  <div><code>\n    *  let monoSynth;\n    *\n    *  function setup() {\n    *    let cnv = createCanvas(100, 100);\n    *    cnv.mousePressed(playSynth);\n    *    background(220);\n    *    textAlign(CENTER);\n    *    text('tap to play', width/2, height/2);\n    *\n    *    monoSynth = new p5.MonoSynth();\n    *  }\n    *\n    *  function playSynth() {\n    *    userStartAudio();\n    *\n    *    let note = random(['Fb4', 'G4']);\n    *    // note velocity (volume, from 0 to 1)\n    *    let velocity = random();\n    *    // time from now (in seconds)\n    *    let time = 0;\n    *    // note duration (in seconds)\n    *    let dur = 1/6;\n    *\n    *    monoSynth.play(note, velocity, time, dur);\n    *  }\n    *  </code></div>\n    *\n    */\n\n  p5.MonoSynth.prototype.play = function (note, velocity, secondsFromNow, susTime) {\n    this.triggerAttack(note, velocity, ~~secondsFromNow);\n    this.triggerRelease(~~secondsFromNow + (susTime || DEFAULT_SUSTAIN));\n  };\n  /**\n     *  Trigger the Attack, and Decay portion of the Envelope.\n     *  Similar to holding down a key on a piano, but it will\n     *  hold the sustain level until you let go.\n     *\n     *  @param {String | Number} note the note you want to play, specified as a\n     *                                 frequency in Hertz (Number) or as a midi\n     *                                 value in Note/Octave format (\"C4\", \"Eb3\"...etc\")\n     *                                 See <a href = \"https://github.com/Tonejs/Tone.js/wiki/Instruments\">\n     *                                 Tone</a>. Defaults to 440 hz\n     *  @param  {Number} [velocity] velocity of the note to play (ranging from 0 to 1)\n     *  @param  {Number} [secondsFromNow]  time from now (in seconds) at which to play\n     *  @method  triggerAttack\n     *  @for p5.MonoSynth\n     *  @example\n     *  <div><code>\n     *  let monoSynth;\n     *\n     *  function setup() {\n     *    let cnv = createCanvas(100, 100);\n     *    cnv.mousePressed(triggerAttack);\n     *    background(220);\n     *    text('tap here for attack, let go to release', 5, 20, width - 20);\n     *    monoSynth = new p5.MonoSynth();\n     *  }\n     *\n     *  function triggerAttack() {\n     *    userStartAudio();\n     *\n     *    monoSynth.triggerAttack(\"E3\");\n     *  }\n     *\n     *  function mouseReleased() {\n     *    monoSynth.triggerRelease();\n     *  }\n     *  </code></div>\n     */\n\n\n  p5.MonoSynth.prototype.triggerAttack = function (note, velocity, secondsFromNow) {\n    var secondsFromNow = ~~secondsFromNow;\n    var freq = noteToFreq(note);\n    var vel = velocity || 0.1;\n    this.oscillator.freq(freq, 0, secondsFromNow);\n    this.env.ramp(this.output.gain, secondsFromNow, vel);\n  };\n  /**\n     *  Trigger the release of the Envelope. This is similar to releasing\n     *  the key on a piano and letting the sound fade according to the\n     *  release level and release time.\n     *\n     *  @param  {Number} secondsFromNow time to trigger the release\n     *  @method  triggerRelease\n     *  @for p5.MonoSynth\n     *  @example\n     *  <div><code>\n     *  let monoSynth;\n     *\n     *  function setup() {\n     *    let cnv = createCanvas(100, 100);\n     *    cnv.mousePressed(triggerAttack);\n     *    background(220);\n     *    text('tap here for attack, let go to release', 5, 20, width - 20);\n     *    monoSynth = new p5.MonoSynth();\n     *  }\n     *\n     *  function triggerAttack() {\n     *    userStartAudio();\n     *\n     *    monoSynth.triggerAttack(\"E3\");\n     *  }\n     *\n     *  function mouseReleased() {\n     *    monoSynth.triggerRelease();\n     *  }\n     *  </code></div>\n     */\n\n\n  p5.MonoSynth.prototype.triggerRelease = function (secondsFromNow) {\n    var secondsFromNow = secondsFromNow || 0;\n    this.env.ramp(this.output.gain, secondsFromNow, 0);\n  };\n  /**\n     *  Set values like a traditional\n     *  <a href=\"https://en.wikipedia.org/wiki/Synthesizer#/media/File:ADSR_parameter.svg\">\n     *  ADSR envelope\n     *  </a>.\n     *\n     *  @method  setADSR\n     *  @for p5.MonoSynth\n     *  @param {Number} attackTime    Time (in seconds before envelope\n     *                                reaches Attack Level\n     *  @param {Number} [decayTime]    Time (in seconds) before envelope\n     *                                reaches Decay/Sustain Level\n     *  @param {Number} [susRatio]    Ratio between attackLevel and releaseLevel, on a scale from 0 to 1,\n     *                                where 1.0 = attackLevel, 0.0 = releaseLevel.\n     *                                The susRatio determines the decayLevel and the level at which the\n     *                                sustain portion of the envelope will sustain.\n     *                                For example, if attackLevel is 0.4, releaseLevel is 0,\n     *                                and susAmt is 0.5, the decayLevel would be 0.2. If attackLevel is\n     *                                increased to 1.0 (using <code>setRange</code>),\n     *                                then decayLevel would increase proportionally, to become 0.5.\n     *  @param {Number} [releaseTime]   Time in seconds from now (defaults to 0)\n     */\n\n\n  p5.MonoSynth.prototype.setADSR = function (attack, decay, sustain, release) {\n    this.env.setADSR(attack, decay, sustain, release);\n  };\n  /**\n   * Getters and Setters\n   * @property {Number} attack\n   * @for p5.MonoSynth\n   */\n\n  /**\n   * @property {Number} decay\n   * @for p5.MonoSynth\n   */\n\n  /**\n   * @property {Number} sustain\n   * @for p5.MonoSynth\n   */\n\n  /**\n   * @property {Number} release\n   * @for p5.MonoSynth\n   */\n\n\n  Object.defineProperties(p5.MonoSynth.prototype, {\n    'attack': {\n      get: function get() {\n        return this.env.aTime;\n      },\n      set: function set(attack) {\n        this.env.setADSR(attack, this.env.dTime, this.env.sPercent, this.env.rTime);\n      }\n    },\n    'decay': {\n      get: function get() {\n        return this.env.dTime;\n      },\n      set: function set(decay) {\n        this.env.setADSR(this.env.aTime, decay, this.env.sPercent, this.env.rTime);\n      }\n    },\n    'sustain': {\n      get: function get() {\n        return this.env.sPercent;\n      },\n      set: function set(sustain) {\n        this.env.setADSR(this.env.aTime, this.env.dTime, sustain, this.env.rTime);\n      }\n    },\n    'release': {\n      get: function get() {\n        return this.env.rTime;\n      },\n      set: function set(release) {\n        this.env.setADSR(this.env.aTime, this.env.dTime, this.env.sPercent, release);\n      }\n    }\n  });\n  /**\n   * MonoSynth amp\n   * @method  amp\n   * @for p5.MonoSynth\n   * @param  {Number} vol      desired volume\n   * @param  {Number} [rampTime] Time to reach new volume\n   * @return {Number}          new volume value\n   */\n\n  p5.MonoSynth.prototype.amp = function (vol, rampTime) {\n    var t = rampTime || 0;\n\n    if (typeof vol !== 'undefined') {\n      this.oscillator.amp(vol, t);\n    }\n\n    return this.oscillator.amp().value;\n  };\n  /**\n   *  Connect to a p5.sound / Web Audio object.\n   *\n   *  @method  connect\n   *  @for p5.MonoSynth\n   *  @param  {Object} unit A p5.sound or Web Audio object\n   */\n\n\n  p5.MonoSynth.prototype.connect = function (unit) {\n    var u = unit || p5sound.input;\n    this.output.connect(u.input ? u.input : u);\n  };\n  /**\n   *  Disconnect all outputs\n   *\n   *  @method  disconnect\n   *  @for p5.MonoSynth\n   */\n\n\n  p5.MonoSynth.prototype.disconnect = function () {\n    if (this.output) {\n      this.output.disconnect();\n    }\n  };\n  /**\n   *  Get rid of the MonoSynth and free up its resources / memory.\n   *\n   *  @method  dispose\n   *  @for p5.MonoSynth\n   */\n\n\n  p5.MonoSynth.prototype.dispose = function () {\n    AudioVoice.prototype.dispose.apply(this);\n\n    if (this.env) {\n      this.env.dispose();\n    }\n\n    if (this.oscillator) {\n      this.oscillator.dispose();\n    }\n  };\n}).call(exports, __nested_webpack_require_103923__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_114750__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  var p5sound = __nested_webpack_require_114750__(1);\n  /**\n   * Base class for monophonic synthesizers. Any extensions of this class\n   * should follow the API and implement the methods below in order to\n   * remain compatible with p5.PolySynth();\n   *\n   * @class p5.AudioVoice\n   * @constructor\n   */\n\n\n  p5.AudioVoice = function () {\n    this.ac = p5sound.audiocontext;\n    this.output = this.ac.createGain();\n    this.connect();\n    p5sound.soundArray.push(this);\n  };\n\n  p5.AudioVoice.prototype.play = function (note, velocity, secondsFromNow, sustime) {};\n\n  p5.AudioVoice.prototype.triggerAttack = function (note, velocity, secondsFromNow) {};\n\n  p5.AudioVoice.prototype.triggerRelease = function (secondsFromNow) {};\n\n  p5.AudioVoice.prototype.amp = function (vol, rampTime) {};\n  /**\n   * Connect to p5 objects or Web Audio Nodes\n   * @method  connect\n   * @for p5.AudioVoice\n   * @param {Object} unit\n   */\n\n\n  p5.AudioVoice.prototype.connect = function (unit) {\n    var u = unit || p5sound.input;\n    this.output.connect(u.input ? u.input : u);\n  };\n  /**\n   * Disconnect from soundOut\n   * @method  disconnect\n   * @for p5.AudioVoice\n   */\n\n\n  p5.AudioVoice.prototype.disconnect = function () {\n    this.output.disconnect();\n  };\n\n  p5.AudioVoice.prototype.dispose = function () {\n    if (this.output) {\n      this.output.disconnect();\n      delete this.output;\n    }\n  };\n\n  return p5.AudioVoice;\n}).call(exports, __nested_webpack_require_114750__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_116462__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_116462__(1);\n\n  var TimelineSignal = __nested_webpack_require_116462__(14);\n\n  var noteToFreq = __nested_webpack_require_116462__(6).noteToFreq;\n  /**\n    *  An AudioVoice is used as a single voice for sound synthesis.\n    *  The PolySynth class holds an array of AudioVoice, and deals\n    *  with voices allocations, with setting notes to be played, and\n    *  parameters to be set.\n    *\n    *  @class p5.PolySynth\n    *  @constructor\n    *\n    *  @param {Number} [synthVoice]   A monophonic synth voice inheriting\n    *                                 the AudioVoice class. Defaults to p5.MonoSynth\n    *  @param {Number} [maxVoices] Number of voices, defaults to 8;\n    *  @example\n    *  <div><code>\n    *  let polySynth;\n    *\n    *  function setup() {\n    *    let cnv = createCanvas(100, 100);\n    *    cnv.mousePressed(playSynth);\n    *    background(220);\n    *    text('click to play', 20, 20);\n    *\n    *    polySynth = new p5.PolySynth();\n    *  }\n    *\n    *  function playSynth() {\n    *    userStartAudio();\n    *\n    *    // note duration (in seconds)\n    *    let dur = 1.5;\n    *\n    *    // time from now (in seconds)\n    *    let time = 0;\n    *\n    *    // velocity (volume, from 0 to 1)\n    *    let vel = 0.1;\n    *\n    *    // notes can overlap with each other\n    *    polySynth.play('G2', vel, 0, dur);\n    *    polySynth.play('C3', vel, time += 1/3, dur);\n    *    polySynth.play('G3', vel, time += 1/3, dur);\n    *  }\n    *  </code></div>\n    **/\n\n\n  p5.PolySynth = function (audioVoice, maxVoices) {\n    this.audiovoices = [];\n    /**\n     * An object that holds information about which notes have been played and\n     * which notes are currently being played. New notes are added as keys\n     * on the fly. While a note has been attacked, but not released, the value of the\n     * key is the audiovoice which is generating that note. When notes are released,\n     * the value of the key becomes undefined.\n     * @property notes\n     */\n\n    this.notes = {}; \n\n    this._newest = 0;\n    this._oldest = 0;\n    /**\n     * A PolySynth must have at least 1 voice, defaults to 8\n     * @property polyvalue\n     */\n\n    this.maxVoices = maxVoices || 8;\n    /**\n     * Monosynth that generates the sound for each note that is triggered. The\n     * p5.PolySynth defaults to using the p5.MonoSynth as its voice.\n     * @property AudioVoice\n     */\n\n    this.AudioVoice = audioVoice === undefined ? p5.MonoSynth : audioVoice;\n    /**\n     * This value must only change as a note is attacked or released. Due to delay\n     * and sustain times, Tone.TimelineSignal is required to schedule the change in value.\n    * @private\n     * @property {Tone.TimelineSignal} _voicesInUse\n     */\n\n    this._voicesInUse = new TimelineSignal(0);\n    this.output = p5sound.audiocontext.createGain();\n    this.connect(); \n\n    this._allocateVoices();\n\n    p5sound.soundArray.push(this);\n  };\n  /**\n   * Construct the appropriate number of audiovoices\n   * @private\n   * @for p5.PolySynth\n   * @method  _allocateVoices\n   */\n\n\n  p5.PolySynth.prototype._allocateVoices = function () {\n    for (var i = 0; i < this.maxVoices; i++) {\n      this.audiovoices.push(new this.AudioVoice());\n      this.audiovoices[i].disconnect();\n      this.audiovoices[i].connect(this.output);\n    }\n  };\n  /**\n   *  Play a note by triggering noteAttack and noteRelease with sustain time\n   *\n   *  @method  play\n   *  @for p5.PolySynth\n   *  @param  {Number} [note] midi note to play (ranging from 0 to 127 - 60 being a middle C)\n   *  @param  {Number} [velocity] velocity of the note to play (ranging from 0 to 1)\n   *  @param  {Number} [secondsFromNow]  time from now (in seconds) at which to play\n   *  @param  {Number} [sustainTime] time to sustain before releasing the envelope\n   *  @example\n   *  <div><code>\n   *  let polySynth;\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(playSynth);\n   *    background(220);\n   *    text('click to play', 20, 20);\n   *\n   *    polySynth = new p5.PolySynth();\n   *  }\n   *\n   *  function playSynth() {\n   *    userStartAudio();\n   *\n   *    // note duration (in seconds)\n   *    let dur = 1.5;\n   *\n   *    // time from now (in seconds)\n   *    let time = 0;\n   *\n   *    // velocity (volume, from 0 to 1)\n   *    let vel = 0.1;\n   *\n   *    // notes can overlap with each other\n   *    polySynth.play('G2', vel, 0, dur);\n   *    polySynth.play('C3', vel, time += 1/3, dur);\n   *    polySynth.play('G3', vel, time += 1/3, dur);\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.PolySynth.prototype.play = function (note, velocity, secondsFromNow, susTime) {\n    var susTime = susTime || 1;\n    this.noteAttack(note, velocity, secondsFromNow);\n    this.noteRelease(note, secondsFromNow + susTime);\n  };\n  /**\n   *  noteADSR sets the envelope for a specific note that has just been triggered.\n   *  Using this method modifies the envelope of whichever audiovoice is being used\n   *  to play the desired note. The envelope should be reset before noteRelease is called\n   *  in order to prevent the modified envelope from being used on other notes.\n   *\n   *  @method  noteADSR\n   *  @for p5.PolySynth\n   *  @param {Number} [note]        Midi note on which ADSR should be set.\n   *  @param {Number} [attackTime]  Time (in seconds before envelope\n   *                                reaches Attack Level\n   *  @param {Number} [decayTime]   Time (in seconds) before envelope\n   *                                reaches Decay/Sustain Level\n   *  @param {Number} [susRatio]    Ratio between attackLevel and releaseLevel, on a scale from 0 to 1,\n   *                                where 1.0 = attackLevel, 0.0 = releaseLevel.\n   *                                The susRatio determines the decayLevel and the level at which the\n   *                                sustain portion of the envelope will sustain.\n   *                                For example, if attackLevel is 0.4, releaseLevel is 0,\n   *                                and susAmt is 0.5, the decayLevel would be 0.2. If attackLevel is\n   *                                increased to 1.0 (using <code>setRange</code>),\n   *                                then decayLevel would increase proportionally, to become 0.5.\n   *  @param {Number} [releaseTime]   Time in seconds from now (defaults to 0)\n   **/\n\n\n  p5.PolySynth.prototype.noteADSR = function (note, a, d, s, r, timeFromNow) {\n    var now = p5sound.audiocontext.currentTime;\n    var timeFromNow = timeFromNow || 0;\n    var t = now + timeFromNow;\n    this.audiovoices[this.notes[note].getValueAtTime(t)].setADSR(a, d, s, r);\n  };\n  /**\n   * Set the PolySynths global envelope. This method modifies the envelopes of each\n   * monosynth so that all notes are played with this envelope.\n   *\n   *  @method  setADSR\n   *  @for p5.PolySynth\n   *  @param {Number} [attackTime]  Time (in seconds before envelope\n   *                                reaches Attack Level\n   *  @param {Number} [decayTime]   Time (in seconds) before envelope\n   *                                reaches Decay/Sustain Level\n   *  @param {Number} [susRatio]    Ratio between attackLevel and releaseLevel, on a scale from 0 to 1,\n   *                                where 1.0 = attackLevel, 0.0 = releaseLevel.\n   *                                The susRatio determines the decayLevel and the level at which the\n   *                                sustain portion of the envelope will sustain.\n   *                                For example, if attackLevel is 0.4, releaseLevel is 0,\n   *                                and susAmt is 0.5, the decayLevel would be 0.2. If attackLevel is\n   *                                increased to 1.0 (using <code>setRange</code>),\n   *                                then decayLevel would increase proportionally, to become 0.5.\n   *  @param {Number} [releaseTime]   Time in seconds from now (defaults to 0)\n   **/\n\n\n  p5.PolySynth.prototype.setADSR = function (a, d, s, r) {\n    this.audiovoices.forEach(function (voice) {\n      voice.setADSR(a, d, s, r);\n    });\n  };\n  /**\n   *  Trigger the Attack, and Decay portion of a MonoSynth.\n   *  Similar to holding down a key on a piano, but it will\n   *  hold the sustain level until you let go.\n   *\n   *  @method  noteAttack\n   *  @for p5.PolySynth\n   *  @param  {Number} [note]           midi note on which attack should be triggered.\n   *  @param  {Number} [velocity]       velocity of the note to play (ranging from 0 to 1)/\n   *  @param  {Number} [secondsFromNow] time from now (in seconds)\n   *  @example\n   *  <div><code>\n   *  let polySynth = new p5.PolySynth();\n   *  let pitches = ['G', 'D', 'G', 'C'];\n   *  let octaves = [2, 3, 4];\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(playChord);\n   *    background(220);\n   *    text('tap to play', 20, 20);\n   *  }\n   *\n   *  function playChord() {\n   *    userStartAudio();\n   *\n   *    // play a chord: multiple notes at the same time\n   *    for (let i = 0; i < 4; i++) {\n   *      let note = random(pitches) + random(octaves);\n   *      polySynth.noteAttack(note, 0.1);\n   *    }\n   *  }\n   *\n   *  function mouseReleased() {\n   *    // release all voices\n   *    polySynth.noteRelease();\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.PolySynth.prototype.noteAttack = function (_note, _velocity, secondsFromNow) {\n    var secondsFromNow = ~~secondsFromNow; \n\n    var acTime = p5sound.audiocontext.currentTime + secondsFromNow; \n\n    var note = noteToFreq(_note);\n    var velocity = _velocity || 0.1;\n    var currentVoice; \n\n    if (this.notes[note] && this.notes[note].getValueAtTime(acTime) !== null) {\n      this.noteRelease(note, 0);\n    } \n\n\n    if (this._voicesInUse.getValueAtTime(acTime) < this.maxVoices) {\n      currentVoice = Math.max(~~this._voicesInUse.getValueAtTime(acTime), 0);\n    } \n    else {\n        currentVoice = this._oldest;\n        var oldestNote = p5.prototype.freqToMidi(this.audiovoices[this._oldest].oscillator.freq().value);\n        this.noteRelease(oldestNote);\n        this._oldest = (this._oldest + 1) % (this.maxVoices - 1);\n      } \n\n\n    this.notes[note] = new TimelineSignal();\n    this.notes[note].setValueAtTime(currentVoice, acTime); \n\n    var previousVal = this._voicesInUse._searchBefore(acTime) === null ? 0 : this._voicesInUse._searchBefore(acTime).value;\n\n    this._voicesInUse.setValueAtTime(previousVal + 1, acTime); \n\n\n    this._updateAfter(acTime, 1);\n\n    this._newest = currentVoice; \n\n    if (typeof velocity === 'number') {\n      var maxRange = 1 / this._voicesInUse.getValueAtTime(acTime) * 2;\n      velocity = velocity > maxRange ? maxRange : velocity;\n    }\n\n    this.audiovoices[currentVoice].triggerAttack(note, velocity, secondsFromNow);\n  };\n  /**\n   * Private method to ensure accurate values of this._voicesInUse\n   * Any time a new value is scheduled, it is necessary to increment all subsequent\n   * scheduledValues after attack, and decrement all subsequent\n   * scheduledValues after release\n   *\n   * @private\n   * @for p5.PolySynth\n   * @param  {[type]} time  [description]\n   * @param  {[type]} value [description]\n   * @return {[type]}       [description]\n   */\n\n\n  p5.PolySynth.prototype._updateAfter = function (time, value) {\n    if (this._voicesInUse._searchAfter(time) === null) {\n      return;\n    } else {\n      this._voicesInUse._searchAfter(time).value += value;\n\n      var nextTime = this._voicesInUse._searchAfter(time).time;\n\n      this._updateAfter(nextTime, value);\n    }\n  };\n  /**\n   *  Trigger the Release of an AudioVoice note. This is similar to releasing\n   *  the key on a piano and letting the sound fade according to the\n   *  release level and release time.\n   *\n   *  @method  noteRelease\n   *  @for p5.PolySynth\n   *  @param  {Number} [note]           midi note on which attack should be triggered.\n   *                                    If no value is provided, all notes will be released.\n   *  @param  {Number} [secondsFromNow] time to trigger the release\n   *  @example\n   *  <div><code>\n   *  let polySynth = new p5.PolySynth();\n   *  let pitches = ['G', 'D', 'G', 'C'];\n   *  let octaves = [2, 3, 4];\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(playChord);\n   *    background(220);\n   *    text('tap to play', 20, 20);\n   *  }\n   *\n   *  function playChord() {\n   *    userStartAudio();\n   *\n   *    // play a chord: multiple notes at the same time\n   *    for (let i = 0; i < 4; i++) {\n   *      let note = random(pitches) + random(octaves);\n   *      polySynth.noteAttack(note, 0.1);\n   *    }\n   *  }\n   *\n   *  function mouseReleased() {\n   *    // release all voices\n   *    polySynth.noteRelease();\n   *  }\n   *  </code></div>\n   *\n   */\n\n\n  p5.PolySynth.prototype.noteRelease = function (_note, secondsFromNow) {\n    var now = p5sound.audiocontext.currentTime;\n    var tFromNow = secondsFromNow || 0;\n    var t = now + tFromNow; \n\n    if (!_note) {\n      this.audiovoices.forEach(function (voice) {\n        voice.triggerRelease(tFromNow);\n      });\n\n      this._voicesInUse.setValueAtTime(0, t);\n\n      for (var n in this.notes) {\n        this.notes[n].dispose();\n        delete this.notes[n];\n      }\n\n      return;\n    } \n\n\n    var note = noteToFreq(_note);\n\n    if (!this.notes[note] || this.notes[note].getValueAtTime(t) === null) {\n      console.warn('Cannot release a note that is not already playing');\n    } else {\n      var previousVal = Math.max(~~this._voicesInUse.getValueAtTime(t).value, 1);\n\n      this._voicesInUse.setValueAtTime(previousVal - 1, t); \n\n\n      if (previousVal > 0) {\n        this._updateAfter(t, -1);\n      }\n\n      this.audiovoices[this.notes[note].getValueAtTime(t)].triggerRelease(tFromNow);\n      this.notes[note].dispose();\n      delete this.notes[note];\n      this._newest = this._newest === 0 ? 0 : (this._newest - 1) % (this.maxVoices - 1);\n    }\n  };\n  /**\n    *  Connect to a p5.sound / Web Audio object.\n    *\n    *  @method  connect\n    *  @for p5.PolySynth\n    *  @param  {Object} unit A p5.sound or Web Audio object\n    */\n\n\n  p5.PolySynth.prototype.connect = function (unit) {\n    var u = unit || p5sound.input;\n    this.output.connect(u.input ? u.input : u);\n  };\n  /**\n  *  Disconnect all outputs\n  *\n  *  @method  disconnect\n  *  @for p5.PolySynth\n  */\n\n\n  p5.PolySynth.prototype.disconnect = function () {\n    if (this.output) {\n      this.output.disconnect();\n    }\n  };\n  /**\n    *  Get rid of the MonoSynth and free up its resources / memory.\n    *\n    *  @method  dispose\n    *  @for p5.PolySynth\n    */\n\n\n  p5.PolySynth.prototype.dispose = function () {\n    this.audiovoices.forEach(function (voice) {\n      voice.dispose();\n    });\n\n    if (this.output) {\n      this.output.disconnect();\n      delete this.output;\n    }\n  };\n}).call(exports, __nested_webpack_require_116462__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_131576__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  __nested_webpack_require_131576__(32);\n\n  __nested_webpack_require_131576__(33);\n\n  __nested_webpack_require_131576__(17);\n\n  var p5SOUND = __nested_webpack_require_131576__(1);\n\n  __nested_webpack_require_131576__(6);\n\n  __nested_webpack_require_131576__(11);\n\n  __nested_webpack_require_131576__(36);\n\n  __nested_webpack_require_131576__(40);\n\n  __nested_webpack_require_131576__(41);\n\n  __nested_webpack_require_131576__(42);\n\n  __nested_webpack_require_131576__(43);\n\n  __nested_webpack_require_131576__(44);\n\n  __nested_webpack_require_131576__(23);\n\n  __nested_webpack_require_131576__(47);\n\n  __nested_webpack_require_131576__(48);\n\n  __nested_webpack_require_131576__(49);\n\n  __nested_webpack_require_131576__(50);\n\n  __nested_webpack_require_131576__(15);\n\n  __nested_webpack_require_131576__(59);\n\n  __nested_webpack_require_131576__(61);\n\n  __nested_webpack_require_131576__(62);\n\n  __nested_webpack_require_131576__(63);\n\n  __nested_webpack_require_131576__(64);\n\n  __nested_webpack_require_131576__(65);\n\n  __nested_webpack_require_131576__(67);\n\n  __nested_webpack_require_131576__(68);\n\n  __nested_webpack_require_131576__(69);\n\n  __nested_webpack_require_131576__(70);\n\n  __nested_webpack_require_131576__(71);\n\n  __nested_webpack_require_131576__(72);\n\n  __nested_webpack_require_131576__(28);\n\n  __nested_webpack_require_131576__(30);\n\n  __nested_webpack_require_131576__(73);\n\n  __nested_webpack_require_131576__(29);\n\n  __nested_webpack_require_131576__(28);\n\n  __nested_webpack_require_131576__(30);\n\n  return p5SOUND;\n}).call(exports, __nested_webpack_require_131576__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports) {\n\n!function(){var l,s=[];function p(e){var o=this,n={},i=-1;this.parameters.forEach(function(e,t){var r=s[++i]||(s[i]=new Float32Array(o.bufferSize));r.fill(e.value),n[t]=r}),this.processor.realm.exec(\"self.sampleRate=sampleRate=\"+this.context.sampleRate+\";self.currentTime=currentTime=\"+this.context.currentTime);var t=a(e.inputBuffer),r=a(e.outputBuffer);this.instance.process([t],[r],n)}function a(e){for(var t=[],r=0;r<e.numberOfChannels;r++)t[r]=e.getChannelData(r);return t}function f(e){return e.$$processors||(e.$$processors={})}function e(e){this.$$context=e}\"function\"!=typeof AudioWorkletNode&&(self.AudioWorkletNode=function(e,t,r){var o=f(e)[t],n=e.createScriptProcessor(void 0,2,r&&r.outputChannelCount?r.outputChannelCount[0]:2);if(n.parameters=new Map,o.properties)for(var i=0;i<o.properties.length;i++){var s=o.properties[i],a=e.createGain().gain;a.value=s.defaultValue,n.parameters.set(s.name,a)}var u=new MessageChannel;l=u.port2;var c=new o.Processor(r||{});return l=null,n.port=u.port1,n.processor=o,n.instance=c,n.onaudioprocess=p,n},Object.defineProperty((self.AudioContext||self.webkitAudioContext).prototype,\"audioWorklet\",{get:function(){return this.$$audioWorklet||(this.$$audioWorklet=new self.AudioWorklet(this))}}),self.AudioWorklet=(e.prototype.addModule=function(e,t){var n=this;return fetch(e).then(function(e){if(!e.ok)throw Error(e.status);return e.text()}).then(function(e){var r={sampleRate:0,currentTime:0,AudioWorkletProcessor:function(){this.port=l},registerProcessor:function(e,t){f(n.$$context)[e]={realm:o,context:r,Processor:t,properties:t.parameterDescriptors||[]}}},o=new function(e,t){var r=document.createElement(\"iframe\");r.style.cssText=\"position:absolute;left:0;top:-999px;width:1px;height:1px;\",t.appendChild(r);var o=r.contentWindow,n=o.document,i=\"var window,$hook\";for(var s in o)s in e||\"eval\"===s||(i+=\",\",i+=s);for(var a in e)i+=\",\",i+=a,i+=\"=self.\",i+=a;var u=n.createElement(\"script\");u.appendChild(n.createTextNode('function $hook(self,console) {\"use strict\";\\n        '+i+\";return function() {return eval(arguments[0])}}\")),n.body.appendChild(u),this.exec=o.$hook(e,console)}(r.self=r,document.documentElement);return o.exec((t&&t.transpile||String)(e)),null})},e))}();\n\n }),\n (function(module, exports, __nested_webpack_require_135203__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n/**\n * This module has shims\n */\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  (function () {\n    function fixSetTarget(param) {\n      if (!param) \n        return;\n      if (!param.setTargetAtTime) param.setTargetAtTime = param.setTargetValueAtTime;\n    }\n\n    if (window.hasOwnProperty('webkitAudioContext') && !window.hasOwnProperty('AudioContext')) {\n      window.AudioContext = window.webkitAudioContext;\n      if (typeof AudioContext.prototype.createGain !== 'function') AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;\n      if (typeof AudioContext.prototype.createDelay !== 'function') AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;\n      if (typeof AudioContext.prototype.createScriptProcessor !== 'function') AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode;\n      if (typeof AudioContext.prototype.createPeriodicWave !== 'function') AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;\n      AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain;\n\n      AudioContext.prototype.createGain = function () {\n        var node = this.internal_createGain();\n        fixSetTarget(node.gain);\n        return node;\n      };\n\n      AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay;\n\n      AudioContext.prototype.createDelay = function (maxDelayTime) {\n        var node = maxDelayTime ? this.internal_createDelay(maxDelayTime) : this.internal_createDelay();\n        fixSetTarget(node.delayTime);\n        return node;\n      };\n\n      AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource;\n\n      AudioContext.prototype.createBufferSource = function () {\n        var node = this.internal_createBufferSource();\n\n        if (!node.start) {\n          node.start = function (when, offset, duration) {\n            if (offset || duration) this.noteGrainOn(when || 0, offset, duration);else this.noteOn(when || 0);\n          };\n        } else {\n          node.internal_start = node.start;\n\n          node.start = function (when, offset, duration) {\n            if (typeof duration !== 'undefined') node.internal_start(when || 0, offset, duration);else node.internal_start(when || 0, offset || 0);\n          };\n        }\n\n        if (!node.stop) {\n          node.stop = function (when) {\n            this.noteOff(when || 0);\n          };\n        } else {\n          node.internal_stop = node.stop;\n\n          node.stop = function (when) {\n            node.internal_stop(when || 0);\n          };\n        }\n\n        fixSetTarget(node.playbackRate);\n        return node;\n      };\n\n      AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor;\n\n      AudioContext.prototype.createDynamicsCompressor = function () {\n        var node = this.internal_createDynamicsCompressor();\n        fixSetTarget(node.threshold);\n        fixSetTarget(node.knee);\n        fixSetTarget(node.ratio);\n        fixSetTarget(node.reduction);\n        fixSetTarget(node.attack);\n        fixSetTarget(node.release);\n        return node;\n      };\n\n      AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter;\n\n      AudioContext.prototype.createBiquadFilter = function () {\n        var node = this.internal_createBiquadFilter();\n        fixSetTarget(node.frequency);\n        fixSetTarget(node.detune);\n        fixSetTarget(node.Q);\n        fixSetTarget(node.gain);\n        return node;\n      };\n\n      if (typeof AudioContext.prototype.createOscillator !== 'function') {\n        AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator;\n\n        AudioContext.prototype.createOscillator = function () {\n          var node = this.internal_createOscillator();\n\n          if (!node.start) {\n            node.start = function (when) {\n              this.noteOn(when || 0);\n            };\n          } else {\n            node.internal_start = node.start;\n\n            node.start = function (when) {\n              node.internal_start(when || 0);\n            };\n          }\n\n          if (!node.stop) {\n            node.stop = function (when) {\n              this.noteOff(when || 0);\n            };\n          } else {\n            node.internal_stop = node.stop;\n\n            node.stop = function (when) {\n              node.internal_stop(when || 0);\n            };\n          }\n\n          if (!node.setPeriodicWave) node.setPeriodicWave = node.setWaveTable;\n          fixSetTarget(node.frequency);\n          fixSetTarget(node.detune);\n          return node;\n        };\n      }\n    }\n\n    if (window.hasOwnProperty('webkitOfflineAudioContext') && !window.hasOwnProperty('OfflineAudioContext')) {\n      window.OfflineAudioContext = window.webkitOfflineAudioContext;\n    }\n  })(window); \n\n\n  navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\n  /**\n   * Determine which filetypes are supported (inspired by buzz.js)\n   * The audio element (el) will only be used to test browser support for various audio formats\n   */\n\n  var el = document.createElement('audio');\n\n  p5.prototype.isSupported = function () {\n    return !!el.canPlayType;\n  };\n\n  var isOGGSupported = function isOGGSupported() {\n    return !!el.canPlayType && el.canPlayType('audio/ogg; codecs=\"vorbis\"');\n  };\n\n  var isMP3Supported = function isMP3Supported() {\n    return !!el.canPlayType && el.canPlayType('audio/mpeg;');\n  };\n\n  var isWAVSupported = function isWAVSupported() {\n    return !!el.canPlayType && el.canPlayType('audio/wav; codecs=\"1\"');\n  };\n\n  var isAACSupported = function isAACSupported() {\n    return !!el.canPlayType && (el.canPlayType('audio/x-m4a;') || el.canPlayType('audio/aac;'));\n  };\n\n  var isAIFSupported = function isAIFSupported() {\n    return !!el.canPlayType && el.canPlayType('audio/x-aiff;');\n  };\n\n  p5.prototype.isFileSupported = function (extension) {\n    switch (extension.toLowerCase()) {\n      case 'mp3':\n        return isMP3Supported();\n\n      case 'wav':\n        return isWAVSupported();\n\n      case 'ogg':\n        return isOGGSupported();\n\n      case 'aac':\n      case 'm4a':\n      case 'mp4':\n        return isAACSupported();\n\n      case 'aif':\n      case 'aiff':\n        return isAIFSupported();\n\n      default:\n        return false;\n    }\n  };\n}).call(exports, __nested_webpack_require_135203__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports) {\n\nvar g;g=function(){return this}();try{g=g||new Function(\"return this\")()}catch(t){\"object\"==typeof window&&(g=window)}module.exports=g;\n\n }),\n (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(e,t){  true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):0}(this,function(){var r=function(e,t){this._dragged=!1,this._element=e,this._bindedMove=this._moved.bind(this),this._bindedEnd=this._ended.bind(this,t),e.addEventListener(\"touchstart\",this._bindedEnd),e.addEventListener(\"touchmove\",this._bindedMove),e.addEventListener(\"touchend\",this._bindedEnd),e.addEventListener(\"mouseup\",this._bindedEnd)};function o(e){return\"running\"===e.state}return r.prototype._moved=function(e){this._dragged=!0},r.prototype._ended=function(e){this._dragged||function(e){var t=e.createBuffer(1,1,e.sampleRate),n=e.createBufferSource();n.buffer=t,n.connect(e.destination),n.start(0),e.resume&&e.resume()}(e),this._dragged=!1},r.prototype.dispose=function(){this._element.removeEventListener(\"touchstart\",this._bindedEnd),this._element.removeEventListener(\"touchmove\",this._bindedMove),this._element.removeEventListener(\"touchend\",this._bindedEnd),this._element.removeEventListener(\"mouseup\",this._bindedEnd),this._bindedMove=null,this._bindedEnd=null,this._element=null},function(t,e,n){var i=new Promise(function(e){!function(t,n){o(t)?n():function e(){o(t)?n():(requestAnimationFrame(e),t.resume&&t.resume())}()}(t,e)}),d=[];return function e(t,n,i){if(Array.isArray(t)||NodeList&&t instanceof NodeList)for(var d=0;d<t.length;d++)e(t[d],n,i);else if(\"string\"==typeof t)e(document.querySelectorAll(t),n,i);else if(t.jquery&&\"function\"==typeof t.toArray)e(t.toArray(),n,i);else if(Element&&t instanceof Element){var o=new r(t,i);n.push(o)}}(e=e||document.body,d,t),i.then(function(){for(var e=0;e<d.length;e++)d[e].dispose();d=null,n&&n()}),i}});\n\n }),\n (function(module, exports, __nested_webpack_require_144230__) {\n\nvar p5sound = __nested_webpack_require_144230__(1);\n\nvar moduleSources = [__nested_webpack_require_144230__(37)[\"default\"], __nested_webpack_require_144230__(38)[\"default\"], __nested_webpack_require_144230__(39)[\"default\"]];\nvar ac = p5sound.audiocontext;\nvar initializedAudioWorklets = false;\n\nfunction loadAudioWorkletModules() {\n  return Promise.all(moduleSources.map(function (moduleSrc) {\n    var blob = new Blob([moduleSrc], {\n      type: 'application/javascript'\n    });\n    var objectURL = URL.createObjectURL(blob);\n    return ac.audioWorklet.addModule(objectURL);\n  }));\n}\n\np5.prototype.registerMethod('init', function () {\n  if (initializedAudioWorklets) return; \n\n  if (!this.preload && !window.preload) {\n    this.preload = function () {};\n  } \n\n\n  this._incrementPreload();\n\n  var onWorkletModulesLoad = function () {\n    initializedAudioWorklets = true;\n\n    this._decrementPreload();\n  }.bind(this);\n\n  loadAudioWorkletModules().then(onWorkletModulesLoad);\n});\n\n }),\n (function(module, __webpack_exports__, __nested_webpack_require_145221__) {\n\n\"use strict\";\n__nested_webpack_require_145221__.r(__webpack_exports__);\n __webpack_exports__[\"default\"] = (\"function _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \\\"function\\\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \\\"function\\\") { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } if (typeof _cache !== \\\"undefined\\\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\\n\\nfunction isNativeReflectConstruct() { if (typeof Reflect === \\\"undefined\\\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \\\"function\\\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\\n\\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\\n\\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\\\"[native code]\\\") !== -1; }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\n// import dependencies via preval.require so that they're available as values at compile time\\nvar processorNames = {\\n  \\\"recorderProcessor\\\": \\\"recorder-processor\\\",\\n  \\\"soundFileProcessor\\\": \\\"sound-file-processor\\\",\\n  \\\"amplitudeProcessor\\\": \\\"amplitude-processor\\\"\\n};\\nvar RingBuffer = {\\n  \\\"default\\\":\\n  /*#__PURE__*/\\n  function () {\\n    /**\\n     * @constructor\\n     * @param  {number} length Buffer length in frames.\\n     * @param  {number} channelCount Buffer channel count.\\n     */\\n    function RingBuffer(length, channelCount) {\\n      _classCallCheck(this, RingBuffer);\\n\\n      this._readIndex = 0;\\n      this._writeIndex = 0;\\n      this._framesAvailable = 0;\\n      this._channelCount = channelCount;\\n      this._length = length;\\n      this._channelData = [];\\n\\n      for (var i = 0; i < this._channelCount; ++i) {\\n        this._channelData[i] = new Float32Array(length);\\n      }\\n    }\\n    /**\\n     * Getter for Available frames in buffer.\\n     *\\n     * @return {number} Available frames in buffer.\\n     */\\n\\n\\n    _createClass(RingBuffer, [{\\n      key: \\\"push\\\",\\n\\n      /**\\n       * Push a sequence of Float32Arrays to buffer.\\n       *\\n       * @param  {array} arraySequence A sequence of Float32Arrays.\\n       */\\n      value: function push(arraySequence) {\\n        // The channel count of arraySequence and the length of each channel must\\n        // match with this buffer obejct.\\n        // Transfer data from the |arraySequence| storage to the internal buffer.\\n        var sourceLength = arraySequence[0].length;\\n\\n        for (var i = 0; i < sourceLength; ++i) {\\n          var writeIndex = (this._writeIndex + i) % this._length;\\n\\n          for (var channel = 0; channel < this._channelCount; ++channel) {\\n            this._channelData[channel][writeIndex] = arraySequence[channel][i];\\n          }\\n        }\\n\\n        this._writeIndex += sourceLength;\\n\\n        if (this._writeIndex >= this._length) {\\n          this._writeIndex = 0;\\n        } // For excessive frames, the buffer will be overwritten.\\n\\n\\n        this._framesAvailable += sourceLength;\\n\\n        if (this._framesAvailable > this._length) {\\n          this._framesAvailable = this._length;\\n        }\\n      }\\n      /**\\n       * Pull data out of buffer and fill a given sequence of Float32Arrays.\\n       *\\n       * @param  {array} arraySequence An array of Float32Arrays.\\n       */\\n\\n    }, {\\n      key: \\\"pull\\\",\\n      value: function pull(arraySequence) {\\n        // The channel count of arraySequence and the length of each channel must\\n        // match with this buffer obejct.\\n        // If the FIFO is completely empty, do nothing.\\n        if (this._framesAvailable === 0) {\\n          return;\\n        }\\n\\n        var destinationLength = arraySequence[0].length; // Transfer data from the internal buffer to the |arraySequence| storage.\\n\\n        for (var i = 0; i < destinationLength; ++i) {\\n          var readIndex = (this._readIndex + i) % this._length;\\n\\n          for (var channel = 0; channel < this._channelCount; ++channel) {\\n            arraySequence[channel][i] = this._channelData[channel][readIndex];\\n          }\\n        }\\n\\n        this._readIndex += destinationLength;\\n\\n        if (this._readIndex >= this._length) {\\n          this._readIndex = 0;\\n        }\\n\\n        this._framesAvailable -= destinationLength;\\n\\n        if (this._framesAvailable < 0) {\\n          this._framesAvailable = 0;\\n        }\\n      }\\n    }, {\\n      key: \\\"framesAvailable\\\",\\n      get: function get() {\\n        return this._framesAvailable;\\n      }\\n    }]);\\n\\n    return RingBuffer;\\n  }()\\n}[\\\"default\\\"];\\n\\nvar RecorderProcessor =\\n/*#__PURE__*/\\nfunction (_AudioWorkletProcesso) {\\n  _inherits(RecorderProcessor, _AudioWorkletProcesso);\\n\\n  function RecorderProcessor(options) {\\n    var _this;\\n\\n    _classCallCheck(this, RecorderProcessor);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RecorderProcessor).call(this));\\n    var processorOptions = options.processorOptions || {};\\n    _this.numOutputChannels = options.outputChannelCount || 2;\\n    _this.numInputChannels = processorOptions.numInputChannels || 2;\\n    _this.bufferSize = processorOptions.bufferSize || 1024;\\n    _this.recording = false;\\n\\n    _this.clear();\\n\\n    _this.port.onmessage = function (event) {\\n      var data = event.data;\\n\\n      if (data.name === 'start') {\\n        _this.record(data.duration);\\n      } else if (data.name === 'stop') {\\n        _this.stop();\\n      }\\n    };\\n\\n    return _this;\\n  }\\n\\n  _createClass(RecorderProcessor, [{\\n    key: \\\"process\\\",\\n    value: function process(inputs) {\\n      if (!this.recording) {\\n        return true;\\n      } else if (this.sampleLimit && this.recordedSamples >= this.sampleLimit) {\\n        this.stop();\\n        return true;\\n      }\\n\\n      var input = inputs[0];\\n      this.inputRingBuffer.push(input);\\n\\n      if (this.inputRingBuffer.framesAvailable >= this.bufferSize) {\\n        this.inputRingBuffer.pull(this.inputRingBufferArraySequence);\\n\\n        for (var channel = 0; channel < this.numOutputChannels; ++channel) {\\n          var inputChannelCopy = this.inputRingBufferArraySequence[channel].slice();\\n\\n          if (channel === 0) {\\n            this.leftBuffers.push(inputChannelCopy);\\n\\n            if (this.numInputChannels === 1) {\\n              this.rightBuffers.push(inputChannelCopy);\\n            }\\n          } else if (channel === 1 && this.numInputChannels > 1) {\\n            this.rightBuffers.push(inputChannelCopy);\\n          }\\n        }\\n\\n        this.recordedSamples += this.bufferSize;\\n      }\\n\\n      return true;\\n    }\\n  }, {\\n    key: \\\"record\\\",\\n    value: function record(duration) {\\n      if (duration) {\\n        this.sampleLimit = Math.round(duration * sampleRate);\\n      }\\n\\n      this.recording = true;\\n    }\\n  }, {\\n    key: \\\"stop\\\",\\n    value: function stop() {\\n      this.recording = false;\\n      var buffers = this.getBuffers();\\n      var leftBuffer = buffers[0].buffer;\\n      var rightBuffer = buffers[1].buffer;\\n      this.port.postMessage({\\n        name: 'buffers',\\n        leftBuffer: leftBuffer,\\n        rightBuffer: rightBuffer\\n      }, [leftBuffer, rightBuffer]);\\n      this.clear();\\n    }\\n  }, {\\n    key: \\\"getBuffers\\\",\\n    value: function getBuffers() {\\n      var buffers = [];\\n      buffers.push(this.mergeBuffers(this.leftBuffers));\\n      buffers.push(this.mergeBuffers(this.rightBuffers));\\n      return buffers;\\n    }\\n  }, {\\n    key: \\\"mergeBuffers\\\",\\n    value: function mergeBuffers(channelBuffer) {\\n      var result = new Float32Array(this.recordedSamples);\\n      var offset = 0;\\n      var lng = channelBuffer.length;\\n\\n      for (var i = 0; i < lng; i++) {\\n        var buffer = channelBuffer[i];\\n        result.set(buffer, offset);\\n        offset += buffer.length;\\n      }\\n\\n      return result;\\n    }\\n  }, {\\n    key: \\\"clear\\\",\\n    value: function clear() {\\n      var _this2 = this;\\n\\n      this.leftBuffers = [];\\n      this.rightBuffers = [];\\n      this.inputRingBuffer = new RingBuffer(this.bufferSize, this.numInputChannels);\\n      this.inputRingBufferArraySequence = new Array(this.numInputChannels).fill(null).map(function () {\\n        return new Float32Array(_this2.bufferSize);\\n      });\\n      this.recordedSamples = 0;\\n      this.sampleLimit = null;\\n    }\\n  }]);\\n\\n  return RecorderProcessor;\\n}(_wrapNativeSuper(AudioWorkletProcessor));\\n\\nregisterProcessor(processorNames.recorderProcessor, RecorderProcessor);\");\n\n }),\n (function(module, __webpack_exports__, __nested_webpack_require_156802__) {\n\n\"use strict\";\n__nested_webpack_require_156802__.r(__webpack_exports__);\n __webpack_exports__[\"default\"] = (\"function _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \\\"function\\\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \\\"function\\\") { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } if (typeof _cache !== \\\"undefined\\\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\\n\\nfunction isNativeReflectConstruct() { if (typeof Reflect === \\\"undefined\\\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \\\"function\\\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\\n\\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\\n\\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\\\"[native code]\\\") !== -1; }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\n// import dependencies via preval.require so that they're available as values at compile time\\nvar processorNames = {\\n  \\\"recorderProcessor\\\": \\\"recorder-processor\\\",\\n  \\\"soundFileProcessor\\\": \\\"sound-file-processor\\\",\\n  \\\"amplitudeProcessor\\\": \\\"amplitude-processor\\\"\\n};\\nvar RingBuffer = {\\n  \\\"default\\\":\\n  /*#__PURE__*/\\n  function () {\\n    /**\\n     * @constructor\\n     * @param  {number} length Buffer length in frames.\\n     * @param  {number} channelCount Buffer channel count.\\n     */\\n    function RingBuffer(length, channelCount) {\\n      _classCallCheck(this, RingBuffer);\\n\\n      this._readIndex = 0;\\n      this._writeIndex = 0;\\n      this._framesAvailable = 0;\\n      this._channelCount = channelCount;\\n      this._length = length;\\n      this._channelData = [];\\n\\n      for (var i = 0; i < this._channelCount; ++i) {\\n        this._channelData[i] = new Float32Array(length);\\n      }\\n    }\\n    /**\\n     * Getter for Available frames in buffer.\\n     *\\n     * @return {number} Available frames in buffer.\\n     */\\n\\n\\n    _createClass(RingBuffer, [{\\n      key: \\\"push\\\",\\n\\n      /**\\n       * Push a sequence of Float32Arrays to buffer.\\n       *\\n       * @param  {array} arraySequence A sequence of Float32Arrays.\\n       */\\n      value: function push(arraySequence) {\\n        // The channel count of arraySequence and the length of each channel must\\n        // match with this buffer obejct.\\n        // Transfer data from the |arraySequence| storage to the internal buffer.\\n        var sourceLength = arraySequence[0].length;\\n\\n        for (var i = 0; i < sourceLength; ++i) {\\n          var writeIndex = (this._writeIndex + i) % this._length;\\n\\n          for (var channel = 0; channel < this._channelCount; ++channel) {\\n            this._channelData[channel][writeIndex] = arraySequence[channel][i];\\n          }\\n        }\\n\\n        this._writeIndex += sourceLength;\\n\\n        if (this._writeIndex >= this._length) {\\n          this._writeIndex = 0;\\n        } // For excessive frames, the buffer will be overwritten.\\n\\n\\n        this._framesAvailable += sourceLength;\\n\\n        if (this._framesAvailable > this._length) {\\n          this._framesAvailable = this._length;\\n        }\\n      }\\n      /**\\n       * Pull data out of buffer and fill a given sequence of Float32Arrays.\\n       *\\n       * @param  {array} arraySequence An array of Float32Arrays.\\n       */\\n\\n    }, {\\n      key: \\\"pull\\\",\\n      value: function pull(arraySequence) {\\n        // The channel count of arraySequence and the length of each channel must\\n        // match with this buffer obejct.\\n        // If the FIFO is completely empty, do nothing.\\n        if (this._framesAvailable === 0) {\\n          return;\\n        }\\n\\n        var destinationLength = arraySequence[0].length; // Transfer data from the internal buffer to the |arraySequence| storage.\\n\\n        for (var i = 0; i < destinationLength; ++i) {\\n          var readIndex = (this._readIndex + i) % this._length;\\n\\n          for (var channel = 0; channel < this._channelCount; ++channel) {\\n            arraySequence[channel][i] = this._channelData[channel][readIndex];\\n          }\\n        }\\n\\n        this._readIndex += destinationLength;\\n\\n        if (this._readIndex >= this._length) {\\n          this._readIndex = 0;\\n        }\\n\\n        this._framesAvailable -= destinationLength;\\n\\n        if (this._framesAvailable < 0) {\\n          this._framesAvailable = 0;\\n        }\\n      }\\n    }, {\\n      key: \\\"framesAvailable\\\",\\n      get: function get() {\\n        return this._framesAvailable;\\n      }\\n    }]);\\n\\n    return RingBuffer;\\n  }()\\n}[\\\"default\\\"];\\n\\nvar SoundFileProcessor =\\n/*#__PURE__*/\\nfunction (_AudioWorkletProcesso) {\\n  _inherits(SoundFileProcessor, _AudioWorkletProcesso);\\n\\n  function SoundFileProcessor(options) {\\n    var _this;\\n\\n    _classCallCheck(this, SoundFileProcessor);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SoundFileProcessor).call(this));\\n    var processorOptions = options.processorOptions || {};\\n    _this.bufferSize = processorOptions.bufferSize || 256;\\n    _this.inputRingBuffer = new RingBuffer(_this.bufferSize, 1);\\n    _this.inputRingBufferArraySequence = [new Float32Array(_this.bufferSize)];\\n    return _this;\\n  }\\n\\n  _createClass(SoundFileProcessor, [{\\n    key: \\\"process\\\",\\n    value: function process(inputs) {\\n      var input = inputs[0]; // we only care about the first input channel, because that contains the position data\\n\\n      this.inputRingBuffer.push([input[0]]);\\n\\n      if (this.inputRingBuffer.framesAvailable >= this.bufferSize) {\\n        this.inputRingBuffer.pull(this.inputRingBufferArraySequence);\\n        var inputChannel = this.inputRingBufferArraySequence[0];\\n        var position = inputChannel[inputChannel.length - 1] || 0;\\n        this.port.postMessage({\\n          name: 'position',\\n          position: position\\n        });\\n      }\\n\\n      return true;\\n    }\\n  }]);\\n\\n  return SoundFileProcessor;\\n}(_wrapNativeSuper(AudioWorkletProcessor));\\n\\nregisterProcessor(processorNames.soundFileProcessor, SoundFileProcessor);\");\n\n }),\n (function(module, __webpack_exports__, __nested_webpack_require_165952__) {\n\n\"use strict\";\n__nested_webpack_require_165952__.r(__webpack_exports__);\n __webpack_exports__[\"default\"] = (\"function _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \\\"function\\\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \\\"function\\\") { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } if (typeof _cache !== \\\"undefined\\\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\\n\\nfunction isNativeReflectConstruct() { if (typeof Reflect === \\\"undefined\\\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \\\"function\\\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\\n\\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\\n\\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\\\"[native code]\\\") !== -1; }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\n// import dependencies via preval.require so that they're available as values at compile time\\nvar processorNames = {\\n  \\\"recorderProcessor\\\": \\\"recorder-processor\\\",\\n  \\\"soundFileProcessor\\\": \\\"sound-file-processor\\\",\\n  \\\"amplitudeProcessor\\\": \\\"amplitude-processor\\\"\\n};\\nvar RingBuffer = {\\n  \\\"default\\\":\\n  /*#__PURE__*/\\n  function () {\\n    /**\\n     * @constructor\\n     * @param  {number} length Buffer length in frames.\\n     * @param  {number} channelCount Buffer channel count.\\n     */\\n    function RingBuffer(length, channelCount) {\\n      _classCallCheck(this, RingBuffer);\\n\\n      this._readIndex = 0;\\n      this._writeIndex = 0;\\n      this._framesAvailable = 0;\\n      this._channelCount = channelCount;\\n      this._length = length;\\n      this._channelData = [];\\n\\n      for (var i = 0; i < this._channelCount; ++i) {\\n        this._channelData[i] = new Float32Array(length);\\n      }\\n    }\\n    /**\\n     * Getter for Available frames in buffer.\\n     *\\n     * @return {number} Available frames in buffer.\\n     */\\n\\n\\n    _createClass(RingBuffer, [{\\n      key: \\\"push\\\",\\n\\n      /**\\n       * Push a sequence of Float32Arrays to buffer.\\n       *\\n       * @param  {array} arraySequence A sequence of Float32Arrays.\\n       */\\n      value: function push(arraySequence) {\\n        // The channel count of arraySequence and the length of each channel must\\n        // match with this buffer obejct.\\n        // Transfer data from the |arraySequence| storage to the internal buffer.\\n        var sourceLength = arraySequence[0].length;\\n\\n        for (var i = 0; i < sourceLength; ++i) {\\n          var writeIndex = (this._writeIndex + i) % this._length;\\n\\n          for (var channel = 0; channel < this._channelCount; ++channel) {\\n            this._channelData[channel][writeIndex] = arraySequence[channel][i];\\n          }\\n        }\\n\\n        this._writeIndex += sourceLength;\\n\\n        if (this._writeIndex >= this._length) {\\n          this._writeIndex = 0;\\n        } // For excessive frames, the buffer will be overwritten.\\n\\n\\n        this._framesAvailable += sourceLength;\\n\\n        if (this._framesAvailable > this._length) {\\n          this._framesAvailable = this._length;\\n        }\\n      }\\n      /**\\n       * Pull data out of buffer and fill a given sequence of Float32Arrays.\\n       *\\n       * @param  {array} arraySequence An array of Float32Arrays.\\n       */\\n\\n    }, {\\n      key: \\\"pull\\\",\\n      value: function pull(arraySequence) {\\n        // The channel count of arraySequence and the length of each channel must\\n        // match with this buffer obejct.\\n        // If the FIFO is completely empty, do nothing.\\n        if (this._framesAvailable === 0) {\\n          return;\\n        }\\n\\n        var destinationLength = arraySequence[0].length; // Transfer data from the internal buffer to the |arraySequence| storage.\\n\\n        for (var i = 0; i < destinationLength; ++i) {\\n          var readIndex = (this._readIndex + i) % this._length;\\n\\n          for (var channel = 0; channel < this._channelCount; ++channel) {\\n            arraySequence[channel][i] = this._channelData[channel][readIndex];\\n          }\\n        }\\n\\n        this._readIndex += destinationLength;\\n\\n        if (this._readIndex >= this._length) {\\n          this._readIndex = 0;\\n        }\\n\\n        this._framesAvailable -= destinationLength;\\n\\n        if (this._framesAvailable < 0) {\\n          this._framesAvailable = 0;\\n        }\\n      }\\n    }, {\\n      key: \\\"framesAvailable\\\",\\n      get: function get() {\\n        return this._framesAvailable;\\n      }\\n    }]);\\n\\n    return RingBuffer;\\n  }()\\n}[\\\"default\\\"];\\n\\nvar AmplitudeProcessor =\\n/*#__PURE__*/\\nfunction (_AudioWorkletProcesso) {\\n  _inherits(AmplitudeProcessor, _AudioWorkletProcesso);\\n\\n  function AmplitudeProcessor(options) {\\n    var _this;\\n\\n    _classCallCheck(this, AmplitudeProcessor);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AmplitudeProcessor).call(this));\\n    var processorOptions = options.processorOptions || {};\\n    _this.numOutputChannels = options.outputChannelCount || 1;\\n    _this.numInputChannels = processorOptions.numInputChannels || 2;\\n    _this.normalize = processorOptions.normalize || false;\\n    _this.smoothing = processorOptions.smoothing || 0;\\n    _this.bufferSize = processorOptions.bufferSize || 2048;\\n    _this.inputRingBuffer = new RingBuffer(_this.bufferSize, _this.numInputChannels);\\n    _this.outputRingBuffer = new RingBuffer(_this.bufferSize, _this.numOutputChannels);\\n    _this.inputRingBufferArraySequence = new Array(_this.numInputChannels).fill(null).map(function () {\\n      return new Float32Array(_this.bufferSize);\\n    });\\n    _this.stereoVol = [0, 0];\\n    _this.stereoVolNorm = [0, 0];\\n    _this.volMax = 0.001;\\n\\n    _this.port.onmessage = function (event) {\\n      var data = event.data;\\n\\n      if (data.name === 'toggleNormalize') {\\n        _this.normalize = data.normalize;\\n      } else if (data.name === 'smoothing') {\\n        _this.smoothing = Math.max(0, Math.min(1, data.smoothing));\\n      }\\n    };\\n\\n    return _this;\\n  } // TO DO make this stereo / dependent on # of audio channels\\n\\n\\n  _createClass(AmplitudeProcessor, [{\\n    key: \\\"process\\\",\\n    value: function process(inputs, outputs) {\\n      var input = inputs[0];\\n      var output = outputs[0];\\n      var smoothing = this.smoothing;\\n      this.inputRingBuffer.push(input);\\n\\n      if (this.inputRingBuffer.framesAvailable >= this.bufferSize) {\\n        this.inputRingBuffer.pull(this.inputRingBufferArraySequence);\\n\\n        for (var channel = 0; channel < this.numInputChannels; ++channel) {\\n          var inputBuffer = this.inputRingBufferArraySequence[channel];\\n          var bufLength = inputBuffer.length;\\n          var sum = 0;\\n\\n          for (var i = 0; i < bufLength; i++) {\\n            var x = inputBuffer[i];\\n\\n            if (this.normalize) {\\n              sum += Math.max(Math.min(x / this.volMax, 1), -1) * Math.max(Math.min(x / this.volMax, 1), -1);\\n            } else {\\n              sum += x * x;\\n            }\\n          } // ... then take the square root of the sum.\\n\\n\\n          var rms = Math.sqrt(sum / bufLength);\\n          this.stereoVol[channel] = Math.max(rms, this.stereoVol[channel] * smoothing);\\n          this.volMax = Math.max(this.stereoVol[channel], this.volMax);\\n        } // calculate stero normalized volume and add volume from all channels together\\n\\n\\n        var volSum = 0;\\n\\n        for (var index = 0; index < this.stereoVol.length; index++) {\\n          this.stereoVolNorm[index] = Math.max(Math.min(this.stereoVol[index] / this.volMax, 1), 0);\\n          volSum += this.stereoVol[index];\\n        } // volume is average of channels\\n\\n\\n        var volume = volSum / this.stereoVol.length; // normalized value\\n\\n        var volNorm = Math.max(Math.min(volume / this.volMax, 1), 0);\\n        this.port.postMessage({\\n          name: 'amplitude',\\n          volume: volume,\\n          volNorm: volNorm,\\n          stereoVol: this.stereoVol,\\n          stereoVolNorm: this.stereoVolNorm\\n        }); // pass input through to output\\n\\n        this.outputRingBuffer.push(this.inputRingBufferArraySequence);\\n      } // pull 128 frames out of the ring buffer\\n      // if the ring buffer does not have enough frames, the output will be silent\\n\\n\\n      this.outputRingBuffer.pull(output);\\n      return true;\\n    }\\n  }]);\\n\\n  return AmplitudeProcessor;\\n}(_wrapNativeSuper(AudioWorkletProcessor));\\n\\nregisterProcessor(processorNames.amplitudeProcessor, AmplitudeProcessor);\");\n\n }),\n (function(module, exports, __nested_webpack_require_177566__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_177566__(1);\n\n  var ac = p5sound.audiocontext; \n\n  if (typeof ac.createStereoPanner !== 'undefined') {\n    p5.Panner = function (input, output) {\n      this.stereoPanner = this.input = ac.createStereoPanner();\n      input.connect(this.stereoPanner);\n      this.stereoPanner.connect(output);\n    };\n\n    p5.Panner.prototype.pan = function (val, tFromNow) {\n      var time = tFromNow || 0;\n      var t = ac.currentTime + time;\n      this.stereoPanner.pan.linearRampToValueAtTime(val, t);\n    }; \n\n\n    p5.Panner.prototype.inputChannels = function () {};\n\n    p5.Panner.prototype.connect = function (obj) {\n      this.stereoPanner.connect(obj);\n    };\n\n    p5.Panner.prototype.disconnect = function () {\n      if (this.stereoPanner) {\n        this.stereoPanner.disconnect();\n      }\n    };\n  } else {\n    p5.Panner = function (input, output, numInputChannels) {\n      this.input = ac.createGain();\n      input.connect(this.input);\n      this.left = ac.createGain();\n      this.right = ac.createGain();\n      this.left.channelInterpretation = 'discrete';\n      this.right.channelInterpretation = 'discrete'; \n\n      if (numInputChannels > 1) {\n        this.splitter = ac.createChannelSplitter(2);\n        this.input.connect(this.splitter);\n        this.splitter.connect(this.left, 1);\n        this.splitter.connect(this.right, 0);\n      } else {\n        this.input.connect(this.left);\n        this.input.connect(this.right);\n      }\n\n      this.output = ac.createChannelMerger(2);\n      this.left.connect(this.output, 0, 1);\n      this.right.connect(this.output, 0, 0);\n      this.output.connect(output);\n    }; \n\n\n    p5.Panner.prototype.pan = function (val, tFromNow) {\n      var time = tFromNow || 0;\n      var t = ac.currentTime + time;\n      var v = (val + 1) / 2;\n      var rightVal = Math.cos(v * Math.PI / 2);\n      var leftVal = Math.sin(v * Math.PI / 2);\n      this.left.gain.linearRampToValueAtTime(leftVal, t);\n      this.right.gain.linearRampToValueAtTime(rightVal, t);\n    };\n\n    p5.Panner.prototype.inputChannels = function (numChannels) {\n      if (numChannels === 1) {\n        this.input.disconnect();\n        this.input.connect(this.left);\n        this.input.connect(this.right);\n      } else if (numChannels === 2) {\n        if (_typeof(this.splitter === 'undefined')) {\n          this.splitter = ac.createChannelSplitter(2);\n        }\n\n        this.input.disconnect();\n        this.input.connect(this.splitter);\n        this.splitter.connect(this.left, 1);\n        this.splitter.connect(this.right, 0);\n      }\n    };\n\n    p5.Panner.prototype.connect = function (obj) {\n      this.output.connect(obj);\n    };\n\n    p5.Panner.prototype.disconnect = function () {\n      if (this.output) {\n        this.output.disconnect();\n      }\n    };\n  }\n}).call(exports, __nested_webpack_require_177566__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_181024__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var CustomError = __nested_webpack_require_181024__(11);\n\n  var p5sound = __nested_webpack_require_181024__(1);\n\n  var ac = p5sound.audiocontext;\n\n  var _require = __nested_webpack_require_181024__(6),\n      midiToFreq = _require.midiToFreq,\n      convertToWav = _require.convertToWav,\n      safeBufferSize = _require.safeBufferSize;\n\n  var processorNames = __nested_webpack_require_181024__(10);\n  /**\n   *  <p>SoundFile object with a path to a file.</p>\n   *\n   *  <p>The p5.SoundFile may not be available immediately because\n   *  it loads the file information asynchronously.</p>\n   *\n   *  <p>To do something with the sound as soon as it loads\n   *  pass the name of a function as the second parameter.</p>\n   *\n   *  <p>Only one file path is required. However, audio file formats\n   *  (i.e. mp3, ogg, wav and m4a/aac) are not supported by all\n   *  web browsers. If you want to ensure compatability, instead of a single\n   *  file path, you may include an Array of filepaths, and the browser will\n   *  choose a format that works.</p>\n   *\n   *  @class p5.SoundFile\n   *  @constructor\n   *  @param {String|Array} path   path to a sound file (String). Optionally,\n   *                               you may include multiple file formats in\n   *                               an array. Alternately, accepts an object\n   *                               from the HTML5 File API, or a p5.File.\n   *  @param {Function} [successCallback]   Name of a function to call once file loads\n   *  @param {Function} [errorCallback]   Name of a function to call if file fails to\n   *                                      load. This function will receive an error or\n   *                                     XMLHttpRequest object with information\n   *                                     about what went wrong.\n   *  @param {Function} [whileLoadingCallback]   Name of a function to call while file\n   *                                             is loading. That function will\n   *                                             receive progress of the request to\n   *                                             load the sound file\n   *                                             (between 0 and 1) as its first\n   *                                             parameter. This progress\n   *                                             does not account for the additional\n   *                                             time needed to decode the audio data.\n   *\n   *  @example\n   *  <div><code>\n   *  let mySound;\n   *  function preload() {\n   *    soundFormats('mp3', 'ogg');\n   *    mySound = loadSound('assets/doorbell');\n   *  }\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(canvasPressed);\n   *    background(220);\n   *    text('tap here to play', 10, 20);\n   *  }\n   *\n   *  function canvasPressed() {\n   *    // playing a sound file on a user gesture\n   *    // is equivalent to `userStartAudio()`\n   *    mySound.play();\n   *  }\n   * </code></div>\n   */\n\n\n  p5.SoundFile = function (paths, onload, onerror, whileLoading) {\n    if (typeof paths !== 'undefined') {\n      if (typeof paths === 'string' || typeof paths[0] === 'string') {\n        var path = p5.prototype._checkFileFormats(paths);\n\n        this.url = path;\n      } else if (_typeof(paths) === 'object') {\n        if (!(window.File && window.FileReader && window.FileList && window.Blob)) {\n          throw 'Unable to load file because the File API is not supported';\n        }\n      } \n\n\n      if (paths.file) {\n        paths = paths.file;\n      }\n\n      this.file = paths;\n    } \n\n\n    this._onended = function () {};\n\n    this._looping = false;\n    this._playing = false;\n    this._paused = false;\n    this._pauseTime = 0; \n\n    this._cues = [];\n    this._cueIDCounter = 0; \n\n    this._lastPos = 0;\n    this._counterNode = null;\n    this._workletNode = null; \n\n    this.bufferSourceNodes = []; \n\n    this.bufferSourceNode = null;\n    this.buffer = null;\n    this.playbackRate = 1;\n    this.input = p5sound.audiocontext.createGain();\n    this.output = p5sound.audiocontext.createGain();\n    this.reversed = false; \n\n    this.startTime = 0;\n    this.endTime = null;\n    this.pauseTime = 0; \n\n    this.mode = 'sustain'; \n\n    this.startMillis = null; \n\n    this.panPosition = 0.0;\n    this.panner = new p5.Panner(this.output, p5sound.input, 2); \n\n    if (this.url || this.file) {\n      this.load(onload, onerror);\n    } \n\n\n    p5sound.soundArray.push(this);\n\n    if (typeof whileLoading === 'function') {\n      this._whileLoading = whileLoading;\n    } else {\n      this._whileLoading = function () {};\n    }\n\n    this._clearOnEnd = _clearOnEnd.bind(this);\n  }; \n\n\n  p5.prototype.registerPreloadMethod('loadSound', p5.prototype);\n  /**\n   *  loadSound() returns a new p5.SoundFile from a specified\n   *  path. If called during preload(), the p5.SoundFile will be ready\n   *  to play in time for setup() and draw(). If called outside of\n   *  preload, the p5.SoundFile will not be ready immediately, so\n   *  loadSound accepts a callback as the second parameter. Using a\n   *  <a href=\"https://github.com/processing/p5.js/wiki/Local-server\">\n   *  local server</a> is recommended when loading external files.\n   *\n   *  @method loadSound\n   *  @for p5\n   *  @param  {String|Array}   path     Path to the sound file, or an array with\n   *                                    paths to soundfiles in multiple formats\n   *                                    i.e. ['sound.ogg', 'sound.mp3'].\n   *                                    Alternately, accepts an object: either\n   *                                    from the HTML5 File API, or a p5.File.\n   *  @param {Function} [successCallback]   Name of a function to call once file loads\n   *  @param {Function} [errorCallback]   Name of a function to call if there is\n   *                                      an error loading the file.\n   *  @param {Function} [whileLoading] Name of a function to call while file is loading.\n   *                                 This function will receive the percentage loaded\n   *                                 so far, from 0.0 to 1.0.\n   *  @return {SoundFile}            Returns a p5.SoundFile\n   *  @example\n   *  <div><code>\n   *  let mySound;\n   *  function preload() {\n   *    soundFormats('mp3', 'ogg');\n   *    mySound = loadSound('assets/doorbell');\n   *  }\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(canvasPressed);\n   *    background(220);\n   *    text('tap here to play', 10, 20);\n   *  }\n   *\n   *  function canvasPressed() {\n   *    // playing a sound file on a user gesture\n   *    // is equivalent to `userStartAudio()`\n   *    mySound.play();\n   *  }\n   *  </code></div>\n   */\n\n  p5.prototype.loadSound = function (path, callback, onerror, whileLoading) {\n    if (window.location.origin.indexOf('file://') > -1 && window.cordova === 'undefined') {\n      window.alert('This sketch may require a server to load external files. Please see http://bit.ly/1qcInwS');\n    }\n\n    var self = this;\n    var s = new p5.SoundFile(path, function () {\n      if (typeof callback === 'function') {\n        callback.apply(self, arguments);\n      }\n\n      if (typeof self._decrementPreload === 'function') {\n        self._decrementPreload();\n      }\n    }, onerror, whileLoading);\n    return s;\n  };\n  /**\n   * This is a helper function that the p5.SoundFile calls to load\n   * itself. Accepts a callback (the name of another function)\n   * as an optional parameter.\n   *\n   * @private\n   * @for p5.SoundFile\n   * @param {Function} [successCallback]   Name of a function to call once file loads\n   * @param {Function} [errorCallback]   Name of a function to call if there is an error\n   */\n\n\n  p5.SoundFile.prototype.load = function (callback, errorCallback) {\n    var self = this;\n    var errorTrace = new Error().stack;\n\n    if (this.url !== undefined && this.url !== '') {\n      var request = new XMLHttpRequest();\n      request.addEventListener('progress', function (evt) {\n        self._updateProgress(evt);\n      }, false);\n      request.open('GET', this.url, true);\n      request.responseType = 'arraybuffer';\n\n      request.onload = function () {\n        if (request.status === 200) {\n          if (!self.panner) return;\n          ac.decodeAudioData(request.response, \n          function (buff) {\n            if (!self.panner) return;\n            self.buffer = buff;\n            self.panner.inputChannels(buff.numberOfChannels);\n\n            if (callback) {\n              callback(self);\n            }\n          }, \n          function () {\n            if (!self.panner) return;\n            var err = new CustomError('decodeAudioData', errorTrace, self.url);\n            var msg = 'AudioContext error at decodeAudioData for ' + self.url;\n\n            if (errorCallback) {\n              err.msg = msg;\n              errorCallback(err);\n            } else {\n              console.error(msg + '\\n The error stack trace includes: \\n' + err.stack);\n            }\n          });\n        } \n        else {\n            if (!self.panner) return;\n            var err = new CustomError('loadSound', errorTrace, self.url);\n            var msg = 'Unable to load ' + self.url + '. The request status was: ' + request.status + ' (' + request.statusText + ')';\n\n            if (errorCallback) {\n              err.message = msg;\n              errorCallback(err);\n            } else {\n              console.error(msg + '\\n The error stack trace includes: \\n' + err.stack);\n            }\n          }\n      }; \n\n\n      request.onerror = function () {\n        var err = new CustomError('loadSound', errorTrace, self.url);\n        var msg = 'There was no response from the server at ' + self.url + '. Check the url and internet connectivity.';\n\n        if (errorCallback) {\n          err.message = msg;\n          errorCallback(err);\n        } else {\n          console.error(msg + '\\n The error stack trace includes: \\n' + err.stack);\n        }\n      };\n\n      request.send();\n    } else if (this.file !== undefined) {\n      var reader = new FileReader();\n\n      reader.onload = function () {\n        if (!self.panner) return;\n        ac.decodeAudioData(reader.result, function (buff) {\n          if (!self.panner) return;\n          self.buffer = buff;\n          self.panner.inputChannels(buff.numberOfChannels);\n\n          if (callback) {\n            callback(self);\n          }\n        });\n      };\n\n      reader.onerror = function (e) {\n        if (!self.panner) return;\n\n        if (onerror) {\n          onerror(e);\n        }\n      };\n\n      reader.readAsArrayBuffer(this.file);\n    }\n  }; \n\n\n  p5.SoundFile.prototype._updateProgress = function (evt) {\n    if (evt.lengthComputable) {\n      var percentComplete = evt.loaded / evt.total * 0.99;\n\n      this._whileLoading(percentComplete, evt); \n\n    } else {\n      this._whileLoading('size unknown');\n    }\n  };\n  /**\n   *  Returns true if the sound file finished loading successfully.\n   *\n   *  @method  isLoaded\n   *  @for p5.SoundFile\n   *  @return {Boolean}\n   */\n\n\n  p5.SoundFile.prototype.isLoaded = function () {\n    if (this.buffer) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\n   * Play the p5.SoundFile\n   *\n   * @method play\n   * @for p5.SoundFile\n   * @param {Number} [startTime]            (optional) schedule playback to start (in seconds from now).\n   * @param {Number} [rate]             (optional) playback rate\n   * @param {Number} [amp]              (optional) amplitude (volume)\n   *                                     of playback\n   * @param {Number} [cueStart]        (optional) cue start time in seconds\n   * @param {Number} [duration]          (optional) duration of playback in seconds\n   */\n\n\n  p5.SoundFile.prototype.play = function (startTime, rate, amp, _cueStart, duration) {\n    if (!this.output) {\n      console.warn('SoundFile.play() called after dispose');\n      return;\n    }\n\n    var now = p5sound.audiocontext.currentTime;\n    var cueStart, cueEnd;\n    var time = startTime || 0;\n\n    if (time < 0) {\n      time = 0;\n    }\n\n    time = time + now;\n\n    if (typeof rate !== 'undefined') {\n      this.rate(rate);\n    }\n\n    if (typeof amp !== 'undefined') {\n      this.setVolume(amp);\n    } \n\n\n    if (this.buffer) {\n      this._pauseTime = 0; \n\n      if (this.mode === 'restart' && this.buffer && this.bufferSourceNode) {\n        this.bufferSourceNode.stop(time);\n\n        this._counterNode.stop(time);\n      } \n\n\n      if (this.mode === 'untildone' && this.isPlaying()) {\n        return;\n      } \n\n\n      this.bufferSourceNode = this._initSourceNode(); \n\n      delete this._counterNode;\n      this._counterNode = this._initCounterNode();\n\n      if (_cueStart) {\n        if (_cueStart >= 0 && _cueStart < this.buffer.duration) {\n          cueStart = _cueStart;\n        } else {\n          throw 'start time out of range';\n        }\n      } else {\n        cueStart = 0;\n      }\n\n      if (duration) {\n        duration = duration <= this.buffer.duration - cueStart ? duration : this.buffer.duration;\n      } \n\n\n      if (this._paused) {\n        this.bufferSourceNode.start(time, this.pauseTime, duration);\n\n        this._counterNode.start(time, this.pauseTime, duration);\n      } else {\n        this.bufferSourceNode.start(time, cueStart, duration);\n\n        this._counterNode.start(time, cueStart, duration);\n      }\n\n      this._playing = true;\n      this._paused = false; \n\n      this.bufferSourceNodes.push(this.bufferSourceNode);\n      this.bufferSourceNode._arrayIndex = this.bufferSourceNodes.length - 1;\n      this.bufferSourceNode.addEventListener('ended', this._clearOnEnd);\n    } \n    else {\n        throw 'not ready to play file, buffer has yet to load. Try preload()';\n      } \n\n\n    this.bufferSourceNode.loop = this._looping;\n    this._counterNode.loop = this._looping;\n\n    if (this._looping === true) {\n      cueEnd = duration ? duration : cueStart - 0.000000000000001;\n      this.bufferSourceNode.loopStart = cueStart;\n      this.bufferSourceNode.loopEnd = cueEnd;\n      this._counterNode.loopStart = cueStart;\n      this._counterNode.loopEnd = cueEnd;\n    }\n  };\n  /**\n   *  p5.SoundFile has two play modes: <code>restart</code> and\n   *  <code>sustain</code>. Play Mode determines what happens to a\n   *  p5.SoundFile if it is triggered while in the middle of playback.\n   *  In sustain mode, playback will continue simultaneous to the\n   *  new playback. In restart mode, play() will stop playback\n   *  and start over. With untilDone, a sound will play only if it's\n   *  not already playing. Sustain is the default mode.\n   *\n   *  @method  playMode\n   *  @for p5.SoundFile\n   *  @param  {String} str 'restart' or 'sustain' or 'untilDone'\n   *  @example\n   *  <div><code>\n   *  let mySound;\n   *  function preload(){\n   *    mySound = loadSound('assets/Damscray_DancingTiger.mp3');\n   *  }\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(canvasPressed);\n   *    noFill();\n   *    rect(0, height/2, width - 1, height/2 - 1);\n   *    rect(0, 0, width - 1, height/2);\n   *    textAlign(CENTER, CENTER);\n   *    fill(20);\n   *    text('restart', width/2, 1 * height/4);\n   *    text('sustain', width/2, 3 * height/4);\n   *  }\n   *  function canvasPressed() {\n   *    if (mouseX < height/2) {\n   *      mySound.playMode('restart');\n   *    } else {\n   *      mySound.playMode('sustain');\n   *    }\n   *    mySound.play();\n   *  }\n   *\n   * </code></div>\n   */\n\n\n  p5.SoundFile.prototype.playMode = function (str) {\n    var s = str.toLowerCase(); \n\n    if (s === 'restart' && this.buffer && this.bufferSourceNode) {\n      for (var i = 0; i < this.bufferSourceNodes.length - 1; i++) {\n        var now = p5sound.audiocontext.currentTime;\n        this.bufferSourceNodes[i].stop(now);\n      }\n    } \n\n\n    if (s === 'restart' || s === 'sustain' || s === 'untildone') {\n      this.mode = s;\n    } else {\n      throw 'Invalid play mode. Must be either \"restart\" or \"sustain\"';\n    }\n  };\n  /**\n   *  Pauses a file that is currently playing. If the file is not\n   *  playing, then nothing will happen.\n   *\n   *  After pausing, .play() will resume from the paused\n   *  position.\n   *  If p5.SoundFile had been set to loop before it was paused,\n   *  it will continue to loop after it is unpaused with .play().\n   *\n   *  @method pause\n   *  @for p5.SoundFile\n   *  @param {Number} [startTime] (optional) schedule event to occur\n   *                               seconds from now\n   *  @example\n   *  <div><code>\n   *  let soundFile;\n   *  function preload() {\n   *    soundFormats('ogg', 'mp3');\n   *    soundFile = loadSound('assets/Damscray_-_Dancing_Tiger_02.mp3');\n   *  }\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(canvasPressed);\n   *    background(220);\n   *    text('tap to play, release to pause', 10, 20, width - 20);\n   *  }\n   *  function canvasPressed() {\n   *    soundFile.loop();\n   *    background(0, 200, 50);\n   *  }\n   *  function mouseReleased() {\n   *    soundFile.pause();\n   *    background(220);\n   *  }\n   *  </code>\n   *  </div>\n   */\n\n\n  p5.SoundFile.prototype.pause = function (startTime) {\n    var now = p5sound.audiocontext.currentTime;\n    var time = startTime || 0;\n    var pTime = time + now;\n\n    if (this.isPlaying() && this.buffer && this.bufferSourceNode) {\n      this._paused = true;\n      this._playing = false;\n      this.pauseTime = this.currentTime();\n      this.bufferSourceNode.stop(pTime);\n\n      this._counterNode.stop(pTime);\n\n      this._pauseTime = this.currentTime(); \n    } else {\n      this._pauseTime = 0;\n    }\n  };\n  /**\n   * Loop the p5.SoundFile. Accepts optional parameters to set the\n   * playback rate, playback volume, loopStart, loopEnd.\n   *\n   * @method loop\n   * @for p5.SoundFile\n   * @param {Number} [startTime] (optional) schedule event to occur\n   *                             seconds from now\n   * @param {Number} [rate]        (optional) playback rate\n   * @param {Number} [amp]         (optional) playback volume\n   * @param {Number} [cueLoopStart] (optional) startTime in seconds\n   * @param {Number} [duration]  (optional) loop duration in seconds\n   * @example\n   *  <div><code>\n   *  let soundFile;\n   *  let loopStart = 0.5;\n   *  let loopDuration = 0.2;\n   *  function preload() {\n   *    soundFormats('ogg', 'mp3');\n   *    soundFile = loadSound('assets/Damscray_-_Dancing_Tiger_02.mp3');\n   *  }\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(canvasPressed);\n   *    background(220);\n   *    text('tap to play, release to pause', 10, 20, width - 20);\n   *  }\n   *  function canvasPressed() {\n   *    soundFile.loop();\n   *    background(0, 200, 50);\n   *  }\n   *  function mouseReleased() {\n   *    soundFile.pause();\n   *    background(220);\n   *  }\n   *  </code>\n   *  </div>\n   */\n\n\n  p5.SoundFile.prototype.loop = function (startTime, rate, amp, loopStart, duration) {\n    this._looping = true;\n    this.play(startTime, rate, amp, loopStart, duration);\n  };\n  /**\n   * Set a p5.SoundFile's looping flag to true or false. If the sound\n   * is currently playing, this change will take effect when it\n   * reaches the end of the current playback.\n   *\n   * @method setLoop\n   * @for p5.SoundFile\n   * @param {Boolean} Boolean   set looping to true or false\n   */\n\n\n  p5.SoundFile.prototype.setLoop = function (bool) {\n    if (bool === true) {\n      this._looping = true;\n    } else if (bool === false) {\n      this._looping = false;\n    } else {\n      throw 'Error: setLoop accepts either true or false';\n    }\n\n    if (this.bufferSourceNode) {\n      this.bufferSourceNode.loop = this._looping;\n      this._counterNode.loop = this._looping;\n    }\n  };\n  /**\n   * Returns 'true' if a p5.SoundFile is currently looping and playing, 'false' if not.\n   *\n   * @method isLooping\n   * @for p5.SoundFile\n   * @return {Boolean}\n   */\n\n\n  p5.SoundFile.prototype.isLooping = function () {\n    if (!this.bufferSourceNode) {\n      return false;\n    }\n\n    if (this._looping === true && this.isPlaying() === true) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   *  Returns true if a p5.SoundFile is playing, false if not (i.e.\n   *  paused or stopped).\n   *\n   *  @method isPlaying\n   *  @for p5.SoundFile\n   *  @return {Boolean}\n   */\n\n\n  p5.SoundFile.prototype.isPlaying = function () {\n    return this._playing;\n  };\n  /**\n   *  Returns true if a p5.SoundFile is paused, false if not (i.e.\n   *  playing or stopped).\n   *\n   *  @method  isPaused\n   *  @for p5.SoundFile\n   *  @return {Boolean}\n   */\n\n\n  p5.SoundFile.prototype.isPaused = function () {\n    return this._paused;\n  };\n  /**\n   * Stop soundfile playback.\n   *\n   * @method stop\n   * @for p5.SoundFile\n   * @param {Number} [startTime] (optional) schedule event to occur\n   *                             in seconds from now\n   */\n\n\n  p5.SoundFile.prototype.stop = function (timeFromNow) {\n    var time = timeFromNow || 0;\n\n    if (this.mode === 'sustain' || this.mode === 'untildone') {\n      this.stopAll(time);\n      this._playing = false;\n      this.pauseTime = 0;\n      this._paused = false;\n    } else if (this.buffer && this.bufferSourceNode) {\n      var now = p5sound.audiocontext.currentTime;\n      var t = time || 0;\n      this.pauseTime = 0;\n      this.bufferSourceNode.stop(now + t);\n\n      this._counterNode.stop(now + t);\n\n      this._playing = false;\n      this._paused = false;\n    }\n  };\n  /**\n   *  Stop playback on all of this soundfile's sources.\n   *  @private\n   */\n\n\n  p5.SoundFile.prototype.stopAll = function (_time) {\n    var now = p5sound.audiocontext.currentTime;\n    var time = _time || 0;\n\n    if (this.buffer && this.bufferSourceNode) {\n      for (var i in this.bufferSourceNodes) {\n        var bufferSourceNode = this.bufferSourceNodes[i];\n\n        if (!!bufferSourceNode) {\n          try {\n            bufferSourceNode.stop(now + time);\n          } catch (e) {\n          }\n        }\n      }\n\n      this._counterNode.stop(now + time);\n\n      this._onended(this);\n    }\n  };\n  /**\n   *  Multiply the output volume (amplitude) of a sound file\n   *  between 0.0 (silence) and 1.0 (full volume).\n   *  1.0 is the maximum amplitude of a digital sound, so multiplying\n   *  by greater than 1.0 may cause digital distortion. To\n   *  fade, provide a <code>rampTime</code> parameter. For more\n   *  complex fades, see the Envelope class.\n   *\n   *  Alternately, you can pass in a signal source such as an\n   *  oscillator to modulate the amplitude with an audio signal.\n   *\n   *  @method  setVolume\n   *  @for p5.SoundFile\n   *  @param {Number|Object} volume  Volume (amplitude) between 0.0\n   *                                     and 1.0 or modulating signal/oscillator\n   *  @param {Number} [rampTime]  Fade for t seconds\n   *  @param {Number} [timeFromNow]  Schedule this event to happen at\n   *                                 t seconds in the future\n   */\n\n\n  p5.SoundFile.prototype.setVolume = function (vol, _rampTime, _tFromNow) {\n    if (typeof vol === 'number') {\n      var rampTime = _rampTime || 0;\n      var tFromNow = _tFromNow || 0;\n      var now = p5sound.audiocontext.currentTime;\n      var currentVol = this.output.gain.value;\n      this.output.gain.cancelScheduledValues(now + tFromNow);\n      this.output.gain.linearRampToValueAtTime(currentVol, now + tFromNow);\n      this.output.gain.linearRampToValueAtTime(vol, now + tFromNow + rampTime);\n    } else if (vol) {\n      vol.connect(this.output.gain);\n    } else {\n      return this.output.gain;\n    }\n  }; \n\n\n  p5.SoundFile.prototype.amp = p5.SoundFile.prototype.setVolume; \n\n  p5.SoundFile.prototype.fade = p5.SoundFile.prototype.setVolume;\n\n  p5.SoundFile.prototype.getVolume = function () {\n    return this.output.gain.value;\n  };\n  /**\n   * Set the stereo panning of a p5.sound object to\n   * a floating point number between -1.0 (left) and 1.0 (right).\n   * Default is 0.0 (center).\n   *\n   * @method pan\n   * @for p5.SoundFile\n   * @param {Number} [panValue]     Set the stereo panner\n   * @param {Number} [timeFromNow]  schedule this event to happen\n   *                                 seconds from now\n   * @example\n   * <div><code>\n   *  let ballX = 0;\n   *  let soundFile;\n   *\n   *  function preload() {\n   *    soundFormats('ogg', 'mp3');\n   *    soundFile = loadSound('assets/beatbox.mp3');\n   *  }\n   *\n   *  function draw() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(canvasPressed);\n   *    background(220);\n   *    ballX = constrain(mouseX, 0, width);\n   *    ellipse(ballX, height/2, 20, 20);\n   *  }\n   *\n   *  function canvasPressed(){\n   *    // map the ball's x location to a panning degree\n   *    // between -1.0 (left) and 1.0 (right)\n   *    let panning = map(ballX, 0., width,-1.0, 1.0);\n   *    soundFile.pan(panning);\n   *    soundFile.play();\n   *  }\n   *  </div></code>\n   */\n\n\n  p5.SoundFile.prototype.pan = function (pval, tFromNow) {\n    this.panPosition = pval;\n    this.panner.pan(pval, tFromNow);\n  };\n  /**\n   * Returns the current stereo pan position (-1.0 to 1.0)\n   *\n   * @method getPan\n   * @for p5.SoundFile\n   * @return {Number} Returns the stereo pan setting of the Oscillator\n   *                          as a number between -1.0 (left) and 1.0 (right).\n   *                          0.0 is center and default.\n   */\n\n\n  p5.SoundFile.prototype.getPan = function () {\n    return this.panPosition;\n  };\n  /**\n   *  Set the playback rate of a sound file. Will change the speed and the pitch.\n   *  Values less than zero will reverse the audio buffer.\n   *\n   *  @method rate\n   *  @for p5.SoundFile\n   *  @param {Number} [playbackRate]     Set the playback rate. 1.0 is normal,\n   *                                     .5 is half-speed, 2.0 is twice as fast.\n   *                                     Values less than zero play backwards.\n   *  @example\n   *  <div><code>\n   *  let mySound;\n   *\n   *  function preload() {\n   *    mySound = loadSound('assets/Damscray_DancingTiger.mp3');\n   *  }\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(canvasPressed);\n   *  }\n   *  function canvasPressed() {\n   *    mySound.loop();\n   *  }\n   *  function mouseReleased() {\n   *    mySound.pause();\n   *  }\n   *  function draw() {\n   *    background(220);\n   *\n   *    // Set the rate to a range between 0.1 and 4\n   *    // Changing the rate also alters the pitch\n   *    let playbackRate = map(mouseY, 0.1, height, 2, 0);\n   *    playbackRate = constrain(playbackRate, 0.01, 4);\n   *    mySound.rate(playbackRate);\n   *\n   *    line(0, mouseY, width, mouseY);\n   *    text('rate: ' + round(playbackRate * 100) + '%', 10, 20);\n   *  }\n   *\n   * </code>\n   * </div>\n   *\n   */\n\n\n  p5.SoundFile.prototype.rate = function (playbackRate) {\n    var reverse = false;\n\n    if (typeof playbackRate === 'undefined') {\n      return this.playbackRate;\n    }\n\n    this.playbackRate = playbackRate;\n\n    if (playbackRate === 0) {\n      playbackRate = 0.0000000000001;\n    } else if (playbackRate < 0 && !this.reversed) {\n      playbackRate = Math.abs(playbackRate);\n      reverse = true;\n    } else if (playbackRate > 0 && this.reversed) {\n      reverse = true;\n    }\n\n    if (this.bufferSourceNode) {\n      var now = p5sound.audiocontext.currentTime;\n      this.bufferSourceNode.playbackRate.cancelScheduledValues(now);\n      this.bufferSourceNode.playbackRate.linearRampToValueAtTime(Math.abs(playbackRate), now);\n\n      this._counterNode.playbackRate.cancelScheduledValues(now);\n\n      this._counterNode.playbackRate.linearRampToValueAtTime(Math.abs(playbackRate), now);\n    }\n\n    if (reverse) {\n      this.reverseBuffer();\n    }\n\n    return this.playbackRate;\n  }; \n\n\n  p5.SoundFile.prototype.setPitch = function (num) {\n    var newPlaybackRate = midiToFreq(num) / midiToFreq(60);\n    this.rate(newPlaybackRate);\n  };\n\n  p5.SoundFile.prototype.getPlaybackRate = function () {\n    return this.playbackRate;\n  };\n  /**\n   * Returns the duration of a sound file in seconds.\n   *\n   * @method duration\n   * @for p5.SoundFile\n   * @return {Number} The duration of the soundFile in seconds.\n   */\n\n\n  p5.SoundFile.prototype.duration = function () {\n    if (this.buffer) {\n      return this.buffer.duration;\n    } else {\n      return 0;\n    }\n  };\n  /**\n   * Return the current position of the p5.SoundFile playhead, in seconds.\n   * Time is relative to the normal buffer direction, so if `reverseBuffer`\n   * has been called, currentTime will count backwards.\n   *\n   * @method currentTime\n   * @for p5.SoundFile\n   * @return {Number}   currentTime of the soundFile in seconds.\n   */\n\n\n  p5.SoundFile.prototype.currentTime = function () {\n    return this.reversed ? Math.abs(this._lastPos - this.buffer.length) / ac.sampleRate : this._lastPos / ac.sampleRate;\n  };\n  /**\n   * Move the playhead of a soundfile that is currently playing to a\n   * new position and a new duration, in seconds.\n   * If none are given, will reset the file to play entire duration\n   * from start to finish. To set the position of a soundfile that is\n   * not currently playing, use the `play` or `loop` methods.\n   *\n   * @method jump\n   * @for p5.SoundFile\n   * @param {Number} cueTime    cueTime of the soundFile in seconds.\n   * @param {Number} duration    duration in seconds.\n   */\n\n\n  p5.SoundFile.prototype.jump = function (cueTime, duration) {\n    if (cueTime < 0 || cueTime > this.buffer.duration) {\n      throw 'jump time out of range';\n    }\n\n    if (duration > this.buffer.duration - cueTime) {\n      throw 'end time out of range';\n    }\n\n    var cTime = cueTime || 0;\n    var dur = duration || undefined;\n\n    if (this.isPlaying()) {\n      this.stop(0);\n      this.play(0, this.playbackRate, this.output.gain.value, cTime, dur);\n    }\n  };\n  /**\n    * Return the number of channels in a sound file.\n    * For example, Mono = 1, Stereo = 2.\n    *\n    * @method channels\n    * @for p5.SoundFile\n    * @return {Number} [channels]\n    */\n\n\n  p5.SoundFile.prototype.channels = function () {\n    return this.buffer.numberOfChannels;\n  };\n  /**\n    * Return the sample rate of the sound file.\n    *\n    * @method sampleRate\n    * @for p5.SoundFile\n    * @return {Number} [sampleRate]\n    */\n\n\n  p5.SoundFile.prototype.sampleRate = function () {\n    return this.buffer.sampleRate;\n  };\n  /**\n    * Return the number of samples in a sound file.\n    * Equal to sampleRate * duration.\n    *\n    * @method frames\n    * @for p5.SoundFile\n    * @return {Number} [sampleCount]\n    */\n\n\n  p5.SoundFile.prototype.frames = function () {\n    return this.buffer.length;\n  };\n  /**\n   * Returns an array of amplitude peaks in a p5.SoundFile that can be\n   * used to draw a static waveform. Scans through the p5.SoundFile's\n   * audio buffer to find the greatest amplitudes. Accepts one\n   * parameter, 'length', which determines size of the array.\n   * Larger arrays result in more precise waveform visualizations.\n   *\n   * Inspired by Wavesurfer.js.\n   *\n   * @method  getPeaks\n   * @for p5.SoundFile\n   * @params {Number} [length] length is the size of the returned array.\n   *                          Larger length results in more precision.\n   *                          Defaults to 5*width of the browser window.\n   * @returns {Float32Array} Array of peaks.\n   */\n\n\n  p5.SoundFile.prototype.getPeaks = function (length) {\n    if (this.buffer) {\n      if (!length) {\n        length = window.width * 5;\n      }\n\n      if (this.buffer) {\n        var buffer = this.buffer;\n        var sampleSize = buffer.length / length;\n        var sampleStep = ~~(sampleSize / 10) || 1;\n        var channels = buffer.numberOfChannels;\n        var peaks = new Float32Array(Math.round(length));\n\n        for (var c = 0; c < channels; c++) {\n          var chan = buffer.getChannelData(c);\n\n          for (var i = 0; i < length; i++) {\n            var start = ~~(i * sampleSize);\n            var end = ~~(start + sampleSize);\n            var max = 0;\n\n            for (var j = start; j < end; j += sampleStep) {\n              var value = chan[j];\n\n              if (value > max) {\n                max = value; \n              } else if (-value > max) {\n                max = value;\n              }\n            }\n\n            if (c === 0 || Math.abs(max) > peaks[i]) {\n              peaks[i] = max;\n            }\n          }\n        }\n\n        return peaks;\n      }\n    } else {\n      throw 'Cannot load peaks yet, buffer is not loaded';\n    }\n  };\n  /**\n   *  Reverses the p5.SoundFile's buffer source.\n   *  Playback must be handled separately (see example).\n   *\n   *  @method  reverseBuffer\n   *  @for p5.SoundFile\n   *  @example\n   *  <div><code>\n   *  let drum;\n   *  function preload() {\n   *    drum = loadSound('assets/drum.mp3');\n   *  }\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(canvasPressed);\n   *    background(220);\n   *    text('tap to play', 20, 20);\n   *  }\n   *\n   *  function canvasPressed() {\n   *    drum.stop();\n   *    drum.reverseBuffer();\n   *    drum.play();\n   *  }\n   * </code>\n   * </div>\n   */\n\n\n  p5.SoundFile.prototype.reverseBuffer = function () {\n    if (this.buffer) {\n      var currentPos = this._lastPos / ac.sampleRate;\n      var curVol = this.getVolume();\n      this.setVolume(0, 0.001);\n      var numChannels = this.buffer.numberOfChannels;\n\n      for (var i = 0; i < numChannels; i++) {\n        this.buffer.getChannelData(i).reverse();\n      } \n\n\n      this.reversed = !this.reversed;\n\n      if (this.isPlaying() && currentPos) {\n        this.jump(this.duration() - currentPos);\n      }\n\n      this.setVolume(curVol, 0.001);\n    } else {\n      throw 'SoundFile is not done loading';\n    }\n  };\n  /**\n   *  Schedule an event to be called when the soundfile\n   *  reaches the end of a buffer. If the soundfile is\n   *  playing through once, this will be called when it\n   *  ends. If it is looping, it will be called when\n   *  stop is called.\n   *\n   *  @method  onended\n   *  @for p5.SoundFile\n   *  @param  {Function} callback function to call when the\n   *                              soundfile has ended.\n   */\n\n\n  p5.SoundFile.prototype.onended = function (callback) {\n    this._onended = callback;\n    return this;\n  };\n\n  p5.SoundFile.prototype.add = function () {\n  };\n\n  p5.SoundFile.prototype.dispose = function () {\n    var now = p5sound.audiocontext.currentTime; \n\n    var index = p5sound.soundArray.indexOf(this);\n    p5sound.soundArray.splice(index, 1);\n    this.stop(now);\n\n    if (this.buffer && this.bufferSourceNode) {\n      for (var i = 0; i < this.bufferSourceNodes.length - 1; i++) {\n        if (this.bufferSourceNodes[i] !== null) {\n          this.bufferSourceNodes[i].disconnect();\n\n          try {\n            this.bufferSourceNodes[i].stop(now);\n          } catch (e) {\n            console.warn('no buffer source node to dispose');\n          }\n\n          this.bufferSourceNodes[i] = null;\n        }\n      }\n\n      if (this.isPlaying()) {\n        try {\n          this._counterNode.stop(now);\n        } catch (e) {\n          console.log(e);\n        }\n\n        this._counterNode = null;\n      }\n    }\n\n    if (this.output) {\n      this.output.disconnect();\n      this.output = null;\n    }\n\n    if (this.panner) {\n      this.panner.disconnect();\n      this.panner = null;\n    }\n  };\n  /**\n   * Connects the output of a p5sound object to input of another\n   * p5.sound object. For example, you may connect a p5.SoundFile to an\n   * FFT or an Effect. If no parameter is given, it will connect to\n   * the master output. Most p5sound objects connect to the master\n   * output when they are created.\n   *\n   * @method connect\n   * @for p5.SoundFile\n   * @param {Object} [object] Audio object that accepts an input\n   */\n\n\n  p5.SoundFile.prototype.connect = function (unit) {\n    if (!unit) {\n      this.panner.connect(p5sound.input);\n    } else {\n      if (unit.hasOwnProperty('input')) {\n        this.panner.connect(unit.input);\n      } else {\n        this.panner.connect(unit);\n      }\n    }\n  };\n  /**\n   * Disconnects the output of this p5sound object.\n   *\n   * @method disconnect\n   * @for p5.SoundFile\n   */\n\n\n  p5.SoundFile.prototype.disconnect = function () {\n    if (this.panner) {\n      this.panner.disconnect();\n    }\n  };\n  /**\n   */\n\n\n  p5.SoundFile.prototype.getLevel = function () {\n    console.warn('p5.SoundFile.getLevel has been removed from the library. Use p5.Amplitude instead');\n  };\n  /**\n   *  Reset the source for this SoundFile to a\n   *  new path (URL).\n   *\n   *  @method  setPath\n   *  @for p5.SoundFile\n   *  @param {String}   path     path to audio file\n   *  @param {Function} callback Callback\n   */\n\n\n  p5.SoundFile.prototype.setPath = function (p, callback) {\n    var path = p5.prototype._checkFileFormats(p);\n\n    this.url = path;\n    this.load(callback);\n  };\n  /**\n   *  Replace the current Audio Buffer with a new Buffer.\n   *\n   *  @method setBuffer\n   *  @for p5.SoundFile\n   *  @param {Array} buf Array of Float32 Array(s). 2 Float32 Arrays\n   *                     will create a stereo source. 1 will create\n   *                     a mono source.\n   */\n\n\n  p5.SoundFile.prototype.setBuffer = function (buf) {\n    var numChannels = buf.length;\n    var size = buf[0].length;\n    var newBuffer = ac.createBuffer(numChannels, size, ac.sampleRate);\n\n    if (!(buf[0] instanceof Float32Array)) {\n      buf[0] = new Float32Array(buf[0]);\n    }\n\n    for (var channelNum = 0; channelNum < numChannels; channelNum++) {\n      var channel = newBuffer.getChannelData(channelNum);\n      channel.set(buf[channelNum]);\n    }\n\n    this.buffer = newBuffer; \n\n    this.panner.inputChannels(numChannels);\n  }; \n\n\n  var _createCounterBuffer = function _createCounterBuffer(buffer) {\n    var len = buffer.length;\n    var audioBuf = ac.createBuffer(1, buffer.length, ac.sampleRate);\n    var arrayBuffer = audioBuf.getChannelData(0);\n\n    for (var index = 0; index < len; index++) {\n      arrayBuffer[index] = index;\n    }\n\n    return audioBuf;\n  }; \n\n\n  p5.SoundFile.prototype._initCounterNode = function () {\n    var _this = this;\n\n    var self = this;\n    var now = ac.currentTime;\n    var cNode = ac.createBufferSource();\n    var workletBufferSize = safeBufferSize(256); \n\n    if (self._workletNode) {\n      self._workletNode.disconnect();\n\n      delete self._workletNode;\n    }\n\n    self._workletNode = new AudioWorkletNode(ac, processorNames.soundFileProcessor, {\n      processorOptions: {\n        bufferSize: workletBufferSize\n      }\n    });\n\n    self._workletNode.port.onmessage = function (event) {\n      if (event.data.name === 'position') {\n        if (event.data.position === 0) {\n          return;\n        }\n\n        _this._lastPos = event.data.position; \n\n        _this._onTimeUpdate(self._lastPos);\n      }\n    }; \n\n\n    cNode.buffer = _createCounterBuffer(self.buffer);\n    cNode.playbackRate.setValueAtTime(self.playbackRate, now);\n    cNode.connect(self._workletNode);\n\n    self._workletNode.connect(p5.soundOut._silentNode);\n\n    return cNode;\n  }; \n\n\n  p5.SoundFile.prototype._initSourceNode = function () {\n    var bufferSourceNode = ac.createBufferSource();\n    bufferSourceNode.buffer = this.buffer;\n    bufferSourceNode.playbackRate.value = this.playbackRate;\n    bufferSourceNode.connect(this.output);\n    return bufferSourceNode;\n  };\n  /**\n   *  processPeaks returns an array of timestamps where it thinks there is a beat.\n   *\n   *  This is an asynchronous function that processes the soundfile in an offline audio context,\n   *  and sends the results to your callback function.\n   *\n   *  The process involves running the soundfile through a lowpass filter, and finding all of the\n   *  peaks above the initial threshold. If the total number of peaks are below the minimum number of peaks,\n   *  it decreases the threshold and re-runs the analysis until either minPeaks or minThreshold are reached.\n   *\n   *  @method  processPeaks\n   *  @for p5.SoundFile\n   *  @param  {Function} callback       a function to call once this data is returned\n   *  @param  {Number}   [initThreshold] initial threshold defaults to 0.9\n   *  @param  {Number}   [minThreshold]   minimum threshold defaults to 0.22\n   *  @param  {Number}   [minPeaks]       minimum number of peaks defaults to 200\n   *  @return {Array}                  Array of timestamped peaks\n   */\n\n\n  p5.SoundFile.prototype.processPeaks = function (callback, _initThreshold, _minThreshold, _minPeaks) {\n    var bufLen = this.buffer.length;\n    var sampleRate = this.buffer.sampleRate;\n    var buffer = this.buffer;\n    var allPeaks = [];\n    var initialThreshold = _initThreshold || 0.9,\n        threshold = initialThreshold,\n        minThreshold = _minThreshold || 0.22,\n        minPeaks = _minPeaks || 200; \n\n    var offlineContext = new window.OfflineAudioContext(1, bufLen, sampleRate); \n\n    var source = offlineContext.createBufferSource();\n    source.buffer = buffer; \n\n    var filter = offlineContext.createBiquadFilter();\n    filter.type = 'lowpass';\n    source.connect(filter);\n    filter.connect(offlineContext.destination); \n\n    source.start(0);\n    offlineContext.startRendering(); \n\n    offlineContext.oncomplete = function (e) {\n      if (!self.panner) return;\n      var filteredBuffer = e.renderedBuffer;\n      var bufferData = filteredBuffer.getChannelData(0); \n\n      do {\n        allPeaks = getPeaksAtThreshold(bufferData, threshold);\n        threshold -= 0.005;\n      } while (Object.keys(allPeaks).length < minPeaks && threshold >= minThreshold); \n\n\n      var intervalCounts = countIntervalsBetweenNearbyPeaks(allPeaks); \n\n      var groups = groupNeighborsByTempo(intervalCounts, filteredBuffer.sampleRate); \n\n      var topTempos = groups.sort(function (intA, intB) {\n        return intB.count - intA.count;\n      }).splice(0, 5); \n\n      this.tempo = topTempos[0].tempo; \n\n      var bpmVariance = 5;\n      var tempoPeaks = getPeaksAtTopTempo(allPeaks, topTempos[0].tempo, filteredBuffer.sampleRate, bpmVariance);\n      callback(tempoPeaks);\n    };\n  }; \n\n\n  var Peak = function Peak(amp, i) {\n    this.sampleIndex = i;\n    this.amplitude = amp;\n    this.tempos = [];\n    this.intervals = [];\n  }; \n\n\n  function getPeaksAtThreshold(data, threshold) {\n    var peaksObj = {};\n    var length = data.length;\n\n    for (var i = 0; i < length; i++) {\n      if (data[i] > threshold) {\n        var amp = data[i];\n        var peak = new Peak(amp, i);\n        peaksObj[i] = peak; \n\n        i += 6000;\n      }\n\n      i++;\n    }\n\n    return peaksObj;\n  } \n\n\n  function countIntervalsBetweenNearbyPeaks(peaksObj) {\n    var intervalCounts = [];\n    var peaksArray = Object.keys(peaksObj).sort();\n\n    for (var index = 0; index < peaksArray.length; index++) {\n      for (var i = 0; i < 10; i++) {\n        var startPeak = peaksObj[peaksArray[index]];\n        var endPeak = peaksObj[peaksArray[index + i]];\n\n        if (startPeak && endPeak) {\n          var startPos = startPeak.sampleIndex;\n          var endPos = endPeak.sampleIndex;\n          var interval = endPos - startPos; \n\n          if (interval > 0) {\n            startPeak.intervals.push(interval);\n          } \n\n\n          var foundInterval = intervalCounts.some(function (intervalCount) {\n            if (intervalCount.interval === interval) {\n              intervalCount.count++;\n              return intervalCount;\n            }\n          }); \n\n          if (!foundInterval) {\n            intervalCounts.push({\n              interval: interval,\n              count: 1\n            });\n          }\n        }\n      }\n    }\n\n    return intervalCounts;\n  } \n\n\n  function groupNeighborsByTempo(intervalCounts, sampleRate) {\n    var tempoCounts = [];\n    intervalCounts.forEach(function (intervalCount) {\n      try {\n        var theoreticalTempo = Math.abs(60 / (intervalCount.interval / sampleRate));\n        theoreticalTempo = mapTempo(theoreticalTempo);\n        var foundTempo = tempoCounts.some(function (tempoCount) {\n          if (tempoCount.tempo === theoreticalTempo) return tempoCount.count += intervalCount.count;\n        });\n\n        if (!foundTempo) {\n          if (isNaN(theoreticalTempo)) {\n            return;\n          }\n\n          tempoCounts.push({\n            tempo: Math.round(theoreticalTempo),\n            count: intervalCount.count\n          });\n        }\n      } catch (e) {\n        throw e;\n      }\n    });\n    return tempoCounts;\n  } \n\n\n  function getPeaksAtTopTempo(peaksObj, tempo, sampleRate, bpmVariance) {\n    var peaksAtTopTempo = [];\n    var peaksArray = Object.keys(peaksObj).sort(); \n\n    for (var i = 0; i < peaksArray.length; i++) {\n      var key = peaksArray[i];\n      var peak = peaksObj[key];\n\n      for (var j = 0; j < peak.intervals.length; j++) {\n        var intervalBPM = Math.round(Math.abs(60 / (peak.intervals[j] / sampleRate)));\n        intervalBPM = mapTempo(intervalBPM);\n\n        if (Math.abs(intervalBPM - tempo) < bpmVariance) {\n          peaksAtTopTempo.push(peak.sampleIndex / sampleRate);\n        }\n      }\n    } \n\n\n    peaksAtTopTempo = peaksAtTopTempo.filter(function (peakTime, index, arr) {\n      var dif = arr[index + 1] - peakTime;\n\n      if (dif > 0.01) {\n        return true;\n      }\n    });\n    return peaksAtTopTempo;\n  } \n\n\n  function mapTempo(theoreticalTempo) {\n    if (!isFinite(theoreticalTempo) || theoreticalTempo === 0) {\n      return;\n    } \n\n\n    while (theoreticalTempo < 90) {\n      theoreticalTempo *= 2;\n    }\n\n    while (theoreticalTempo > 180 && theoreticalTempo > 90) {\n      theoreticalTempo /= 2;\n    }\n\n    return theoreticalTempo;\n  }\n\n\n  var Cue = function Cue(callback, time, id, val) {\n    this.callback = callback;\n    this.time = time;\n    this.id = id;\n    this.val = val;\n  };\n  /**\n   *  Schedule events to trigger every time a MediaElement\n   *  (audio/video) reaches a playback cue point.\n   *\n   *  Accepts a callback function, a time (in seconds) at which to trigger\n   *  the callback, and an optional parameter for the callback.\n   *\n   *  Time will be passed as the first parameter to the callback function,\n   *  and param will be the second parameter.\n   *\n   *\n   *  @method  addCue\n   *  @for p5.SoundFile\n   *  @param {Number}   time     Time in seconds, relative to this media\n   *                             element's playback. For example, to trigger\n   *                             an event every time playback reaches two\n   *                             seconds, pass in the number 2. This will be\n   *                             passed as the first parameter to\n   *                             the callback function.\n   *  @param {Function} callback Name of a function that will be\n   *                             called at the given time. The callback will\n   *                             receive time and (optionally) param as its\n   *                             two parameters.\n   *  @param {Object} [value]    An object to be passed as the\n   *                             second parameter to the\n   *                             callback function.\n   *  @return {Number} id ID of this cue,\n   *                      useful for removeCue(id)\n   *  @example\n   *  <div><code>\n   *  let mySound;\n   *  function preload() {\n   *    mySound = loadSound('assets/Damscray_DancingTiger.mp3');\n   *  }\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(canvasPressed);\n   *    background(220);\n   *    text('tap to play', 10, 20);\n   *\n   *    // schedule calls to changeText\n   *    mySound.addCue(0, changeText, \"hello\" );\n   *    mySound.addCue(0.5, changeText, \"hello,\" );\n   *    mySound.addCue(1, changeText, \"hello, p5!\");\n   *    mySound.addCue(1.5, changeText, \"hello, p5!!\");\n   *    mySound.addCue(2, changeText, \"hello, p5!!!!!\");\n   *  }\n   *\n   *  function changeText(val) {\n   *    background(220);\n   *    text(val, 10, 20);\n   *  }\n   *\n   *  function canvasPressed() {\n   *    mySound.play();\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.SoundFile.prototype.addCue = function (time, callback, val) {\n    var id = this._cueIDCounter++;\n    var cue = new Cue(callback, time, id, val);\n\n    this._cues.push(cue); \n\n\n    return id;\n  };\n  /**\n   *  Remove a callback based on its ID. The ID is returned by the\n   *  addCue method.\n   *\n   *  @method removeCue\n   *  @for p5.SoundFile\n   *  @param  {Number} id ID of the cue, as returned by addCue\n   */\n\n\n  p5.SoundFile.prototype.removeCue = function (id) {\n    var cueLength = this._cues.length;\n\n    for (var i = 0; i < cueLength; i++) {\n      var cue = this._cues[i];\n\n      if (cue.id === id) {\n        this._cues.splice(i, 1);\n\n        break;\n      }\n    }\n\n    if (this._cues.length === 0) {\n    }\n  };\n  /**\n   *  Remove all of the callbacks that had originally been scheduled\n   *  via the addCue method.\n   *\n   *  @method  clearCues\n   */\n\n\n  p5.SoundFile.prototype.clearCues = function () {\n    this._cues = []; \n  }; \n\n\n  p5.SoundFile.prototype._onTimeUpdate = function (position) {\n    var playbackTime = position / this.buffer.sampleRate;\n    var cueLength = this._cues.length;\n\n    for (var i = 0; i < cueLength; i++) {\n      var cue = this._cues[i];\n      var callbackTime = cue.time;\n      var val = cue.val;\n\n      if (~~this._prevUpdateTime <= callbackTime && callbackTime <= playbackTime) {\n        cue.callback(val);\n      }\n    }\n\n    this._prevUpdateTime = playbackTime;\n  };\n  /**\n   * Save a p5.SoundFile as a .wav file. The browser will prompt the user\n   * to download the file to their device. To upload a file to a server, see\n   * <a href=\"/docs/reference/#/p5.SoundFile/getBlob\">getBlob</a>\n   *\n   * @method save\n   * @for p5.SoundFile\n   * @param  {String} [fileName]      name of the resulting .wav file.\n   * @example\n   *  <div><code>\n   *  let mySound;\n   *  function preload() {\n   *    mySound = loadSound('assets/doorbell.mp3');\n   *  }\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(canvasPressed);\n   *    background(220);\n   *    text('tap to download', 10, 20);\n   *  }\n   *\n   *  function canvasPressed() {\n   *    mySound.save('my cool filename');\n   *  }\n   * </code></div>\n   */\n\n\n  p5.SoundFile.prototype.save = function (fileName) {\n    p5.prototype.saveSound(this, fileName, 'wav');\n  };\n  /**\n   * This method is useful for sending a SoundFile to a server. It returns the\n   * .wav-encoded audio data as a \"<a target=\"_blank\" title=\"Blob reference at\n   * MDN\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/Blob\">Blob</a>\".\n   * A Blob is a file-like data object that can be uploaded to a server\n   * with an <a href=\"/docs/reference/#/p5/httpDo\">http</a> request. We'll\n   * use the `httpDo` options object to send a POST request with some\n   * specific options: we encode the request as `multipart/form-data`,\n   * and attach the blob as one of the form values using `FormData`.\n   *\n   *\n   * @method getBlob\n   * @for p5.SoundFile\n   * @returns {Blob} A file-like data object\n   * @example\n   *  <div><code>\n   *  function preload() {\n   *    mySound = loadSound('assets/doorbell.mp3');\n   *  }\n   *\n   *  function setup() {\n   *    noCanvas();\n   *    let soundBlob = mySound.getBlob();\n   *\n   *    // Now we can send the blob to a server...\n   *    let serverUrl = 'https://jsonplaceholder.typicode.com/posts';\n   *    let httpRequestOptions = {\n   *      method: 'POST',\n   *      body: new FormData().append('soundBlob', soundBlob),\n   *      headers: new Headers({\n   *        'Content-Type': 'multipart/form-data'\n   *      })\n   *    };\n   *    httpDo(serverUrl, httpRequestOptions);\n   *\n   *    // We can also create an `ObjectURL` pointing to the Blob\n   *    let blobUrl = URL.createObjectURL(soundBlob);\n   *\n   *    // The `<Audio>` Element accepts Object URL's\n   *    createAudio(blobUrl).showControls();\n   *\n   *    createDiv();\n   *\n   *    // The ObjectURL exists as long as this tab is open\n   *    let input = createInput(blobUrl);\n   *    input.attribute('readonly', true);\n   *    input.mouseClicked(function() { input.elt.select() });\n   *  }\n   *\n   * </code></div>\n   */\n\n\n  p5.SoundFile.prototype.getBlob = function () {\n    var dataView = convertToWav(this.buffer);\n    return new Blob([dataView], {\n      type: 'audio/wav'\n    });\n  }; \n\n\n  function _clearOnEnd(e) {\n    var thisBufferSourceNode = e.target;\n    var soundFile = this; \n\n    thisBufferSourceNode._playing = false;\n    thisBufferSourceNode.removeEventListener('ended', soundFile._clearOnEnd); \n\n    soundFile._onended(soundFile); \n\n\n    soundFile.bufferSourceNodes.map(function (_, i) {\n      return i;\n    }).reverse().forEach(function (i) {\n      var n = soundFile.bufferSourceNodes[i];\n\n      if (n._playing === false) {\n        soundFile.bufferSourceNodes.splice(i, 1);\n      }\n    });\n\n    if (soundFile.bufferSourceNodes.length === 0) {\n      soundFile._playing = false;\n    }\n  }\n}).call(exports, __nested_webpack_require_181024__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_234416__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_234416__(1);\n\n  var _require = __nested_webpack_require_234416__(6),\n      safeBufferSize = _require.safeBufferSize;\n\n  var processorNames = __nested_webpack_require_234416__(10);\n  /**\n   *  Amplitude measures volume between 0.0 and 1.0.\n   *  Listens to all p5sound by default, or use setInput()\n   *  to listen to a specific sound source. Accepts an optional\n   *  smoothing value, which defaults to 0.\n   *\n   *  @class p5.Amplitude\n   *  @constructor\n   *  @param {Number} [smoothing] between 0.0 and .999 to smooth\n   *                             amplitude readings (defaults to 0)\n   *  @example\n   *  <div><code>\n   *  let sound, amplitude;\n   *\n   *  function preload(){\n   *    sound = loadSound('assets/beat.mp3');\n   *  }\n   *  function setup() {\n   *    let cnv = createCanvas(100,100);\n   *    cnv.mouseClicked(toggleSound);\n   *    amplitude = new p5.Amplitude();\n   *  }\n   *\n   *  function draw() {\n   *    background(220);\n   *    text('tap to play', 20, 20);\n   *\n   *    let level = amplitude.getLevel();\n   *    let size = map(level, 0, 1, 0, 200);\n   *    ellipse(width/2, height/2, size, size);\n   *  }\n   *\n   *  function toggleSound() {\n   *    if (sound.isPlaying() ){\n   *      sound.stop();\n   *    } else {\n   *      sound.play();\n   *    }\n   *  }\n   *\n   *  </code></div>\n   */\n\n\n  p5.Amplitude = function (smoothing) {\n    this.bufferSize = safeBufferSize(2048); \n\n    this.audiocontext = p5sound.audiocontext;\n    this._workletNode = new AudioWorkletNode(this.audiocontext, processorNames.amplitudeProcessor, {\n      outputChannelCount: [1],\n      parameterData: {\n        smoothing: smoothing || 0\n      },\n      processorOptions: {\n        normalize: false,\n        smoothing: smoothing || 0,\n        numInputChannels: 2,\n        bufferSize: this.bufferSize\n      }\n    });\n\n    this._workletNode.port.onmessage = function (event) {\n      if (event.data.name === 'amplitude') {\n        this.volume = event.data.volume;\n        this.volNorm = event.data.volNorm;\n        this.stereoVol = event.data.stereoVol;\n        this.stereoVolNorm = event.data.stereoVolNorm;\n      }\n    }.bind(this); \n\n\n    this.input = this._workletNode;\n    this.output = this.audiocontext.createGain(); \n\n    this.volume = 0;\n    this.volNorm = 0;\n    this.stereoVol = [0, 0];\n    this.stereoVolNorm = [0, 0];\n    this.normalize = false;\n\n    this._workletNode.connect(this.output);\n\n    this.output.gain.value = 0; \n\n    this.output.connect(this.audiocontext.destination); \n\n    p5sound.meter.connect(this._workletNode); \n\n    p5sound.soundArray.push(this);\n  };\n  /**\n   *  Connects to the p5sound instance (master output) by default.\n   *  Optionally, you can pass in a specific source (i.e. a soundfile).\n   *\n   *  @method setInput\n   *  @for p5.Amplitude\n   *  @param {soundObject|undefined} [snd] set the sound source\n   *                                       (optional, defaults to\n   *                                       master output)\n   *  @param {Number|undefined} [smoothing] a range between 0.0 and 1.0\n   *                                        to smooth amplitude readings\n   *  @example\n   *  <div><code>\n   *  function preload(){\n   *    sound1 = loadSound('assets/beat.mp3');\n   *    sound2 = loadSound('assets/drum.mp3');\n   *  }\n   *  function setup(){\n   *    cnv = createCanvas(100, 100);\n   *    cnv.mouseClicked(toggleSound);\n   *\n   *    amplitude = new p5.Amplitude();\n   *    amplitude.setInput(sound2);\n   *  }\n   *\n   *  function draw() {\n   *    background(220);\n   *    text('tap to play', 20, 20);\n   *\n   *    let level = amplitude.getLevel();\n   *    let size = map(level, 0, 1, 0, 200);\n   *    ellipse(width/2, height/2, size, size);\n   *  }\n   *\n   *  function toggleSound(){\n   *    if (sound1.isPlaying() && sound2.isPlaying()) {\n   *      sound1.stop();\n   *      sound2.stop();\n   *    } else {\n   *      sound1.play();\n   *      sound2.play();\n   *    }\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.Amplitude.prototype.setInput = function (source, smoothing) {\n    p5sound.meter.disconnect();\n\n    if (smoothing) {\n      this._workletNode.parameters.get('smoothing').value = smoothing;\n    } \n\n\n    if (source == null) {\n      console.log('Amplitude input source is not ready! Connecting to master output instead');\n      p5sound.meter.connect(this._workletNode);\n    } \n    else if (source instanceof p5.Signal) {\n        source.output.connect(this._workletNode);\n      } \n      else if (source) {\n          source.connect(this._workletNode);\n\n          this._workletNode.disconnect();\n\n          this._workletNode.connect(this.output);\n        } \n        else {\n            p5sound.meter.connect(this._workletNode);\n          }\n  };\n\n  p5.Amplitude.prototype.connect = function (unit) {\n    if (unit) {\n      if (unit.hasOwnProperty('input')) {\n        this.output.connect(unit.input);\n      } else {\n        this.output.connect(unit);\n      }\n    } else {\n      this.output.connect(this.panner.connect(p5sound.input));\n    }\n  };\n\n  p5.Amplitude.prototype.disconnect = function () {\n    if (this.output) {\n      this.output.disconnect();\n    }\n  };\n  /**\n   *  Returns a single Amplitude reading at the moment it is called.\n   *  For continuous readings, run in the draw loop.\n   *\n   *  @method getLevel\n   *  @for p5.Amplitude\n   *  @param {Number} [channel] Optionally return only channel 0 (left) or 1 (right)\n   *  @return {Number}       Amplitude as a number between 0.0 and 1.0\n   *  @example\n   *  <div><code>\n   *  function preload(){\n   *    sound = loadSound('assets/beat.mp3');\n   *  }\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mouseClicked(toggleSound);\n   *    amplitude = new p5.Amplitude();\n   *  }\n   *\n   *  function draw() {\n   *    background(220, 150);\n   *    textAlign(CENTER);\n   *    text('tap to play', width/2, 20);\n   *\n   *    let level = amplitude.getLevel();\n   *    let size = map(level, 0, 1, 0, 200);\n   *    ellipse(width/2, height/2, size, size);\n   *  }\n   *\n   *  function toggleSound(){\n   *    if (sound.isPlaying()) {\n   *      sound.stop();\n   *    } else {\n   *      sound.play();\n   *    }\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.Amplitude.prototype.getLevel = function (channel) {\n    if (typeof channel !== 'undefined') {\n      if (this.normalize) {\n        return this.stereoVolNorm[channel];\n      } else {\n        return this.stereoVol[channel];\n      }\n    } else if (this.normalize) {\n      return this.volNorm;\n    } else {\n      return this.volume;\n    }\n  };\n  /**\n   * Determines whether the results of Amplitude.process() will be\n   * Normalized. To normalize, Amplitude finds the difference the\n   * loudest reading it has processed and the maximum amplitude of\n   * 1.0. Amplitude adds this difference to all values to produce\n   * results that will reliably map between 0.0 and 1.0. However,\n   * if a louder moment occurs, the amount that Normalize adds to\n   * all the values will change. Accepts an optional boolean parameter\n   * (true or false). Normalizing is off by default.\n   *\n   * @method toggleNormalize\n   * @for p5.Amplitude\n   * @param {boolean} [boolean] set normalize to true (1) or false (0)\n   */\n\n\n  p5.Amplitude.prototype.toggleNormalize = function (bool) {\n    if (typeof bool === 'boolean') {\n      this.normalize = bool;\n    } else {\n      this.normalize = !this.normalize;\n    }\n\n    this._workletNode.port.postMessage({\n      name: 'toggleNormalize',\n      normalize: this.normalize\n    });\n  };\n  /**\n   *  Smooth Amplitude analysis by averaging with the last analysis\n   *  frame. Off by default.\n   *\n   *  @method smooth\n   *  @for p5.Amplitude\n   *  @param {Number} set smoothing from 0.0 <= 1\n   */\n\n\n  p5.Amplitude.prototype.smooth = function (s) {\n    if (s >= 0 && s < 1) {\n      this._workletNode.port.postMessage({\n        name: 'smoothing',\n        smoothing: s\n      });\n    } else {\n      console.log('Error: smoothing must be between 0 and 1');\n    }\n  };\n\n  p5.Amplitude.prototype.dispose = function () {\n    var index = p5sound.soundArray.indexOf(this);\n    p5sound.soundArray.splice(index, 1);\n\n    if (this.input) {\n      this.input.disconnect();\n      delete this.input;\n    }\n\n    if (this.output) {\n      this.output.disconnect();\n      delete this.output;\n    }\n\n    this._workletNode.disconnect();\n\n    delete this._workletNode;\n  };\n}).call(exports, __nested_webpack_require_234416__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_243082__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_243082__(1);\n  /**\n   *  <p>FFT (Fast Fourier Transform) is an analysis algorithm that\n   *  isolates individual\n   *  <a href=\"https://en.wikipedia.org/wiki/Audio_frequency\">\n   *  audio frequencies</a> within a waveform.</p>\n   *\n   *  <p>Once instantiated, a p5.FFT object can return an array based on\n   *  two types of analyses: <br> • <code>FFT.waveform()</code> computes\n   *  amplitude values along the time domain. The array indices correspond\n   *  to samples across a brief moment in time. Each value represents\n   *  amplitude of the waveform at that sample of time.<br>\n   *  • <code>FFT.analyze() </code> computes amplitude values along the\n   *  frequency domain. The array indices correspond to frequencies (i.e.\n   *  pitches), from the lowest to the highest that humans can hear. Each\n   *  value represents amplitude at that slice of the frequency spectrum.\n   *  Use with <code>getEnergy()</code> to measure amplitude at specific\n   *  frequencies, or within a range of frequencies. </p>\n   *\n   *  <p>FFT analyzes a very short snapshot of sound called a sample\n   *  buffer. It returns an array of amplitude measurements, referred\n   *  to as <code>bins</code>. The array is 1024 bins long by default.\n   *  You can change the bin array length, but it must be a power of 2\n   *  between 16 and 1024 in order for the FFT algorithm to function\n   *  correctly. The actual size of the FFT buffer is twice the\n   *  number of bins, so given a standard sample rate, the buffer is\n   *  2048/44100 seconds long.</p>\n   *\n   *\n   *  @class p5.FFT\n   *  @constructor\n   *  @param {Number} [smoothing]   Smooth results of Freq Spectrum.\n   *                                0.0 < smoothing < 1.0.\n   *                                Defaults to 0.8.\n   *  @param {Number} [bins]    Length of resulting array.\n   *                            Must be a power of two between\n   *                            16 and 1024. Defaults to 1024.\n   *  @example\n   *  <div><code>\n   *  function preload(){\n   *    sound = loadSound('assets/Damscray_DancingTiger.mp3');\n   *  }\n   *\n   *  function setup(){\n   *    let cnv = createCanvas(100,100);\n   *    cnv.mouseClicked(togglePlay);\n   *    fft = new p5.FFT();\n   *    sound.amp(0.2);\n   *  }\n   *\n   *  function draw(){\n   *    background(220);\n   *\n   *    let spectrum = fft.analyze();\n   *    noStroke();\n   *    fill(255, 0, 255);\n   *    for (let i = 0; i< spectrum.length; i++){\n   *      let x = map(i, 0, spectrum.length, 0, width);\n   *      let h = -height + map(spectrum[i], 0, 255, height, 0);\n   *      rect(x, height, width / spectrum.length, h )\n   *    }\n   *\n   *    let waveform = fft.waveform();\n   *    noFill();\n   *    beginShape();\n   *    stroke(20);\n   *    for (let i = 0; i < waveform.length; i++){\n   *      let x = map(i, 0, waveform.length, 0, width);\n   *      let y = map( waveform[i], -1, 1, 0, height);\n   *      vertex(x,y);\n   *    }\n   *    endShape();\n   *\n   *    text('tap to play', 20, 20);\n   *  }\n   *\n   *  function togglePlay() {\n   *    if (sound.isPlaying()) {\n   *      sound.pause();\n   *    } else {\n   *      sound.loop();\n   *    }\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.FFT = function (smoothing, bins) {\n    this.input = this.analyser = p5sound.audiocontext.createAnalyser();\n    Object.defineProperties(this, {\n      bins: {\n        get: function get() {\n          return this.analyser.fftSize / 2;\n        },\n        set: function set(b) {\n          this.analyser.fftSize = b * 2;\n        },\n        configurable: true,\n        enumerable: true\n      },\n      smoothing: {\n        get: function get() {\n          return this.analyser.smoothingTimeConstant;\n        },\n        set: function set(s) {\n          this.analyser.smoothingTimeConstant = s;\n        },\n        configurable: true,\n        enumerable: true\n      }\n    }); \n\n    this.smooth(smoothing);\n    this.bins = bins || 1024; \n\n    p5sound.fftMeter.connect(this.analyser);\n    this.freqDomain = new Uint8Array(this.analyser.frequencyBinCount);\n    this.timeDomain = new Uint8Array(this.analyser.frequencyBinCount); \n\n    this.bass = [20, 140];\n    this.lowMid = [140, 400];\n    this.mid = [400, 2600];\n    this.highMid = [2600, 5200];\n    this.treble = [5200, 14000]; \n\n    p5sound.soundArray.push(this);\n  };\n  /**\n   *  Set the input source for the FFT analysis. If no source is\n   *  provided, FFT will analyze all sound in the sketch.\n   *\n   *  @method  setInput\n   *  @for p5.FFT\n   *  @param {Object} [source] p5.sound object (or web audio API source node)\n   */\n\n\n  p5.FFT.prototype.setInput = function (source) {\n    if (!source) {\n      p5sound.fftMeter.connect(this.analyser);\n    } else {\n      if (source.output) {\n        source.output.connect(this.analyser);\n      } else if (source.connect) {\n        source.connect(this.analyser);\n      }\n\n      p5sound.fftMeter.disconnect();\n    }\n  };\n  /**\n   *  Returns an array of amplitude values (between -1.0 and +1.0) that represent\n   *  a snapshot of amplitude readings in a single buffer. Length will be\n   *  equal to bins (defaults to 1024). Can be used to draw the waveform\n   *  of a sound.\n   *\n   *  @method waveform\n   *  @for p5.FFT\n   *  @param {Number} [bins]    Must be a power of two between\n   *                            16 and 1024. Defaults to 1024.\n   *  @param {String} [precision] If any value is provided, will return results\n   *                              in a Float32 Array which is more precise\n   *                              than a regular array.\n   *  @return {Array}  Array    Array of amplitude values (-1 to 1)\n   *                            over time. Array length = bins.\n   *\n   */\n\n\n  p5.FFT.prototype.waveform = function () {\n    var bins, mode, normalArray;\n\n    for (var i = 0; i < arguments.length; i++) {\n      if (typeof arguments[i] === 'number') {\n        bins = arguments[i];\n        this.analyser.fftSize = bins * 2;\n      }\n\n      if (typeof arguments[i] === 'string') {\n        mode = arguments[i];\n      }\n    } \n\n\n    if (mode && !p5.prototype._isSafari()) {\n      timeToFloat(this, this.timeDomain);\n      this.analyser.getFloatTimeDomainData(this.timeDomain);\n      return this.timeDomain;\n    } else {\n      timeToInt(this, this.timeDomain);\n      this.analyser.getByteTimeDomainData(this.timeDomain);\n      var normalArray = new Array();\n\n      for (var j = 0; j < this.timeDomain.length; j++) {\n        var scaled = p5.prototype.map(this.timeDomain[j], 0, 255, -1, 1);\n        normalArray.push(scaled);\n      }\n\n      return normalArray;\n    }\n  };\n  /**\n   *  Returns an array of amplitude values (between 0 and 255)\n   *  across the frequency spectrum. Length is equal to FFT bins\n   *  (1024 by default). The array indices correspond to frequencies\n   *  (i.e. pitches), from the lowest to the highest that humans can\n   *  hear. Each value represents amplitude at that slice of the\n   *  frequency spectrum. Must be called prior to using\n   *  <code>getEnergy()</code>.\n   *\n   *  @method analyze\n   *  @for p5.FFT\n   *  @param {Number} [bins]    Must be a power of two between\n   *                             16 and 1024. Defaults to 1024.\n   *  @param {Number} [scale]    If \"dB,\" returns decibel\n   *                             float measurements between\n   *                             -140 and 0 (max).\n   *                             Otherwise returns integers from 0-255.\n   *  @return {Array} spectrum    Array of energy (amplitude/volume)\n   *                              values across the frequency spectrum.\n   *                              Lowest energy (silence) = 0, highest\n   *                              possible is 255.\n   *  @example\n   *  <div><code>\n   *  let osc, fft;\n   *\n   *  function setup(){\n   *    let cnv = createCanvas(100,100);\n   *    cnv.mousePressed(startSound);\n   *    osc = new p5.Oscillator();\n   *    osc.amp(0);\n   *    fft = new p5.FFT();\n   *  }\n   *\n   *  function draw(){\n   *    background(220);\n   *\n   *    let freq = map(mouseX, 0, windowWidth, 20, 10000);\n   *    freq = constrain(freq, 1, 20000);\n   *    osc.freq(freq);\n   *\n   *    let spectrum = fft.analyze();\n   *    noStroke();\n   *    fill(255, 0, 255);\n   *    for (let i = 0; i< spectrum.length; i++){\n   *      let x = map(i, 0, spectrum.length, 0, width);\n   *      let h = -height + map(spectrum[i], 0, 255, height, 0);\n   *      rect(x, height, width / spectrum.length, h );\n   *    }\n   *\n   *    stroke(255);\n   *    if (!osc.started) {\n   *      text('tap here and drag to change frequency', 10, 20, width - 20);\n   *    } else {\n   *      text(round(freq)+'Hz', 10, 20);\n   *    }\n   *  }\n   *\n   *  function startSound() {\n   *    osc.start();\n   *    osc.amp(0.5, 0.2);\n   *  }\n   *\n   *  function mouseReleased() {\n   *    osc.amp(0, 0.2);\n   *  }\n   *  </code></div>\n   *\n   *\n   */\n\n\n  p5.FFT.prototype.analyze = function () {\n    var mode;\n\n    for (var i = 0; i < arguments.length; i++) {\n      if (typeof arguments[i] === 'number') {\n        this.bins = arguments[i];\n        this.analyser.fftSize = this.bins * 2;\n      }\n\n      if (typeof arguments[i] === 'string') {\n        mode = arguments[i];\n      }\n    }\n\n    if (mode && mode.toLowerCase() === 'db') {\n      freqToFloat(this);\n      this.analyser.getFloatFrequencyData(this.freqDomain);\n      return this.freqDomain;\n    } else {\n      freqToInt(this, this.freqDomain);\n      this.analyser.getByteFrequencyData(this.freqDomain);\n      var normalArray = Array.apply([], this.freqDomain);\n      return normalArray;\n    }\n  };\n  /**\n   *  Returns the amount of energy (volume) at a specific\n   *  <a href=\"https://en.wikipedia.org/wiki/Audio_frequency\" target=\"_blank\">\n   *  frequency</a>, or the average amount of energy between two\n   *  frequencies. Accepts Number(s) corresponding\n   *  to frequency (in Hz), or a String corresponding to predefined\n   *  frequency ranges (\"bass\", \"lowMid\", \"mid\", \"highMid\", \"treble\").\n   *  Returns a range between 0 (no energy/volume at that frequency) and\n   *  255 (maximum energy).\n   *  <em>NOTE: analyze() must be called prior to getEnergy(). Analyze()\n   *  tells the FFT to analyze frequency data, and getEnergy() uses\n   *  the results determine the value at a specific frequency or\n   *  range of frequencies.</em></p>\n   *\n   *  @method  getEnergy\n   *  @for p5.FFT\n   *  @param  {Number|String} frequency1   Will return a value representing\n   *                                energy at this frequency. Alternately,\n   *                                the strings \"bass\", \"lowMid\" \"mid\",\n   *                                \"highMid\", and \"treble\" will return\n   *                                predefined frequency ranges.\n   *  @param  {Number} [frequency2] If a second frequency is given,\n   *                                will return average amount of\n   *                                energy that exists between the\n   *                                two frequencies.\n   *  @return {Number}   Energy   Energy (volume/amplitude) from\n   *                              0 and 255.\n   *\n   */\n\n\n  p5.FFT.prototype.getEnergy = function (frequency1, frequency2) {\n    var nyquist = p5sound.audiocontext.sampleRate / 2;\n\n    if (frequency1 === 'bass') {\n      frequency1 = this.bass[0];\n      frequency2 = this.bass[1];\n    } else if (frequency1 === 'lowMid') {\n      frequency1 = this.lowMid[0];\n      frequency2 = this.lowMid[1];\n    } else if (frequency1 === 'mid') {\n      frequency1 = this.mid[0];\n      frequency2 = this.mid[1];\n    } else if (frequency1 === 'highMid') {\n      frequency1 = this.highMid[0];\n      frequency2 = this.highMid[1];\n    } else if (frequency1 === 'treble') {\n      frequency1 = this.treble[0];\n      frequency2 = this.treble[1];\n    }\n\n    if (typeof frequency1 !== 'number') {\n      throw 'invalid input for getEnergy()';\n    } else if (!frequency2) {\n      var index = Math.round(frequency1 / nyquist * this.freqDomain.length);\n      return this.freqDomain[index];\n    } else if (frequency1 && frequency2) {\n      if (frequency1 > frequency2) {\n        var swap = frequency2;\n        frequency2 = frequency1;\n        frequency1 = swap;\n      }\n\n      var lowIndex = Math.round(frequency1 / nyquist * this.freqDomain.length);\n      var highIndex = Math.round(frequency2 / nyquist * this.freqDomain.length);\n      var total = 0;\n      var numFrequencies = 0; \n\n      for (var i = lowIndex; i <= highIndex; i++) {\n        total += this.freqDomain[i];\n        numFrequencies += 1;\n      } \n\n\n      var toReturn = total / numFrequencies;\n      return toReturn;\n    } else {\n      throw 'invalid input for getEnergy()';\n    }\n  }; \n\n\n  p5.FFT.prototype.getFreq = function (freq1, freq2) {\n    console.log('getFreq() is deprecated. Please use getEnergy() instead.');\n    var x = this.getEnergy(freq1, freq2);\n    return x;\n  };\n  /**\n   *  Returns the\n   *  <a href=\"http://en.wikipedia.org/wiki/Spectral_centroid\" target=\"_blank\">\n   *  spectral centroid</a> of the input signal.\n   *  <em>NOTE: analyze() must be called prior to getCentroid(). Analyze()\n   *  tells the FFT to analyze frequency data, and getCentroid() uses\n   *  the results determine the spectral centroid.</em></p>\n   *\n   *  @method  getCentroid\n   *  @for p5.FFT\n   *  @return {Number}   Spectral Centroid Frequency   Frequency of the spectral centroid in Hz.\n   *\n   *\n   * @example\n   *  <div><code>\n   * function setup(){\n   *  cnv = createCanvas(100,100);\n   *  cnv.mousePressed(userStartAudio);\n   *  sound = new p5.AudioIn();\n   *  sound.start();\n   *  fft = new p5.FFT();\n   *  sound.connect(fft);\n   *}\n   *\n   *function draw() {\n   *  if (getAudioContext().state !== 'running') {\n   *    background(220);\n   *    text('tap here and enable mic to begin', 10, 20, width - 20);\n   *    return;\n   *  }\n   *  let centroidplot = 0.0;\n   *  let spectralCentroid = 0;\n   *\n   *  background(0);\n   *  stroke(0,255,0);\n   *  let spectrum = fft.analyze();\n   *  fill(0,255,0); // spectrum is green\n   *\n   *  //draw the spectrum\n   *  for (let i = 0; i < spectrum.length; i++){\n   *    let x = map(log(i), 0, log(spectrum.length), 0, width);\n   *    let h = map(spectrum[i], 0, 255, 0, height);\n   *    let rectangle_width = (log(i+1)-log(i))*(width/log(spectrum.length));\n   *    rect(x, height, rectangle_width, -h )\n   *  }\n   *  let nyquist = 22050;\n   *\n   *  // get the centroid\n   *  spectralCentroid = fft.getCentroid();\n   *\n   *  // the mean_freq_index calculation is for the display.\n   *  let mean_freq_index = spectralCentroid/(nyquist/spectrum.length);\n   *\n   *  centroidplot = map(log(mean_freq_index), 0, log(spectrum.length), 0, width);\n   *\n   *  stroke(255,0,0); // the line showing where the centroid is will be red\n   *\n   *  rect(centroidplot, 0, width / spectrum.length, height)\n   *  noStroke();\n   *  fill(255,255,255);  // text is white\n   *  text('centroid: ', 10, 20);\n   *  text(round(spectralCentroid)+' Hz', 10, 40);\n   *}\n   * </code></div>\n   */\n\n\n  p5.FFT.prototype.getCentroid = function () {\n    var nyquist = p5sound.audiocontext.sampleRate / 2;\n    var cumulative_sum = 0;\n    var centroid_normalization = 0;\n\n    for (var i = 0; i < this.freqDomain.length; i++) {\n      cumulative_sum += i * this.freqDomain[i];\n      centroid_normalization += this.freqDomain[i];\n    }\n\n    var mean_freq_index = 0;\n\n    if (centroid_normalization !== 0) {\n      mean_freq_index = cumulative_sum / centroid_normalization;\n    }\n\n    var spec_centroid_freq = mean_freq_index * (nyquist / this.freqDomain.length);\n    return spec_centroid_freq;\n  };\n  /**\n   *  Smooth FFT analysis by averaging with the last analysis frame.\n   *\n   *  @method smooth\n   *  @param {Number} smoothing    0.0 < smoothing < 1.0.\n   *                               Defaults to 0.8.\n   */\n\n\n  p5.FFT.prototype.smooth = function (s) {\n    if (typeof s !== 'undefined') {\n      this.smoothing = s;\n    }\n\n    return this.smoothing;\n  };\n\n  p5.FFT.prototype.dispose = function () {\n    var index = p5sound.soundArray.indexOf(this);\n    p5sound.soundArray.splice(index, 1);\n\n    if (this.analyser) {\n      this.analyser.disconnect();\n      delete this.analyser;\n    }\n  };\n  /**\n   *  Returns an array of average amplitude values for a given number\n   *  of frequency bands split equally. N defaults to 16.\n   *  <em>NOTE: analyze() must be called prior to linAverages(). Analyze()\n   *  tells the FFT to analyze frequency data, and linAverages() uses\n   *  the results to group them into a smaller set of averages.</em></p>\n   *\n   *  @method  linAverages\n   *  @for p5.FFT\n   *  @param  {Number}  N                Number of returned frequency groups\n   *  @return {Array}   linearAverages   Array of average amplitude values for each group\n   */\n\n\n  p5.FFT.prototype.linAverages = function (N) {\n    var N = N || 16; \n\n    var spectrum = this.freqDomain;\n    var spectrumLength = spectrum.length;\n    var spectrumStep = Math.floor(spectrumLength / N);\n    var linearAverages = new Array(N); \n\n    var groupIndex = 0;\n\n    for (var specIndex = 0; specIndex < spectrumLength; specIndex++) {\n      linearAverages[groupIndex] = linearAverages[groupIndex] !== undefined ? (linearAverages[groupIndex] + spectrum[specIndex]) / 2 : spectrum[specIndex]; \n\n      if (specIndex % spectrumStep === spectrumStep - 1) {\n        groupIndex++;\n      }\n    }\n\n    return linearAverages;\n  };\n  /**\n   *  Returns an array of average amplitude values of the spectrum, for a given\n   *  set of <a href=\"https://en.wikipedia.org/wiki/Octave_band\" target=\"_blank\">\n   *  Octave Bands</a>\n   *  <em>NOTE: analyze() must be called prior to logAverages(). Analyze()\n   *  tells the FFT to analyze frequency data, and logAverages() uses\n   *  the results to group them into a smaller set of averages.</em></p>\n   *\n   *  @method  logAverages\n   *  @for p5.FFT\n   *  @param  {Array}   octaveBands    Array of Octave Bands objects for grouping\n   *  @return {Array}   logAverages    Array of average amplitude values for each group\n   */\n\n\n  p5.FFT.prototype.logAverages = function (octaveBands) {\n    var nyquist = p5sound.audiocontext.sampleRate / 2;\n    var spectrum = this.freqDomain;\n    var spectrumLength = spectrum.length;\n    var logAverages = new Array(octaveBands.length); \n\n    var octaveIndex = 0;\n\n    for (var specIndex = 0; specIndex < spectrumLength; specIndex++) {\n      var specIndexFrequency = Math.round(specIndex * nyquist / this.freqDomain.length); \n\n      if (specIndexFrequency > octaveBands[octaveIndex].hi) {\n        octaveIndex++;\n      }\n\n      logAverages[octaveIndex] = logAverages[octaveIndex] !== undefined ? (logAverages[octaveIndex] + spectrum[specIndex]) / 2 : spectrum[specIndex];\n    }\n\n    return logAverages;\n  };\n  /**\n   *  Calculates and Returns the 1/N\n   *  <a href=\"https://en.wikipedia.org/wiki/Octave_band\" target=\"_blank\">Octave Bands</a>\n   *  N defaults to 3 and minimum central frequency to 15.625Hz.\n   *  (1/3 Octave Bands ~= 31 Frequency Bands)\n   *  Setting fCtr0 to a central value of a higher octave will ignore the lower bands\n   *  and produce less frequency groups.\n   *\n   *  @method   getOctaveBands\n   *  @for p5.FFT\n   *  @param  {Number}  N             Specifies the 1/N type of generated octave bands\n   *  @param  {Number}  fCtr0         Minimum central frequency for the lowest band\n   *  @return {Array}   octaveBands   Array of octave band objects with their bounds\n   */\n\n\n  p5.FFT.prototype.getOctaveBands = function (N, fCtr0) {\n    var N = N || 3; \n\n    var fCtr0 = fCtr0 || 15.625; \n\n    var octaveBands = [];\n    var lastFrequencyBand = {\n      lo: fCtr0 / Math.pow(2, 1 / (2 * N)),\n      ctr: fCtr0,\n      hi: fCtr0 * Math.pow(2, 1 / (2 * N))\n    };\n    octaveBands.push(lastFrequencyBand);\n    var nyquist = p5sound.audiocontext.sampleRate / 2;\n\n    while (lastFrequencyBand.hi < nyquist) {\n      var newFrequencyBand = {};\n      newFrequencyBand.lo = lastFrequencyBand.hi;\n      newFrequencyBand.ctr = lastFrequencyBand.ctr * Math.pow(2, 1 / N);\n      newFrequencyBand.hi = newFrequencyBand.ctr * Math.pow(2, 1 / (2 * N));\n      octaveBands.push(newFrequencyBand);\n      lastFrequencyBand = newFrequencyBand;\n    }\n\n    return octaveBands;\n  }; \n\n\n  var freqToFloat = function freqToFloat(fft) {\n    if (fft.freqDomain instanceof Float32Array === false) {\n      fft.freqDomain = new Float32Array(fft.analyser.frequencyBinCount);\n    }\n  };\n\n  var freqToInt = function freqToInt(fft) {\n    if (fft.freqDomain instanceof Uint8Array === false) {\n      fft.freqDomain = new Uint8Array(fft.analyser.frequencyBinCount);\n    }\n  };\n\n  var timeToFloat = function timeToFloat(fft) {\n    if (fft.timeDomain instanceof Float32Array === false) {\n      fft.timeDomain = new Float32Array(fft.analyser.frequencyBinCount);\n    }\n  };\n\n  var timeToInt = function timeToInt(fft) {\n    if (fft.timeDomain instanceof Uint8Array === false) {\n      fft.timeDomain = new Uint8Array(fft.analyser.frequencyBinCount);\n    }\n  };\n}).call(exports, __nested_webpack_require_243082__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_264331__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var Signal = __nested_webpack_require_264331__(2);\n\n  var Add = __nested_webpack_require_264331__(7);\n\n  var Mult = __nested_webpack_require_264331__(3);\n\n  var Scale = __nested_webpack_require_264331__(13);\n  /**\n   *  <p>p5.Signal is a constant audio-rate signal used by p5.Oscillator\n   *  and p5.Envelope for modulation math.</p>\n   *\n   *  <p>This is necessary because Web Audio is processed on a seprate clock.\n   *  For example, the p5 draw loop runs about 60 times per second. But\n   *  the audio clock must process samples 44100 times per second. If we\n   *  want to add a value to each of those samples, we can't do it in the\n   *  draw loop, but we can do it by adding a constant-rate audio signal.</p.\n   *\n   *  <p>This class mostly functions behind the scenes in p5.sound, and returns\n   *  a Tone.Signal from the Tone.js library by Yotam Mann.\n   *  If you want to work directly with audio signals for modular\n   *  synthesis, check out\n   *  <a href='http://bit.ly/1oIoEng' target=_'blank'>tone.js.</a></p>\n   *\n   *  @class  p5.Signal\n   *  @constructor\n   *  @return {Tone.Signal} A Signal object from the Tone.js library\n   *  @example\n   *  <div><code>\n   *  let carrier, modulator;\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(canvasPressed);\n   *    background(220);\n   *    text('tap to play', 20, 20);\n   *\n   *    carrier = new p5.Oscillator('sine');\n   *    carrier.start();\n   *    carrier.amp(1); // set amplitude\n   *    carrier.freq(220); // set frequency\n   *\n   *    modulator = new p5.Oscillator('sawtooth');\n   *    modulator.disconnect();\n   *    modulator.start();\n   *    modulator.amp(1);\n   *    modulator.freq(4);\n   *\n   *    // Modulator's default amplitude range is -1 to 1.\n   *    // Multiply it by -200, so the range is -200 to 200\n   *    // then add 220 so the range is 20 to 420\n   *    carrier.freq( modulator.mult(-400).add(220) );\n   *  }\n   *\n   *  function canvasPressed() {\n   *    userStartAudio();\n   *    carrier.amp(1.0);\n   *  }\n   *\n   *  function mouseReleased() {\n   *    carrier.amp(0);\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.Signal = function (value) {\n    var s = new Signal(value); \n\n    return s; \n  };\n  /**\n   *  Fade to value, for smooth transitions\n   *\n   *  @method  fade\n   *  @for p5.Signal\n   *  @param  {Number} value          Value to set this signal\n   *  @param  {Number} [secondsFromNow] Length of fade, in seconds from now\n   */\n\n\n  Signal.prototype.fade = Signal.prototype.linearRampToValueAtTime;\n  Mult.prototype.fade = Signal.prototype.fade;\n  Add.prototype.fade = Signal.prototype.fade;\n  Scale.prototype.fade = Signal.prototype.fade;\n  /**\n   *  Connect a p5.sound object or Web Audio node to this\n   *  p5.Signal so that its amplitude values can be scaled.\n   *\n   *  @method setInput\n   *  @for p5.Signal\n   *  @param {Object} input\n   */\n\n  Signal.prototype.setInput = function (_input) {\n    _input.connect(this);\n  };\n\n  Mult.prototype.setInput = Signal.prototype.setInput;\n  Add.prototype.setInput = Signal.prototype.setInput;\n  Scale.prototype.setInput = Signal.prototype.setInput; \n\n  /**\n   *  Add a constant value to this audio signal,\n   *  and return the resulting audio signal. Does\n   *  not change the value of the original signal,\n   *  instead it returns a new p5.SignalAdd.\n   *\n   *  @method  add\n   *  @for p5.Signal\n   *  @param {Number} number\n   *  @return {p5.Signal} object\n   */\n\n  Signal.prototype.add = function (num) {\n    var add = new Add(num); \n\n    this.connect(add);\n    return add;\n  };\n\n  Mult.prototype.add = Signal.prototype.add;\n  Add.prototype.add = Signal.prototype.add;\n  Scale.prototype.add = Signal.prototype.add;\n  /**\n   *  Multiply this signal by a constant value,\n   *  and return the resulting audio signal. Does\n   *  not change the value of the original signal,\n   *  instead it returns a new p5.SignalMult.\n   *\n   *  @method  mult\n   *  @for p5.Signal\n   *  @param {Number} number to multiply\n   *  @return {p5.Signal} object\n   */\n\n  Signal.prototype.mult = function (num) {\n    var mult = new Mult(num); \n\n    this.connect(mult);\n    return mult;\n  };\n\n  Mult.prototype.mult = Signal.prototype.mult;\n  Add.prototype.mult = Signal.prototype.mult;\n  Scale.prototype.mult = Signal.prototype.mult;\n  /**\n   *  Scale this signal value to a given range,\n   *  and return the result as an audio signal. Does\n   *  not change the value of the original signal,\n   *  instead it returns a new p5.SignalScale.\n   *\n   *  @method  scale\n   *  @for p5.Signal\n   *  @param {Number} number to multiply\n   *  @param  {Number} inMin  input range minumum\n   *  @param  {Number} inMax  input range maximum\n   *  @param  {Number} outMin input range minumum\n   *  @param  {Number} outMax input range maximum\n   *  @return {p5.Signal} object\n   */\n\n  Signal.prototype.scale = function (inMin, inMax, outMin, outMax) {\n    var mapOutMin, mapOutMax;\n\n    if (arguments.length === 4) {\n      mapOutMin = p5.prototype.map(outMin, inMin, inMax, 0, 1) - 0.5;\n      mapOutMax = p5.prototype.map(outMax, inMin, inMax, 0, 1) - 0.5;\n    } else {\n      mapOutMin = arguments[0];\n      mapOutMax = arguments[1];\n    }\n\n    var scale = new Scale(mapOutMin, mapOutMax);\n    this.connect(scale);\n    return scale;\n  };\n\n  Mult.prototype.scale = Signal.prototype.scale;\n  Add.prototype.scale = Signal.prototype.scale;\n  Scale.prototype.scale = Signal.prototype.scale;\n}).call(exports, __nested_webpack_require_264331__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_270027__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_270027__(0),__nested_webpack_require_270027__(21)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(o){o.Frequency=function(e,t){if(!(this instanceof o.Frequency))return new o.Frequency(e,t);o.TimeBase.call(this,e,t)},o.extend(o.Frequency,o.TimeBase),o.Frequency.prototype._primaryExpressions=Object.create(o.TimeBase.prototype._primaryExpressions),o.Frequency.prototype._primaryExpressions.midi={regexp:/^(\\d+(?:\\.\\d+)?midi)/,method:function(e){return this.midiToFrequency(e)}},o.Frequency.prototype._primaryExpressions.note={regexp:/^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,method:function(e,t){var r=n[e.toLowerCase()]+12*(parseInt(t)+1);return this.midiToFrequency(r)}},o.Frequency.prototype._primaryExpressions.tr={regexp:/^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,method:function(e,t,r){var n=1;return e&&\"0\"!==e&&(n*=this._beatsToUnits(this._timeSignature()*parseFloat(e))),t&&\"0\"!==t&&(n*=this._beatsToUnits(parseFloat(t))),r&&\"0\"!==r&&(n*=this._beatsToUnits(parseFloat(r)/4)),n}},o.Frequency.prototype.transpose=function(e){return this._expr=function(e,t){return e()*this.intervalToFrequencyRatio(t)}.bind(this,this._expr,e),this},o.Frequency.prototype.harmonize=function(e){return this._expr=function(e,t){for(var r=e(),n=[],o=0;o<t.length;o++)n[o]=r*this.intervalToFrequencyRatio(t[o]);return n}.bind(this,this._expr,e),this},o.Frequency.prototype.toMidi=function(){return this.frequencyToMidi(this.valueOf())},o.Frequency.prototype.toNote=function(){var e=this.valueOf(),t=Math.log(e/o.Frequency.A4)/Math.LN2,r=Math.round(12*t)+57,n=Math.floor(r/12);return n<0&&(r+=-12*n),i[r%12]+n.toString()},o.Frequency.prototype.toSeconds=function(){return 1/this.valueOf()},o.Frequency.prototype.toFrequency=function(){return this.valueOf()},o.Frequency.prototype.toTicks=function(){var e=this._beatsToUnits(1),t=this.valueOf()/e;return Math.floor(t*o.Transport.PPQ)},o.Frequency.prototype._frequencyToUnits=function(e){return e},o.Frequency.prototype._ticksToUnits=function(e){return 1/(60*e/(o.Transport.bpm.value*o.Transport.PPQ))},o.Frequency.prototype._beatsToUnits=function(e){return 1/o.TimeBase.prototype._beatsToUnits.call(this,e)},o.Frequency.prototype._secondsToUnits=function(e){return 1/e},o.Frequency.prototype._defaultUnits=\"hz\";var n={cbb:-2,cb:-1,c:0,\"c#\":1,cx:2,dbb:0,db:1,d:2,\"d#\":3,dx:4,ebb:2,eb:3,e:4,\"e#\":5,ex:6,fbb:3,fb:4,f:5,\"f#\":6,fx:7,gbb:5,gb:6,g:7,\"g#\":8,gx:9,abb:7,ab:8,a:9,\"a#\":10,ax:11,bbb:9,bb:10,b:11,\"b#\":12,bx:13},i=[\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"];return o.Frequency.A4=440,o.Frequency.prototype.midiToFrequency=function(e){return o.Frequency.A4*Math.pow(2,(e-69)/12)},o.Frequency.prototype.frequencyToMidi=function(e){return 69+12*Math.log(e/o.Frequency.A4)/Math.LN2},o.Frequency}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_273070__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_273070__(0),__nested_webpack_require_273070__(20)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(o){return o.TransportTime=function(t,r){if(!(this instanceof o.TransportTime))return new o.TransportTime(t,r);o.Time.call(this,t,r)},o.extend(o.TransportTime,o.Time),o.TransportTime.prototype._unaryExpressions=Object.create(o.Time.prototype._unaryExpressions),o.TransportTime.prototype._unaryExpressions.quantize={regexp:/^@/,method:function(t){var r=this._secondsToTicks(t()),e=Math.ceil(o.Transport.ticks/r);return this._ticksToUnits(e*r)}},o.TransportTime.prototype._secondsToTicks=function(t){var r=t/this._beatsToUnits(1);return Math.round(r*o.Transport.PPQ)},o.TransportTime.prototype.valueOf=function(){return this._secondsToTicks(this._expr())+(this._plusNow?o.Transport.ticks:0)},o.TransportTime.prototype.toTicks=function(){return this.valueOf()},o.TransportTime.prototype.toSeconds=function(){return this._expr()+(this._plusNow?o.Transport.seconds:0)},o.TransportTime.prototype.toFrequency=function(){return 1/this.toSeconds()},o.TransportTime}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_274422__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_274422__(1);\n\n  var Add = __nested_webpack_require_274422__(7);\n\n  var Mult = __nested_webpack_require_274422__(3);\n\n  var Scale = __nested_webpack_require_274422__(13);\n\n  var TimelineSignal = __nested_webpack_require_274422__(14);\n  /**\n   *  <p>Envelopes are pre-defined amplitude distribution over time.\n   *  Typically, envelopes are used to control the output volume\n   *  of an object, a series of fades referred to as Attack, Decay,\n   *  Sustain and Release (\n   *  <a href=\"https://upload.wikimedia.org/wikipedia/commons/e/ea/ADSR_parameter.svg\">ADSR</a>\n   *  ). Envelopes can also control other Web Audio Parameters—for example, a p5.Envelope can\n   *  control an Oscillator's frequency like this: <code>osc.freq(env)</code>.</p>\n   *  <p>Use <code><a href=\"#/p5.Envelope/setRange\">setRange</a></code> to change the attack/release level.\n   *  Use <code><a href=\"#/p5.Envelope/setADSR\">setADSR</a></code> to change attackTime, decayTime, sustainPercent and releaseTime.</p>\n   *  <p>Use the <code><a href=\"#/p5.Envelope/play\">play</a></code> method to play the entire envelope,\n   *  the <code><a href=\"#/p5.Envelope/ramp\">ramp</a></code> method for a pingable trigger,\n   *  or <code><a href=\"#/p5.Envelope/triggerAttack\">triggerAttack</a></code>/\n   *  <code><a href=\"#/p5.Envelope/triggerRelease\">triggerRelease</a></code> to trigger noteOn/noteOff.</p>\n   *\n   *  @class p5.Envelope\n   *  @constructor\n   *  @example\n   *  <div><code>\n   *  let t1 = 0.1; // attack time in seconds\n   *  let l1 = 0.7; // attack level 0.0 to 1.0\n   *  let t2 = 0.3; // decay time in seconds\n   *  let l2 = 0.1; // decay level  0.0 to 1.0\n   *\n   *  let env;\n   *  let triOsc;\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    background(220);\n   *    text('tap to play', 20, 20);\n   *    cnv.mousePressed(playSound);\n   *\n   *    env = new p5.Envelope(t1, l1, t2, l2);\n   *    triOsc = new p5.Oscillator('triangle');\n   *  }\n   *\n   *  function playSound() {\n   *    // starting the oscillator ensures that audio is enabled.\n   *    triOsc.start();\n   *    env.play(triOsc);\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.Envelope = function (t1, l1, t2, l2, t3, l3) {\n    /**\n     * Time until envelope reaches attackLevel\n     * @property attackTime\n     */\n    this.aTime = t1 || 0.1;\n    /**\n     * Level once attack is complete.\n     * @property attackLevel\n     */\n\n    this.aLevel = l1 || 1;\n    /**\n     * Time until envelope reaches decayLevel.\n     * @property decayTime\n     */\n\n    this.dTime = t2 || 0.5;\n    /**\n     * Level after decay. The envelope will sustain here until it is released.\n     * @property decayLevel\n     */\n\n    this.dLevel = l2 || 0;\n    /**\n     * Duration of the release portion of the envelope.\n     * @property releaseTime\n     */\n\n    this.rTime = t3 || 0;\n    /**\n     * Level at the end of the release.\n     * @property releaseLevel\n     */\n\n    this.rLevel = l3 || 0;\n    this._rampHighPercentage = 0.98;\n    this._rampLowPercentage = 0.02;\n    this.output = p5sound.audiocontext.createGain();\n    this.control = new TimelineSignal();\n\n    this._init(); \n\n\n    this.control.connect(this.output); \n\n    this.connection = null; \n\n    this.mathOps = [this.control]; \n\n    this.isExponential = false; \n\n    this.sourceToClear = null; \n\n    this.wasTriggered = false; \n\n    p5sound.soundArray.push(this);\n  }; \n\n\n  p5.Envelope.prototype._init = function () {\n    var now = p5sound.audiocontext.currentTime;\n    var t = now;\n    this.control.setTargetAtTime(0.00001, t, .001); \n\n    this._setRampAD(this.aTime, this.dTime);\n  };\n  /**\n   *  Reset the envelope with a series of time/value pairs.\n   *\n   *  @method  set\n   *  @for p5.Envelope\n   *  @param {Number} attackTime     Time (in seconds) before level\n   *                                 reaches attackLevel\n   *  @param {Number} attackLevel    Typically an amplitude between\n   *                                 0.0 and 1.0\n   *  @param {Number} decayTime      Time\n   *  @param {Number} decayLevel   Amplitude (In a standard ADSR envelope,\n   *                                 decayLevel = sustainLevel)\n   *  @param {Number} releaseTime   Release Time (in seconds)\n   *  @param {Number} releaseLevel  Amplitude\n   *  @example\n   *  <div><code>\n   *  let attackTime;\n   *  let l1 = 0.7; // attack level 0.0 to 1.0\n   *  let t2 = 0.3; // decay time in seconds\n   *  let l2 = 0.1; // decay level  0.0 to 1.0\n   *  let l3 = 0.2; // release time in seconds\n   *\n   *  let env, triOsc;\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(playSound);\n   *\n   *    env = new p5.Envelope();\n   *    triOsc = new p5.Oscillator('triangle');\n   *  }\n   *\n   *  function draw() {\n   *    background(220);\n   *    text('tap here to play', 5, 20);\n   *\n   *    attackTime = map(mouseX, 0, width, 0.0, 1.0);\n   *    text('attack time: ' + attackTime, 5, height - 20);\n   *  }\n   *\n   *  // mouseClick triggers envelope if over canvas\n   *  function playSound() {\n   *    env.set(attackTime, l1, t2, l2, l3);\n   *\n   *    triOsc.start();\n   *    env.play(triOsc);\n   *  }\n   *  </code></div>\n   *\n   */\n\n\n  p5.Envelope.prototype.set = function (t1, l1, t2, l2, t3, l3) {\n    this.aTime = t1;\n    this.aLevel = l1;\n    this.dTime = t2 || 0;\n    this.dLevel = l2 || 0;\n    this.rTime = t3 || 0;\n    this.rLevel = l3 || 0; \n\n    this._setRampAD(t1, t2);\n  };\n  /**\n   *  Set values like a traditional\n   *  <a href=\"https://en.wikipedia.org/wiki/Synthesizer#/media/File:ADSR_parameter.svg\">\n   *  ADSR envelope\n   *  </a>.\n   *\n   *  @method  setADSR\n   *  @for p5.Envelope\n   *  @param {Number} attackTime    Time (in seconds before envelope\n   *                                reaches Attack Level\n   *  @param {Number} [decayTime]    Time (in seconds) before envelope\n   *                                reaches Decay/Sustain Level\n   *  @param {Number} [susRatio]    Ratio between attackLevel and releaseLevel, on a scale from 0 to 1,\n   *                                where 1.0 = attackLevel, 0.0 = releaseLevel.\n   *                                The susRatio determines the decayLevel and the level at which the\n   *                                sustain portion of the envelope will sustain.\n   *                                For example, if attackLevel is 0.4, releaseLevel is 0,\n   *                                and susAmt is 0.5, the decayLevel would be 0.2. If attackLevel is\n   *                                increased to 1.0 (using <code>setRange</code>),\n   *                                then decayLevel would increase proportionally, to become 0.5.\n   *  @param {Number} [releaseTime]   Time in seconds from now (defaults to 0)\n   *  @example\n   *  <div><code>\n   *  let attackLevel = 1.0;\n   *  let releaseLevel = 0;\n   *\n   *  let attackTime = 0.001;\n   *  let decayTime = 0.2;\n   *  let susPercent = 0.2;\n   *  let releaseTime = 0.5;\n   *\n   *  let env, triOsc;\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(playEnv);\n   *\n   *    env = new p5.Envelope();\n   *    triOsc = new p5.Oscillator('triangle');\n   *    triOsc.amp(env);\n   *    triOsc.freq(220);\n   *  }\n   *\n   *  function draw() {\n   *    background(220);\n   *    text('tap here to play', 5, 20);\n   *    attackTime = map(mouseX, 0, width, 0, 1.0);\n   *    text('attack time: ' + attackTime, 5, height - 40);\n   *  }\n   *\n   *  function playEnv() {\n   *    triOsc.start();\n   *    env.setADSR(attackTime, decayTime, susPercent, releaseTime);\n   *    env.play();\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.Envelope.prototype.setADSR = function (aTime, dTime, sPercent, rTime) {\n    this.aTime = aTime;\n    this.dTime = dTime || 0; \n\n    this.sPercent = sPercent || 0;\n    this.dLevel = typeof sPercent !== 'undefined' ? sPercent * (this.aLevel - this.rLevel) + this.rLevel : 0;\n    this.rTime = rTime || 0; \n\n    this._setRampAD(aTime, dTime);\n  };\n  /**\n   *  Set max (attackLevel) and min (releaseLevel) of envelope.\n   *\n   *  @method  setRange\n   *  @for p5.Envelope\n   *  @param {Number} aLevel attack level (defaults to 1)\n   *  @param {Number} rLevel release level (defaults to 0)\n   *  @example\n   *  <div><code>\n   *  let attackLevel = 1.0;\n   *  let releaseLevel = 0;\n   *\n   *  let attackTime = 0.001;\n   *  let decayTime = 0.2;\n   *  let susPercent = 0.2;\n   *  let releaseTime = 0.5;\n   *\n   *  let env, triOsc;\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(playEnv);\n   *\n   *    env = new p5.Envelope();\n   *    triOsc = new p5.Oscillator('triangle');\n   *    triOsc.amp(env);\n   *    triOsc.freq(220);\n   *  }\n   *\n   *  function draw() {\n   *    background(220);\n   *    text('tap here to play', 5, 20);\n   *    attackLevel = map(mouseY, height, 0, 0, 1.0);\n   *    text('attack level: ' + attackLevel, 5, height - 20);\n   *  }\n   *\n   *  function playEnv() {\n   *    triOsc.start();\n   *    env.setRange(attackLevel, releaseLevel);\n   *    env.play();\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.Envelope.prototype.setRange = function (aLevel, rLevel) {\n    this.aLevel = aLevel || 1;\n    this.rLevel = rLevel || 0; \n  }; \n\n\n  p5.Envelope.prototype._setRampAD = function (t1, t2) {\n    this._rampAttackTime = this.checkExpInput(t1);\n    this._rampDecayTime = this.checkExpInput(t2);\n    var TCDenominator = 1.0; \n\n    TCDenominator = Math.log(1.0 / this.checkExpInput(1.0 - this._rampHighPercentage));\n    this._rampAttackTC = t1 / this.checkExpInput(TCDenominator);\n    TCDenominator = Math.log(1.0 / this._rampLowPercentage);\n    this._rampDecayTC = t2 / this.checkExpInput(TCDenominator);\n  }; \n\n\n  p5.Envelope.prototype.setRampPercentages = function (p1, p2) {\n    this._rampHighPercentage = this.checkExpInput(p1);\n    this._rampLowPercentage = this.checkExpInput(p2);\n    var TCDenominator = 1.0; \n\n    TCDenominator = Math.log(1.0 / this.checkExpInput(1.0 - this._rampHighPercentage));\n    this._rampAttackTC = this._rampAttackTime / this.checkExpInput(TCDenominator);\n    TCDenominator = Math.log(1.0 / this._rampLowPercentage);\n    this._rampDecayTC = this._rampDecayTime / this.checkExpInput(TCDenominator);\n  };\n  /**\n   *  Assign a parameter to be controlled by this envelope.\n   *  If a p5.Sound object is given, then the p5.Envelope will control its\n   *  output gain. If multiple inputs are provided, the env will\n   *  control all of them.\n   *\n   *  @method  setInput\n   *  @for p5.Envelope\n   *  @param  {Object} [...inputs]         A p5.sound object or\n   *                                Web Audio Param.\n   */\n\n\n  p5.Envelope.prototype.setInput = function () {\n    for (var i = 0; i < arguments.length; i++) {\n      this.connect(arguments[i]);\n    }\n  };\n  /**\n   *  Set whether the envelope ramp is linear (default) or exponential.\n   *  Exponential ramps can be useful because we perceive amplitude\n   *  and frequency logarithmically.\n   *\n   *  @method  setExp\n   *  @for p5.Envelope\n   *  @param {Boolean} isExp true is exponential, false is linear\n   */\n\n\n  p5.Envelope.prototype.setExp = function (isExp) {\n    this.isExponential = isExp;\n  }; \n\n\n  p5.Envelope.prototype.checkExpInput = function (value) {\n    if (value <= 0) {\n      value = 0.00000001;\n    }\n\n    return value;\n  };\n  /**\n   *  <p>Play tells the envelope to start acting on a given input.\n   *  If the input is a p5.sound object (i.e. AudioIn, Oscillator,\n   *  SoundFile), then Envelope will control its output volume.\n   *  Envelopes can also be used to control any <a href=\"\n   *  http://docs.webplatform.org/wiki/apis/webaudio/AudioParam\">\n   *  Web Audio Audio Param.</a></p>\n   *\n   *  @method  play\n   *  @for p5.Envelope\n   *  @param  {Object} unit         A p5.sound object or\n   *                                Web Audio Param.\n   *  @param  {Number} [startTime]  time from now (in seconds) at which to play\n   *  @param  {Number} [sustainTime] time to sustain before releasing the envelope\n   *  @example\n   *  <div><code>\n   *  let attackLevel = 1.0;\n   *  let releaseLevel = 0;\n   *\n   *  let attackTime = 0.001;\n   *  let decayTime = 0.2;\n   *  let susPercent = 0.2;\n   *  let releaseTime = 0.5;\n   *\n   *  let env, triOsc;\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(playEnv);\n   *\n   *    env = new p5.Envelope();\n   *    triOsc = new p5.Oscillator('triangle');\n   *    triOsc.amp(env);\n   *    triOsc.freq(220);\n   *    triOsc.start();\n   *  }\n   *\n   *  function draw() {\n   *    background(220);\n   *    text('tap here to play', 5, 20);\n   *    attackTime = map(mouseX, 0, width, 0, 1.0);\n   *    attackLevel = map(mouseY, height, 0, 0, 1.0);\n   *    text('attack time: ' + attackTime, 5, height - 40);\n   *    text('attack level: ' + attackLevel, 5, height - 20);\n   *  }\n   *\n   *  function playEnv() {\n   *    // ensure that audio is enabled\n   *    userStartAudio();\n   *\n   *    env.setADSR(attackTime, decayTime, susPercent, releaseTime);\n   *    env.setRange(attackLevel, releaseLevel);\n   *    env.play();\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.Envelope.prototype.play = function (unit, secondsFromNow, susTime) {\n    var tFromNow = secondsFromNow || 0;\n    var susTime = susTime || 0;\n\n    if (unit) {\n      if (this.connection !== unit) {\n        this.connect(unit);\n      }\n    }\n\n    this.triggerAttack(unit, tFromNow);\n    this.triggerRelease(unit, tFromNow + this.aTime + this.dTime + susTime);\n  };\n  /**\n   *  Trigger the Attack, and Decay portion of the Envelope.\n   *  Similar to holding down a key on a piano, but it will\n   *  hold the sustain level until you let go. Input can be\n   *  any p5.sound object, or a <a href=\"\n   *  http://docs.webplatform.org/wiki/apis/webaudio/AudioParam\">\n   *  Web Audio Param</a>.\n   *\n   *  @method  triggerAttack\n   *  @for p5.Envelope\n   *  @param  {Object} unit p5.sound Object or Web Audio Param\n   *  @param  {Number} secondsFromNow time from now (in seconds)\n   *  @example\n   *  <div><code>\n   *  let attackTime = 0.001;\n   *  let decayTime = 0.2;\n   *  let susPercent = 0.3;\n   *  let releaseTime = 0.4;\n   *  let env, triOsc;\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    background(220);\n   *    textAlign(CENTER);\n   *    textSize(10);\n   *    text('tap to triggerAttack', width/2, height/2);\n   *\n   *    env = new p5.Envelope();\n   *    env.setADSR(attackTime, decayTime, susPercent, releaseTime);\n   *    env.setRange(1.0, 0.0);\n   *    triOsc = new p5.Oscillator('triangle');\n   *    triOsc.freq(220);\n   *\n   *    cnv.mousePressed(envAttack);\n   *  }\n   *\n   *  function envAttack()  {\n   *    background(0, 255, 255);\n   *    text('release to release', width/2, height/2);\n   *\n   *    // ensures audio is enabled. See also: `userStartAudio`\n   *    triOsc.start();\n   *\n   *    env.triggerAttack(triOsc);\n   *  }\n   *\n   *  function mouseReleased() {\n   *    background(220);\n   *    text('tap to triggerAttack', width/2, height/2);\n   *\n   *    env.triggerRelease(triOsc);\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.Envelope.prototype.triggerAttack = function (unit, secondsFromNow) {\n    var now = p5sound.audiocontext.currentTime;\n    var tFromNow = secondsFromNow || 0;\n    var t = now + tFromNow;\n    this.lastAttack = t;\n    this.wasTriggered = true;\n\n    if (unit) {\n      if (this.connection !== unit) {\n        this.connect(unit);\n      }\n    } \n\n\n    var valToSet = this.control.getValueAtTime(t);\n\n    if (this.isExponential === true) {\n      this.control.exponentialRampToValueAtTime(this.checkExpInput(valToSet), t);\n    } else {\n      this.control.linearRampToValueAtTime(valToSet, t);\n    } \n\n\n    t += this.aTime;\n\n    if (this.isExponential === true) {\n      this.control.exponentialRampToValueAtTime(this.checkExpInput(this.aLevel), t);\n      valToSet = this.checkExpInput(this.control.getValueAtTime(t));\n      this.control.cancelScheduledValues(t);\n      this.control.exponentialRampToValueAtTime(valToSet, t);\n    } else {\n      this.control.linearRampToValueAtTime(this.aLevel, t);\n      valToSet = this.control.getValueAtTime(t);\n      this.control.cancelScheduledValues(t);\n      this.control.linearRampToValueAtTime(valToSet, t);\n    } \n\n\n    t += this.dTime;\n\n    if (this.isExponential === true) {\n      this.control.exponentialRampToValueAtTime(this.checkExpInput(this.dLevel), t);\n      valToSet = this.checkExpInput(this.control.getValueAtTime(t));\n      this.control.cancelScheduledValues(t);\n      this.control.exponentialRampToValueAtTime(valToSet, t);\n    } else {\n      this.control.linearRampToValueAtTime(this.dLevel, t);\n      valToSet = this.control.getValueAtTime(t);\n      this.control.cancelScheduledValues(t);\n      this.control.linearRampToValueAtTime(valToSet, t);\n    }\n  };\n  /**\n   *  Trigger the Release of the Envelope. This is similar to releasing\n   *  the key on a piano and letting the sound fade according to the\n   *  release level and release time.\n   *\n   *  @method  triggerRelease\n   *  @for p5.Envelope\n   *  @param  {Object} unit p5.sound Object or Web Audio Param\n   *  @param  {Number} secondsFromNow time to trigger the release\n   *  @example\n   *  <div><code>\n   *  let attackTime = 0.001;\n   *  let decayTime = 0.2;\n   *  let susPercent = 0.3;\n   *  let releaseTime = 0.4;\n   *  let env, triOsc;\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    background(220);\n   *    textAlign(CENTER);\n   *    textSize(10);\n   *    text('tap to triggerAttack', width/2, height/2);\n   *\n   *    env = new p5.Envelope();\n   *    env.setADSR(attackTime, decayTime, susPercent, releaseTime);\n   *    env.setRange(1.0, 0.0);\n   *    triOsc = new p5.Oscillator('triangle');\n   *    triOsc.freq(220);\n   *\n   *    cnv.mousePressed(envAttack);\n   *  }\n   *\n   *  function envAttack()  {\n   *    background(0, 255, 255);\n   *    text('release to release', width/2, height/2);\n   *\n   *    // ensures audio is enabled. See also: `userStartAudio`\n   *    triOsc.start();\n   *\n   *    env.triggerAttack(triOsc);\n   *  }\n   *\n   *  function mouseReleased() {\n   *    background(220);\n   *    text('tap to triggerAttack', width/2, height/2);\n   *\n   *    env.triggerRelease(triOsc);\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.Envelope.prototype.triggerRelease = function (unit, secondsFromNow) {\n    if (!this.wasTriggered) {\n      return;\n    }\n\n    var now = p5sound.audiocontext.currentTime;\n    var tFromNow = secondsFromNow || 0;\n    var t = now + tFromNow;\n\n    if (unit) {\n      if (this.connection !== unit) {\n        this.connect(unit);\n      }\n    } \n\n\n    var valToSet = this.control.getValueAtTime(t);\n\n    if (this.isExponential === true) {\n      this.control.exponentialRampToValueAtTime(this.checkExpInput(valToSet), t);\n    } else {\n      this.control.linearRampToValueAtTime(valToSet, t);\n    } \n\n\n    t += this.rTime;\n\n    if (this.isExponential === true) {\n      this.control.exponentialRampToValueAtTime(this.checkExpInput(this.rLevel), t);\n      valToSet = this.checkExpInput(this.control.getValueAtTime(t));\n      this.control.cancelScheduledValues(t);\n      this.control.exponentialRampToValueAtTime(valToSet, t);\n    } else {\n      this.control.linearRampToValueAtTime(this.rLevel, t);\n      valToSet = this.control.getValueAtTime(t);\n      this.control.cancelScheduledValues(t);\n      this.control.linearRampToValueAtTime(valToSet, t);\n    }\n\n    this.wasTriggered = false;\n  };\n  /**\n   *  Exponentially ramp to a value using the first two\n   *  values from <code><a href=\"#/p5.Envelope/setADSR\">setADSR(attackTime, decayTime)</a></code>\n   *  as <a href=\"https://en.wikipedia.org/wiki/RC_time_constant\">\n   *  time constants</a> for simple exponential ramps.\n   *  If the value is higher than current value, it uses attackTime,\n   *  while a decrease uses decayTime.\n   *\n   *  @method  ramp\n   *  @for p5.Envelope\n   *  @param  {Object} unit           p5.sound Object or Web Audio Param\n   *  @param  {Number} secondsFromNow When to trigger the ramp\n   *  @param  {Number} v              Target value\n   *  @param  {Number} [v2]           Second target value (optional)\n   *  @example\n   *  <div><code>\n   *  let env, osc, amp;\n   *\n   *  let attackTime = 0.001;\n   *  let decayTime = 0.2;\n   *  let attackLevel = 1;\n   *  let decayLevel = 0;\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    fill(0,255,0);\n   *    noStroke();\n   *\n   *    env = new p5.Envelope();\n   *    env.setADSR(attackTime, decayTime);\n   *    osc = new p5.Oscillator();\n   *    osc.amp(env);\n   *    amp = new p5.Amplitude();\n   *\n   *    cnv.mousePressed(triggerRamp);\n   *  }\n   *\n   *  function triggerRamp() {\n   *    // ensures audio is enabled. See also: `userStartAudio`\n   *    osc.start();\n   *\n   *    env.ramp(osc, 0, attackLevel, decayLevel);\n   *  }\n   *\n   *  function draw() {\n   *    background(20);\n   *    text('tap to play', 10, 20);\n   *    let h = map(amp.getLevel(), 0, 0.4, 0, height);;\n   *    rect(0, height, width, -h);\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.Envelope.prototype.ramp = function (unit, secondsFromNow, v1, v2) {\n    var now = p5sound.audiocontext.currentTime;\n    var tFromNow = secondsFromNow || 0;\n    var t = now + tFromNow;\n    var destination1 = this.checkExpInput(v1);\n    var destination2 = typeof v2 !== 'undefined' ? this.checkExpInput(v2) : undefined; \n\n    if (unit) {\n      if (this.connection !== unit) {\n        this.connect(unit);\n      }\n    } \n\n\n    var currentVal = this.checkExpInput(this.control.getValueAtTime(t)); \n\n    if (destination1 > currentVal) {\n      this.control.setTargetAtTime(destination1, t, this._rampAttackTC);\n      t += this._rampAttackTime;\n    } \n    else if (destination1 < currentVal) {\n        this.control.setTargetAtTime(destination1, t, this._rampDecayTC);\n        t += this._rampDecayTime;\n      } \n\n\n    if (destination2 === undefined) return; \n\n    if (destination2 > destination1) {\n      this.control.setTargetAtTime(destination2, t, this._rampAttackTC);\n    } \n    else if (destination2 < destination1) {\n        this.control.setTargetAtTime(destination2, t, this._rampDecayTC);\n      }\n  };\n\n  p5.Envelope.prototype.connect = function (unit) {\n    this.connection = unit; \n\n    if (unit instanceof p5.Oscillator || unit instanceof p5.SoundFile || unit instanceof p5.AudioIn || unit instanceof p5.Reverb || unit instanceof p5.Noise || unit instanceof p5.Filter || unit instanceof p5.Delay) {\n      unit = unit.output.gain;\n    }\n\n    if (unit instanceof AudioParam) {\n      unit.setValueAtTime(0, p5sound.audiocontext.currentTime);\n    }\n\n    if (unit instanceof p5.Signal) {\n      unit.setValue(0);\n    }\n\n    this.output.connect(unit);\n  };\n\n  p5.Envelope.prototype.disconnect = function () {\n    if (this.output) {\n      this.output.disconnect();\n    }\n  }; \n\n  /**\n   *  Add a value to the p5.Oscillator's output amplitude,\n   *  and return the oscillator. Calling this method\n   *  again will override the initial add() with new values.\n   *\n   *  @method  add\n   *  @for p5.Envelope\n   *  @param {Number} number Constant number to add\n   *  @return {p5.Envelope} Envelope Returns this envelope\n   *                                     with scaled output\n   */\n\n\n  p5.Envelope.prototype.add = function (num) {\n    var add = new Add(num);\n    var thisChain = this.mathOps.length;\n    var nextChain = this.output;\n    return p5.prototype._mathChain(this, add, thisChain, nextChain, Add);\n  };\n  /**\n   *  Multiply the p5.Envelope's output amplitude\n   *  by a fixed value. Calling this method\n   *  again will override the initial mult() with new values.\n   *\n   *  @method  mult\n   *  @for p5.Envelope\n   *  @param {Number} number Constant number to multiply\n   *  @return {p5.Envelope} Envelope Returns this envelope\n   *                                     with scaled output\n   */\n\n\n  p5.Envelope.prototype.mult = function (num) {\n    var mult = new Mult(num);\n    var thisChain = this.mathOps.length;\n    var nextChain = this.output;\n    return p5.prototype._mathChain(this, mult, thisChain, nextChain, Mult);\n  };\n  /**\n   *  Scale this envelope's amplitude values to a given\n   *  range, and return the envelope. Calling this method\n   *  again will override the initial scale() with new values.\n   *\n   *  @method  scale\n   *  @for p5.Envelope\n   *  @param  {Number} inMin  input range minumum\n   *  @param  {Number} inMax  input range maximum\n   *  @param  {Number} outMin input range minumum\n   *  @param  {Number} outMax input range maximum\n   *  @return {p5.Envelope} Envelope Returns this envelope\n   *                                     with scaled output\n   */\n\n\n  p5.Envelope.prototype.scale = function (inMin, inMax, outMin, outMax) {\n    var scale = new Scale(inMin, inMax, outMin, outMax);\n    var thisChain = this.mathOps.length;\n    var nextChain = this.output;\n    return p5.prototype._mathChain(this, scale, thisChain, nextChain, Scale);\n  }; \n\n\n  p5.Envelope.prototype.dispose = function () {\n    var index = p5sound.soundArray.indexOf(this);\n    p5sound.soundArray.splice(index, 1);\n    this.disconnect();\n\n    if (this.control) {\n      this.control.dispose();\n      this.control = null;\n    }\n\n    for (var i = 1; i < this.mathOps.length; i++) {\n      this.mathOps[i].dispose();\n    }\n  }; \n\n\n  p5.Env = function (t1, l1, t2, l2, t3, l3) {\n    console.warn('WARNING: p5.Env is now deprecated and may be removed in future versions. ' + 'Please use the new p5.Envelope instead.');\n    p5.Envelope.call(this, t1, l1, t2, l2, t3, l3);\n  };\n\n  p5.Env.prototype = Object.create(p5.Envelope.prototype);\n}).call(exports, __nested_webpack_require_274422__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_300270__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_300270__(1);\n\n  __nested_webpack_require_300270__(23);\n  /**\n   *  Creates a Pulse object, an oscillator that implements\n   *  Pulse Width Modulation.\n   *  The pulse is created with two oscillators.\n   *  Accepts a parameter for frequency, and to set the\n   *  width between the pulses. See <a href=\"\n   *  http://p5js.org/reference/#/p5.Oscillator\">\n   *  <code>p5.Oscillator</code> for a full list of methods.\n   *\n   *  @class p5.Pulse\n   *  @extends p5.Oscillator\n   *  @constructor\n   *  @param {Number} [freq] Frequency in oscillations per second (Hz)\n   *  @param {Number} [w]    Width between the pulses (0 to 1.0,\n   *                         defaults to 0)\n   *  @example\n   *  <div><code>\n   *  let pulse;\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(startPulse);\n   *    background(220);\n   *\n   *    pulse = new p5.Pulse();\n   *    pulse.amp(0.5);\n   *    pulse.freq(220);\n   *  }\n   *  function startPulse() {\n   *    pulse.start();\n   *    pulse.amp(0.5, 0.02);\n   *  }\n   *  function mouseReleased() {\n   *    pulse.amp(0, 0.2);\n   *  }\n   *  function draw() {\n   *    background(220);\n   *    text('tap to play', 5, 20, width - 20);\n   *    let w = map(mouseX, 0, width, 0, 1);\n   *    w = constrain(w, 0, 1);\n   *    pulse.width(w);\n   *    text('pulse width: ' + w, 5, height - 20);\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.Pulse = function (freq, w) {\n    p5.Oscillator.call(this, freq, 'sawtooth'); \n\n    this.w = w || 0; \n\n    this.osc2 = new p5.SawOsc(freq); \n\n    this.dNode = p5sound.audiocontext.createDelay(); \n\n    this.dcOffset = createDCOffset();\n    this.dcGain = p5sound.audiocontext.createGain();\n    this.dcOffset.connect(this.dcGain);\n    this.dcGain.connect(this.output); \n\n    this.f = freq || 440;\n    var mW = this.w / this.oscillator.frequency.value;\n    this.dNode.delayTime.value = mW;\n    this.dcGain.gain.value = 1.7 * (0.5 - this.w); \n\n    this.osc2.disconnect();\n    this.osc2.panner.disconnect();\n    this.osc2.amp(-1); \n\n    this.osc2.output.connect(this.dNode);\n    this.dNode.connect(this.output);\n    this.output.gain.value = 1;\n    this.output.connect(this.panner);\n  };\n\n  p5.Pulse.prototype = Object.create(p5.Oscillator.prototype);\n  /**\n   *  Set the width of a Pulse object (an oscillator that implements\n   *  Pulse Width Modulation).\n   *\n   *  @method  width\n   *  @param {Number} [width]    Width between the pulses (0 to 1.0,\n   *                         defaults to 0)\n   */\n\n  p5.Pulse.prototype.width = function (w) {\n    if (typeof w === 'number') {\n      if (w <= 1.0 && w >= 0.0) {\n        this.w = w; \n\n        var mW = this.w / this.oscillator.frequency.value;\n        this.dNode.delayTime.value = mW;\n      }\n\n      this.dcGain.gain.value = 1.7 * (0.5 - this.w);\n    } else {\n      w.connect(this.dNode.delayTime);\n      var sig = new p5.SignalAdd(-0.5);\n      sig.setInput(w);\n      sig = sig.mult(-1);\n      sig = sig.mult(1.7);\n      sig.connect(this.dcGain.gain);\n    }\n  };\n\n  p5.Pulse.prototype.start = function (f, time) {\n    var now = p5sound.audiocontext.currentTime;\n    var t = time || 0;\n\n    if (!this.started) {\n      var freq = f || this.f;\n      var type = this.oscillator.type;\n      this.oscillator = p5sound.audiocontext.createOscillator();\n      this.oscillator.frequency.setValueAtTime(freq, now);\n      this.oscillator.type = type;\n      this.oscillator.connect(this.output);\n      this.oscillator.start(t + now); \n\n      this.osc2.oscillator = p5sound.audiocontext.createOscillator();\n      this.osc2.oscillator.frequency.setValueAtTime(freq, t + now);\n      this.osc2.oscillator.type = type;\n      this.osc2.oscillator.connect(this.osc2.output);\n      this.osc2.start(t + now);\n      this.freqNode = [this.oscillator.frequency, this.osc2.oscillator.frequency]; \n\n      this.dcOffset = createDCOffset();\n      this.dcOffset.connect(this.dcGain);\n      this.dcOffset.start(t + now); \n\n      if (this.mods !== undefined && this.mods.frequency !== undefined) {\n        this.mods.frequency.connect(this.freqNode[0]);\n        this.mods.frequency.connect(this.freqNode[1]);\n      }\n\n      this.started = true;\n      this.osc2.started = true;\n    }\n  };\n\n  p5.Pulse.prototype.stop = function (time) {\n    if (this.started) {\n      var t = time || 0;\n      var now = p5sound.audiocontext.currentTime;\n      this.oscillator.stop(t + now);\n\n      if (this.osc2.oscillator) {\n        this.osc2.oscillator.stop(t + now);\n      }\n\n      this.dcOffset.stop(t + now);\n      this.started = false;\n      this.osc2.started = false;\n    }\n  };\n\n  p5.Pulse.prototype.freq = function (val, rampTime, tFromNow) {\n    if (typeof val === 'number') {\n      this.f = val;\n      var now = p5sound.audiocontext.currentTime;\n      var rampTime = rampTime || 0;\n      var tFromNow = tFromNow || 0;\n      var currentFreq = this.oscillator.frequency.value;\n      this.oscillator.frequency.cancelScheduledValues(now);\n      this.oscillator.frequency.setValueAtTime(currentFreq, now + tFromNow);\n      this.oscillator.frequency.exponentialRampToValueAtTime(val, tFromNow + rampTime + now);\n      this.osc2.oscillator.frequency.cancelScheduledValues(now);\n      this.osc2.oscillator.frequency.setValueAtTime(currentFreq, now + tFromNow);\n      this.osc2.oscillator.frequency.exponentialRampToValueAtTime(val, tFromNow + rampTime + now);\n\n      if (this.freqMod) {\n        this.freqMod.output.disconnect();\n        this.freqMod = null;\n      }\n    } else if (val.output) {\n      val.output.disconnect();\n      val.output.connect(this.oscillator.frequency);\n      val.output.connect(this.osc2.oscillator.frequency);\n      this.freqMod = val;\n    }\n  }; \n\n\n  function createDCOffset() {\n    var ac = p5sound.audiocontext;\n    var buffer = ac.createBuffer(1, 2048, ac.sampleRate);\n    var data = buffer.getChannelData(0);\n\n    for (var i = 0; i < 2048; i++) {\n      data[i] = 1.0;\n    }\n\n    var bufferSource = ac.createBufferSource();\n    bufferSource.buffer = buffer;\n    bufferSource.loop = true;\n    return bufferSource;\n  }\n}).call(exports, __nested_webpack_require_300270__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_306638__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_306638__(1);\n  /**\n   *  Noise is a type of oscillator that generates a buffer with random values.\n   *\n   *  @class p5.Noise\n   *  @extends p5.Oscillator\n   *  @constructor\n   *  @param {String} type Type of noise can be 'white' (default),\n   *                       'brown' or 'pink'.\n   */\n\n\n  p5.Noise = function (type) {\n    var assignType;\n    p5.Oscillator.call(this);\n    delete this.f;\n    delete this.freq;\n    delete this.oscillator;\n\n    if (type === 'brown') {\n      assignType = _brownNoise;\n    } else if (type === 'pink') {\n      assignType = _pinkNoise;\n    } else {\n      assignType = _whiteNoise;\n    }\n\n    this.buffer = assignType;\n  };\n\n  p5.Noise.prototype = Object.create(p5.Oscillator.prototype); \n\n  var _whiteNoise = function () {\n    var bufferSize = 2 * p5sound.audiocontext.sampleRate;\n    var whiteBuffer = p5sound.audiocontext.createBuffer(1, bufferSize, p5sound.audiocontext.sampleRate);\n    var noiseData = whiteBuffer.getChannelData(0);\n\n    for (var i = 0; i < bufferSize; i++) {\n      noiseData[i] = Math.random() * 2 - 1;\n    }\n\n    whiteBuffer.type = 'white';\n    return whiteBuffer;\n  }();\n\n  var _pinkNoise = function () {\n    var bufferSize = 2 * p5sound.audiocontext.sampleRate;\n    var pinkBuffer = p5sound.audiocontext.createBuffer(1, bufferSize, p5sound.audiocontext.sampleRate);\n    var noiseData = pinkBuffer.getChannelData(0);\n    var b0, b1, b2, b3, b4, b5, b6;\n    b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\n    for (var i = 0; i < bufferSize; i++) {\n      var white = Math.random() * 2 - 1;\n      b0 = 0.99886 * b0 + white * 0.0555179;\n      b1 = 0.99332 * b1 + white * 0.0750759;\n      b2 = 0.96900 * b2 + white * 0.1538520;\n      b3 = 0.86650 * b3 + white * 0.3104856;\n      b4 = 0.55000 * b4 + white * 0.5329522;\n      b5 = -0.7616 * b5 - white * 0.0168980;\n      noiseData[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n      noiseData[i] *= 0.11; \n\n      b6 = white * 0.115926;\n    }\n\n    pinkBuffer.type = 'pink';\n    return pinkBuffer;\n  }();\n\n  var _brownNoise = function () {\n    var bufferSize = 2 * p5sound.audiocontext.sampleRate;\n    var brownBuffer = p5sound.audiocontext.createBuffer(1, bufferSize, p5sound.audiocontext.sampleRate);\n    var noiseData = brownBuffer.getChannelData(0);\n    var lastOut = 0.0;\n\n    for (var i = 0; i < bufferSize; i++) {\n      var white = Math.random() * 2 - 1;\n      noiseData[i] = (lastOut + 0.02 * white) / 1.02;\n      lastOut = noiseData[i];\n      noiseData[i] *= 3.5;\n    }\n\n    brownBuffer.type = 'brown';\n    return brownBuffer;\n  }();\n  /**\n   *  Set type of noise to 'white', 'pink' or 'brown'.\n   *  White is the default.\n   *\n   *  @method setType\n   *  @param {String} [type] 'white', 'pink' or 'brown'\n   */\n\n\n  p5.Noise.prototype.setType = function (type) {\n    switch (type) {\n      case 'white':\n        this.buffer = _whiteNoise;\n        break;\n\n      case 'pink':\n        this.buffer = _pinkNoise;\n        break;\n\n      case 'brown':\n        this.buffer = _brownNoise;\n        break;\n\n      default:\n        this.buffer = _whiteNoise;\n    }\n\n    if (this.started) {\n      var now = p5sound.audiocontext.currentTime;\n      this.stop(now);\n      this.start(now + .01);\n    }\n  };\n\n  p5.Noise.prototype.getType = function () {\n    return this.buffer.type;\n  };\n\n  p5.Noise.prototype.start = function () {\n    if (this.started) {\n      this.stop();\n    }\n\n    this.noise = p5sound.audiocontext.createBufferSource();\n    this.noise.buffer = this.buffer;\n    this.noise.loop = true;\n    this.noise.connect(this.output);\n    var now = p5sound.audiocontext.currentTime;\n    this.noise.start(now);\n    this.started = true;\n  };\n\n  p5.Noise.prototype.stop = function () {\n    var now = p5sound.audiocontext.currentTime;\n\n    if (this.noise) {\n      this.noise.stop(now);\n      this.started = false;\n    }\n  };\n\n  p5.Noise.prototype.dispose = function () {\n    var now = p5sound.audiocontext.currentTime; \n\n    var index = p5sound.soundArray.indexOf(this);\n    p5sound.soundArray.splice(index, 1);\n\n    if (this.noise) {\n      this.noise.disconnect();\n      this.stop(now);\n    }\n\n    if (this.output) {\n      this.output.disconnect();\n    }\n\n    if (this.panner) {\n      this.panner.disconnect();\n    }\n\n    this.output = null;\n    this.panner = null;\n    this.buffer = null;\n    this.noise = null;\n  };\n}).call(exports, __nested_webpack_require_306638__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_311303__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_311303__(1); \n\n\n  p5sound.inputSources = [];\n  /**\n   *  <p>Get audio from an input, i.e. your computer's microphone.</p>\n   *\n   *  <p>Turn the mic on/off with the start() and stop() methods. When the mic\n   *  is on, its volume can be measured with getLevel or by connecting an\n   *  FFT object.</p>\n   *\n   *  <p>If you want to hear the AudioIn, use the .connect() method.\n   *  AudioIn does not connect to p5.sound output by default to prevent\n   *  feedback.</p>\n   *\n   *  <p><em>Note: This uses the <a href=\"http://caniuse.com/stream\">getUserMedia/\n   *  Stream</a> API, which is not supported by certain browsers. Access in Chrome browser\n   *  is limited to localhost and https, but access over http may be limited.</em></p>\n   *\n   *  @class p5.AudioIn\n   *  @constructor\n   *  @param {Function} [errorCallback] A function to call if there is an error\n   *                                    accessing the AudioIn. For example,\n   *                                    Safari and iOS devices do not\n   *                                    currently allow microphone access.\n   *  @example\n   *  <div><code>\n   *  let mic;\n   *\n   *   function setup(){\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(userStartAudio);\n   *    textAlign(CENTER);\n   *    mic = new p5.AudioIn();\n   *    mic.start();\n   *  }\n   *\n   *  function draw(){\n   *    background(0);\n   *    fill(255);\n   *    text('tap to start', width/2, 20);\n   *\n   *    micLevel = mic.getLevel();\n   *    let y = height - micLevel * height;\n   *    ellipse(width/2, y, 10, 10);\n   *  }\n   *  </code></div>\n   */\n\n  p5.AudioIn = function (errorCallback) {\n\n    /**\n     * @property {GainNode} input\n     */\n    this.input = p5sound.audiocontext.createGain();\n    /**\n     * @property {GainNode} output\n     */\n\n    this.output = p5sound.audiocontext.createGain();\n    /**\n     * @property {MediaStream|null} stream\n     */\n\n    this.stream = null;\n    /**\n     * @property {MediaStreamAudioSourceNode|null} mediaStream\n     */\n\n    this.mediaStream = null;\n    /**\n     * @property {Number|null} currentSource\n     */\n\n    this.currentSource = null;\n    /**\n     *  Client must allow browser to access their microphone / audioin source.\n     *  Default: false. Will become true when the client enables access.\n     *\n     *  @property {Boolean} enabled\n     */\n\n    this.enabled = false;\n    /**\n     * Input amplitude, connect to it by default but not to master out\n     *\n     *  @property {p5.Amplitude} amplitude\n     */\n\n    this.amplitude = new p5.Amplitude();\n    this.output.connect(this.amplitude.input);\n\n    if (!window.MediaStreamTrack || !window.navigator.mediaDevices || !window.navigator.mediaDevices.getUserMedia) {\n      errorCallback ? errorCallback() : window.alert('This browser does not support MediaStreamTrack and mediaDevices');\n    } \n\n\n    p5sound.soundArray.push(this);\n  };\n  /**\n   *  Start processing audio input. This enables the use of other\n   *  AudioIn methods like getLevel(). Note that by default, AudioIn\n   *  is not connected to p5.sound's output. So you won't hear\n   *  anything unless you use the connect() method.<br/>\n   *\n   *  Certain browsers limit access to the user's microphone. For example,\n   *  Chrome only allows access from localhost and over https. For this reason,\n   *  you may want to include an errorCallback—a function that is called in case\n   *  the browser won't provide mic access.\n   *\n   *  @method start\n   *  @for p5.AudioIn\n   *  @param {Function} [successCallback] Name of a function to call on\n   *                                    success.\n   *  @param {Function} [errorCallback] Name of a function to call if\n   *                                    there was an error. For example,\n   *                                    some browsers do not support\n   *                                    getUserMedia.\n   */\n\n\n  p5.AudioIn.prototype.start = function (successCallback, errorCallback) {\n    var self = this;\n\n    if (this.stream) {\n      this.stop();\n    } \n\n\n    var audioSource = p5sound.inputSources[self.currentSource];\n    var constraints = {\n      audio: {\n        sampleRate: p5sound.audiocontext.sampleRate,\n        echoCancellation: false\n      }\n    }; \n\n    if (p5sound.inputSources[this.currentSource]) {\n      constraints.audio.deviceId = audioSource.deviceId;\n    }\n\n    window.navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {\n      self.stream = stream;\n      self.enabled = true; \n\n      self.mediaStream = p5sound.audiocontext.createMediaStreamSource(stream);\n      self.mediaStream.connect(self.output); \n\n      self.amplitude.setInput(self.output);\n      if (successCallback) successCallback();\n    })[\"catch\"](function (err) {\n      if (errorCallback) errorCallback(err);else console.error(err);\n    });\n  };\n  /**\n   *  Turn the AudioIn off. If the AudioIn is stopped, it cannot getLevel().\n   *  If re-starting, the user may be prompted for permission access.\n   *\n   *  @method stop\n   *  @for p5.AudioIn\n   */\n\n\n  p5.AudioIn.prototype.stop = function () {\n    if (this.stream) {\n      this.stream.getTracks().forEach(function (track) {\n        track.stop();\n      });\n      this.mediaStream.disconnect();\n      delete this.mediaStream;\n      delete this.stream;\n    }\n  };\n  /**\n   *  Connect to an audio unit. If no parameter is provided, will\n   *  connect to the master output (i.e. your speakers).<br/>\n   *\n   *  @method  connect\n   *  @for p5.AudioIn\n   *  @param  {Object} [unit] An object that accepts audio input,\n   *                          such as an FFT\n   */\n\n\n  p5.AudioIn.prototype.connect = function (unit) {\n    if (unit) {\n      if (unit.hasOwnProperty('input')) {\n        this.output.connect(unit.input);\n      } else if (unit.hasOwnProperty('analyser')) {\n        this.output.connect(unit.analyser);\n      } else {\n        this.output.connect(unit);\n      }\n    } else {\n      this.output.connect(p5sound.input);\n    }\n  };\n  /**\n   *  Disconnect the AudioIn from all audio units. For example, if\n   *  connect() had been called, disconnect() will stop sending\n   *  signal to your speakers.<br/>\n   *\n   *  @method  disconnect\n   *  @for p5.AudioIn\n   */\n\n\n  p5.AudioIn.prototype.disconnect = function () {\n    if (this.output) {\n      this.output.disconnect(); \n\n      this.output.connect(this.amplitude.input);\n    }\n  };\n  /**\n   *  Read the Amplitude (volume level) of an AudioIn. The AudioIn\n   *  class contains its own instance of the Amplitude class to help\n   *  make it easy to get a microphone's volume level. Accepts an\n   *  optional smoothing value (0.0 < 1.0). <em>NOTE: AudioIn must\n   *  .start() before using .getLevel().</em><br/>\n   *\n   *  @method  getLevel\n   *  @for p5.AudioIn\n   *  @param  {Number} [smoothing] Smoothing is 0.0 by default.\n   *                               Smooths values based on previous values.\n   *  @return {Number}           Volume level (between 0.0 and 1.0)\n   */\n\n\n  p5.AudioIn.prototype.getLevel = function (smoothing) {\n    if (smoothing) {\n      this.amplitude.smoothing = smoothing;\n    }\n\n    return this.amplitude.getLevel();\n  };\n  /**\n   *  Set amplitude (volume) of a mic input between 0 and 1.0. <br/>\n   *\n   *  @method  amp\n   *  @for p5.AudioIn\n   *  @param  {Number} vol between 0 and 1.0\n   *  @param {Number} [time] ramp time (optional)\n   */\n\n\n  p5.AudioIn.prototype.amp = function (vol, t) {\n    if (t) {\n      var rampTime = t || 0;\n      var currentVol = this.output.gain.value;\n      this.output.gain.cancelScheduledValues(p5sound.audiocontext.currentTime);\n      this.output.gain.setValueAtTime(currentVol, p5sound.audiocontext.currentTime);\n      this.output.gain.linearRampToValueAtTime(vol, rampTime + p5sound.audiocontext.currentTime);\n    } else {\n      this.output.gain.cancelScheduledValues(p5sound.audiocontext.currentTime);\n      this.output.gain.setValueAtTime(vol, p5sound.audiocontext.currentTime);\n    }\n  };\n  /**\n   * Returns a list of available input sources. This is a wrapper\n   * for <a title=\"MediaDevices.enumerateDevices() - Web APIs | MDN\" target=\"_blank\" href=\n   *  \"https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices\"\n   *  > and it returns a Promise.\n   *\n   * @method  getSources\n   * @for p5.AudioIn\n   * @param  {Function} [successCallback] This callback function handles the sources when they\n   *                                      have been enumerated. The callback function\n   *                                      receives the deviceList array as its only argument\n   * @param  {Function} [errorCallback] This optional callback receives the error\n   *                                    message as its argument.\n   * @returns {Promise} Returns a Promise that can be used in place of the callbacks, similar\n   *                            to the enumerateDevices() method\n   * @example\n   *  <div><code>\n   *  let audioIn;\n   *\n   *  function setup(){\n   *    text('getting sources...', 0, 20);\n   *    audioIn = new p5.AudioIn();\n   *    audioIn.getSources(gotSources);\n   *  }\n   *\n   *  function gotSources(deviceList) {\n   *    if (deviceList.length > 0) {\n   *      //set the source to the first item in the deviceList array\n   *      audioIn.setSource(0);\n   *      let currentSource = deviceList[audioIn.currentSource];\n   *      text('set source to: ' + currentSource.deviceId, 5, 20, width);\n   *    }\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.AudioIn.prototype.getSources = function (onSuccess, onError) {\n    return new Promise(function (resolve, reject) {\n      window.navigator.mediaDevices.enumerateDevices().then(function (devices) {\n        p5sound.inputSources = devices.filter(function (device) {\n          return device.kind === 'audioinput';\n        });\n        resolve(p5sound.inputSources);\n\n        if (onSuccess) {\n          onSuccess(p5sound.inputSources);\n        }\n      })[\"catch\"](function (error) {\n        reject(error);\n\n        if (onError) {\n          onError(error);\n        } else {\n          console.error('This browser does not support MediaStreamTrack.getSources()');\n        }\n      });\n    });\n  };\n  /**\n   *  Set the input source. Accepts a number representing a\n   *  position in the array returned by getSources().\n   *  This is only available in browsers that support\n   *  <a title=\"MediaDevices.enumerateDevices() - Web APIs | MDN\" target=\"_blank\" href=\n   *  \"https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices\"\n   *  >navigator.mediaDevices.enumerateDevices()</a>.<br/>\n   *\n   *  @method setSource\n   *  @for p5.AudioIn\n   *  @param {number} num position of input source in the array\n   *  @example\n   *  <div><code>\n   *  let audioIn;\n   *\n   *  function setup(){\n   *    text('getting sources...', 0, 20);\n   *    audioIn = new p5.AudioIn();\n   *    audioIn.getSources(gotSources);\n   *  }\n   *\n   *  function gotSources(deviceList) {\n   *    if (deviceList.length > 0) {\n   *      //set the source to the first item in the deviceList array\n   *      audioIn.setSource(0);\n   *      let currentSource = deviceList[audioIn.currentSource];\n   *      text('set source to: ' + currentSource.deviceId, 5, 20, width);\n   *    }\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.AudioIn.prototype.setSource = function (num) {\n    if (p5sound.inputSources.length > 0 && num < p5sound.inputSources.length) {\n      this.currentSource = num;\n      console.log('set source to ', p5sound.inputSources[this.currentSource]);\n    } else {\n      console.log('unable to set input source');\n    } \n\n\n    if (this.stream && this.stream.active) {\n      this.start();\n    }\n  }; \n\n\n  p5.AudioIn.prototype.dispose = function () {\n    var index = p5sound.soundArray.indexOf(this);\n    p5sound.soundArray.splice(index, 1);\n    this.stop();\n\n    if (this.output) {\n      this.output.disconnect();\n    }\n\n    if (this.amplitude) {\n      this.amplitude.disconnect();\n    }\n\n    delete this.amplitude;\n    delete this.output;\n  };\n}).call(exports, __nested_webpack_require_311303__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_323602__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_323602__(0),__nested_webpack_require_323602__(2),__nested_webpack_require_323602__(52),__nested_webpack_require_323602__(58),__nested_webpack_require_323602__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(i){\"use strict\";return i.CrossFade=function(e){this.createInsOuts(2,1),this.a=this.input[0]=new i.Gain,this.b=this.input[1]=new i.Gain,this.fade=new i.Signal(this.defaultArg(e,.5),i.Type.NormalRange),this._equalPowerA=new i.EqualPowerGain,this._equalPowerB=new i.EqualPowerGain,this._invert=new i.Expr(\"1 - $0\"),this.a.connect(this.output),this.b.connect(this.output),this.fade.chain(this._equalPowerB,this.b.gain),this.fade.chain(this._invert,this._equalPowerA,this.a.gain),this._readOnly(\"fade\")},i.extend(i.CrossFade),i.CrossFade.prototype.dispose=function(){return i.prototype.dispose.call(this),this._writable(\"fade\"),this._equalPowerA.dispose(),this._equalPowerA=null,this._equalPowerB.dispose(),this._equalPowerB=null,this.fade.dispose(),this.fade=null,this._invert.dispose(),this._invert=null,this.a.dispose(),this.a=null,this.b.dispose(),this.b=null,this},i.CrossFade}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_324946__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_324946__(0),__nested_webpack_require_324946__(7),__nested_webpack_require_324946__(16),__nested_webpack_require_324946__(3),__nested_webpack_require_324946__(53),__nested_webpack_require_324946__(26),__nested_webpack_require_324946__(54),__nested_webpack_require_324946__(25),__nested_webpack_require_324946__(55),__nested_webpack_require_324946__(56),__nested_webpack_require_324946__(57)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(p){\"use strict\";function r(e,n,r){var t=new e;return r._eval(n[0]).connect(t,0,0),r._eval(n[1]).connect(t,0,1),t}function t(e,n,r){var t=new e;return r._eval(n[0]).connect(t,0,0),t}function o(e){return e?parseFloat(e):void 0}function i(e){return e&&e.args?parseFloat(e.args):void 0}return p.Expr=function(){var n=this._replacements(Array.prototype.slice.call(arguments)),e=this._parseInputs(n);this._nodes=[],this.input=new Array(e);for(var r=0;r<e;r++)this.input[r]=this.context.createGain();var t,o=this._parseTree(n);try{t=this._eval(o)}catch(e){throw this._disposeNodes(),new Error(\"Tone.Expr: Could evaluate expression: \"+n)}this.output=t},p.extend(p.Expr,p.SignalBase),p.Expr._Expressions={value:{signal:{regexp:/^\\d+\\.\\d+|^\\d+/,method:function(e){return new p.Signal(o(e))}},input:{regexp:/^\\$\\d/,method:function(e,n){return n.input[o(e.substr(1))]}}},glue:{\"(\":{regexp:/^\\(/},\")\":{regexp:/^\\)/},\",\":{regexp:/^,/}},func:{abs:{regexp:/^abs/,method:t.bind(this,p.Abs)},mod:{regexp:/^mod/,method:function(e,n){var r=i(e[1]),t=new p.Modulo(r);return n._eval(e[0]).connect(t),t}},pow:{regexp:/^pow/,method:function(e,n){var r=i(e[1]),t=new p.Pow(r);return n._eval(e[0]).connect(t),t}},a2g:{regexp:/^a2g/,method:function(e,n){var r=new p.AudioToGain;return n._eval(e[0]).connect(r),r}}},binary:{\"+\":{regexp:/^\\+/,precedence:1,method:r.bind(this,p.Add)},\"-\":{regexp:/^\\-/,precedence:1,method:function(e,n){return 1===e.length?t(p.Negate,e,n):r(p.Subtract,e,n)}},\"*\":{regexp:/^\\*/,precedence:0,method:r.bind(this,p.Multiply)}},unary:{\"-\":{regexp:/^\\-/,method:t.bind(this,p.Negate)},\"!\":{regexp:/^\\!/,method:t.bind(this,p.NOT)}}},p.Expr.prototype._parseInputs=function(e){var n=e.match(/\\$\\d/g),r=0;if(null!==n)for(var t=0;t<n.length;t++){var o=parseInt(n[t].substr(1))+1;r=Math.max(r,o)}return r},p.Expr.prototype._replacements=function(e){for(var n=e.shift(),r=0;r<e.length;r++)n=n.replace(/\\%/i,e[r]);return n},p.Expr.prototype._tokenize=function(e){for(var n=-1,r=[];0<e.length;){var t=o(e=e.trim());r.push(t),e=e.substr(t.value.length)}function o(e){for(var n in p.Expr._Expressions){var r=p.Expr._Expressions[n];for(var t in r){var o=r[t],i=o.regexp,a=e.match(i);if(null!==a)return{type:n,value:a[0],method:o.method}}}throw new SyntaxError(\"Tone.Expr: Unexpected token \"+e)}return{next:function(){return r[++n]},peek:function(){return r[n+1]}}},p.Expr.prototype._parseTree=function(e){var t=this._tokenize(e),a=this.isUndef.bind(this);function r(e,n){return!a(e)&&\"glue\"===e.type&&e.value===n}function o(e,n,r){var t=p.Expr._Expressions[n];if(!a(e))for(var o in t){var i=t[o];if(i.regexp.test(e.value)){if(a(r))return!0;if(i.precedence===r)return!0}}return!1}function i(e){var n;a(e)&&(e=5),n=e<0?function e(){var n,r;n=t.peek();if(o(n,\"unary\"))return n=t.next(),r=e(),{operator:n.value,method:n.method,args:[r]};return s()}():i(e-1);for(var r=t.peek();o(r,\"binary\",e);)n={operator:(r=t.next()).value,method:r.method,args:[n,i(e-1)]},r=t.peek();return n}function s(){var e,n;if(e=t.peek(),a(e))throw new SyntaxError(\"Tone.Expr: Unexpected termination of expression\");if(\"func\"===e.type)return function(e){var n=[];if(!r(t.next(),\"(\"))throw new SyntaxError('Tone.Expr: Expected ( in a function call \"'+e.value+'\"');r(t.peek(),\")\")||(n=function(){var e,n=[];for(;e=i(),!a(e)&&(n.push(e),r(t.peek(),\",\"));)t.next();return n}());if(r(t.next(),\")\"))return{method:e.method,args:n,name:name};throw new SyntaxError('Tone.Expr: Expected ) in a function call \"'+e.value+'\"')}(e=t.next());if(\"value\"===e.type)return{method:(e=t.next()).method,args:e.value};if(r(e,\"(\")){if(t.next(),n=i(),!r(e=t.next(),\")\"))throw new SyntaxError(\"Expected )\");return n}throw new SyntaxError(\"Tone.Expr: Parse error, cannot process token \"+e.value)}return i()},p.Expr.prototype._eval=function(e){if(!this.isUndef(e)){var n=e.method(e.args,this);return this._nodes.push(n),n}},p.Expr.prototype._disposeNodes=function(){for(var e=0;e<this._nodes.length;e++){var n=this._nodes[e];this.isFunction(n.dispose)?n.dispose():this.isFunction(n.disconnect)&&n.disconnect(),n=null,this._nodes[e]=null}this._nodes=null},p.Expr.prototype.dispose=function(){p.prototype.dispose.call(this),this._disposeNodes()},p.Expr}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_329735__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_329735__(0),__nested_webpack_require_329735__(26),__nested_webpack_require_329735__(16),__nested_webpack_require_329735__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(e){\"use strict\";return e.GreaterThan=function(t){this.createInsOuts(2,0),this._param=this.input[0]=new e.Subtract(t),this.input[1]=this._param.input[1],this._gtz=this.output=new e.GreaterThanZero,this._param.connect(this._gtz)},e.extend(e.GreaterThan,e.Signal),e.GreaterThan.prototype.dispose=function(){return e.prototype.dispose.call(this),this._param.dispose(),this._param=null,this._gtz.dispose(),this._gtz=null,this},e.GreaterThan}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_330615__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_330615__(0),__nested_webpack_require_330615__(5),__nested_webpack_require_330615__(19)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(s){\"use strict\";return s.Abs=function(){this._abs=this.input=this.output=new s.WaveShaper(function(s){return 0===s?0:Math.abs(s)},127)},s.extend(s.Abs,s.SignalBase),s.Abs.prototype.dispose=function(){return s.prototype.dispose.call(this),this._abs.dispose(),this._abs=null,this},s.Abs}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_331320__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_331320__(0),__nested_webpack_require_331320__(5),__nested_webpack_require_331320__(3),__nested_webpack_require_331320__(16)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(i){\"use strict\";return i.Modulo=function(t){this.createInsOuts(1,0),this._shaper=new i.WaveShaper(Math.pow(2,16)),this._multiply=new i.Multiply,this._subtract=this.output=new i.Subtract,this._modSignal=new i.Signal(t),this.input.fan(this._shaper,this._subtract),this._modSignal.connect(this._multiply,0,0),this._shaper.connect(this._multiply,0,1),this._multiply.connect(this._subtract,0,1),this._setWaveShaper(t)},i.extend(i.Modulo,i.SignalBase),i.Modulo.prototype._setWaveShaper=function(i){this._shaper.setMap(function(t){return Math.floor((t+1e-4)/i)})},Object.defineProperty(i.Modulo.prototype,\"value\",{get:function(){return this._modSignal.value},set:function(t){this._modSignal.value=t,this._setWaveShaper(t)}}),i.Modulo.prototype.dispose=function(){return i.prototype.dispose.call(this),this._shaper.dispose(),this._shaper=null,this._multiply.dispose(),this._multiply=null,this._subtract.dispose(),this._subtract=null,this._modSignal.dispose(),this._modSignal=null,this},i.Modulo}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_332750__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_332750__(0),__nested_webpack_require_332750__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(t){\"use strict\";return t.Pow=function(e){this._exp=this.defaultArg(e,1),this._expScaler=this.input=this.output=new t.WaveShaper(this._expFunc(this._exp),8192)},t.extend(t.Pow,t.SignalBase),Object.defineProperty(t.Pow.prototype,\"value\",{get:function(){return this._exp},set:function(e){this._exp=e,this._expScaler.setMap(this._expFunc(this._exp))}}),t.Pow.prototype._expFunc=function(t){return function(e){return Math.pow(Math.abs(e),t)}},t.Pow.prototype.dispose=function(){return t.prototype.dispose.call(this),this._expScaler.dispose(),this._expScaler=null,this},t.Pow}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_333716__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_333716__(0),__nested_webpack_require_333716__(5),__nested_webpack_require_333716__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(n){\"use strict\";return n.AudioToGain=function(){this._norm=this.input=this.output=new n.WaveShaper(function(n){return(n+1)/2})},n.extend(n.AudioToGain,n.SignalBase),n.AudioToGain.prototype.dispose=function(){return n.prototype.dispose.call(this),this._norm.dispose(),this._norm=null,this},n.AudioToGain}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_334438__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_334438__(0),__nested_webpack_require_334438__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(e){\"use strict\";return e.EqualPowerGain=function(){this._eqPower=this.input=this.output=new e.WaveShaper(function(e){return Math.abs(e)<.001?0:this.equalPowerScale(e)}.bind(this),4096)},e.extend(e.EqualPowerGain,e.SignalBase),e.EqualPowerGain.prototype.dispose=function(){return e.prototype.dispose.call(this),this._eqPower.dispose(),this._eqPower=null,this},e.EqualPowerGain}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_335210__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var Effect = __nested_webpack_require_335210__(4);\n\n  var EQFilter = __nested_webpack_require_335210__(60);\n  /**\n   * p5.EQ is an audio effect that performs the function of a multiband\n   * audio equalizer. Equalization is used to adjust the balance of\n   * frequency compoenents of an audio signal. This process is commonly used\n   * in sound production and recording to change the waveform before it reaches\n   * a sound output device. EQ can also be used as an audio effect to create\n   * interesting distortions by filtering out parts of the spectrum. p5.EQ is\n   * built using a chain of Web Audio Biquad Filter Nodes and can be\n   * instantiated with 3 or 8 bands. Bands can be added or removed from\n   * the EQ by directly modifying p5.EQ.bands (the array that stores filters).\n   *\n   * This class extends <a href = \"/reference/#/p5.Effect\">p5.Effect</a>.\n   * Methods <a href = \"/reference/#/p5.Effect/amp\">amp()</a>, <a href = \"/reference/#/p5.Effect/chain\">chain()</a>,\n   * <a href = \"/reference/#/p5.Effect/drywet\">drywet()</a>, <a href = \"/reference/#/p5.Effect/connect\">connect()</a>, and\n   * <a href = \"/reference/#/p5.Effect/disconnect\">disconnect()</a> are available.\n   *\n   * @class p5.EQ\n   * @constructor\n   * @extends p5.Effect\n   * @param {Number} [_eqsize] Constructor will accept 3 or 8, defaults to 3\n   * @return {Object} p5.EQ object\n   *\n   * @example\n   * <div><code>\n   * let eq, soundFile\n   * let eqBandIndex = 0;\n   * let eqBandNames = ['lows', 'mids', 'highs'];\n   *\n   * function preload() {\n   *   soundFormats('mp3', 'ogg');\n   *   soundFile = loadSound('assets/beat');\n   * }\n   *\n   * function setup() {\n   *   let cnv = createCanvas(100, 100);\n   *   cnv.mousePressed(toggleSound);\n   *\n   *   eq = new p5.EQ(eqBandNames.length);\n   *   soundFile.disconnect();\n   *   eq.process(soundFile);\n   * }\n   *\n   * function draw() {\n   *   background(30);\n   *   noStroke();\n   *   fill(255);\n   *   textAlign(CENTER);\n   *   text('filtering ', 50, 25);\n   *\n   *   fill(255, 40, 255);\n   *   textSize(26);\n   *   text(eqBandNames[eqBandIndex], 50, 55);\n   *\n   *   fill(255);\n   *   textSize(9);\n   *\n   *   if (!soundFile.isPlaying()) {\n   *     text('tap to play', 50, 80);\n   *   } else {\n   *     text('tap to filter next band', 50, 80)\n   *   }\n   * }\n   *\n   * function toggleSound() {\n   *   if (!soundFile.isPlaying()) {\n   *     soundFile.play();\n   *   } else {\n   *     eqBandIndex = (eqBandIndex + 1) % eq.bands.length;\n   *   }\n   *\n   *   for (let i = 0; i < eq.bands.length; i++) {\n   *     eq.bands[i].gain(0);\n   *   }\n   *   // filter the band we want to filter\n   *   eq.bands[eqBandIndex].gain(-40);\n   * }\n   * </code></div>\n   */\n\n\n  p5.EQ = function (_eqsize) {\n    Effect.call(this); \n\n    _eqsize = _eqsize === 3 || _eqsize === 8 ? _eqsize : 3;\n    var factor;\n    _eqsize === 3 ? factor = Math.pow(2, 3) : factor = 2;\n    /**\n      *  The p5.EQ is built with abstracted p5.Filter objects.\n      *  To modify any bands, use methods of the <a\n      *  href=\"/reference/#/p5.Filter\" title=\"p5.Filter reference\">\n      *  p5.Filter</a> API, especially `gain` and `freq`.\n      *  Bands are stored in an array, with indices 0 - 3, or 0 - 7\n      *  @property {Array}  bands\n      *\n    */\n\n    this.bands = [];\n    var freq, res;\n\n    for (var i = 0; i < _eqsize; i++) {\n      if (i === _eqsize - 1) {\n        freq = 21000;\n        res = .01;\n      } else if (i === 0) {\n        freq = 100;\n        res = .1;\n      } else if (i === 1) {\n        freq = _eqsize === 3 ? 360 * factor : 360;\n        res = 1;\n      } else {\n        freq = this.bands[i - 1].freq() * factor;\n        res = 1;\n      }\n\n      this.bands[i] = this._newBand(freq, res);\n\n      if (i > 0) {\n        this.bands[i - 1].connect(this.bands[i].biquad);\n      } else {\n        this.input.connect(this.bands[i].biquad);\n      }\n    }\n\n    this.bands[_eqsize - 1].connect(this.output);\n  };\n\n  p5.EQ.prototype = Object.create(Effect.prototype);\n  /**\n   * Process an input by connecting it to the EQ\n   * @method  process\n   * @param  {Object} src Audio source\n   */\n\n  p5.EQ.prototype.process = function (src) {\n    src.connect(this.input);\n  }; \n  //   * Set the frequency and gain of each band in the EQ. This method should be\n  //   * called with 3 or 8 frequency and gain pairs, depending on the size of the EQ.\n  //   * ex. eq.set(freq0, gain0, freq1, gain1, freq2, gain2);\n  //   *\n  //   * @method  set\n  //   * @for p5.EQ\n  //   * @param {Number} [freq0] Frequency value for band with index 0\n  //   * @param {Number} [gain0] Gain value for band with index 0\n  //   * @param {Number} [freq1] Frequency value for band with index 1\n  //   * @param {Number} [gain1] Gain value for band with index 1\n  //   * @param {Number} [freq2] Frequency value for band with index 2\n  //   * @param {Number} [gain2] Gain value for band with index 2\n  //   * @param {Number} [freq3] Frequency value for band with index 3\n  //   * @param {Number} [gain3] Gain value for band with index 3\n  //   * @param {Number} [freq4] Frequency value for band with index 4\n  //   * @param {Number} [gain4] Gain value for band with index 4\n  //   * @param {Number} [freq5] Frequency value for band with index 5\n  //   * @param {Number} [gain5] Gain value for band with index 5\n  //   * @param {Number} [freq6] Frequency value for band with index 6\n  //   * @param {Number} [gain6] Gain value for band with index 6\n  //   * @param {Number} [freq7] Frequency value for band with index 7\n  //   * @param {Number} [gain7] Gain value for band with index 7\n  //   */\n\n\n  p5.EQ.prototype.set = function () {\n    if (arguments.length === this.bands.length * 2) {\n      for (var i = 0; i < arguments.length; i += 2) {\n        this.bands[i / 2].freq(arguments[i]);\n        this.bands[i / 2].gain(arguments[i + 1]);\n      }\n    } else {\n      console.error('Argument mismatch. .set() should be called with ' + this.bands.length * 2 + ' arguments. (one frequency and gain value pair for each band of the eq)');\n    }\n  };\n  /**\n   * Add a new band. Creates a p5.Filter and strips away everything but\n   * the raw biquad filter. This method returns an abstracted p5.Filter,\n   * which can be added to p5.EQ.bands, in order to create new EQ bands.\n   * @private\n   * @for p5.EQ\n   * @method  _newBand\n   * @param  {Number} freq\n   * @param  {Number} res\n   * @return {Object}      Abstracted Filter\n   */\n\n\n  p5.EQ.prototype._newBand = function (freq, res) {\n    return new EQFilter(freq, res);\n  };\n\n  p5.EQ.prototype.dispose = function () {\n    Effect.prototype.dispose.apply(this);\n\n    if (this.bands) {\n      while (this.bands.length > 0) {\n        delete this.bands.pop().dispose();\n      }\n\n      delete this.bands;\n    }\n  };\n\n  return p5.EQ;\n}).call(exports, __nested_webpack_require_335210__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_342243__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var Filter = __nested_webpack_require_342243__(15);\n\n  var p5sound = __nested_webpack_require_342243__(1);\n  /**\n   *  EQFilter extends p5.Filter with constraints\n   *  necessary for the p5.EQ\n   *\n   *  @private\n   */\n\n\n  var EQFilter = function EQFilter(freq, res) {\n    Filter.call(this, 'peaking');\n    this.disconnect();\n    this.set(freq, res);\n    this.biquad.gain.value = 0;\n    delete this.input;\n    delete this.output;\n    delete this._drywet;\n    delete this.wet;\n  };\n\n  EQFilter.prototype = Object.create(Filter.prototype);\n\n  EQFilter.prototype.amp = function () {\n    console.warn('`amp()` is not available for p5.EQ bands. Use `.gain()`');\n  };\n\n  EQFilter.prototype.drywet = function () {\n    console.warn('`drywet()` is not available for p5.EQ bands.');\n  };\n\n  EQFilter.prototype.connect = function (unit) {\n    var u = unit || p5.soundOut.input;\n\n    if (this.biquad) {\n      this.biquad.connect(u.input ? u.input : u);\n    } else {\n      this.output.connect(u.input ? u.input : u);\n    }\n  };\n\n  EQFilter.prototype.disconnect = function () {\n    if (this.biquad) {\n      this.biquad.disconnect();\n    }\n  };\n\n  EQFilter.prototype.dispose = function () {\n    var index = p5sound.soundArray.indexOf(this);\n    p5sound.soundArray.splice(index, 1);\n    this.disconnect();\n    delete this.biquad;\n  };\n\n  return EQFilter;\n}).call(exports, __nested_webpack_require_342243__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_343878__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_343878__(1);\n\n  var Effect = __nested_webpack_require_343878__(4);\n  /**\n   * Panner3D is based on the <a title=\"Web Audio Panner docs\"  href=\n   * \"https://developer.mozilla.org/en-US/docs/Web/API/PannerNode\">\n   * Web Audio Spatial Panner Node</a>.\n   * This panner is a spatial processing node that allows audio to be positioned\n   * and oriented in 3D space.\n   *\n   * The position is relative to an <a title=\"Web Audio Listener docs\" href=\n   * \"https://developer.mozilla.org/en-US/docs/Web/API/AudioListener\">\n   * Audio Context Listener</a>, which can be accessed\n   * by <code>p5.soundOut.audiocontext.listener</code>\n   *\n   *\n   * @class p5.Panner3D\n   * @constructor\n   */\n\n\n  p5.Panner3D = function () {\n    Effect.call(this);\n    /**\n     *  <a title=\"Web Audio Panner docs\"  href=\n     *  \"https://developer.mozilla.org/en-US/docs/Web/API/PannerNode\">\n     *  Web Audio Spatial Panner Node</a>\n     *\n     *  Properties include\n     *    -  <a title=\"w3 spec for Panning Model\"\n     *    href=\"https://www.w3.org/TR/webaudio/#idl-def-PanningModelType\"\n     *    >panningModel</a>: \"equal power\" or \"HRTF\"\n     *    -  <a title=\"w3 spec for Distance Model\"\n     *    href=\"https://www.w3.org/TR/webaudio/#idl-def-DistanceModelType\"\n     *    >distanceModel</a>: \"linear\", \"inverse\", or \"exponential\"\n     *\n     *  @property {AudioNode} panner\n     *\n     */\n\n    this.panner = this.ac.createPanner();\n    this.panner.panningModel = 'HRTF';\n    this.panner.distanceModel = 'linear';\n    this.panner.connect(this.output);\n    this.input.connect(this.panner);\n  };\n\n  p5.Panner3D.prototype = Object.create(Effect.prototype);\n  /**\n   * Connect an audio sorce\n   *\n   * @method  process\n   * @for p5.Panner3D\n   * @param  {Object} src Input source\n   */\n\n  p5.Panner3D.prototype.process = function (src) {\n    src.connect(this.input);\n  };\n  /**\n   * Set the X,Y,Z position of the Panner\n   * @method set\n   * @for p5.Panner3D\n   * @param  {Number} xVal\n   * @param  {Number} yVal\n   * @param  {Number} zVal\n   * @param  {Number} time\n   * @return {Array}      Updated x, y, z values as an array\n   */\n\n\n  p5.Panner3D.prototype.set = function (xVal, yVal, zVal, time) {\n    this.positionX(xVal, time);\n    this.positionY(yVal, time);\n    this.positionZ(zVal, time);\n    return [this.panner.positionX.value, this.panner.positionY.value, this.panner.positionZ.value];\n  };\n  /**\n   * Getter and setter methods for position coordinates\n   * @method positionX\n   * @for p5.Panner3D\n   * @return {Number}      updated coordinate value\n   */\n\n  /**\n   * Getter and setter methods for position coordinates\n   * @method positionY\n   * @for p5.Panner3D\n   * @return {Number}      updated coordinate value\n   */\n\n  /**\n   * Getter and setter methods for position coordinates\n   * @method positionZ\n   * @for p5.Panner3D\n   * @return {Number}      updated coordinate value\n   */\n\n\n  p5.Panner3D.prototype.positionX = function (xVal, time) {\n    var t = time || 0;\n\n    if (typeof xVal === 'number') {\n      this.panner.positionX.value = xVal;\n      this.panner.positionX.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.panner.positionX.linearRampToValueAtTime(xVal, this.ac.currentTime + 0.02 + t);\n    } else if (xVal) {\n      xVal.connect(this.panner.positionX);\n    }\n\n    return this.panner.positionX.value;\n  };\n\n  p5.Panner3D.prototype.positionY = function (yVal, time) {\n    var t = time || 0;\n\n    if (typeof yVal === 'number') {\n      this.panner.positionY.value = yVal;\n      this.panner.positionY.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.panner.positionY.linearRampToValueAtTime(yVal, this.ac.currentTime + 0.02 + t);\n    } else if (yVal) {\n      yVal.connect(this.panner.positionY);\n    }\n\n    return this.panner.positionY.value;\n  };\n\n  p5.Panner3D.prototype.positionZ = function (zVal, time) {\n    var t = time || 0;\n\n    if (typeof zVal === 'number') {\n      this.panner.positionZ.value = zVal;\n      this.panner.positionZ.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.panner.positionZ.linearRampToValueAtTime(zVal, this.ac.currentTime + 0.02 + t);\n    } else if (zVal) {\n      zVal.connect(this.panner.positionZ);\n    }\n\n    return this.panner.positionZ.value;\n  };\n  /**\n   * Set the X,Y,Z position of the Panner\n   * @method  orient\n   * @for p5.Panner3D\n   * @param  {Number} xVal\n   * @param  {Number} yVal\n   * @param  {Number} zVal\n   * @param  {Number} time\n   * @return {Array}      Updated x, y, z values as an array\n   */\n\n\n  p5.Panner3D.prototype.orient = function (xVal, yVal, zVal, time) {\n    this.orientX(xVal, time);\n    this.orientY(yVal, time);\n    this.orientZ(zVal, time);\n    return [this.panner.orientationX.value, this.panner.orientationY.value, this.panner.orientationZ.value];\n  };\n  /**\n   * Getter and setter methods for orient coordinates\n   * @method orientX\n   * @for p5.Panner3D\n   * @return {Number}      updated coordinate value\n   */\n\n  /**\n   * Getter and setter methods for orient coordinates\n   * @method orientY\n   * @for p5.Panner3D\n   * @return {Number}      updated coordinate value\n   */\n\n  /**\n   * Getter and setter methods for orient coordinates\n   * @method orientZ\n   * @for p5.Panner3D\n   * @return {Number}      updated coordinate value\n   */\n\n\n  p5.Panner3D.prototype.orientX = function (xVal, time) {\n    var t = time || 0;\n\n    if (typeof xVal === 'number') {\n      this.panner.orientationX.value = xVal;\n      this.panner.orientationX.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.panner.orientationX.linearRampToValueAtTime(xVal, this.ac.currentTime + 0.02 + t);\n    } else if (xVal) {\n      xVal.connect(this.panner.orientationX);\n    }\n\n    return this.panner.orientationX.value;\n  };\n\n  p5.Panner3D.prototype.orientY = function (yVal, time) {\n    var t = time || 0;\n\n    if (typeof yVal === 'number') {\n      this.panner.orientationY.value = yVal;\n      this.panner.orientationY.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.panner.orientationY.linearRampToValueAtTime(yVal, this.ac.currentTime + 0.02 + t);\n    } else if (yVal) {\n      yVal.connect(this.panner.orientationY);\n    }\n\n    return this.panner.orientationY.value;\n  };\n\n  p5.Panner3D.prototype.orientZ = function (zVal, time) {\n    var t = time || 0;\n\n    if (typeof zVal === 'number') {\n      this.panner.orientationZ.value = zVal;\n      this.panner.orientationZ.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.panner.orientationZ.linearRampToValueAtTime(zVal, this.ac.currentTime + 0.02 + t);\n    } else if (zVal) {\n      zVal.connect(this.panner.orientationZ);\n    }\n\n    return this.panner.orientationZ.value;\n  };\n  /**\n   * Set the rolloff factor and max distance\n   * @method  setFalloff\n   * @for p5.Panner3D\n   * @param {Number} [maxDistance]\n   * @param {Number} [rolloffFactor]\n   */\n\n\n  p5.Panner3D.prototype.setFalloff = function (maxDistance, rolloffFactor) {\n    this.maxDist(maxDistance);\n    this.rolloff(rolloffFactor);\n  };\n  /**\n   * Maxium distance between the source and the listener\n   * @method  maxDist\n   * @for p5.Panner3D\n   * @param  {Number} maxDistance\n   * @return {Number} updated value\n   */\n\n\n  p5.Panner3D.prototype.maxDist = function (maxDistance) {\n    if (typeof maxDistance === 'number') {\n      this.panner.maxDistance = maxDistance;\n    }\n\n    return this.panner.maxDistance;\n  };\n  /**\n   * How quickly the volume is reduced as the source moves away from the listener\n   * @method  rollof\n   * @for p5.Panner3D\n   * @param  {Number} rolloffFactor\n   * @return {Number} updated value\n   */\n\n\n  p5.Panner3D.prototype.rolloff = function (rolloffFactor) {\n    if (typeof rolloffFactor === 'number') {\n      this.panner.rolloffFactor = rolloffFactor;\n    }\n\n    return this.panner.rolloffFactor;\n  };\n\n  p5.Panner3D.dispose = function () {\n    Effect.prototype.dispose.apply(this);\n\n    if (this.panner) {\n      this.panner.disconnect();\n      delete this.panner;\n    }\n  };\n\n  return p5.Panner3D;\n}).call(exports, __nested_webpack_require_343878__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_352205__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_352205__(1);\n\n  var Effect = __nested_webpack_require_352205__(4); \n  //   * listener is a class that can construct both a Spatial Panner\n  //   * and a Spatial Listener. The panner is based on the \n  //   * Web Audio Spatial Panner Node\n  //   * https://www.w3.org/TR/webaudio/#the-listenernode-interface\n  //   * This panner is a spatial processing node that allows audio to be positioned\n  //   * and oriented in 3D space. \n  //   *\n  //   * The Listener modifies the properties of the Audio Context Listener. \n  //   * Both objects types use the same methods. The default is a spatial panner.\n  //   *\n  //   * <code>p5.Panner3D</code> - Constructs a Spatial Panner<br/>\n  //   * <code>p5.Listener3D</code> - Constructs a Spatial Listener<br/>\n  //   *\n  //   * @class listener\n  //   * @constructor\n  //   * @return {Object} p5.Listener3D Object\n  //   *\n  //   * @param {Web Audio Node} listener Web Audio Spatial Panning Node\n  //   * @param {AudioParam} listener.panningModel \"equal power\" or \"HRTF\"\n  //   * @param {AudioParam} listener.distanceModel \"linear\", \"inverse\", or \"exponential\"\n  //   * @param {String} [type] [Specify construction of a spatial panner or listener]\n  //   */\n\n\n  p5.Listener3D = function (type) {\n    this.ac = p5sound.audiocontext;\n    this.listener = this.ac.listener;\n  }; \n  //   * Connect an audio sorce\n  //   * @param  {Object} src Input source\n  //   */\n\n\n  p5.Listener3D.prototype.process = function (src) {\n    src.connect(this.input);\n  }; \n  //   * Set the X,Y,Z position of the Panner\n  //   * @param  {[Number]} xVal\n  //   * @param  {[Number]} yVal\n  //   * @param  {[Number]} zVal\n  //   * @param  {[Number]} time\n  //   * @return {[Array]}      [Updated x, y, z values as an array]\n  //   */\n\n\n  p5.Listener3D.prototype.position = function (xVal, yVal, zVal, time) {\n    this.positionX(xVal, time);\n    this.positionY(yVal, time);\n    this.positionZ(zVal, time);\n    return [this.listener.positionX.value, this.listener.positionY.value, this.listener.positionZ.value];\n  }; \n  //   * Getter and setter methods for position coordinates\n  //   * @return {Number}      [updated coordinate value]\n  //   */\n\n\n  p5.Listener3D.prototype.positionX = function (xVal, time) {\n    var t = time || 0;\n\n    if (typeof xVal === 'number') {\n      this.listener.positionX.value = xVal;\n      this.listener.positionX.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.listener.positionX.linearRampToValueAtTime(xVal, this.ac.currentTime + 0.02 + t);\n    } else if (xVal) {\n      xVal.connect(this.listener.positionX);\n    }\n\n    return this.listener.positionX.value;\n  };\n\n  p5.Listener3D.prototype.positionY = function (yVal, time) {\n    var t = time || 0;\n\n    if (typeof yVal === 'number') {\n      this.listener.positionY.value = yVal;\n      this.listener.positionY.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.listener.positionY.linearRampToValueAtTime(yVal, this.ac.currentTime + 0.02 + t);\n    } else if (yVal) {\n      yVal.connect(this.listener.positionY);\n    }\n\n    return this.listener.positionY.value;\n  };\n\n  p5.Listener3D.prototype.positionZ = function (zVal, time) {\n    var t = time || 0;\n\n    if (typeof zVal === 'number') {\n      this.listener.positionZ.value = zVal;\n      this.listener.positionZ.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.listener.positionZ.linearRampToValueAtTime(zVal, this.ac.currentTime + 0.02 + t);\n    } else if (zVal) {\n      zVal.connect(this.listener.positionZ);\n    }\n\n    return this.listener.positionZ.value;\n  }; \n  //   * Overrides the listener orient() method because Listener has slightly\n  //   * different params. In human terms, Forward vectors are the direction the \n  //   * nose is pointing. Up vectors are the direction of the top of the head.\n  //   *\n  //   * @method orient\n  //   * @param  {Number} xValF  Forward vector X direction\n  //   * @param  {Number} yValF  Forward vector Y direction\n  //   * @param  {Number} zValF  Forward vector Z direction\n  //   * @param  {Number} xValU  Up vector X direction\n  //   * @param  {Number} yValU  Up vector Y direction\n  //   * @param  {Number} zValU  Up vector Z direction\n  //   * @param  {Number} time  \n  //   * @return {Array}       All orienation params\n  //   */\n\n\n  p5.Listener3D.prototype.orient = function (xValF, yValF, zValF, xValU, yValU, zValU, time) {\n    if (arguments.length === 3 || arguments.length === 4) {\n      time = arguments[3];\n      this.orientForward(xValF, yValF, zValF, time);\n    } else if (arguments.length === 6 || arguments === 7) {\n      this.orientForward(xValF, yValF, zValF);\n      this.orientUp(xValU, yValU, zValU, time);\n    }\n\n    return [this.listener.forwardX.value, this.listener.forwardY.value, this.listener.forwardZ.value, this.listener.upX.value, this.listener.upY.value, this.listener.upZ.value];\n  };\n\n  p5.Listener3D.prototype.orientForward = function (xValF, yValF, zValF, time) {\n    this.forwardX(xValF, time);\n    this.forwardY(yValF, time);\n    this.forwardZ(zValF, time);\n    return [this.listener.forwardX, this.listener.forwardY, this.listener.forwardZ];\n  };\n\n  p5.Listener3D.prototype.orientUp = function (xValU, yValU, zValU, time) {\n    this.upX(xValU, time);\n    this.upY(yValU, time);\n    this.upZ(zValU, time);\n    return [this.listener.upX, this.listener.upY, this.listener.upZ];\n  }; \n  //   * Getter and setter methods for orient coordinates\n  //   * @return {Number}      [updated coordinate value]\n  //   */\n\n\n  p5.Listener3D.prototype.forwardX = function (xVal, time) {\n    var t = time || 0;\n\n    if (typeof xVal === 'number') {\n      this.listener.forwardX.value = xVal;\n      this.listener.forwardX.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.listener.forwardX.linearRampToValueAtTime(xVal, this.ac.currentTime + 0.02 + t);\n    } else if (xVal) {\n      xVal.connect(this.listener.forwardX);\n    }\n\n    return this.listener.forwardX.value;\n  };\n\n  p5.Listener3D.prototype.forwardY = function (yVal, time) {\n    var t = time || 0;\n\n    if (typeof yVal === 'number') {\n      this.listener.forwardY.value = yVal;\n      this.listener.forwardY.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.listener.forwardY.linearRampToValueAtTime(yVal, this.ac.currentTime + 0.02 + t);\n    } else if (yVal) {\n      yVal.connect(this.listener.forwardY);\n    }\n\n    return this.listener.forwardY.value;\n  };\n\n  p5.Listener3D.prototype.forwardZ = function (zVal, time) {\n    var t = time || 0;\n\n    if (typeof zVal === 'number') {\n      this.listener.forwardZ.value = zVal;\n      this.listener.forwardZ.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.listener.forwardZ.linearRampToValueAtTime(zVal, this.ac.currentTime + 0.02 + t);\n    } else if (zVal) {\n      zVal.connect(this.listener.forwardZ);\n    }\n\n    return this.listener.forwardZ.value;\n  };\n\n  p5.Listener3D.prototype.upX = function (xVal, time) {\n    var t = time || 0;\n\n    if (typeof xVal === 'number') {\n      this.listener.upX.value = xVal;\n      this.listener.upX.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.listener.upX.linearRampToValueAtTime(xVal, this.ac.currentTime + 0.02 + t);\n    } else if (xVal) {\n      xVal.connect(this.listener.upX);\n    }\n\n    return this.listener.upX.value;\n  };\n\n  p5.Listener3D.prototype.upY = function (yVal, time) {\n    var t = time || 0;\n\n    if (typeof yVal === 'number') {\n      this.listener.upY.value = yVal;\n      this.listener.upY.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.listener.upY.linearRampToValueAtTime(yVal, this.ac.currentTime + 0.02 + t);\n    } else if (yVal) {\n      yVal.connect(this.listener.upY);\n    }\n\n    return this.listener.upY.value;\n  };\n\n  p5.Listener3D.prototype.upZ = function (zVal, time) {\n    var t = time || 0;\n\n    if (typeof zVal === 'number') {\n      this.listener.upZ.value = zVal;\n      this.listener.upZ.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.listener.upZ.linearRampToValueAtTime(zVal, this.ac.currentTime + 0.02 + t);\n    } else if (zVal) {\n      zVal.connect(this.listener.upZ);\n    }\n\n    return this.listener.upZ.value;\n  };\n\n  return p5.Listener3D;\n}).call(exports, __nested_webpack_require_352205__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_360725__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var Filter = __nested_webpack_require_360725__(15);\n\n  var Effect = __nested_webpack_require_360725__(4);\n  /**\n   *  Delay is an echo effect. It processes an existing sound source,\n   *  and outputs a delayed version of that sound. The p5.Delay can\n   *  produce different effects depending on the delayTime, feedback,\n   *  filter, and type. In the example below, a feedback of 0.5 (the\n   *  default value) will produce a looping delay that decreases in\n   *  volume by 50% each repeat. A filter will cut out the high\n   *  frequencies so that the delay does not sound as piercing as the\n   *  original source.\n   *\n   *\n   *  This class extends <a href = \"/reference/#/p5.Effect\">p5.Effect</a>.\n   *  Methods <a href = \"/reference/#/p5.Effect/amp\">amp()</a>, <a href = \"/reference/#/p5.Effect/chain\">chain()</a>,\n   *  <a href = \"/reference/#/p5.Effect/drywet\">drywet()</a>, <a href = \"/reference/#/p5.Effect/connect\">connect()</a>, and\n   *  <a href = \"/reference/#/p5.Effect/disconnect\">disconnect()</a> are available.\n   *  @class p5.Delay\n   *  @extends p5.Effect\n   *  @constructor\n   *  @example\n   *  <div><code>\n   *  let osc;\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    background(220);\n   *    textAlign(CENTER);\n   *    text('tap to play', width/2, height/2);\n   *\n   *    osc = new p5.Oscillator('square');\n   *    osc.amp(0.5);\n   *    delay = new p5.Delay();\n   *\n   *    // delay.process() accepts 4 parameters:\n   *    // source, delayTime (in seconds), feedback, filter frequency\n   *    delay.process(osc, 0.12, .7, 2300);\n   *\n   *    cnv.mousePressed(oscStart);\n   *  }\n   *\n   *  function oscStart() {\n   *    osc.start();\n   *  }\n   *\n   *  function mouseReleased() {\n   *    osc.stop();\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.Delay = function () {\n    Effect.call(this);\n    this._split = this.ac.createChannelSplitter(2);\n    this._merge = this.ac.createChannelMerger(2);\n    this._leftGain = this.ac.createGain();\n    this._rightGain = this.ac.createGain();\n    /**\n     *  The p5.Delay is built with two\n     *  <a href=\"http://www.w3.org/TR/webaudio/#DelayNode\">\n     *  Web Audio Delay Nodes</a>, one for each stereo channel.\n     *\n     *  @for p5.Delay\n     *  @property {DelayNode} leftDelay\n     */\n\n    this.leftDelay = this.ac.createDelay();\n    /**\n     *  The p5.Delay is built with two\n     *  <a href=\"http://www.w3.org/TR/webaudio/#DelayNode\">\n     *  Web Audio Delay Nodes</a>, one for each stereo channel.\n     *  @for p5.Delay\n     *  @property {DelayNode} rightDelay\n     */\n\n    this.rightDelay = this.ac.createDelay();\n    this._leftFilter = new Filter();\n    this._rightFilter = new Filter();\n\n    this._leftFilter.disconnect();\n\n    this._rightFilter.disconnect();\n\n    this._leftFilter.biquad.frequency.setValueAtTime(1200, this.ac.currentTime);\n\n    this._rightFilter.biquad.frequency.setValueAtTime(1200, this.ac.currentTime);\n\n    this._leftFilter.biquad.Q.setValueAtTime(0.3, this.ac.currentTime);\n\n    this._rightFilter.biquad.Q.setValueAtTime(0.3, this.ac.currentTime); \n\n\n    this.input.connect(this._split);\n    this.leftDelay.connect(this._leftGain);\n    this.rightDelay.connect(this._rightGain);\n\n    this._leftGain.connect(this._leftFilter.input);\n\n    this._rightGain.connect(this._rightFilter.input);\n\n    this._merge.connect(this.wet);\n\n    this._leftFilter.biquad.gain.setValueAtTime(1, this.ac.currentTime);\n\n    this._rightFilter.biquad.gain.setValueAtTime(1, this.ac.currentTime); \n\n\n    this.setType(0);\n    this._maxDelay = this.leftDelay.delayTime.maxValue; \n\n    this.feedback(0.5);\n  };\n\n  p5.Delay.prototype = Object.create(Effect.prototype);\n  /**\n   *  Add delay to an audio signal according to a set\n   *  of delay parameters.\n   *\n   *  @method  process\n   *  @for p5.Delay\n   *  @param  {Object} Signal  An object that outputs audio\n   *  @param  {Number} [delayTime] Time (in seconds) of the delay/echo.\n   *                               Some browsers limit delayTime to\n   *                               1 second.\n   *  @param  {Number} [feedback]  sends the delay back through itself\n   *                               in a loop that decreases in volume\n   *                               each time.\n   *  @param  {Number} [lowPass]   Cutoff frequency. Only frequencies\n   *                               below the lowPass will be part of the\n   *                               delay.\n   */\n\n  p5.Delay.prototype.process = function (src, _delayTime, _feedback, _filter) {\n    var feedback = _feedback || 0;\n    var delayTime = _delayTime || 0;\n\n    if (feedback >= 1.0) {\n      throw new Error('Feedback value will force a positive feedback loop.');\n    }\n\n    if (delayTime >= this._maxDelay) {\n      throw new Error('Delay Time exceeds maximum delay time of ' + this._maxDelay + ' second.');\n    }\n\n    src.connect(this.input);\n    this.leftDelay.delayTime.setValueAtTime(delayTime, this.ac.currentTime);\n    this.rightDelay.delayTime.setValueAtTime(delayTime, this.ac.currentTime);\n    this._leftGain.gain.value = feedback;\n    this._rightGain.gain.value = feedback;\n\n    if (_filter) {\n      this._leftFilter.freq(_filter);\n\n      this._rightFilter.freq(_filter);\n    }\n  };\n  /**\n   *  Set the delay (echo) time, in seconds. Usually this value will be\n   *  a floating point number between 0.0 and 1.0.\n   *\n   *  @method  delayTime\n   *  @for p5.Delay\n   *  @param {Number} delayTime Time (in seconds) of the delay\n   */\n\n\n  p5.Delay.prototype.delayTime = function (t) {\n    if (typeof t !== 'number') {\n      t.connect(this.leftDelay.delayTime);\n      t.connect(this.rightDelay.delayTime);\n    } else {\n      this.leftDelay.delayTime.cancelScheduledValues(this.ac.currentTime);\n      this.rightDelay.delayTime.cancelScheduledValues(this.ac.currentTime);\n      this.leftDelay.delayTime.linearRampToValueAtTime(t, this.ac.currentTime);\n      this.rightDelay.delayTime.linearRampToValueAtTime(t, this.ac.currentTime);\n    }\n  };\n  /**\n   *  Feedback occurs when Delay sends its signal back through its input\n   *  in a loop. The feedback amount determines how much signal to send each\n   *  time through the loop. A feedback greater than 1.0 is not desirable because\n   *  it will increase the overall output each time through the loop,\n   *  creating an infinite feedback loop. The default value is 0.5\n   *\n   *  @method  feedback\n   *  @for p5.Delay\n   *  @param {Number|Object} feedback 0.0 to 1.0, or an object such as an\n   *                                  Oscillator that can be used to\n   *                                  modulate this param\n   *  @returns {Number} Feedback value\n   *\n   */\n\n\n  p5.Delay.prototype.feedback = function (f) {\n    if (f && typeof f !== 'number') {\n      f.connect(this._leftGain.gain);\n      f.connect(this._rightGain.gain);\n    } else if (f >= 1.0) {\n      throw new Error('Feedback value will force a positive feedback loop.');\n    } else if (typeof f === 'number') {\n      this._leftGain.gain.value = f;\n      this._rightGain.gain.value = f;\n    } \n\n\n    return this._leftGain.gain.value;\n  };\n  /**\n   *  Set a lowpass filter frequency for the delay. A lowpass filter\n   *  will cut off any frequencies higher than the filter frequency.\n   *\n   *  @method  filter\n   *  @for p5.Delay\n   *  @param {Number|Object} cutoffFreq  A lowpass filter will cut off any\n   *                              frequencies higher than the filter frequency.\n   *  @param {Number|Object} res  Resonance of the filter frequency\n   *                              cutoff, or an object (i.e. a p5.Oscillator)\n   *                              that can be used to modulate this parameter.\n   *                              High numbers (i.e. 15) will produce a resonance,\n   *                              low numbers (i.e. .2) will produce a slope.\n   */\n\n\n  p5.Delay.prototype.filter = function (freq, q) {\n    this._leftFilter.set(freq, q);\n\n    this._rightFilter.set(freq, q);\n  };\n  /**\n   *  Choose a preset type of delay. 'pingPong' bounces the signal\n   *  from the left to the right channel to produce a stereo effect.\n   *  Any other parameter will revert to the default delay setting.\n   *\n   *  @method  setType\n   *  @for p5.Delay\n   *  @param {String|Number} type 'pingPong' (1) or 'default' (0)\n   */\n\n\n  p5.Delay.prototype.setType = function (t) {\n    if (t === 1) {\n      t = 'pingPong';\n    }\n\n    this._split.disconnect();\n\n    this._leftFilter.disconnect();\n\n    this._rightFilter.disconnect();\n\n    this._split.connect(this.leftDelay, 0);\n\n    this._split.connect(this.rightDelay, 1);\n\n    switch (t) {\n      case 'pingPong':\n        this._rightFilter.setType(this._leftFilter.biquad.type);\n\n        this._leftFilter.output.connect(this._merge, 0, 0);\n\n        this._rightFilter.output.connect(this._merge, 0, 1);\n\n        this._leftFilter.output.connect(this.rightDelay);\n\n        this._rightFilter.output.connect(this.leftDelay);\n\n        break;\n\n      default:\n        this._leftFilter.output.connect(this._merge, 0, 0);\n\n        this._rightFilter.output.connect(this._merge, 0, 1);\n\n        this._leftFilter.output.connect(this.leftDelay);\n\n        this._rightFilter.output.connect(this.rightDelay);\n\n    }\n  }; \n\n  /**\n   *  Set the output level of the delay effect.\n   *\n   *  @method  amp\n   *  @for p5.Delay\n   *  @param  {Number} volume amplitude between 0 and 1.0\n   *  @param {Number} [rampTime] create a fade that lasts rampTime\n   *  @param {Number} [timeFromNow] schedule this event to happen\n   *                                seconds from now\n   */\n\n  /**\n   *  Send output to a p5.sound or web audio object\n   *\n   *  @method  connect\n   *  @for p5.Delay\n   *  @param  {Object} unit\n   */\n\n  /**\n   *  Disconnect all output.\n   *\n   *  @method disconnect\n   *  @for p5.Delay\n   */\n\n\n  p5.Delay.prototype.dispose = function () {\n    Effect.prototype.dispose.apply(this);\n\n    this._split.disconnect();\n\n    this._leftFilter.dispose();\n\n    this._rightFilter.dispose();\n\n    this._merge.disconnect();\n\n    this._leftGain.disconnect();\n\n    this._rightGain.disconnect();\n\n    this.leftDelay.disconnect();\n    this.rightDelay.disconnect();\n    this._split = undefined;\n    this._leftFilter = undefined;\n    this._rightFilter = undefined;\n    this._merge = undefined;\n    this._leftGain = undefined;\n    this._rightGain = undefined;\n    this.leftDelay = undefined;\n    this.rightDelay = undefined;\n  };\n}).call(exports, __nested_webpack_require_360725__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_371408__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var CustomError = __nested_webpack_require_371408__(11);\n\n  var Effect = __nested_webpack_require_371408__(4);\n  /**\n   *  Reverb adds depth to a sound through a large number of decaying\n   *  echoes. It creates the perception that sound is occurring in a\n   *  physical space. The p5.Reverb has paramters for Time (how long does the\n   *  reverb last) and decayRate (how much the sound decays with each echo)\n   *  that can be set with the .set() or .process() methods. The p5.Convolver\n   *  extends p5.Reverb allowing you to recreate the sound of actual physical\n   *  spaces through convolution.\n   *\n   *  This class extends <a href = \"/reference/#/p5.Effect\">p5.Effect</a>.\n   *  Methods <a href = \"/reference/#/p5.Effect/amp\">amp()</a>, <a href = \"/reference/#/p5.Effect/chain\">chain()</a>,\n   *  <a href = \"/reference/#/p5.Effect/drywet\">drywet()</a>, <a href = \"/reference/#/p5.Effect/connect\">connect()</a>, and\n   *  <a href = \"/reference/#/p5.Effect/disconnect\">disconnect()</a> are available.\n   *\n   *  @class p5.Reverb\n   *  @extends p5.Effect\n   *  @constructor\n   *  @example\n   *  <div><code>\n   *  let soundFile, reverb;\n   *  function preload() {\n   *    soundFile = loadSound('assets/Damscray_DancingTiger.mp3');\n   *  }\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(playSound);\n   *\n   *    reverb = new p5.Reverb();\n   *    soundFile.disconnect(); // so we'll only hear reverb...\n   *\n   *    // connect soundFile to reverb, process w/\n   *    // 3 second reverbTime, decayRate of 2%\n   *    reverb.process(soundFile, 3, 2);\n   *  }\n   *\n   *  function draw() {\n   *    let dryWet = constrain(map(mouseX, 0, width, 0, 1), 0, 1);\n   *    // 1 = all reverb, 0 = no reverb\n   *    reverb.drywet(dryWet);\n   *\n   *    background(220);\n   *    text('tap to play', 10, 20);\n   *    text('dry/wet: ' + round(dryWet * 100) + '%', 10, height - 20);\n   *  }\n   *\n   *  function playSound() {\n   *    soundFile.play();\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.Reverb = function () {\n    Effect.call(this);\n\n    this._initConvolverNode(); \n\n\n    this.input.gain.value = 0.5; \n\n    this._seconds = 3;\n    this._decay = 2;\n    this._reverse = false;\n\n    this._buildImpulse();\n  };\n\n  p5.Reverb.prototype = Object.create(Effect.prototype);\n\n  p5.Reverb.prototype._initConvolverNode = function () {\n    this.convolverNode = this.ac.createConvolver();\n    this.input.connect(this.convolverNode);\n    this.convolverNode.connect(this.wet);\n  };\n\n  p5.Reverb.prototype._teardownConvolverNode = function () {\n    if (this.convolverNode) {\n      this.convolverNode.disconnect();\n      delete this.convolverNode;\n    }\n  };\n\n  p5.Reverb.prototype._setBuffer = function (audioBuffer) {\n    this._teardownConvolverNode();\n\n    this._initConvolverNode();\n\n    this.convolverNode.buffer = audioBuffer;\n  };\n  /**\n   *  Connect a source to the reverb, and assign reverb parameters.\n   *\n   *  @method  process\n   *  @for p5.Reverb\n   *  @param  {Object} src     p5.sound / Web Audio object with a sound\n   *                           output.\n   *  @param  {Number} [seconds] Duration of the reverb, in seconds.\n   *                           Min: 0, Max: 10. Defaults to 3.\n   *  @param  {Number} [decayRate] Percentage of decay with each echo.\n   *                            Min: 0, Max: 100. Defaults to 2.\n   *  @param  {Boolean} [reverse] Play the reverb backwards or forwards.\n   */\n\n\n  p5.Reverb.prototype.process = function (src, seconds, decayRate, reverse) {\n    src.connect(this.input);\n    var rebuild = false;\n\n    if (seconds) {\n      this._seconds = seconds;\n      rebuild = true;\n    }\n\n    if (decayRate) {\n      this._decay = decayRate;\n    }\n\n    if (reverse) {\n      this._reverse = reverse;\n    }\n\n    if (rebuild) {\n      this._buildImpulse();\n    }\n  };\n  /**\n   *  Set the reverb settings. Similar to .process(), but without\n   *  assigning a new input.\n   *\n   *  @method  set\n   *  @for p5.Reverb\n   *  @param  {Number} [seconds] Duration of the reverb, in seconds.\n   *                           Min: 0, Max: 10. Defaults to 3.\n   *  @param  {Number} [decayRate] Percentage of decay with each echo.\n   *                            Min: 0, Max: 100. Defaults to 2.\n   *  @param  {Boolean} [reverse] Play the reverb backwards or forwards.\n   */\n\n\n  p5.Reverb.prototype.set = function (seconds, decayRate, reverse) {\n    var rebuild = false;\n\n    if (seconds) {\n      this._seconds = seconds;\n      rebuild = true;\n    }\n\n    if (decayRate) {\n      this._decay = decayRate;\n    }\n\n    if (reverse) {\n      this._reverse = reverse;\n    }\n\n    if (rebuild) {\n      this._buildImpulse();\n    }\n  }; \n\n  /**\n   *  Set the output level of the reverb effect.\n   *\n   *  @method  amp\n   *  @for p5.Reverb\n   *  @param  {Number} volume amplitude between 0 and 1.0\n   *  @param  {Number} [rampTime] create a fade that lasts rampTime\n   *  @param  {Number} [timeFromNow] schedule this event to happen\n   *                                seconds from now\n   */\n\n  /**\n   *  Send output to a p5.sound or web audio object\n   *\n   *  @method  connect\n   *  @for p5.Reverb\n   *  @param  {Object} unit\n   */\n\n  /**\n   *  Disconnect all output.\n   *\n   *  @method disconnect\n   *  @for p5.Reverb\n   */\n\n  /**\n   *  Inspired by Simple Reverb by Jordan Santell\n   *  https://github.com/web-audio-components/simple-reverb/blob/master/index.js\n   *\n   *  Utility function for building an impulse response\n   *  based on the module parameters.\n   *\n   *  @private\n   */\n\n\n  p5.Reverb.prototype._buildImpulse = function () {\n    var rate = this.ac.sampleRate;\n    var length = rate * this._seconds;\n    var decay = this._decay;\n    var impulse = this.ac.createBuffer(2, length, rate);\n    var impulseL = impulse.getChannelData(0);\n    var impulseR = impulse.getChannelData(1);\n    var n, i;\n\n    for (i = 0; i < length; i++) {\n      n = this._reverse ? length - i : i;\n      impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);\n      impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);\n    }\n\n    this._setBuffer(impulse);\n  };\n\n  p5.Reverb.prototype.dispose = function () {\n    Effect.prototype.dispose.apply(this);\n\n    this._teardownConvolverNode();\n  }; \n\n  /**\n   *  <p>p5.Convolver extends p5.Reverb. It can emulate the sound of real\n   *  physical spaces through a process called <a href=\"\n   *  https://en.wikipedia.org/wiki/Convolution_reverb#Real_space_simulation\">\n   *  convolution</a>.</p>\n   *\n   *  <p>Convolution multiplies any audio input by an \"impulse response\"\n   *  to simulate the dispersion of sound over time. The impulse response is\n   *  generated from an audio file that you provide. One way to\n   *  generate an impulse response is to pop a balloon in a reverberant space\n   *  and record the echo. Convolution can also be used to experiment with\n   *  sound.</p>\n   *\n   *  <p>Use the method <code>createConvolution(path)</code> to instantiate a\n   *  p5.Convolver with a path to your impulse response audio file.</p>\n   *\n   *  @class p5.Convolver\n   *  @extends p5.Effect\n   *  @constructor\n   *  @param  {String}   path     path to a sound file\n   *  @param  {Function} [callback] function to call when loading succeeds\n   *  @param  {Function} [errorCallback] function to call if loading fails.\n   *                                     This function will receive an error or\n   *                                     XMLHttpRequest object with information\n   *                                     about what went wrong.\n   *  @example\n   *  <div><code>\n   *  let cVerb, sound;\n   *  function preload() {\n   *    // We have both MP3 and OGG versions of all sound assets\n   *    soundFormats('ogg', 'mp3');\n   *\n   *    // Try replacing 'bx-spring' with other soundfiles like\n   *    // 'concrete-tunnel' 'small-plate' 'drum' 'beatbox'\n   *    cVerb = createConvolver('assets/bx-spring.mp3');\n   *\n   *    // Try replacing 'Damscray_DancingTiger' with\n   *    // 'beat', 'doorbell', lucky_dragons_-_power_melody'\n   *    sound = loadSound('assets/Damscray_DancingTiger.mp3');\n   *  }\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(playSound);\n   *    background(220);\n   *    text('tap to play', 20, 20);\n   *\n   *    // disconnect from master output...\n   *    sound.disconnect();\n   *\n   *    // ...and process with cVerb\n   *    // so that we only hear the convolution\n   *    cVerb.process(sound);\n   *  }\n   *\n   *  function playSound() {\n   *    sound.play();\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.Convolver = function (path, callback, errorCallback) {\n    p5.Reverb.call(this);\n    /**\n     *  Internally, the p5.Convolver uses the a\n     *  <a href=\"http://www.w3.org/TR/webaudio/#ConvolverNode\">\n     *  Web Audio Convolver Node</a>.\n     *\n     *  @property {ConvolverNode} convolverNode\n     */\n\n    this._initConvolverNode(); \n\n\n    this.input.gain.value = 0.5;\n\n    if (path) {\n      this.impulses = [];\n\n      this._loadBuffer(path, callback, errorCallback);\n    } else {\n      this._seconds = 3;\n      this._decay = 2;\n      this._reverse = false;\n\n      this._buildImpulse();\n    }\n  };\n\n  p5.Convolver.prototype = Object.create(p5.Reverb.prototype);\n  p5.prototype.registerPreloadMethod('createConvolver', p5.prototype);\n  /**\n   *  Create a p5.Convolver. Accepts a path to a soundfile\n   *  that will be used to generate an impulse response.\n   *\n   *  @method  createConvolver\n   *  @for p5\n   *  @param  {String}   path     path to a sound file\n   *  @param  {Function} [callback] function to call if loading is successful.\n   *                                The object will be passed in as the argument\n   *                                to the callback function.\n   *  @param  {Function} [errorCallback] function to call if loading is not successful.\n   *                                A custom error will be passed in as the argument\n   *                                to the callback function.\n   *  @return {p5.Convolver}\n   *  @example\n   *  <div><code>\n   *  let cVerb, sound;\n   *  function preload() {\n   *    // We have both MP3 and OGG versions of all sound assets\n   *    soundFormats('ogg', 'mp3');\n   *\n   *    // Try replacing 'bx-spring' with other soundfiles like\n   *    // 'concrete-tunnel' 'small-plate' 'drum' 'beatbox'\n   *    cVerb = createConvolver('assets/bx-spring.mp3');\n   *\n   *    // Try replacing 'Damscray_DancingTiger' with\n   *    // 'beat', 'doorbell', lucky_dragons_-_power_melody'\n   *    sound = loadSound('assets/Damscray_DancingTiger.mp3');\n   *  }\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(playSound);\n   *    background(220);\n   *    text('tap to play', 20, 20);\n   *\n   *    // disconnect from master output...\n   *    sound.disconnect();\n   *\n   *    // ...and process with cVerb\n   *    // so that we only hear the convolution\n   *    cVerb.process(sound);\n   *  }\n   *\n   *  function playSound() {\n   *    sound.play();\n   *  }\n   *  </code></div>\n   */\n\n  p5.prototype.createConvolver = function (path, callback, errorCallback) {\n    if (window.location.origin.indexOf('file://') > -1 && window.cordova === 'undefined') {\n      alert('This sketch may require a server to load external files. Please see http://bit.ly/1qcInwS');\n    }\n\n    var self = this;\n    var cReverb = new p5.Convolver(path, function (buffer) {\n      if (typeof callback === 'function') {\n        callback(buffer);\n      }\n\n      if (typeof self._decrementPreload === 'function') {\n        self._decrementPreload();\n      }\n    }, errorCallback);\n    cReverb.impulses = [];\n    return cReverb;\n  };\n  /**\n   *  Private method to load a buffer as an Impulse Response,\n   *  assign it to the convolverNode, and add to the Array of .impulses.\n   *\n   *  @param   {String}   path\n   *  @param   {Function} callback\n   *  @param   {Function} errorCallback\n   *  @private\n   */\n\n\n  p5.Convolver.prototype._loadBuffer = function (path, callback, errorCallback) {\n    var path = p5.prototype._checkFileFormats(path);\n\n    var self = this;\n    var errorTrace = new Error().stack;\n    var ac = p5.prototype.getAudioContext();\n    var request = new XMLHttpRequest();\n    request.open('GET', path, true);\n    request.responseType = 'arraybuffer';\n\n    request.onload = function () {\n      if (request.status === 200) {\n        ac.decodeAudioData(request.response, function (buff) {\n          var buffer = {};\n          var chunks = path.split('/');\n          buffer.name = chunks[chunks.length - 1];\n          buffer.audioBuffer = buff;\n          self.impulses.push(buffer);\n\n          self._setBuffer(buffer.audioBuffer);\n\n          if (callback) {\n            callback(buffer);\n          }\n        }, \n        function () {\n          var err = new CustomError('decodeAudioData', errorTrace, self.url);\n          var msg = 'AudioContext error at decodeAudioData for ' + self.url;\n\n          if (errorCallback) {\n            err.msg = msg;\n            errorCallback(err);\n          } else {\n            console.error(msg + '\\n The error stack trace includes: \\n' + err.stack);\n          }\n        });\n      } \n      else {\n          var err = new CustomError('loadConvolver', errorTrace, self.url);\n          var msg = 'Unable to load ' + self.url + '. The request status was: ' + request.status + ' (' + request.statusText + ')';\n\n          if (errorCallback) {\n            err.message = msg;\n            errorCallback(err);\n          } else {\n            console.error(msg + '\\n The error stack trace includes: \\n' + err.stack);\n          }\n        }\n    }; \n\n\n    request.onerror = function () {\n      var err = new CustomError('loadConvolver', errorTrace, self.url);\n      var msg = 'There was no response from the server at ' + self.url + '. Check the url and internet connectivity.';\n\n      if (errorCallback) {\n        err.message = msg;\n        errorCallback(err);\n      } else {\n        console.error(msg + '\\n The error stack trace includes: \\n' + err.stack);\n      }\n    };\n\n    request.send();\n  };\n\n  p5.Convolver.prototype.set = null;\n  /**\n   *  Connect a source to the convolver.\n   *\n   *  @method  process\n   *  @for p5.Convolver\n   *  @param  {Object} src     p5.sound / Web Audio object with a sound\n   *                           output.\n   *  @example\n   *  <div><code>\n   *  let cVerb, sound;\n   *  function preload() {\n   *    // We have both MP3 and OGG versions of all sound assets\n   *    soundFormats('ogg', 'mp3');\n   *\n   *    // Try replacing 'bx-spring' with other soundfiles like\n   *    // 'concrete-tunnel' 'small-plate' 'drum' 'beatbox'\n   *    cVerb = createConvolver('assets/bx-spring.mp3');\n   *\n   *    // Try replacing 'Damscray_DancingTiger' with\n   *    // 'beat', 'doorbell', lucky_dragons_-_power_melody'\n   *    sound = loadSound('assets/Damscray_DancingTiger.mp3');\n   *  }\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(playSound);\n   *    background(220);\n   *    text('tap to play', 20, 20);\n   *\n   *    // disconnect from master output...\n   *    sound.disconnect();\n   *\n   *    // ...and process with cVerb\n   *    // so that we only hear the convolution\n   *    cVerb.process(sound);\n   *  }\n   *\n   *  function playSound() {\n   *    sound.play();\n   *  }\n   *\n   *  </code></div>\n   */\n\n  p5.Convolver.prototype.process = function (src) {\n    src.connect(this.input);\n  };\n  /**\n   *  If you load multiple impulse files using the .addImpulse method,\n   *  they will be stored as Objects in this Array. Toggle between them\n   *  with the <code>toggleImpulse(id)</code> method.\n   *\n   *  @property {Array} impulses\n   *  @for p5.Convolver\n   */\n\n\n  p5.Convolver.prototype.impulses = [];\n  /**\n   *  Load and assign a new Impulse Response to the p5.Convolver.\n   *  The impulse is added to the <code>.impulses</code> array. Previous\n   *  impulses can be accessed with the <code>.toggleImpulse(id)</code>\n   *  method.\n   *\n   *  @method  addImpulse\n   *  @for p5.Convolver\n   *  @param  {String}   path     path to a sound file\n   *  @param  {Function} callback function (optional)\n   *  @param  {Function} errorCallback function (optional)\n   */\n\n  p5.Convolver.prototype.addImpulse = function (path, callback, errorCallback) {\n    if (window.location.origin.indexOf('file://') > -1 && window.cordova === 'undefined') {\n      alert('This sketch may require a server to load external files. Please see http://bit.ly/1qcInwS');\n    }\n\n    this._loadBuffer(path, callback, errorCallback);\n  };\n  /**\n   *  Similar to .addImpulse, except that the <code>.impulses</code>\n   *  Array is reset to save memory. A new <code>.impulses</code>\n   *  array is created with this impulse as the only item.\n   *\n   *  @method  resetImpulse\n   *  @for p5.Convolver\n   *  @param  {String}   path     path to a sound file\n   *  @param  {Function} callback function (optional)\n   *  @param  {Function} errorCallback function (optional)\n   */\n\n\n  p5.Convolver.prototype.resetImpulse = function (path, callback, errorCallback) {\n    if (window.location.origin.indexOf('file://') > -1 && window.cordova === 'undefined') {\n      alert('This sketch may require a server to load external files. Please see http://bit.ly/1qcInwS');\n    }\n\n    this.impulses = [];\n\n    this._loadBuffer(path, callback, errorCallback);\n  };\n  /**\n   *  If you have used <code>.addImpulse()</code> to add multiple impulses\n   *  to a p5.Convolver, then you can use this method to toggle between\n   *  the items in the <code>.impulses</code> Array. Accepts a parameter\n   *  to identify which impulse you wish to use, identified either by its\n   *  original filename (String) or by its position in the <code>.impulses\n   *  </code> Array (Number).<br/>\n   *  You can access the objects in the .impulses Array directly. Each\n   *  Object has two attributes: an <code>.audioBuffer</code> (type:\n   *  Web Audio <a href=\"\n   *  http://webaudio.github.io/web-audio-api/#the-audiobuffer-interface\">\n   *  AudioBuffer)</a> and a <code>.name</code>, a String that corresponds\n   *  with the original filename.\n   *\n   *  @method toggleImpulse\n   *  @for p5.Convolver\n   *  @param {String|Number} id Identify the impulse by its original filename\n   *                            (String), or by its position in the\n   *                            <code>.impulses</code> Array (Number).\n   */\n\n\n  p5.Convolver.prototype.toggleImpulse = function (id) {\n    if (typeof id === 'number' && id < this.impulses.length) {\n      this._setBuffer(this.impulses[id].audioBuffer);\n    }\n\n    if (typeof id === 'string') {\n      for (var i = 0; i < this.impulses.length; i++) {\n        if (this.impulses[i].name === id) {\n          this._setBuffer(this.impulses[i].audioBuffer);\n\n          break;\n        }\n      }\n    }\n  };\n\n  p5.Convolver.prototype.dispose = function () {\n    p5.Reverb.prototype.dispose.apply(this); \n\n    for (var i in this.impulses) {\n      if (this.impulses[i]) {\n        this.impulses[i] = null;\n      }\n    }\n  };\n}).call(exports, __nested_webpack_require_371408__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_390737__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_390737__(1); \n\n\n  var Clock = __nested_webpack_require_390737__(27);\n\n  p5.Metro = function () {\n    this.clock = new Clock({\n      'callback': this.ontick.bind(this)\n    });\n    this.syncedParts = [];\n    this.bpm = 120; \n\n    this._init();\n\n    this.prevTick = 0;\n    this.tatumTime = 0;\n\n    this.tickCallback = function () {};\n  };\n\n  p5.Metro.prototype.ontick = function (tickTime) {\n    var elapsedTime = tickTime - this.prevTick;\n    var secondsFromNow = tickTime - p5sound.audiocontext.currentTime;\n\n    if (elapsedTime - this.tatumTime <= -0.02) {\n      return;\n    } else {\n      this.prevTick = tickTime; \n\n      var self = this;\n      this.syncedParts.forEach(function (thisPart) {\n        if (!thisPart.isPlaying) return;\n        thisPart.incrementStep(secondsFromNow); \n\n        thisPart.phrases.forEach(function (thisPhrase) {\n          var phraseArray = thisPhrase.sequence;\n          var bNum = self.metroTicks % phraseArray.length;\n\n          if (phraseArray[bNum] !== 0 && (self.metroTicks < phraseArray.length || !thisPhrase.looping)) {\n            thisPhrase.callback(secondsFromNow, phraseArray[bNum]);\n          }\n        });\n      });\n      this.metroTicks += 1;\n      this.tickCallback(secondsFromNow);\n    }\n  };\n\n  p5.Metro.prototype.setBPM = function (bpm, rampTime) {\n    var beatTime = 60 / (bpm * this.tatums);\n    var now = p5sound.audiocontext.currentTime;\n    this.tatumTime = beatTime;\n    var rampTime = rampTime || 0;\n    this.clock.frequency.setValueAtTime(this.clock.frequency.value, now);\n    this.clock.frequency.linearRampToValueAtTime(bpm, now + rampTime);\n    this.bpm = bpm;\n  };\n\n  p5.Metro.prototype.getBPM = function () {\n    return this.clock.getRate() / this.tatums * 60;\n  };\n\n  p5.Metro.prototype._init = function () {\n    this.metroTicks = 0; \n  }; \n\n\n  p5.Metro.prototype.resetSync = function (part) {\n    this.syncedParts = [part];\n  }; \n\n\n  p5.Metro.prototype.pushSync = function (part) {\n    this.syncedParts.push(part);\n  };\n\n  p5.Metro.prototype.start = function (timeFromNow) {\n    var t = timeFromNow || 0;\n    var now = p5sound.audiocontext.currentTime;\n    this.clock.start(now + t);\n    this.setBPM(this.bpm);\n  };\n\n  p5.Metro.prototype.stop = function (timeFromNow) {\n    var t = timeFromNow || 0;\n    var now = p5sound.audiocontext.currentTime;\n    this.clock.stop(now + t);\n  };\n\n  p5.Metro.prototype.beatLength = function (tatums) {\n    this.tatums = 1 / tatums / 4; \n  };\n}).call(exports, __nested_webpack_require_390737__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_393513__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__nested_webpack_require_393513__(0),__nested_webpack_require_393513__(24),__nested_webpack_require_393513__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(t){\"use strict\";return t.TimelineState=function(e){t.Timeline.call(this),this._initial=e},t.extend(t.TimelineState,t.Timeline),t.TimelineState.prototype.getValueAtTime=function(e){var t=this.get(e);return null!==t?t.state:this._initial},t.TimelineState.prototype.setStateAtTime=function(e,t){this.add({state:e,time:t})},t.TimelineState}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_394269__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_394269__(1);\n\n  var BPM = 120;\n  /**\n   *  Set the global tempo, in beats per minute, for all\n   *  p5.Parts. This method will impact all active p5.Parts.\n   *\n   *  @method setBPM\n   *  @for p5\n   *  @param {Number} BPM      Beats Per Minute\n   *  @param {Number} rampTime Seconds from now\n   */\n\n  p5.prototype.setBPM = function (bpm, rampTime) {\n    BPM = bpm;\n\n    for (var i in p5sound.parts) {\n      if (p5sound.parts[i]) {\n        p5sound.parts[i].setBPM(bpm, rampTime);\n      }\n    }\n  };\n  /**\n   *  <p>A phrase is a pattern of musical events over time, i.e.\n   *  a series of notes and rests.</p>\n   *\n   *  <p>Phrases must be added to a p5.Part for playback, and\n   *  each part can play multiple phrases at the same time.\n   *  For example, one Phrase might be a kick drum, another\n   *  could be a snare, and another could be the bassline.</p>\n   *\n   *  <p>The first parameter is a name so that the phrase can be\n   *  modified or deleted later. The callback is a a function that\n   *  this phrase will call at every step—for example it might be\n   *  called <code>playNote(value){}</code>. The array determines\n   *  which value is passed into the callback at each step of the\n   *  phrase. It can be numbers, an object with multiple numbers,\n   *  or a zero (0) indicates a rest so the callback won't be called).</p>\n   *\n   *  @class p5.Phrase\n   *  @constructor\n   *  @param {String}   name     Name so that you can access the Phrase.\n   *  @param {Function} callback The name of a function that this phrase\n   *                             will call. Typically it will play a sound,\n   *                             and accept two parameters: a time at which\n   *                             to play the sound (in seconds from now),\n   *                             and a value from the sequence array. The\n   *                             time should be passed into the play() or\n   *                             start() method to ensure precision.\n   *  @param {Array}   sequence    Array of values to pass into the callback\n   *                            at each step of the phrase.\n   *  @example\n   *  <div><code>\n   *  let mySound, myPhrase, myPart;\n   *  let pattern = [1,0,0,2,0,2,0,0];\n   *\n   *  function preload() {\n   *    mySound = loadSound('assets/beatbox.mp3');\n   *  }\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(playMyPart);\n   *    background(220);\n   *    text('tap to play', width/2, height/2);\n   *    textAlign(CENTER, CENTER);\n   *\n   *    myPhrase = new p5.Phrase('bbox', onEachStep, pattern);\n   *    myPart = new p5.Part();\n   *    myPart.addPhrase(myPhrase);\n   *    myPart.setBPM(60);\n   *  }\n   *\n   *  function onEachStep(time, playbackRate) {\n   *    mySound.rate(playbackRate);\n   *    mySound.play(time);\n   *  }\n   *\n   *  function playMyPart() {\n   *    userStartAudio();\n   *    myPart.start();\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.Phrase = function (name, callback, sequence) {\n    this.phraseStep = 0;\n    this.name = name;\n    this.callback = callback;\n    /**\n     * Array of values to pass into the callback\n     * at each step of the phrase. Depending on the callback\n     * function's requirements, these values may be numbers,\n     * strings, or an object with multiple parameters.\n     * Zero (0) indicates a rest.\n     *\n     * @property {Array} sequence\n     */\n\n    this.sequence = sequence;\n  };\n  /**\n   *  <p>A p5.Part plays back one or more p5.Phrases. Instantiate a part\n   *  with steps and tatums. By default, each step represents a 1/16th note.</p>\n   *\n   *  <p>See p5.Phrase for more about musical timing.</p>\n   *\n   *  @class p5.Part\n   *  @constructor\n   *  @param {Number} [steps]   Steps in the part\n   *  @param {Number} [tatums] Divisions of a beat, e.g. use 1/4, or 0.25 for a quater note (default is 1/16, a sixteenth note)\n   *  @example\n   *  <div><code>\n   *  let box, drum, myPart;\n   *  let boxPat = [1,0,0,2,0,2,0,0];\n   *  let drumPat = [0,1,1,0,2,0,1,0];\n   *\n   *  function preload() {\n   *    box = loadSound('assets/beatbox.mp3');\n   *    drum = loadSound('assets/drum.mp3');\n   *  }\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(playMyPart);\n   *    background(220);\n   *    textAlign(CENTER, CENTER);\n   *    text('tap to play', width/2, height/2);\n   *\n   *    let boxPhrase = new p5.Phrase('box', playBox, boxPat);\n   *    let drumPhrase = new p5.Phrase('drum', playDrum, drumPat);\n   *    myPart = new p5.Part();\n   *    myPart.addPhrase(boxPhrase);\n   *    myPart.addPhrase(drumPhrase);\n   *    myPart.setBPM(60);\n   *  }\n   *\n   *  function playBox(time, playbackRate) {\n   *    box.rate(playbackRate);\n   *    box.play(time);\n   *  }\n   *\n   *  function playDrum(time, playbackRate) {\n   *    drum.rate(playbackRate);\n   *    drum.play(time);\n   *  }\n   *\n   *  function playMyPart() {\n   *    userStartAudio();\n   *\n   *    myPart.start();\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.Part = function (steps, bLength) {\n    this.length = steps || 0; \n\n    this.partStep = 0;\n    this.phrases = [];\n    this.isPlaying = false;\n    this.noLoop();\n    this.tatums = bLength || 0.0625; \n\n    this.metro = new p5.Metro();\n\n    this.metro._init();\n\n    this.metro.beatLength(this.tatums);\n    this.metro.setBPM(BPM);\n    p5sound.parts.push(this);\n\n    this.callback = function () {};\n  };\n  /**\n   *  Set the tempo of this part, in Beats Per Minute.\n   *\n   *  @method  setBPM\n   *  @for p5.Part\n   *  @param {Number} BPM      Beats Per Minute\n   *  @param {Number} [rampTime] Seconds from now\n   */\n\n\n  p5.Part.prototype.setBPM = function (tempo, rampTime) {\n    this.metro.setBPM(tempo, rampTime);\n  };\n  /**\n   *  Returns the tempo, in Beats Per Minute, of this part.\n   *\n   *  @method getBPM\n   *  @for p5.Part\n   *  @return {Number}\n   */\n\n\n  p5.Part.prototype.getBPM = function () {\n    return this.metro.getBPM();\n  };\n  /**\n   *  Start playback of this part. It will play\n   *  through all of its phrases at a speed\n   *  determined by setBPM.\n   *\n   *  @method  start\n   *  @for p5.Part\n   *  @param  {Number} [time] seconds from now\n   */\n\n\n  p5.Part.prototype.start = function (time) {\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      this.metro.resetSync(this);\n      var t = time || 0;\n      this.metro.start(t);\n    }\n  };\n  /**\n   *  Loop playback of this part. It will begin\n   *  looping through all of its phrases at a speed\n   *  determined by setBPM.\n   *\n   *  @method  loop\n   *  @for p5.Part\n   *  @param  {Number} [time] seconds from now\n   */\n\n\n  p5.Part.prototype.loop = function (time) {\n    this.looping = true; \n\n    this.onended = function () {\n      this.partStep = 0;\n    };\n\n    var t = time || 0;\n    this.start(t);\n  };\n  /**\n   *  Tell the part to stop looping.\n   *\n   *  @method  noLoop\n   *  @for p5.Part\n   */\n\n\n  p5.Part.prototype.noLoop = function () {\n    this.looping = false; \n\n    this.onended = function () {\n      this.stop();\n    };\n  };\n  /**\n   *  Stop the part and cue it to step 0. Playback will resume from the begining of the Part when it is played again.\n   *\n   *  @method  stop\n   *  @for p5.Part\n   *  @param  {Number} [time] seconds from now\n   */\n\n\n  p5.Part.prototype.stop = function (time) {\n    this.partStep = 0;\n    this.pause(time);\n  };\n  /**\n   *  Pause the part. Playback will resume\n   *  from the current step.\n   *\n   *  @method  pause\n   *  @for p5.Part\n   *  @param  {Number} time seconds from now\n   */\n\n\n  p5.Part.prototype.pause = function (time) {\n    this.isPlaying = false;\n    var t = time || 0;\n    this.metro.stop(t);\n  };\n  /**\n   *  Add a p5.Phrase to this Part.\n   *\n   *  @method  addPhrase\n   *  @for p5.Part\n   *  @param {p5.Phrase}   phrase   reference to a p5.Phrase\n   */\n\n\n  p5.Part.prototype.addPhrase = function (name, callback, array) {\n    var p;\n\n    if (arguments.length === 3) {\n      p = new p5.Phrase(name, callback, array);\n    } else if (arguments[0] instanceof p5.Phrase) {\n      p = arguments[0];\n    } else {\n      throw 'invalid input. addPhrase accepts name, callback, array or a p5.Phrase';\n    }\n\n    this.phrases.push(p); \n\n    if (p.sequence.length > this.length) {\n      this.length = p.sequence.length;\n    }\n  };\n  /**\n   *  Remove a phrase from this part, based on the name it was\n   *  given when it was created.\n   *\n   *  @method  removePhrase\n   *  @for p5.Part\n   *  @param  {String} phraseName\n   */\n\n\n  p5.Part.prototype.removePhrase = function (name) {\n    for (var i in this.phrases) {\n      if (this.phrases[i].name === name) {\n        this.phrases.splice(i, 1);\n      }\n    }\n  };\n  /**\n   *  Get a phrase from this part, based on the name it was\n   *  given when it was created. Now you can modify its array.\n   *\n   *  @method  getPhrase\n   *  @for p5.Part\n   *  @param  {String} phraseName\n   */\n\n\n  p5.Part.prototype.getPhrase = function (name) {\n    for (var i in this.phrases) {\n      if (this.phrases[i].name === name) {\n        return this.phrases[i];\n      }\n    }\n  };\n  /**\n   *  Find all sequences with the specified name, and replace their patterns with the specified array.\n   *\n   *  @method  replaceSequence\n   *  @for p5.Part\n   *  @param  {String} phraseName\n   *  @param  {Array} sequence  Array of values to pass into the callback\n   *                            at each step of the phrase.\n   */\n\n\n  p5.Part.prototype.replaceSequence = function (name, array) {\n    for (var i in this.phrases) {\n      if (this.phrases[i].name === name) {\n        this.phrases[i].sequence = array;\n      }\n    }\n  };\n\n  p5.Part.prototype.incrementStep = function (time) {\n    if (this.partStep < this.length - 1) {\n      this.callback(time);\n      this.partStep += 1;\n    } else {\n      if (!this.looping && this.partStep === this.length - 1) {\n        this.onended();\n      }\n    }\n  };\n  /**\n   *  Set the function that will be called at every step. This will clear the previous function.\n   *\n   *  @method onStep\n   *  @for p5.Part\n   *  @param  {Function} callback The name of the callback\n   *                              you want to fire\n   *                              on every beat/tatum.\n   */\n\n\n  p5.Part.prototype.onStep = function (callback) {\n    this.callback = callback;\n  }; \n\n  /**\n   *  A Score consists of a series of Parts. The parts will\n   *  be played back in order. For example, you could have an\n   *  A part, a B part, and a C part, and play them back in this order\n   *  <code>new p5.Score(a, a, b, a, c)</code>\n   *\n   *  @class p5.Score\n   *  @constructor\n   *  @param {p5.Part} [...parts] One or multiple parts, to be played in sequence.\n   */\n\n\n  p5.Score = function () {\n    this.parts = [];\n    this.currentPart = 0;\n    var thisScore = this;\n\n    for (var i in arguments) {\n      if (arguments[i] && this.parts[i]) {\n        this.parts[i] = arguments[i];\n        this.parts[i].nextPart = this.parts[i + 1];\n\n        this.parts[i].onended = function () {\n          thisScore.resetPart(i);\n          playNextPart(thisScore);\n        };\n      }\n    }\n\n    this.looping = false;\n  };\n\n  p5.Score.prototype.onended = function () {\n    if (this.looping) {\n      this.parts[0].start();\n    } else {\n      this.parts[this.parts.length - 1].onended = function () {\n        this.stop();\n        this.resetParts();\n      };\n    }\n\n    this.currentPart = 0;\n  };\n  /**\n   *  Start playback of the score.\n   *\n   *  @method  start\n   *  @for p5.Score\n   */\n\n\n  p5.Score.prototype.start = function () {\n    this.parts[this.currentPart].start();\n    this.scoreStep = 0;\n  };\n  /**\n   *  Stop playback of the score.\n   *\n   *  @method  stop\n   *  @for p5.Score\n   */\n\n\n  p5.Score.prototype.stop = function () {\n    this.parts[this.currentPart].stop();\n    this.currentPart = 0;\n    this.scoreStep = 0;\n  };\n  /**\n   *  Pause playback of the score.\n   *\n   *  @method  pause\n   *  @for p5.Score\n   */\n\n\n  p5.Score.prototype.pause = function () {\n    this.parts[this.currentPart].stop();\n  };\n  /**\n   *  Loop playback of the score.\n   *\n   *  @method  loop\n   *  @for p5.Score\n   */\n\n\n  p5.Score.prototype.loop = function () {\n    this.looping = true;\n    this.start();\n  };\n  /**\n   *  Stop looping playback of the score. If it\n   *  is currently playing, this will go into effect\n   *  after the current round of playback completes.\n   *\n   *  @method  noLoop\n   *  @for p5.Score\n   */\n\n\n  p5.Score.prototype.noLoop = function () {\n    this.looping = false;\n  };\n\n  p5.Score.prototype.resetParts = function () {\n    var self = this;\n    this.parts.forEach(function (part) {\n      self.resetParts[part];\n    });\n  };\n\n  p5.Score.prototype.resetPart = function (i) {\n    this.parts[i].stop();\n    this.parts[i].partStep = 0;\n\n    for (var p in this.parts[i].phrases) {\n      if (this.parts[i]) {\n        this.parts[i].phrases[p].phraseStep = 0;\n      }\n    }\n  };\n  /**\n   *  Set the tempo for all parts in the score\n   *\n   *  @method setBPM\n   *  @for p5.Score\n   *  @param {Number} BPM      Beats Per Minute\n   *  @param {Number} rampTime Seconds from now\n   */\n\n\n  p5.Score.prototype.setBPM = function (bpm, rampTime) {\n    for (var i in this.parts) {\n      if (this.parts[i]) {\n        this.parts[i].setBPM(bpm, rampTime);\n      }\n    }\n  };\n\n  function playNextPart(aScore) {\n    aScore.currentPart++;\n\n    if (aScore.currentPart >= aScore.parts.length) {\n      aScore.scoreStep = 0;\n      aScore.onended();\n    } else {\n      aScore.scoreStep = 0;\n      aScore.parts[aScore.currentPart - 1].stop();\n      aScore.parts[aScore.currentPart].start();\n    }\n  }\n}).call(exports, __nested_webpack_require_394269__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_408156__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_408156__(1);\n\n  var Clock = __nested_webpack_require_408156__(27);\n  /**\n   * SoundLoop\n   *\n   * @class p5.SoundLoop\n   * @constructor\n   *\n   * @param {Function} callback this function will be called on each iteration of theloop\n   * @param {Number|String} [interval] amount of time (if a number) or beats (if a string, following <a href = \"https://github.com/Tonejs/Tone.js/wiki/Time\">Tone.Time</a> convention) for each iteration of the loop. Defaults to 1 second.\n   *\n   * @example\n   * <div><code>\n   *  let synth, soundLoop;\n   *  let notePattern = [60, 62, 64, 67, 69, 72];\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(canvasPressed);\n   *    colorMode(HSB);\n   *    background(0, 0, 86);\n   *    text('tap to start/stop', 10, 20);\n   *\n   *    //the looper's callback is passed the timeFromNow\n   *    //this value should be used as a reference point from\n   *    //which to schedule sounds\n   *    let intervalInSeconds = 0.2;\n   *    soundLoop = new p5.SoundLoop(onSoundLoop, intervalInSeconds);\n   *\n   *    synth = new p5.MonoSynth();\n   * }\n   *\n   * function canvasPressed() {\n   *   // ensure audio is enabled\n   *   userStartAudio();\n   *\n   *   if (soundLoop.isPlaying) {\n   *     soundLoop.stop();\n   *   } else {\n   *     // start the loop\n   *     soundLoop.start();\n   *   }\n   * }\n   *\n   * function onSoundLoop(timeFromNow) {\n   *   let noteIndex = (soundLoop.iterations - 1) % notePattern.length;\n   *   let note = midiToFreq(notePattern[noteIndex]);\n   *   synth.play(note, 0.5, timeFromNow);\n   *   background(noteIndex * 360 / notePattern.length, 50, 100);\n   * }\n   * </code></div>\n   */\n\n\n  p5.SoundLoop = function (callback, interval) {\n    this.callback = callback;\n    /**\n     * musicalTimeMode uses <a href = \"https://github.com/Tonejs/Tone.js/wiki/Time\">Tone.Time</a> convention\n     * true if string, false if number\n     * @property {Boolean} musicalTimeMode\n     */\n\n    this.musicalTimeMode = typeof this._interval === 'number' ? false : true;\n    this._interval = interval || 1;\n    /**\n     * musicalTimeMode variables\n     * modify these only when the interval is specified in musicalTime format as a string\n     */\n\n    this._timeSignature = 4;\n    this._bpm = 60;\n    this.isPlaying = false;\n    /**\n     * Set a limit to the number of loops to play. defaults to Infinity\n     * @property {Number} maxIterations\n     */\n\n    this.maxIterations = Infinity;\n    var self = this;\n    this.clock = new Clock({\n      'callback': function callback(time) {\n        var timeFromNow = time - p5sound.audiocontext.currentTime;\n        /**\n         * Do not initiate the callback if timeFromNow is < 0\n         * This ususually occurs for a few milliseconds when the page\n         * is not fully loaded\n         *\n         * The callback should only be called until maxIterations is reached\n         */\n\n        if (timeFromNow > 0 && self.iterations <= self.maxIterations) {\n          self.callback(timeFromNow);\n        }\n      },\n      'frequency': this._calcFreq()\n    });\n  };\n  /**\n   * Start the loop\n   * @method  start\n   * @for p5.SoundLoop\n   * @param  {Number} [timeFromNow] schedule a starting time\n   */\n\n\n  p5.SoundLoop.prototype.start = function (timeFromNow) {\n    var t = timeFromNow || 0;\n    var now = p5sound.audiocontext.currentTime;\n\n    if (!this.isPlaying) {\n      this.clock.start(now + t);\n      this.isPlaying = true;\n    }\n  };\n  /**\n   * Stop the loop\n   * @method  stop\n   * @for p5.SoundLoop\n   * @param  {Number} [timeFromNow] schedule a stopping time\n   */\n\n\n  p5.SoundLoop.prototype.stop = function (timeFromNow) {\n    var t = timeFromNow || 0;\n    var now = p5sound.audiocontext.currentTime;\n\n    if (this.isPlaying) {\n      this.clock.stop(now + t);\n      this.isPlaying = false;\n    }\n  };\n  /**\n   * Pause the loop\n   * @method pause\n   * @for p5.SoundLoop\n   * @param  {Number} [timeFromNow] schedule a pausing time\n   */\n\n\n  p5.SoundLoop.prototype.pause = function (timeFromNow) {\n    var t = timeFromNow || 0;\n    var now = p5sound.audiocontext.currentTime;\n\n    if (this.isPlaying) {\n      this.clock.pause(now + t);\n      this.isPlaying = false;\n    }\n  };\n  /**\n   * Synchronize loops. Use this method to start two more more loops in synchronization\n   * or to start a loop in synchronization with a loop that is already playing\n   * This method will schedule the implicit loop in sync with the explicit master loop\n   * i.e. loopToStart.syncedStart(loopToSyncWith)\n   *\n   * @method  syncedStart\n   * @for p5.SoundLoop\n   * @param  {Object} otherLoop   a p5.SoundLoop to sync with\n   * @param  {Number} [timeFromNow] Start the loops in sync after timeFromNow seconds\n   */\n\n\n  p5.SoundLoop.prototype.syncedStart = function (otherLoop, timeFromNow) {\n    var t = timeFromNow || 0;\n    var now = p5sound.audiocontext.currentTime;\n\n    if (!otherLoop.isPlaying) {\n      otherLoop.clock.start(now + t);\n      otherLoop.isPlaying = true;\n      this.clock.start(now + t);\n      this.isPlaying = true;\n    } else if (otherLoop.isPlaying) {\n      var time = otherLoop.clock._nextTick - p5sound.audiocontext.currentTime;\n      this.clock.start(now + time);\n      this.isPlaying = true;\n    }\n  };\n  /**\n   * Updates frequency value, reflected in next callback\n   * @private\n   * @for p5.SoundLoop\n   * @method  _update\n   */\n\n\n  p5.SoundLoop.prototype._update = function () {\n    this.clock.frequency.value = this._calcFreq();\n  };\n  /**\n   * Calculate the frequency of the clock's callback based on bpm, interval, and timesignature\n   * @private\n   * @for p5.SoundLoop\n   * @method  _calcFreq\n   * @return {Number} new clock frequency value\n   */\n\n\n  p5.SoundLoop.prototype._calcFreq = function () {\n    if (typeof this._interval === 'number') {\n      this.musicalTimeMode = false;\n      return 1 / this._interval;\n    } \n    else if (typeof this._interval === 'string') {\n        this.musicalTimeMode = true;\n        return this._bpm / 60 / this._convertNotation(this._interval) * (this._timeSignature / 4);\n      }\n  };\n  /**\n   * Convert notation from musical time format to seconds\n   * Uses <a href = \"https://github.com/Tonejs/Tone.js/wiki/Time\">Tone.Time</a> convention\n   * @private\n   * @for p5.SoundLoop\n   * @method _convertNotation\n   * @param  {String} value value to be converted\n   * @return {Number}       converted value in seconds\n   */\n\n\n  p5.SoundLoop.prototype._convertNotation = function (value) {\n    var type = value.slice(-1);\n    value = Number(value.slice(0, -1));\n\n    switch (type) {\n      case 'm':\n        return this._measure(value);\n\n      case 'n':\n        return this._note(value);\n\n      default:\n        console.warn('Specified interval is not formatted correctly. See Tone.js ' + 'timing reference for more info: https://github.com/Tonejs/Tone.js/wiki/Time');\n    }\n  };\n  /**\n   * Helper conversion methods of measure and note\n   * @private\n   * @for p5.SoundLoop\n   * @method  _measure\n   */\n\n\n  p5.SoundLoop.prototype._measure = function (value) {\n    return value * this._timeSignature;\n  };\n  /**\n   * @private\n   * @method  _note\n   * @for p5.SoundLoop\n   */\n\n\n  p5.SoundLoop.prototype._note = function (value) {\n    return this._timeSignature / value;\n  };\n  /**\n   * Getters and Setters, setting any paramter will result in a change in the clock's\n   * frequency, that will be reflected after the next callback\n   * beats per minute (defaults to 60)\n   * @property {Number} bpm\n   * @for p5.SoundLoop\n   */\n\n\n  Object.defineProperty(p5.SoundLoop.prototype, 'bpm', {\n    get: function get() {\n      return this._bpm;\n    },\n    set: function set(bpm) {\n      if (!this.musicalTimeMode) {\n        console.warn('Changing the BPM in \"seconds\" mode has no effect. ' + 'BPM is only relevant in musicalTimeMode ' + 'when the interval is specified as a string ' + '(\"2n\", \"4n\", \"1m\"...etc)');\n      }\n\n      this._bpm = bpm;\n\n      this._update();\n    }\n  });\n  /**\n   * number of quarter notes in a measure (defaults to 4)\n   * @property {Number} timeSignature\n   * @for p5.SoundLoop\n   */\n\n  Object.defineProperty(p5.SoundLoop.prototype, 'timeSignature', {\n    get: function get() {\n      return this._timeSignature;\n    },\n    set: function set(timeSig) {\n      if (!this.musicalTimeMode) {\n        console.warn('Changing the timeSignature in \"seconds\" mode has no effect. ' + 'BPM is only relevant in musicalTimeMode ' + 'when the interval is specified as a string ' + '(\"2n\", \"4n\", \"1m\"...etc)');\n      }\n\n      this._timeSignature = timeSig;\n\n      this._update();\n    }\n  });\n  /**\n   * length of the loops interval\n   * @property {Number|String} interval\n   * @for p5.SoundLoop\n   */\n\n  Object.defineProperty(p5.SoundLoop.prototype, 'interval', {\n    get: function get() {\n      return this._interval;\n    },\n    set: function set(interval) {\n      this.musicalTimeMode = typeof interval === 'Number' ? false : true;\n      this._interval = interval;\n\n      this._update();\n    }\n  });\n  /**\n   * how many times the callback has been called so far\n   * @property {Number} iterations\n   * @for p5.SoundLoop\n   * @readonly\n   */\n\n  Object.defineProperty(p5.SoundLoop.prototype, 'iterations', {\n    get: function get() {\n      return this.clock.ticks;\n    }\n  });\n  return p5.SoundLoop;\n}).call(exports, __nested_webpack_require_408156__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_417744__) {\n\nvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  'use strict';\n\n  var p5sound = __nested_webpack_require_417744__(1);\n\n  var Effect = __nested_webpack_require_417744__(4);\n\n  var CustomError = __nested_webpack_require_417744__(11);\n  /**\n   * Compressor is an audio effect class that performs dynamics compression\n   * on an audio input source. This is a very commonly used technique in music\n   * and sound production. Compression creates an overall louder, richer,\n   * and fuller sound by lowering the volume of louds and raising that of softs.\n   * Compression can be used to avoid clipping (sound distortion due to\n   * peaks in volume) and is especially useful when many sounds are played\n   * at once. Compression can be used on indivudal sound sources in addition\n   * to the master output.\n   *\n   * This class extends <a href = \"/reference/#/p5.Effect\">p5.Effect</a>.\n   * Methods <a href = \"/reference/#/p5.Effect/amp\">amp()</a>, <a href = \"/reference/#/p5.Effect/chain\">chain()</a>,\n   * <a href = \"/reference/#/p5.Effect/drywet\">drywet()</a>, <a href = \"/reference/#/p5.Effect/connect\">connect()</a>, and\n   * <a href = \"/reference/#/p5.Effect/disconnect\">disconnect()</a> are available.\n   *\n   * @class p5.Compressor\n   * @constructor\n   * @extends p5.Effect\n   *\n   *\n   */\n\n\n  p5.Compressor = function () {\n    Effect.call(this);\n    /**\n     * The p5.Compressor is built with a <a href=\"https://www.w3.org/TR/webaudio/#the-dynamicscompressornode-interface\"\n    *   target=\"_blank\" title=\"W3 spec for Dynamics Compressor Node\">Web Audio Dynamics Compressor Node\n    *   </a>\n     * @property {AudioNode} compressor\n     */\n\n    this.compressor = this.ac.createDynamicsCompressor();\n    this.input.connect(this.compressor);\n    this.compressor.connect(this.wet);\n  };\n\n  p5.Compressor.prototype = Object.create(Effect.prototype);\n  /**\n   * Performs the same function as .connect, but also accepts\n   * optional parameters to set compressor's audioParams\n   * @method process\n   * @for p5.Compressor\n   *\n   * @param {Object} src         Sound source to be connected\n   *\n   * @param {Number} [attack]     The amount of time (in seconds) to reduce the gain by 10dB,\n   *                            default = .003, range 0 - 1\n   * @param {Number} [knee]       A decibel value representing the range above the\n   *                            threshold where the curve smoothly transitions to the \"ratio\" portion.\n   *                            default = 30, range 0 - 40\n   * @param {Number} [ratio]      The amount of dB change in input for a 1 dB change in output\n   *                            default = 12, range 1 - 20\n   * @param {Number} [threshold]  The decibel value above which the compression will start taking effect\n   *                            default = -24, range -100 - 0\n   * @param {Number} [release]    The amount of time (in seconds) to increase the gain by 10dB\n   *                            default = .25, range 0 - 1\n   */\n\n  p5.Compressor.prototype.process = function (src, attack, knee, ratio, threshold, release) {\n    src.connect(this.input);\n    this.set(attack, knee, ratio, threshold, release);\n  };\n  /**\n   * Set the paramters of a compressor.\n   * @method  set\n   * @for p5.Compressor\n   * @param {Number} attack     The amount of time (in seconds) to reduce the gain by 10dB,\n   *                            default = .003, range 0 - 1\n   * @param {Number} knee       A decibel value representing the range above the\n   *                            threshold where the curve smoothly transitions to the \"ratio\" portion.\n   *                            default = 30, range 0 - 40\n   * @param {Number} ratio      The amount of dB change in input for a 1 dB change in output\n   *                            default = 12, range 1 - 20\n   * @param {Number} threshold  The decibel value above which the compression will start taking effect\n   *                            default = -24, range -100 - 0\n   * @param {Number} release    The amount of time (in seconds) to increase the gain by 10dB\n   *                            default = .25, range 0 - 1\n   */\n\n\n  p5.Compressor.prototype.set = function (attack, knee, ratio, threshold, release) {\n    if (typeof attack !== 'undefined') {\n      this.attack(attack);\n    }\n\n    if (typeof knee !== 'undefined') {\n      this.knee(knee);\n    }\n\n    if (typeof ratio !== 'undefined') {\n      this.ratio(ratio);\n    }\n\n    if (typeof threshold !== 'undefined') {\n      this.threshold(threshold);\n    }\n\n    if (typeof release !== 'undefined') {\n      this.release(release);\n    }\n  };\n  /**\n   * Get current attack or set value w/ time ramp\n   *\n   *\n   * @method attack\n   * @for p5.Compressor\n   * @param {Number} [attack] Attack is the amount of time (in seconds) to reduce the gain by 10dB,\n   *                          default = .003, range 0 - 1\n   * @param {Number} [time]  Assign time value to schedule the change in value\n   */\n\n\n  p5.Compressor.prototype.attack = function (attack, time) {\n    var t = time || 0;\n\n    if (typeof attack == 'number') {\n      this.compressor.attack.value = attack;\n      this.compressor.attack.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.compressor.attack.linearRampToValueAtTime(attack, this.ac.currentTime + 0.02 + t);\n    } else if (typeof attack !== 'undefined') {\n      attack.connect(this.compressor.attack);\n    }\n\n    return this.compressor.attack.value;\n  };\n  /**\n    * Get current knee or set value w/ time ramp\n    *\n    * @method knee\n    * @for p5.Compressor\n    * @param {Number} [knee] A decibel value representing the range above the\n    *                        threshold where the curve smoothly transitions to the \"ratio\" portion.\n    *                        default = 30, range 0 - 40\n    * @param {Number} [time]  Assign time value to schedule the change in value\n    */\n\n\n  p5.Compressor.prototype.knee = function (knee, time) {\n    var t = time || 0;\n\n    if (typeof knee == 'number') {\n      this.compressor.knee.value = knee;\n      this.compressor.knee.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.compressor.knee.linearRampToValueAtTime(knee, this.ac.currentTime + 0.02 + t);\n    } else if (typeof knee !== 'undefined') {\n      knee.connect(this.compressor.knee);\n    }\n\n    return this.compressor.knee.value;\n  };\n  /**\n   * Get current ratio or set value w/ time ramp\n   * @method ratio\n   * @for p5.Compressor\n   * @param {Number} [ratio]      The amount of dB change in input for a 1 dB change in output\n   *                            default = 12, range 1 - 20\n   * @param {Number} [time]  Assign time value to schedule the change in value\n   */\n\n\n  p5.Compressor.prototype.ratio = function (ratio, time) {\n    var t = time || 0;\n\n    if (typeof ratio == 'number') {\n      this.compressor.ratio.value = ratio;\n      this.compressor.ratio.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.compressor.ratio.linearRampToValueAtTime(ratio, this.ac.currentTime + 0.02 + t);\n    } else if (typeof ratio !== 'undefined') {\n      ratio.connect(this.compressor.ratio);\n    }\n\n    return this.compressor.ratio.value;\n  };\n  /**\n   * Get current threshold or set value w/ time ramp\n   * @method threshold\n   * @for p5.Compressor\n   * @param {Number} threshold  The decibel value above which the compression will start taking effect\n   *                            default = -24, range -100 - 0\n   * @param {Number} [time]  Assign time value to schedule the change in value\n   */\n\n\n  p5.Compressor.prototype.threshold = function (threshold, time) {\n    var t = time || 0;\n\n    if (typeof threshold == 'number') {\n      this.compressor.threshold.value = threshold;\n      this.compressor.threshold.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.compressor.threshold.linearRampToValueAtTime(threshold, this.ac.currentTime + 0.02 + t);\n    } else if (typeof threshold !== 'undefined') {\n      threshold.connect(this.compressor.threshold);\n    }\n\n    return this.compressor.threshold.value;\n  };\n  /**\n   * Get current release or set value w/ time ramp\n   * @method release\n   * @for p5.Compressor\n   * @param {Number} release    The amount of time (in seconds) to increase the gain by 10dB\n   *                            default = .25, range 0 - 1\n   *\n   * @param {Number} [time]  Assign time value to schedule the change in value\n   */\n\n\n  p5.Compressor.prototype.release = function (release, time) {\n    var t = time || 0;\n\n    if (typeof release == 'number') {\n      this.compressor.release.value = release;\n      this.compressor.release.cancelScheduledValues(this.ac.currentTime + 0.01 + t);\n      this.compressor.release.linearRampToValueAtTime(release, this.ac.currentTime + 0.02 + t);\n    } else if (typeof number !== 'undefined') {\n      release.connect(this.compressor.release);\n    }\n\n    return this.compressor.release.value;\n  };\n  /**\n   * Return the current reduction value\n   *\n   * @method reduction\n   * @for p5.Compressor\n   * @return {Number} Value of the amount of gain reduction that is applied to the signal\n   */\n\n\n  p5.Compressor.prototype.reduction = function () {\n    return this.compressor.reduction.value;\n  };\n\n  p5.Compressor.prototype.dispose = function () {\n    Effect.prototype.dispose.apply(this);\n\n    if (this.compressor) {\n      this.compressor.disconnect();\n      delete this.compressor;\n    }\n  };\n\n  return p5.Compressor;\n}).call(exports, __nested_webpack_require_417744__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_427357__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_427357__(1);\n\n  var _require = __nested_webpack_require_427357__(6),\n      convertToWav = _require.convertToWav,\n      safeBufferSize = _require.safeBufferSize;\n\n  var processorNames = __nested_webpack_require_427357__(10);\n\n  var ac = p5sound.audiocontext;\n  /**\n   *  <p>Record sounds for playback and/or to save as a .wav file.\n   *  The p5.SoundRecorder records all sound output from your sketch,\n   *  or can be assigned a specific source with setInput().</p>\n   *  <p>The record() method accepts a p5.SoundFile as a parameter.\n   *  When playback is stopped (either after the given amount of time,\n   *  or with the stop() method), the p5.SoundRecorder will send its\n   *  recording to that p5.SoundFile for playback.</p>\n   *\n   *  @class p5.SoundRecorder\n   *  @constructor\n   *  @example\n   *  <div><code>\n   *  let mic, recorder, soundFile;\n   *  let state = 0;\n   *\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(canvasPressed);\n   *    background(220);\n   *    textAlign(CENTER, CENTER);\n   *\n   *    // create an audio in\n   *    mic = new p5.AudioIn();\n   *\n   *    // prompts user to enable their browser mic\n   *    mic.start();\n   *\n   *    // create a sound recorder\n   *    recorder = new p5.SoundRecorder();\n   *\n   *    // connect the mic to the recorder\n   *    recorder.setInput(mic);\n   *\n   *    // this sound file will be used to\n   *    // playback & save the recording\n   *    soundFile = new p5.SoundFile();\n   *\n   *    text('tap to record', width/2, height/2);\n   *  }\n   *\n   *  function canvasPressed() {\n   *    // ensure audio is enabled\n   *    userStartAudio();\n   *\n   *    // make sure user enabled the mic\n   *    if (state === 0 && mic.enabled) {\n   *\n   *      // record to our p5.SoundFile\n   *      recorder.record(soundFile);\n   *\n   *      background(255,0,0);\n   *      text('Recording!', width/2, height/2);\n   *      state++;\n   *    }\n   *    else if (state === 1) {\n   *      background(0,255,0);\n   *\n   *      // stop recorder and\n   *      // send result to soundFile\n   *      recorder.stop();\n   *\n   *      text('Done! Tap to play and download', width/2, height/2, width - 20);\n   *      state++;\n   *    }\n   *\n   *    else if (state === 2) {\n   *      soundFile.play(); // play the result!\n   *      save(soundFile, 'mySound.wav');\n   *      state++;\n   *    }\n   *  }\n   *  </div></code>\n   */\n\n  p5.SoundRecorder = function () {\n    this.input = ac.createGain();\n    this.output = ac.createGain();\n    this._inputChannels = 2;\n    this._outputChannels = 2; \n\n    var workletBufferSize = safeBufferSize(1024);\n    this._workletNode = new AudioWorkletNode(ac, processorNames.recorderProcessor, {\n      outputChannelCount: [this._outputChannels],\n      processorOptions: {\n        numInputChannels: this._inputChannels,\n        bufferSize: workletBufferSize\n      }\n    });\n\n    this._workletNode.port.onmessage = function (event) {\n      if (event.data.name === 'buffers') {\n        var buffers = [new Float32Array(event.data.leftBuffer), new Float32Array(event.data.rightBuffer)];\n\n        this._callback(buffers);\n      }\n    }.bind(this);\n    /**\n     *  callback invoked when the recording is over\n     *  @private\n     *  @type Function(Float32Array)\n     */\n\n\n    this._callback = function () {}; \n\n\n    this._workletNode.connect(p5.soundOut._silentNode);\n\n    this.setInput(); \n\n    p5sound.soundArray.push(this);\n  };\n  /**\n   *  Connect a specific device to the p5.SoundRecorder.\n   *  If no parameter is given, p5.SoundRecorer will record\n   *  all audible p5.sound from your sketch.\n   *\n   *  @method  setInput\n   *  @for p5.SoundRecorder\n   *  @param {Object} [unit] p5.sound object or a web audio unit\n   *                         that outputs sound\n   */\n\n\n  p5.SoundRecorder.prototype.setInput = function (unit) {\n    this.input.disconnect();\n    this.input = null;\n    this.input = ac.createGain();\n    this.input.connect(this._workletNode);\n    this.input.connect(this.output);\n\n    if (unit) {\n      unit.connect(this.input);\n    } else {\n      p5.soundOut.output.connect(this.input);\n    }\n  };\n  /**\n   *  Start recording. To access the recording, provide\n   *  a p5.SoundFile as the first parameter. The p5.SoundRecorder\n   *  will send its recording to that p5.SoundFile for playback once\n   *  recording is complete. Optional parameters include duration\n   *  (in seconds) of the recording, and a callback function that\n   *  will be called once the complete recording has been\n   *  transfered to the p5.SoundFile.\n   *\n   *  @method  record\n   *  @for p5.SoundRecorder\n   *  @param  {p5.SoundFile}   soundFile    p5.SoundFile\n   *  @param  {Number}   [duration] Time (in seconds)\n   *  @param  {Function} [callback] The name of a function that will be\n   *                                called once the recording completes\n   */\n\n\n  p5.SoundRecorder.prototype.record = function (sFile, duration, callback) {\n    this._workletNode.port.postMessage({\n      name: 'start',\n      duration: duration\n    });\n\n    if (sFile && callback) {\n      this._callback = function (buffer) {\n        sFile.setBuffer(buffer);\n        callback();\n      };\n    } else if (sFile) {\n      this._callback = function (buffer) {\n        sFile.setBuffer(buffer);\n      };\n    }\n  };\n  /**\n   *  Stop the recording. Once the recording is stopped,\n   *  the results will be sent to the p5.SoundFile that\n   *  was given on .record(), and if a callback function\n   *  was provided on record, that function will be called.\n   *\n   *  @method  stop\n   *  @for p5.SoundRecorder\n   */\n\n\n  p5.SoundRecorder.prototype.stop = function () {\n    this._workletNode.port.postMessage({\n      name: 'stop'\n    });\n  };\n\n  p5.SoundRecorder.prototype.dispose = function () {\n    var index = p5sound.soundArray.indexOf(this);\n    p5sound.soundArray.splice(index, 1);\n\n    this._callback = function () {};\n\n    if (this.input) {\n      this.input.disconnect();\n    }\n\n    this.input = null;\n    this._workletNode = null;\n  };\n  /**\n   * Save a p5.SoundFile as a .wav file. The browser will prompt the user\n   * to download the file to their device.\n   * For uploading audio to a server, use\n   * <a href=\"/docs/reference/#/p5.SoundFile/saveBlob\">`p5.SoundFile.saveBlob`</a>.\n   *\n   *  @for p5\n   *  @method saveSound\n   *  @param  {p5.SoundFile} soundFile p5.SoundFile that you wish to save\n   *  @param  {String} fileName      name of the resulting .wav file.\n   */\n\n\n  p5.prototype.saveSound = function (soundFile, fileName) {\n    var dataView = convertToWav(soundFile.buffer);\n    p5.prototype.writeFile([dataView], fileName, 'wav');\n  };\n}).call(exports, __nested_webpack_require_427357__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_434306__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  /**\n   *  <p>PeakDetect works in conjunction with p5.FFT to\n   *  look for onsets in some or all of the frequency spectrum.\n   *  </p>\n   *  <p>\n   *  To use p5.PeakDetect, call <code>update</code> in the draw loop\n   *  and pass in a p5.FFT object.\n   *  </p>\n   *  <p>\n   *  You can listen for a specific part of the frequency spectrum by\n   *  setting the range between <code>freq1</code> and <code>freq2</code>.\n   *  </p>\n   *\n   *  <p><code>threshold</code> is the threshold for detecting a peak,\n   *  scaled between 0 and 1. It is logarithmic, so 0.1 is half as loud\n   *  as 1.0.</p>\n   *\n   *  <p>\n   *  The update method is meant to be run in the draw loop, and\n   *  <b>frames</b> determines how many loops must pass before\n   *  another peak can be detected.\n   *  For example, if the frameRate() = 60, you could detect the beat of a\n   *  120 beat-per-minute song with this equation:\n   *  <code> framesPerPeak = 60 / (estimatedBPM / 60 );</code>\n   *  </p>\n   *\n   *  <p>\n   *  Based on example contribtued by @b2renger, and a simple beat detection\n   *  explanation by <a\n   *  href=\"http://www.airtightinteractive.com/2013/10/making-audio-reactive-visuals/\"\n   *  target=\"_blank\">Felix Turner</a>.\n   *  </p>\n   *\n   *  @class  p5.PeakDetect\n   *  @constructor\n   *  @param {Number} [freq1]     lowFrequency - defaults to 20Hz\n   *  @param {Number} [freq2]     highFrequency - defaults to 20000 Hz\n   *  @param {Number} [threshold] Threshold for detecting a beat between 0 and 1\n   *                            scaled logarithmically where 0.1 is 1/2 the loudness\n   *                            of 1.0. Defaults to 0.35.\n   *  @param {Number} [framesPerPeak]     Defaults to 20.\n   *  @example\n   *  <div><code>\n   *\n   *  var cnv, soundFile, fft, peakDetect;\n   *  var ellipseWidth = 10;\n   *\n   *  function preload() {\n   *    soundFile = loadSound('assets/beat.mp3');\n   *  }\n   *\n   *  function setup() {\n   *    background(0);\n   *    noStroke();\n   *    fill(255);\n   *    textAlign(CENTER);\n   *\n   *    // p5.PeakDetect requires a p5.FFT\n   *    fft = new p5.FFT();\n   *    peakDetect = new p5.PeakDetect();\n   *  }\n   *\n   *  function draw() {\n   *    background(0);\n   *    text('click to play/pause', width/2, height/2);\n   *\n   *    // peakDetect accepts an fft post-analysis\n   *    fft.analyze();\n   *    peakDetect.update(fft);\n   *\n   *    if ( peakDetect.isDetected ) {\n   *      ellipseWidth = 50;\n   *    } else {\n   *      ellipseWidth *= 0.95;\n   *    }\n   *\n   *    ellipse(width/2, height/2, ellipseWidth, ellipseWidth);\n   *  }\n   *\n   *  // toggle play/stop when canvas is clicked\n   *  function mouseClicked() {\n   *    if (mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {\n   *      if (soundFile.isPlaying() ) {\n   *        soundFile.stop();\n   *      } else {\n   *        soundFile.play();\n   *      }\n   *    }\n   *  }\n   *  </code></div>\n   */\n  p5.PeakDetect = function (freq1, freq2, threshold, _framesPerPeak) {\n    this.framesPerPeak = _framesPerPeak || 20;\n    this.framesSinceLastPeak = 0;\n    this.decayRate = 0.95;\n    this.threshold = threshold || 0.35;\n    this.cutoff = 0; \n\n    this.cutoffMult = 1.5;\n    this.energy = 0;\n    this.penergy = 0; \n\n    this.currentValue = 0;\n    /**\n     *  isDetected is set to true when a peak is detected.\n     *\n     *  @attribute isDetected {Boolean}\n     *  @default  false\n     */\n\n    this.isDetected = false;\n    this.f1 = freq1 || 40;\n    this.f2 = freq2 || 20000; \n\n    this._onPeak = function () {};\n  };\n  /**\n   *  The update method is run in the draw loop.\n   *\n   *  Accepts an FFT object. You must call .analyze()\n   *  on the FFT object prior to updating the peakDetect\n   *  because it relies on a completed FFT analysis.\n   *\n   *  @method  update\n   *  @param  {p5.FFT} fftObject A p5.FFT object\n   */\n\n\n  p5.PeakDetect.prototype.update = function (fftObject) {\n    var nrg = this.energy = fftObject.getEnergy(this.f1, this.f2) / 255;\n\n    if (nrg > this.cutoff && nrg > this.threshold && nrg - this.penergy > 0) {\n      this._onPeak();\n\n      this.isDetected = true; \n\n      this.cutoff = nrg * this.cutoffMult;\n      this.framesSinceLastPeak = 0;\n    } else {\n      this.isDetected = false;\n\n      if (this.framesSinceLastPeak <= this.framesPerPeak) {\n        this.framesSinceLastPeak++;\n      } else {\n        this.cutoff *= this.decayRate;\n        this.cutoff = Math.max(this.cutoff, this.threshold);\n      }\n    }\n\n    this.currentValue = nrg;\n    this.penergy = nrg;\n  };\n  /**\n   *  onPeak accepts two arguments: a function to call when\n   *  a peak is detected. The value of the peak,\n   *  between 0.0 and 1.0, is passed to the callback.\n   *\n   *  @method  onPeak\n   *  @param  {Function} callback Name of a function that will\n   *                              be called when a peak is\n   *                              detected.\n   *  @param  {Object}   [val]    Optional value to pass\n   *                              into the function when\n   *                              a peak is detected.\n   *  @example\n   *  <div><code>\n   *  var cnv, soundFile, fft, peakDetect;\n   *  var ellipseWidth = 0;\n   *\n   *  function preload() {\n   *    soundFile = loadSound('assets/beat.mp3');\n   *  }\n   *\n   *  function setup() {\n   *    cnv = createCanvas(100,100);\n   *    textAlign(CENTER);\n   *\n   *    fft = new p5.FFT();\n   *    peakDetect = new p5.PeakDetect();\n   *\n   *    setupSound();\n   *\n   *    // when a beat is detected, call triggerBeat()\n   *    peakDetect.onPeak(triggerBeat);\n   *  }\n   *\n   *  function draw() {\n   *    background(0);\n   *    fill(255);\n   *    text('click to play', width/2, height/2);\n   *\n   *    fft.analyze();\n   *    peakDetect.update(fft);\n   *\n   *    ellipseWidth *= 0.95;\n   *    ellipse(width/2, height/2, ellipseWidth, ellipseWidth);\n   *  }\n   *\n   *  // this function is called by peakDetect.onPeak\n   *  function triggerBeat() {\n   *    ellipseWidth = 50;\n   *  }\n   *\n   *  // mouseclick starts/stops sound\n   *  function setupSound() {\n   *    cnv.mouseClicked( function() {\n   *      if (soundFile.isPlaying() ) {\n   *        soundFile.stop();\n   *      } else {\n   *        soundFile.play();\n   *      }\n   *    });\n   *  }\n   *  </code></div>\n   */\n\n\n  p5.PeakDetect.prototype.onPeak = function (callback, val) {\n    var self = this;\n\n    self._onPeak = function () {\n      callback(self.energy, val);\n    };\n  };\n}).call(exports, __nested_webpack_require_434306__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_441025__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var p5sound = __nested_webpack_require_441025__(1);\n  /**\n   *  A gain node is usefull to set the relative volume of sound.\n   *  It's typically used to build mixers.\n   *\n   *  @class p5.Gain\n   *  @constructor\n   *  @example\n   *  <div><code>\n   *\n   *  // load two soundfile and crossfade beetween them\n   *  let sound1,sound2;\n   *  let sound1Gain, sound2Gain, masterGain;\n   *  function preload(){\n   *    soundFormats('ogg', 'mp3');\n   *    sound1 = loadSound('assets/Damscray_-_Dancing_Tiger_01');\n   *    sound2 = loadSound('assets/beat');\n   *  }\n   *  function setup() {\n   *    let cnv = createCanvas(100, 100);\n   *    cnv.mousePressed(startSound);\n   *    // create a 'master' gain to which we will connect both soundfiles\n   *    masterGain = new p5.Gain();\n   *    masterGain.connect();\n   *    sound1.disconnect(); // diconnect from p5 output\n   *    sound1Gain = new p5.Gain(); // setup a gain node\n   *    sound1Gain.setInput(sound1); // connect the first sound to its input\n   *    sound1Gain.connect(masterGain); // connect its output to the 'master'\n   *    sound2.disconnect();\n   *    sound2Gain = new p5.Gain();\n   *    sound2Gain.setInput(sound2);\n   *    sound2Gain.connect(masterGain);\n   *  }\n   *  function startSound() {\n   *    sound1.loop();\n   *    sound2.loop();\n   *    loop();\n   *  }\n   *  function mouseReleased() {\n   *    sound1.stop();\n   *    sound2.stop();\n   *  }\n   *  function draw(){\n   *    background(220);\n   *    textAlign(CENTER);\n   *    textSize(11);\n   *    fill(0);\n   *    if (!sound1.isPlaying()) {\n   *      text('tap and drag to play', width/2, height/2);\n   *      return;\n   *    }\n   *    // map the horizontal position of the mouse to values useable for volume    *  control of sound1\n   *    var sound1Volume = constrain(map(mouseX,width,0,0,1), 0, 1);\n   *    var sound2Volume = 1-sound1Volume;\n   *    sound1Gain.amp(sound1Volume);\n   *    sound2Gain.amp(sound2Volume);\n   *    // map the vertical position of the mouse to values useable for 'master    *  volume control'\n   *    var masterVolume = constrain(map(mouseY,height,0,0,1), 0, 1);\n   *    masterGain.amp(masterVolume);\n   *    text('master', width/2, height - masterVolume * height * 0.9)\n   *    fill(255, 0, 255);\n   *    textAlign(LEFT);\n   *    text('sound1', 5, height - sound1Volume * height * 0.9);\n   *    textAlign(RIGHT);\n   *    text('sound2', width - 5, height - sound2Volume * height * 0.9);\n   *  }\n   *</code></div>\n   */\n\n\n  p5.Gain = function () {\n    this.ac = p5sound.audiocontext;\n    this.input = this.ac.createGain();\n    this.output = this.ac.createGain(); \n\n    this.input.gain.value = 0.5;\n    this.input.connect(this.output); \n\n    p5sound.soundArray.push(this);\n  };\n  /**\n   *  Connect a source to the gain node.\n   *\n   *  @method  setInput\n   *  @for p5.Gain\n   *  @param  {Object} src     p5.sound / Web Audio object with a sound\n   *                           output.\n   */\n\n\n  p5.Gain.prototype.setInput = function (src) {\n    src.connect(this.input);\n  };\n  /**\n   *  Send output to a p5.sound or web audio object\n   *\n   *  @method  connect\n   *  @for p5.Gain\n   *  @param  {Object} unit\n   */\n\n\n  p5.Gain.prototype.connect = function (unit) {\n    var u = unit || p5.soundOut.input;\n    this.output.connect(u.input ? u.input : u);\n  };\n  /**\n   *  Disconnect all output.\n   *\n   *  @method disconnect\n   *  @for p5.Gain\n   */\n\n\n  p5.Gain.prototype.disconnect = function () {\n    if (this.output) {\n      this.output.disconnect();\n    }\n  };\n  /**\n   *  Set the output level of the gain node.\n   *\n   *  @method  amp\n   *  @for p5.Gain\n   *  @param  {Number} volume amplitude between 0 and 1.0\n   *  @param  {Number} [rampTime] create a fade that lasts rampTime\n   *  @param  {Number} [timeFromNow] schedule this event to happen\n   *                                seconds from now\n   */\n\n\n  p5.Gain.prototype.amp = function (vol, rampTime, tFromNow) {\n    var rampTime = rampTime || 0;\n    var tFromNow = tFromNow || 0;\n    var now = p5sound.audiocontext.currentTime;\n    var currentVol = this.output.gain.value;\n    this.output.gain.cancelScheduledValues(now);\n    this.output.gain.linearRampToValueAtTime(currentVol, now + tFromNow);\n    this.output.gain.linearRampToValueAtTime(vol, now + tFromNow + rampTime);\n  };\n\n  p5.Gain.prototype.dispose = function () {\n    var index = p5sound.soundArray.indexOf(this);\n    p5sound.soundArray.splice(index, 1);\n\n    if (this.output) {\n      this.output.disconnect();\n      delete this.output;\n    }\n\n    if (this.input) {\n      this.input.disconnect();\n      delete this.input;\n    }\n  };\n}).call(exports, __nested_webpack_require_441025__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n }),\n (function(module, exports, __nested_webpack_require_445931__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {\n  var Effect = __nested_webpack_require_445931__(4);\n\n\n  function makeDistortionCurve(amount) {\n    var k = typeof amount === 'number' ? amount : 50;\n    var numSamples = 44100;\n    var curve = new Float32Array(numSamples);\n    var deg = Math.PI / 180;\n    var i = 0;\n    var x;\n\n    for (; i < numSamples; ++i) {\n      x = i * 2 / numSamples - 1;\n      curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));\n    }\n\n    return curve;\n  }\n  /**\n   * A Distortion effect created with a Waveshaper Node,\n   * with an approach adapted from\n   * [Kevin Ennis](http://stackoverflow.com/questions/22312841/waveshaper-node-in-webaudio-how-to-emulate-distortion)\n   *\n   * This class extends <a href = \"/reference/#/p5.Effect\">p5.Effect</a>.\n   * Methods <a href = \"/reference/#/p5.Effect/amp\">amp()</a>, <a href = \"/reference/#/p5.Effect/chain\">chain()</a>,\n   * <a href = \"/reference/#/p5.Effect/drywet\">drywet()</a>, <a href = \"/reference/#/p5.Effect/connect\">connect()</a>, and\n   * <a href = \"/reference/#/p5.Effect/disconnect\">disconnect()</a> are available.\n   *\n   * @class p5.Distortion\n   * @extends p5.Effect\n   * @constructor\n   * @param {Number} [amount=0.25] Unbounded distortion amount.\n   *                                Normal values range from 0-1.\n   * @param {String} [oversample='none'] 'none', '2x', or '4x'.\n   *\n   */\n\n\n  p5.Distortion = function (amount, oversample) {\n    Effect.call(this);\n\n    if (typeof amount === 'undefined') {\n      amount = 0.25;\n    }\n\n    if (typeof amount !== 'number') {\n      throw new Error('amount must be a number');\n    }\n\n    if (typeof oversample === 'undefined') {\n      oversample = '2x';\n    }\n\n    if (typeof oversample !== 'string') {\n      throw new Error('oversample must be a String');\n    }\n\n    var curveAmount = p5.prototype.map(amount, 0.0, 1.0, 0, 2000);\n    /**\n     *  The p5.Distortion is built with a\n     *  <a href=\"http://www.w3.org/TR/webaudio/#WaveShaperNode\">\n     *  Web Audio WaveShaper Node</a>.\n     *\n     *  @property {AudioNode} WaveShaperNode\n     */\n\n    this.waveShaperNode = this.ac.createWaveShaper();\n    this.amount = curveAmount;\n    this.waveShaperNode.curve = makeDistortionCurve(curveAmount);\n    this.waveShaperNode.oversample = oversample;\n    this.input.connect(this.waveShaperNode);\n    this.waveShaperNode.connect(this.wet);\n  };\n\n  p5.Distortion.prototype = Object.create(Effect.prototype);\n  /**\n   * Process a sound source, optionally specify amount and oversample values.\n   *\n   * @method process\n   * @for p5.Distortion\n   * @param {Number} [amount=0.25] Unbounded distortion amount.\n   *                                Normal values range from 0-1.\n   * @param {String} [oversample='none'] 'none', '2x', or '4x'.\n   */\n\n  p5.Distortion.prototype.process = function (src, amount, oversample) {\n    src.connect(this.input);\n    this.set(amount, oversample);\n  };\n  /**\n   * Set the amount and oversample of the waveshaper distortion.\n   *\n   * @method set\n   * @for p5.Distortion\n   * @param {Number} [amount=0.25] Unbounded distortion amount.\n   *                                Normal values range from 0-1.\n   * @param {String} [oversample='none'] 'none', '2x', or '4x'.\n   */\n\n\n  p5.Distortion.prototype.set = function (amount, oversample) {\n    if (amount) {\n      var curveAmount = p5.prototype.map(amount, 0.0, 1.0, 0, 2000);\n      this.amount = curveAmount;\n      this.waveShaperNode.curve = makeDistortionCurve(curveAmount);\n    }\n\n    if (oversample) {\n      this.waveShaperNode.oversample = oversample;\n    }\n  };\n  /**\n   *  Return the distortion amount, typically between 0-1.\n   *\n   *  @method  getAmount\n   *  @for p5.Distortion\n   *  @return {Number} Unbounded distortion amount.\n   *                   Normal values range from 0-1.\n   */\n\n\n  p5.Distortion.prototype.getAmount = function () {\n    return this.amount;\n  };\n  /**\n   *  Return the oversampling.\n   *\n   *  @method getOversample\n   *  @for p5.Distortion\n   *  @return {String} Oversample can either be 'none', '2x', or '4x'.\n   */\n\n\n  p5.Distortion.prototype.getOversample = function () {\n    return this.waveShaperNode.oversample;\n  };\n\n  p5.Distortion.prototype.dispose = function () {\n    Effect.prototype.dispose.apply(this);\n\n    if (this.waveShaperNode) {\n      this.waveShaperNode.disconnect();\n      this.waveShaperNode = null;\n    }\n  };\n}).call(exports, __nested_webpack_require_445931__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n })\n ]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDUvbGliL2FkZG9ucy9wNS5zb3VuZC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsK0JBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsK0JBQW1CO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLEVBQUUsK0JBQW1CO0FBQ3JCLEVBQUUsK0JBQW1CO0FBQ3JCLEVBQUUsK0JBQW1CO0FBQ3JCLE9BQU8sK0JBQW1CO0FBQzFCLDJDQUEyQywrQkFBK0I7QUFDMUU7QUFDQTtBQUNBLEVBQUUsK0JBQW1CO0FBQ3JCO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRTtBQUNBLGtEQUFrRCxhQUFhO0FBQy9EO0FBQ0EsRUFBRSwrQkFBbUI7QUFDckIsd0JBQXdCLCtCQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxHQUFHLCtCQUFtQjtBQUN0QiwwQ0FBMEMsZ0NBQWdDO0FBQzFFLGtFQUFrRSwrQkFBbUIsNEJBQTRCLG9CQUFvQjtBQUNySTtBQUNBO0FBQ0EsRUFBRSwrQkFBbUI7QUFDckI7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hELGtDQUFrQztBQUNsQyxHQUFHLCtCQUFtQjtBQUN0QjtBQUNBO0FBQ0EsRUFBRSwrQkFBbUIsa0NBQWtDO0FBQ3ZELEVBQUUsK0JBQW1CO0FBQ3JCLFNBQVMsK0JBQW1CLENBQUMsK0JBQW1CO0FBQ2hELEVBQUU7QUFDRjtBQUNBLDRCQUE0QiwrQkFBbUI7O0FBRS9DLGtDQUFrQyw4Q0FBOEMsYUFBYSxnQkFBZ0Isd0xBQXdMLE1BQU0sdUNBQXVDLHdCQUF3QiwwQkFBMEIsU0FBUyxXQUFXLGtCQUFrQixPQUFPLFdBQVcsd0JBQXdCLDJCQUEyQixhQUFhLGdDQUFnQyxnQkFBZ0Isa0JBQWtCLFdBQVcsV0FBVyxnQkFBZ0IsV0FBVyxrT0FBa08sWUFBWSw2QkFBNkIsb0ZBQW9GLFlBQVksS0FBSyxXQUFXLEtBQUssc0JBQXNCLHdCQUF3QiwyQkFBMkIsYUFBYSxLQUFLLFdBQVcsYUFBYSxlQUFlLGdCQUFnQixXQUFXLHdPQUF3TyxTQUFTLDBDQUEwQyxTQUFTLCtIQUErSCxXQUFXLHVDQUF1QyxTQUFTLGlDQUFpQyxnQkFBZ0Isc0RBQXNELHdDQUF3QyxhQUFhLHFEQUFxRCxlQUFlLGtFQUFrRSx1REFBdUQsZUFBZSxxRUFBcUUsaUNBQWlDLDBOQUEwTixxQ0FBcUMseUhBQXlILHdDQUF3QyxxTEFBcUwsc0NBQXNDLGlEQUFpRCxtQkFBbUIsS0FBSyxtQkFBbUIsaUJBQWlCLFlBQVksOEJBQThCLHlDQUF5QyxtQkFBbUIsS0FBSyxtQkFBbUIsaUJBQWlCLFlBQVksNEJBQTRCLGtDQUFrQyxtQkFBbUIsK0JBQStCLFlBQVksMEhBQTBILHVDQUF1QyxTQUFTLCtDQUErQywrQ0FBK0MsU0FBUywyQkFBMkIsMkNBQTJDLFNBQVMsNENBQTRDLGlCQUFpQixXQUFXLGlCQUFpQiw4Q0FBOEMsaUNBQWlDLGtCQUFrQixvQ0FBb0MsMkJBQTJCLGtDQUFrQyx5QkFBeUIsa0NBQWtDLG9GQUFvRixtQ0FBbUMsMEJBQTBCLGlDQUFpQyx3QkFBd0Isa0NBQWtDLHlCQUF5QixvQkFBb0IsbUNBQW1DLGdDQUFnQyxXQUFXLHlCQUF5QixtQ0FBbUMsMEJBQTBCLEVBQUUsbUNBQW1DLGdDQUFnQyxXQUFXLHlCQUF5QixtQ0FBbUMsWUFBWSxFQUFFLFVBQVUsb0RBQW9ELHlDQUF5QyxpQkFBaUIscUJBQXFCLGtDQUFrQyx1QkFBdUIsa0NBQWtDLGdDQUFnQyxrREFBa0Qsd0JBQXdCLDRCQUE0Qix1QkFBdUIsa0JBQWtCLHVCQUF1Qix3QkFBd0IsY0FBYyw2R0FBNkcsb0NBQW9DLGVBQWUsU0FBUyxpQkFBaUIsNEZBQTRGLCtDQUErQyxlQUFlLGtCQUFrQiwyQkFBMkIsWUFBWSxnREFBZ0QsZUFBZSxvQ0FBb0Msa0RBQWtELGVBQWUsa0NBQWtDLHVDQUF1QyxlQUFlLDhKQUE4SixnQkFBZ0Isc0hBQXNILGdCQUFnQixnQkFBZ0IsK0JBQW1CO0FBQ3h2TDs7QUFFQSxFQUFFO0FBQ0YsNEJBQTRCLGdDQUFtQjs7QUFFL0M7QUFDQTs7QUFFQSxrQ0FBa0MsZ0NBQW1CO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLEVBQUU7QUFDRiw0QkFBNEIsZ0NBQW1COztBQUUvQyxnRUFBZ0Usa0NBQWtDLGdDQUFtQixJQUFJLGdDQUFtQixJQUFJLGdDQUFtQixJQUFJLGdDQUFtQixLQUFLLGdDQUFtQixtREFBbUQsYUFBYSwyQkFBMkIsd0VBQXdFLG1MQUFtTCwrQ0FBK0Msd0NBQXdDLGlHQUFpRywwR0FBMEcsVUFBVTtBQUNwMUI7O0FBRUEsRUFBRTtBQUNGLDRCQUE0QixnQ0FBbUI7O0FBRS9DLGdFQUFnRSxrQ0FBa0MsZ0NBQW1CLElBQUksZ0NBQW1CLElBQUksZ0NBQW1CLG1EQUFtRCxhQUFhLDhCQUE4QiwwSkFBMEosdUVBQXVFLGlHQUFpRyxZQUFZO0FBQy9rQjs7QUFFQSxFQUFFO0FBQ0YsNEJBQTRCLGdDQUFtQjs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixnQ0FBbUI7O0FBRW5DLGtCQUFrQixnQ0FBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsV0FBVztBQUN4QixhQUFhLFdBQVc7QUFDeEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLGdCQUFnQixnQ0FBbUI7QUFDcEM7O0FBRUEsRUFBRTtBQUNGLDRCQUE0QixnQ0FBbUI7O0FBRS9DLGdFQUFnRSxrQ0FBa0MsZ0NBQW1CLElBQUksZ0NBQW1CLG9EQUFvRCxhQUFhLGtDQUFrQyxpU0FBaVMsK0VBQStFLGlDQUFpQyxJQUFJLEtBQUssa0JBQWtCLHNCQUFzQiwyQ0FBMkMsdURBQXVELGVBQWUsMEJBQTBCLGlCQUFpQixnRUFBZ0UsNkRBQTZELGVBQWUsK0JBQStCLGlCQUFpQixpSUFBaUksMkJBQTJCLDRDQUE0Qyx3R0FBd0csY0FBYztBQUN2MEM7O0FBRUEsRUFBRTtBQUNGLDRCQUE0QixnQ0FBbUI7O0FBRS9DO0FBQ0E7O0FBRUEsd0JBQXdCLDJFQUEyRSxrQ0FBa0Msd0JBQXdCLE9BQU8sa0NBQWtDLG1JQUFtSTs7QUFFelU7QUFDQSxnQkFBZ0IsZ0NBQW1COztBQUVuQyx1QkFBdUIsZ0NBQW1CO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QiwyQkFBMkI7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQixnQ0FBbUI7QUFDcEM7O0FBRUEsRUFBRTtBQUNGLDRCQUE0QixnQ0FBbUI7O0FBRS9DLGdFQUFnRSxrQ0FBa0MsZ0NBQW1CLElBQUksZ0NBQW1CLElBQUksZ0NBQW1CLG1EQUFtRCxhQUFhLHlCQUF5Qiw4SkFBOEosNkRBQTZELHFIQUFxSCxPQUFPO0FBQ25sQjs7QUFFQSxFQUFFO0FBQ0YsNEJBQTRCLGdDQUFtQjs7QUFFL0MsZ0VBQWdFLGtDQUFrQyxnQ0FBbUIsSUFBSSxnQ0FBbUIsS0FBSyxnQ0FBbUIsS0FBSyxnQ0FBbUIsS0FBSyxnQ0FBbUIsb0RBQW9ELGVBQWUscVpBQXFaLG1DQUFtQyw2SUFBNkkscUNBQXFDLHdJQUF3SSxpQ0FBaUMsd0pBQXdKLEdBQUc7QUFDcnNDOztBQUVBLEVBQUU7QUFDRiw0QkFBNEIsZ0NBQW1COztBQUUvQyxnRUFBZ0Usa0NBQWtDLGdDQUFtQixJQUFJLGdDQUFtQixLQUFLLGdDQUFtQixtREFBbUQsYUFBYSx3SkFBd0oscUVBQXFFLHVGQUF1Rix1RUFBdUUseUJBQXlCLG1DQUFtQyxrQkFBa0IscUNBQXFDLCtJQUErSSx5Q0FBeUMsd0hBQXdILFFBQVE7QUFDMWdDOztBQUVBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRiw0QkFBNEIsZ0NBQW1COztBQUUvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMsZ0JBQWdCLGdDQUFtQjtBQUNwQzs7QUFFQSxFQUFFO0FBQ0YsNEJBQTRCLGdDQUFtQjs7QUFFL0MsZ0VBQWdFLGtDQUFrQyxnQ0FBbUIsSUFBSSxnQ0FBbUIsb0RBQW9ELGtCQUFrQixxSEFBcUgsU0FBUywyREFBMkQsU0FBUyx3REFBd0QsUUFBUSxpS0FBaUssbUlBQW1JLDhLQUE4Syw0R0FBNEcscURBQXFELGVBQWUsZ0RBQWdELGlCQUFpQixRQUFRLEVBQUUsb0NBQW9DLGlDQUFpQyw4Q0FBOEMsd0NBQXdDLDZFQUE2RSwrQkFBK0IscUNBQXFDLGdCQUFnQixnQ0FBZ0MsNEJBQTRCLE9BQU8sNkNBQTZDLCtDQUErQyxrQkFBa0IscURBQXFELGlCQUFpQixvQ0FBb0MseUJBQXlCLDBFQUEwRSxtQkFBbUIsZUFBZSw2Q0FBNkMsZ0RBQWdELCtGQUErRixXQUFXLFdBQVcseUNBQXlDLDJHQUEyRyxrREFBa0QsZUFBZSx3REFBd0Qsd0JBQXdCLHlEQUF5RCxlQUFlLHVCQUF1QixpQkFBaUIsbUJBQW1CLDhEQUE4RCxlQUFlLDRCQUE0QixpQkFBaUIsb0dBQW9HLDJEQUEyRCxlQUFlLHlCQUF5QixpQkFBaUIsUUFBUSxrREFBa0QsbURBQW1ELE1BQU0sZ0RBQWdELE1BQU0saURBQWlELE1BQU0sb0JBQW9CLDBDQUEwQyw2TEFBNkwsb0dBQW9HLGdEQUFnRCxTQUFTLHdCQUF3QixTQUFTLHdEQUF3RCwyRkFBMkY7QUFDcm5IOztBQUVBLEVBQUU7QUFDRiw0QkFBNEIsZ0NBQW1COztBQUUvQyxnRUFBZ0Usa0NBQWtDLGdDQUFtQixJQUFJLGdDQUFtQixJQUFJLGdDQUFtQixJQUFJLGdDQUFtQixtREFBbUQsYUFBYSw2QkFBNkIsc01BQXNNLCtFQUErRSxlQUFlLHVCQUF1QixpQkFBaUIsb0NBQW9DLGlEQUFpRCxlQUFlLHVCQUF1QixpQkFBaUIsb0NBQW9DLHlDQUF5QyxrRkFBa0Ysc0NBQXNDLHFIQUFxSCxTQUFTO0FBQ2xqQzs7QUFFQSxFQUFFO0FBQ0YsNEJBQTRCLGdDQUFtQjs7QUFFL0MsZ0VBQWdFLGtDQUFrQyxnQ0FBbUIsSUFBSSxnQ0FBbUIsSUFBSSxnQ0FBbUIsb0RBQW9ELGFBQWEsbUNBQW1DLHdFQUF3RSxpSkFBaUosMkRBQTJELGtGQUFrRiwyREFBMkQsZUFBZSwwQ0FBMEMsd0JBQXdCLGlCQUFpQix5QkFBeUIsa0VBQWtFLDBEQUEwRCxrRUFBa0UsOENBQThDLHVDQUF1QyxrRUFBa0Usa0VBQWtFLGlEQUFpRCxnREFBZ0QsdUVBQXVFLG9CQUFvQiw0QkFBNEIsaUZBQWlGLGtDQUFrQyx5QkFBeUIsc0RBQXNELDhLQUE4Syw0REFBNEQsOEhBQThILDREQUE0RCwwQ0FBMEMsa0VBQWtFLHVCQUF1QixrQ0FBa0MsV0FBVyxpQ0FBaUMsMERBQTBELDJEQUEyRCxxQ0FBcUMsWUFBWSxXQUFXLEtBQUsseUJBQXlCLDRDQUE0QyxZQUFZLDhEQUE4RCw0RkFBNEYscURBQXFELG9CQUFvQixvRUFBb0UsK0RBQStELHFJQUFxSSxLQUFLLDJCQUEyQix1TkFBdU4sWUFBWSxxRUFBcUUsbUVBQW1FLDBFQUEwRSx3RUFBd0Usc0RBQXNELDJCQUEyQixxREFBcUQsZ0NBQWdDLHVEQUF1RCxvQkFBb0IsbUVBQW1FLDRCQUE0QiwrQ0FBK0MsdUNBQXVDLDRGQUE0RixpVUFBaVUsU0FBUyx1SUFBdUksa0NBQWtDLG1FQUFtRSwyQkFBMkIsd0VBQXdFLGdFQUFnRSxnRUFBZ0UsZUFBZSx3QkFBd0Isb0JBQW9CLHVFQUF1RSx3REFBd0QsK0NBQStDLG9IQUFvSCxrQkFBa0I7QUFDbG1LOztBQUVBLEVBQUU7QUFDRiw0QkFBNEIsZ0NBQW1COztBQUUvQztBQUNBOztBQUVBO0FBQ0EsZUFBZSxnQ0FBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LFlBQVksZ0NBQW1COztBQUUvQixhQUFhLGdDQUFtQjs7QUFFaEMsY0FBYyxnQ0FBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZUFBZTtBQUM5QjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHVDQUF1QztBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGNBQWM7QUFDdEM7O0FBRUEsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxTQUFTO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQSxnQkFB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QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGVBQWUsV0FBVztBQUMxQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGVBQWUsV0FBVztBQUMxQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOzs7QUFHQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixlQUFlLGFBQWE7QUFDNUI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsYUFBYTtBQUM1QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMsZ0JBQWdCLGlDQUFtQjtBQUNwQzs7QUFFQSxFQUFFO0FBQ0YsNEJBQTRCLGlDQUFtQjs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixpQ0FBbUI7O0FBRW5DLEVBQUUsaUNBQW1CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCLGlDQUFtQjtBQUNwQzs7QUFFQSxFQUFFO0FBQ0YsNEJBQTRCLGlDQUFtQjs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixp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Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxZQUFZO0FBQzFCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFlBQVk7QUFDMUI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxnQkFBZ0IsaUNBQW1CO0FBQ3BDOztBQUVBLEVBQUU7QUFDRiw0QkFBNEIsaUNBQW1COztBQUUvQztBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGlDQUFtQjs7QUFFbkMsZUFBZSxpQ0FBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGlCQUFpQixZQUFZO0FBQzdCLGlCQUFpQixZQUFZO0FBQzdCLGlCQUFpQixRQUFRO0FBQ3pCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUIsa0JBQWtCLFVBQVU7QUFDNUIsa0JBQWtCLFVBQVU7QUFDNUIsa0JBQWtCLFVBQVU7QUFDNUIsa0JBQWtCLGNBQWM7QUFDaEM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixhQUFhO0FBQy9COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLGdCQUFnQixpQ0FBbUI7QUFDcEM7O0FBRUEsRUFBRTtBQUNGLDRCQUE0QixpQ0FBbUI7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGlDQUFtQjs7QUFFbEMsZUFBZSxpQ0FBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQixpQ0FBbUI7QUFDcEM7O0FBRUEsRUFBRTtBQUNGLDRCQUE0QixpQ0FBbUI7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsaUNBQW1COztBQUV2QyxlQUFlLGlDQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsU0FBUztBQUN4Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0IsaUNBQW1CO0FBQ3BDOztBQUVBLEVBQUU7QUFDRiw0QkFBNEIsaUNBQW1COztBQUUvQztBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGlDQUFtQjs7QUFFbkMsY0FBYyxpQ0FBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLGNBQWM7QUFDNUI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUMsZ0JBQWdCLGlDQUFtQjtBQUNwQzs7QUFFQSxFQUFFO0FBQ0YsNEJBQTRCLGlDQUFtQjs7QUFFL0Msa0NBQWtDO0FBQ2xDOztBQUVBLGdCQUFnQixpQ0FBbUI7O0FBRW5DLGVBQWUsaUNBQW1COztBQUVsQyxvQkFBb0IsaUNBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxh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LGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtB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QUNwQzs7QUFFQSxFQUFFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3A1L2xpYi9hZGRvbnMvcDUuc291bmQuanM/N2NjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogW3A1LnNvdW5kXSAgVmVyc2lvbjogMC4zLjEyIC0gMjAyMC0wMS0wNiAqLyBcbiAvKipcbiAqICA8cD5wNS5zb3VuZCBleHRlbmRzIHA1IHdpdGggPGEgaHJlZj1cImh0dHA6Ly9jYW5pdXNlLmNvbS9hdWRpby1hcGlcIlxuICogIHRhcmdldD1cIl9ibGFua1wiPldlYiBBdWRpbzwvYT4gZnVuY3Rpb25hbGl0eSBpbmNsdWRpbmcgYXVkaW8gaW5wdXQsXG4gKiAgcGxheWJhY2ssIGFuYWx5c2lzIGFuZCBzeW50aGVzaXMuXG4gKiAgPC9wPlxuICogIDx1bD5cbiAqICA8bGk+PGEgaHJlZj1cIiMvcDUuU291bmRGaWxlXCI+PGI+cDUuU291bmRGaWxlPC9iPjwvYT46IExvYWQgYW5kIHBsYXkgc291bmQgZmlsZXMuPC9saT5cbiAqICA8bGk+PGEgaHJlZj1cIiMvcDUuQW1wbGl0dWRlXCI+PGI+cDUuQW1wbGl0dWRlPC9iPjwvYT46IEdldCB0aGUgY3VycmVudCB2b2x1bWUgb2YgYSBzb3VuZC48L2xpPlxuICogIDxsaT48YSBocmVmPVwiIy9wNS5BdWRpb0luXCI+PGI+cDUuQXVkaW9JbjwvYj48L2E+OiBHZXQgc291bmQgZnJvbSBhbiBpbnB1dCBzb3VyY2UsIHR5cGljYWxseVxuICogICAgYSBjb21wdXRlciBtaWNyb3Bob25lLjwvbGk+XG4gKiAgPGxpPjxhIGhyZWY9XCIjL3A1LkZGVFwiPjxiPnA1LkZGVDwvYj48L2E+OiBBbmFseXplIHRoZSBmcmVxdWVuY3kgb2Ygc291bmQuIFJldHVybnNcbiAqICAgIHJlc3VsdHMgZnJvbSB0aGUgZnJlcXVlbmN5IHNwZWN0cnVtIG9yIHRpbWUgZG9tYWluICh3YXZlZm9ybSkuPC9saT5cbiAqICA8bGk+PGEgaHJlZj1cIiMvcDUuT3NjaWxsYXRvclwiPjxiPnA1Lk9zY2lsbGF0b3I8L2I+PC9hPjogR2VuZXJhdGUgU2luZSxcbiAqICAgIFRyaWFuZ2xlLCBTcXVhcmUgYW5kIFNhd3Rvb3RoIHdhdmVmb3Jtcy4gQmFzZSBjbGFzcyBvZlxuICogICAgPGxpPjxhIGhyZWY9XCIjL3A1Lk5vaXNlXCI+cDUuTm9pc2U8L2E+IGFuZCA8YSBocmVmPVwiIy9wNS5QdWxzZVwiPnA1LlB1bHNlPC9hPi5cbiAqICAgIDwvbGk+XG4gKiAgPGxpPlxuICogICAgPGEgaHJlZj1cIiMvcDUuTW9ub1N5bnRoXCI+cDUuTW9ub1N5bnRoPC9hPiBhbmQgPGEgaHJlZj1cIiMvcDUuUG9seVN5bnRoXCI+cDUuUG9seVN5bnRoPC9hPjogUGxheSBtdXNpY2FsIG5vdGVzXG4gKiAgPC9saT5cbiAqICA8bGk+PGEgaHJlZj1cIiMvcDUuRW52ZWxvcGVcIj48Yj5wNS5FbnZlbG9wZTwvYj48L2E+OiBBbiBFbnZlbG9wZSBpcyBhIHNlcmllc1xuICogICAgb2YgZmFkZXMgb3ZlciB0aW1lLiBPZnRlbiB1c2VkIHRvIGNvbnRyb2wgYW4gb2JqZWN0J3NcbiAqICAgIG91dHB1dCBnYWluIGxldmVsIGFzIGFuIFwiQURTUiBFbnZlbG9wZVwiIChBdHRhY2ssIERlY2F5LFxuICogICAgU3VzdGFpbiwgUmVsZWFzZSkuIENhbiBhbHNvIG1vZHVsYXRlIG90aGVyIHBhcmFtZXRlcnMuPC9saT5cbiAqICA8bGk+PGEgaHJlZj1cIiMvcDUuRGVsYXlcIj48Yj5wNS5EZWxheTwvYj48L2E+OiBBIGRlbGF5IGVmZmVjdCB3aXRoXG4gKiAgICBwYXJhbWV0ZXJzIGZvciBmZWVkYmFjaywgZGVsYXlUaW1lLCBhbmQgbG93cGFzcyBmaWx0ZXIuPC9saT5cbiAqICA8bGk+PGEgaHJlZj1cIiMvcDUuRmlsdGVyXCI+PGI+cDUuRmlsdGVyPC9iPjwvYT46IEZpbHRlciB0aGUgZnJlcXVlbmN5IHJhbmdlIG9mIGFcbiAqICAgIHNvdW5kLlxuICogIDwvbGk+XG4gKiAgPGxpPjxhIGhyZWY9XCIjL3A1LlJldmVyYlwiPjxiPnA1LlJldmVyYjwvYj48L2E+OiBBZGQgcmV2ZXJiIHRvIGEgc291bmQgYnkgc3BlY2lmeWluZ1xuICogICAgZHVyYXRpb24gYW5kIGRlY2F5LiA8L2xpPlxuICogIDxiPjxsaT48YSBocmVmPVwiIy9wNS5Db252b2x2ZXJcIj5wNS5Db252b2x2ZXI8L2E+OjwvYj4gRXh0ZW5kc1xuICogIDxhIGhyZWY9XCIjL3A1LlJldmVyYlwiPnA1LlJldmVyYjwvYT4gdG8gc2ltdWxhdGUgdGhlIHNvdW5kIG9mIHJlYWxcbiAqICAgIHBoeXNpY2FsIHNwYWNlcyB0aHJvdWdoIGNvbnZvbHV0aW9uLjwvbGk+XG4gKiAgPGI+PGxpPjxhIGhyZWY9XCIjL3A1LlNvdW5kUmVjb3JkZXJcIj5wNS5Tb3VuZFJlY29yZGVyPC9hPjwvYj46IFJlY29yZCBzb3VuZCBmb3IgcGxheWJhY2tcbiAqICAgIC8gc2F2ZSB0aGUgLndhdiBmaWxlLlxuICogIDxiPjxsaT48YSBocmVmPVwiIy9wNS5Tb3VuZExvb3BcIj5wNS5Tb3VuZExvb3A8L2E+LCA8YSBocmVmPVwiIy9wNS5QaHJhc2VcIj5wNS5QaHJhc2U8L2E+PC9iPiwgPGI+PGEgaHJlZj1cIiMvcDUuUGFydFwiPnA1LlBhcnQ8L2E+PC9iPiBhbmRcbiAqICA8Yj48YSBocmVmPVwiIy9wNS5TY29yZVwiPnA1LlNjb3JlPC9hPjwvYj46IENvbXBvc2UgbXVzaWNhbCBzZXF1ZW5jZXMuXG4gKiAgPC9saT5cbiAqICA8bGk+PGEgaHJlZj1cIiMvcDUvdXNlclN0YXJ0QXVkaW9cIj51c2VyU3RhcnRBdWRpbzwvYT46IEVuYWJsZSBhdWRpbyBpbiBhXG4gKiAgYnJvd3Nlci0gYW5kIHVzZXItZnJpZW5kbHkgd2F5LjwvYT5cbiAqICA8cD5wNS5zb3VuZCBpcyBvbiA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL3RoZXJld2FzYWd1eS9wNS5zb3VuZC9cIj5HaXRIdWI8L2E+LlxuICogIERvd25sb2FkIHRoZSBsYXRlc3QgdmVyc2lvblxuICogIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vdGhlcmV3YXNhZ3V5L3A1LnNvdW5kL2Jsb2IvbWFzdGVyL2xpYi9wNS5zb3VuZC5qc1wiPmhlcmU8L2E+LjwvcD5cbiAqXG4gKiAgQG1vZHVsZSBwNS5zb3VuZFxuICogIEBzdWJtb2R1bGUgcDUuc291bmRcbiAqICBAZm9yIHA1LnNvdW5kXG4gKiAgQG1haW5cbiAqL1xuXG4vKipcbiAqICBwNS5zb3VuZCBcbiAqICBodHRwczovL3A1anMub3JnL3JlZmVyZW5jZS8jL2xpYnJhcmllcy9wNS5zb3VuZFxuICpcbiAqICBGcm9tIHRoZSBQcm9jZXNzaW5nIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9jZXNzaW5nL3A1LmpzLXNvdW5kL2dyYXBocy9jb250cmlidXRvcnNcbiAqXG4gKiAgTUlUIExpY2Vuc2UgKE1JVClcbiAqICBodHRwczovL2dpdGh1Yi5jb20vcHJvY2Vzc2luZy9wNS5qcy1zb3VuZC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogIFNvbWUgb2YgdGhlIG1hbnkgYXVkaW8gbGlicmFyaWVzICYgcmVzb3VyY2VzIHRoYXQgaW5zcGlyZSBwNS5zb3VuZDpcbiAqICAgLSBUT05FLmpzIChjKSBZb3RhbSBNYW5uLiBMaWNlbnNlZCB1bmRlciBUaGUgTUlUIExpY2Vuc2UgKE1JVCkuIGh0dHBzOi8vZ2l0aHViLmNvbS9UT05Fbm9UT05FL1RvbmUuanNcbiAqICAgLSBidXp6LmpzIChjKSBKYXkgU2FsdmF0LiBMaWNlbnNlZCB1bmRlciBUaGUgTUlUIExpY2Vuc2UgKE1JVCkuIGh0dHA6Ly9idXp6LmpheXNhbHZhdC5jb20vXG4gKiAgIC0gQm9yaXMgU211cyBXZWIgQXVkaW8gQVBJIGJvb2ssIDIwMTMuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqICAgLSB3YXZlc3VyZmVyLmpzIGh0dHBzOi8vZ2l0aHViLmNvbS9rYXRzcGF1Z2gvd2F2ZXN1cmZlci5qc1xuICogICAtIFdlYiBBdWRpbyBDb21wb25lbnRzIGJ5IEpvcmRhbiBTYW50ZWxsIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWItYXVkaW8tY29tcG9uZW50c1xuICogICAtIFdpbG0gVGhvYmVuJ3MgU291bmQgbGlicmFyeSBmb3IgUHJvY2Vzc2luZyBodHRwczovL2dpdGh1Yi5jb20vcHJvY2Vzc2luZy9wcm9jZXNzaW5nL3RyZWUvbWFzdGVyL2phdmEvbGlicmFyaWVzL3NvdW5kXG4gKlxuICogICBXZWIgQXVkaW8gQVBJOiBodHRwOi8vdzMub3JnL1RSL3dlYmF1ZGlvL1xuICovXG5cbiAoZnVuY3Rpb24obW9kdWxlcykgeyBcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuIFx0XHRtb2R1bGUubCA9IHRydWU7XG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDMxKTtcbiB9KVxuIChbXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGEodCxlKXt0aGlzLmlzVW5kZWYodCl8fDE9PT10P3RoaXMuaW5wdXQ9dGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKToxPHQmJih0aGlzLmlucHV0PW5ldyBBcnJheSh0KSksdGhpcy5pc1VuZGVmKGUpfHwxPT09ZT90aGlzLm91dHB1dD10aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpOjE8ZSYmKHRoaXMub3V0cHV0PW5ldyBBcnJheSh0KSl9dmFyIGU7cmV0dXJuIGEucHJvdG90eXBlLnNldD1mdW5jdGlvbih0LGUsbil7aWYodGhpcy5pc09iamVjdCh0KSluPWU7ZWxzZSBpZih0aGlzLmlzU3RyaW5nKHQpKXt2YXIgbz17fTtvW3RdPWUsdD1vfXQ6Zm9yKHZhciBpIGluIHQpe2U9dFtpXTt2YXIgcj10aGlzO2lmKC0xIT09aS5pbmRleE9mKFwiLlwiKSl7Zm9yKHZhciBzPWkuc3BsaXQoXCIuXCIpLHU9MDt1PHMubGVuZ3RoLTE7dSsrKWlmKChyPXJbc1t1XV0paW5zdGFuY2VvZiBhKXtzLnNwbGljZSgwLHUrMSk7dmFyIHA9cy5qb2luKFwiLlwiKTtyLnNldChwLGUpO2NvbnRpbnVlIHR9aT1zW3MubGVuZ3RoLTFdfXZhciBjPXJbaV07dGhpcy5pc1VuZGVmKGMpfHwoYS5TaWduYWwmJmMgaW5zdGFuY2VvZiBhLlNpZ25hbHx8YS5QYXJhbSYmYyBpbnN0YW5jZW9mIGEuUGFyYW0/Yy52YWx1ZSE9PWUmJih0aGlzLmlzVW5kZWYobik/Yy52YWx1ZT1lOmMucmFtcFRvKGUsbikpOmMgaW5zdGFuY2VvZiBBdWRpb1BhcmFtP2MudmFsdWUhPT1lJiYoYy52YWx1ZT1lKTpjIGluc3RhbmNlb2YgYT9jLnNldChlKTpjIT09ZSYmKHJbaV09ZSkpfXJldHVybiB0aGlzfSxhLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7dGhpcy5pc1VuZGVmKHQpP3Q9dGhpcy5fY29sbGVjdERlZmF1bHRzKHRoaXMuY29uc3RydWN0b3IpOnRoaXMuaXNTdHJpbmcodCkmJih0PVt0XSk7Zm9yKHZhciBlPXt9LG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXSxpPXRoaXMscj1lO2lmKC0xIT09by5pbmRleE9mKFwiLlwiKSl7Zm9yKHZhciBzPW8uc3BsaXQoXCIuXCIpLHU9MDt1PHMubGVuZ3RoLTE7dSsrKXt2YXIgcD1zW3VdO3JbcF09cltwXXx8e30scj1yW3BdLGk9aVtwXX1vPXNbcy5sZW5ndGgtMV19dmFyIGM9aVtvXTt0aGlzLmlzT2JqZWN0KHRbb10pP3Jbb109Yy5nZXQoKTphLlNpZ25hbCYmYyBpbnN0YW5jZW9mIGEuU2lnbmFsP3Jbb109Yy52YWx1ZTphLlBhcmFtJiZjIGluc3RhbmNlb2YgYS5QYXJhbT9yW29dPWMudmFsdWU6YyBpbnN0YW5jZW9mIEF1ZGlvUGFyYW0/cltvXT1jLnZhbHVlOmMgaW5zdGFuY2VvZiBhP3Jbb109Yy5nZXQoKTp0aGlzLmlzRnVuY3Rpb24oYyl8fHRoaXMuaXNVbmRlZihjKXx8KHJbb109Yyl9cmV0dXJuIGV9LGEucHJvdG90eXBlLl9jb2xsZWN0RGVmYXVsdHM9ZnVuY3Rpb24odCl7dmFyIGU9W107aWYodGhpcy5pc1VuZGVmKHQuZGVmYXVsdHMpfHwoZT1PYmplY3Qua2V5cyh0LmRlZmF1bHRzKSksIXRoaXMuaXNVbmRlZih0Ll9zdXBlcikpZm9yKHZhciBuPXRoaXMuX2NvbGxlY3REZWZhdWx0cyh0Ll9zdXBlciksbz0wO288bi5sZW5ndGg7bysrKS0xPT09ZS5pbmRleE9mKG5bb10pJiZlLnB1c2gobltvXSk7cmV0dXJuIGV9LGEucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIGEpe3ZhciBlPXRbMF0ubWF0Y2goL15bQS1aXSQvKSxuPWFbdF09PT10aGlzLmNvbnN0cnVjdG9yO2lmKHRoaXMuaXNGdW5jdGlvbihhW3RdKSYmZSYmbilyZXR1cm4gdH1yZXR1cm5cIlRvbmVcIn0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGEucHJvdG90eXBlLFwibnVtYmVyT2ZJbnB1dHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5wdXQ/dGhpcy5pc0FycmF5KHRoaXMuaW5wdXQpP3RoaXMuaW5wdXQubGVuZ3RoOjE6MH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYS5wcm90b3R5cGUsXCJudW1iZXJPZk91dHB1dHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3V0cHV0P3RoaXMuaXNBcnJheSh0aGlzLm91dHB1dCk/dGhpcy5vdXRwdXQubGVuZ3RoOjE6MH19KSxhLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNVbmRlZih0aGlzLmlucHV0KXx8KHRoaXMuaW5wdXQgaW5zdGFuY2VvZiBBdWRpb05vZGUmJnRoaXMuaW5wdXQuZGlzY29ubmVjdCgpLHRoaXMuaW5wdXQ9bnVsbCksdGhpcy5pc1VuZGVmKHRoaXMub3V0cHV0KXx8KHRoaXMub3V0cHV0IGluc3RhbmNlb2YgQXVkaW9Ob2RlJiZ0aGlzLm91dHB1dC5kaXNjb25uZWN0KCksdGhpcy5vdXRwdXQ9bnVsbCksdGhpc30sYS5wcm90b3R5cGUuY29ubmVjdD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5vdXRwdXQpPyhlPXRoaXMuZGVmYXVsdEFyZyhlLDApLHRoaXMub3V0cHV0W2VdLmNvbm5lY3QodCwwLG4pKTp0aGlzLm91dHB1dC5jb25uZWN0KHQsZSxuKSx0aGlzfSxhLnByb3RvdHlwZS5kaXNjb25uZWN0PWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmlzQXJyYXkodGhpcy5vdXRwdXQpP3RoaXMuaXNOdW1iZXIodCk/dGhpcy5vdXRwdXRbdF0uZGlzY29ubmVjdCgpOihlPXRoaXMuZGVmYXVsdEFyZyhlLDApLHRoaXMub3V0cHV0W2VdLmRpc2Nvbm5lY3QodCwwLG4pKTp0aGlzLm91dHB1dC5kaXNjb25uZWN0LmFwcGx5KHRoaXMub3V0cHV0LGFyZ3VtZW50cyl9LGEucHJvdG90eXBlLmNvbm5lY3RTZXJpZXM9ZnVuY3Rpb24oKXtpZigxPGFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7dmFyIG49YXJndW1lbnRzW2VdO3QuY29ubmVjdChuKSx0PW59cmV0dXJuIHRoaXN9LGEucHJvdG90eXBlLmNoYWluPWZ1bmN0aW9uKCl7aWYoMDxhcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgdD10aGlzLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgbj1hcmd1bWVudHNbZV07dC5jb25uZWN0KG4pLHQ9bn1yZXR1cm4gdGhpc30sYS5wcm90b3R5cGUuZmFuPWZ1bmN0aW9uKCl7aWYoMDxhcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspdGhpcy5jb25uZWN0KGFyZ3VtZW50c1t0XSk7cmV0dXJuIHRoaXN9LEF1ZGlvTm9kZS5wcm90b3R5cGUuY2hhaW49YS5wcm90b3R5cGUuY2hhaW4sQXVkaW9Ob2RlLnByb3RvdHlwZS5mYW49YS5wcm90b3R5cGUuZmFuLGEucHJvdG90eXBlLmRlZmF1bHRBcmc9ZnVuY3Rpb24odCxlKXtpZih0aGlzLmlzT2JqZWN0KHQpJiZ0aGlzLmlzT2JqZWN0KGUpKXt2YXIgbj17fTtmb3IodmFyIG8gaW4gdCluW29dPXRoaXMuZGVmYXVsdEFyZyhlW29dLHRbb10pO2Zvcih2YXIgaSBpbiBlKW5baV09dGhpcy5kZWZhdWx0QXJnKHRbaV0sZVtpXSk7cmV0dXJuIG59cmV0dXJuIHRoaXMuaXNVbmRlZih0KT9lOnR9LGEucHJvdG90eXBlLm9wdGlvbnNPYmplY3Q9ZnVuY3Rpb24odCxlLG4pe3ZhciBvPXt9O2lmKDE9PT10Lmxlbmd0aCYmdGhpcy5pc09iamVjdCh0WzBdKSlvPXRbMF07ZWxzZSBmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKylvW2VbaV1dPXRbaV07cmV0dXJuIHRoaXMuaXNVbmRlZihuKT9vOnRoaXMuZGVmYXVsdEFyZyhvLG4pfSxhLnByb3RvdHlwZS5pc1VuZGVmPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10fSxhLnByb3RvdHlwZS5pc0Z1bmN0aW9uPWZ1bmN0aW9uKHQpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHR9LGEucHJvdG90eXBlLmlzTnVtYmVyPWZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0fSxhLnByb3RvdHlwZS5pc09iamVjdD1mdW5jdGlvbih0KXtyZXR1cm5cIltvYmplY3QgT2JqZWN0XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpJiZ0LmNvbnN0cnVjdG9yPT09T2JqZWN0fSxhLnByb3RvdHlwZS5pc0Jvb2xlYW49ZnVuY3Rpb24odCl7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiB0fSxhLnByb3RvdHlwZS5pc0FycmF5PWZ1bmN0aW9uKHQpe3JldHVybiBBcnJheS5pc0FycmF5KHQpfSxhLnByb3RvdHlwZS5pc1N0cmluZz1mdW5jdGlvbih0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdH0sYS5ub09wPWZ1bmN0aW9uKCl7fSxhLnByb3RvdHlwZS5fcmVhZE9ubHk9ZnVuY3Rpb24odCl7aWYoQXJyYXkuaXNBcnJheSh0KSlmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKyl0aGlzLl9yZWFkT25seSh0W2VdKTtlbHNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLHQse3dyaXRhYmxlOiExLGVudW1lcmFibGU6ITB9KX0sYS5wcm90b3R5cGUuX3dyaXRhYmxlPWZ1bmN0aW9uKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpZm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKyspdGhpcy5fd3JpdGFibGUodFtlXSk7ZWxzZSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyx0LHt3cml0YWJsZTohMH0pfSxhLlN0YXRlPXtTdGFydGVkOlwic3RhcnRlZFwiLFN0b3BwZWQ6XCJzdG9wcGVkXCIsUGF1c2VkOlwicGF1c2VkXCJ9LGEucHJvdG90eXBlLmVxdWFsUG93ZXJTY2FsZT1mdW5jdGlvbih0KXt2YXIgZT0uNSpNYXRoLlBJO3JldHVybiBNYXRoLnNpbih0KmUpfSxhLnByb3RvdHlwZS5kYlRvR2Fpbj1mdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5wb3coMix0LzYpfSxhLnByb3RvdHlwZS5nYWluVG9EYj1mdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5sb2codCkvTWF0aC5MTjEwKjIwfSxhLnByb3RvdHlwZS5pbnRlcnZhbFRvRnJlcXVlbmN5UmF0aW89ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGgucG93KDIsdC8xMil9LGEucHJvdG90eXBlLm5vdz1mdW5jdGlvbigpe3JldHVybiBhLmNvbnRleHQubm93KCl9LGEubm93PWZ1bmN0aW9uKCl7cmV0dXJuIGEuY29udGV4dC5ub3coKX0sYS5leHRlbmQ9ZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7fWEucHJvdG90eXBlLmlzVW5kZWYoZSkmJihlPWEpLG4ucHJvdG90eXBlPWUucHJvdG90eXBlLHQucHJvdG90eXBlPW5ldyBuLCh0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10KS5fc3VwZXI9ZX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsXCJjb250ZXh0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiBlfSxzZXQ6ZnVuY3Rpb24odCl7ZT1hLkNvbnRleHQmJnQgaW5zdGFuY2VvZiBhLkNvbnRleHQ/dDpuZXcgYS5Db250ZXh0KHQpLGEuQ29udGV4dCYmYS5Db250ZXh0LmVtaXQoXCJpbml0XCIsZSl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGEucHJvdG90eXBlLFwiY29udGV4dFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYS5jb250ZXh0fX0pLGEuc2V0Q29udGV4dD1mdW5jdGlvbih0KXthLmNvbnRleHQ9dH0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGEucHJvdG90eXBlLFwiYmxvY2tUaW1lXCIse2dldDpmdW5jdGlvbigpe3JldHVybiAxMjgvdGhpcy5jb250ZXh0LnNhbXBsZVJhdGV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGEucHJvdG90eXBlLFwic2FtcGxlVGltZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gMS90aGlzLmNvbnRleHQuc2FtcGxlUmF0ZX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcInN1cHBvcnRlZFwiLHtnZXQ6ZnVuY3Rpb24oKXt2YXIgdD13aW5kb3cuaGFzT3duUHJvcGVydHkoXCJBdWRpb0NvbnRleHRcIil8fHdpbmRvdy5oYXNPd25Qcm9wZXJ0eShcIndlYmtpdEF1ZGlvQ29udGV4dFwiKSxlPXdpbmRvdy5oYXNPd25Qcm9wZXJ0eShcIlByb21pc2VcIiksbj13aW5kb3cuaGFzT3duUHJvcGVydHkoXCJXb3JrZXJcIik7cmV0dXJuIHQmJmUmJm59fSksYS52ZXJzaW9uPVwicjEwXCIsd2luZG93LlRPTkVfU0lMRU5DRV9WRVJTSU9OX0xPR0dJTkd8fGNvbnNvbGUubG9nKFwiJWMgKiBUb25lLmpzIFwiK2EudmVyc2lvbitcIiAqIFwiLFwiYmFja2dyb3VuZDogIzAwMDsgY29sb3I6ICNmZmZcIiksYX0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMTcpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKGF1ZGlvY29udGV4dCkge1xuICB2YXIgTWFzdGVyID0gZnVuY3Rpb24gTWFzdGVyKCkge1xuICAgIHRoaXMuaW5wdXQgPSBhdWRpb2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgIHRoaXMub3V0cHV0ID0gYXVkaW9jb250ZXh0LmNyZWF0ZUdhaW4oKTsgXG5cbiAgICB0aGlzLmxpbWl0ZXIgPSBhdWRpb2NvbnRleHQuY3JlYXRlRHluYW1pY3NDb21wcmVzc29yKCk7XG4gICAgdGhpcy5saW1pdGVyLnRocmVzaG9sZC52YWx1ZSA9IC0zO1xuICAgIHRoaXMubGltaXRlci5yYXRpby52YWx1ZSA9IDIwO1xuICAgIHRoaXMubGltaXRlci5rbmVlLnZhbHVlID0gMTtcbiAgICB0aGlzLmF1ZGlvY29udGV4dCA9IGF1ZGlvY29udGV4dDtcbiAgICB0aGlzLm91dHB1dC5kaXNjb25uZWN0KCk7IFxuXG4gICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMubGltaXRlcik7IFxuXG4gICAgdGhpcy5saW1pdGVyLmNvbm5lY3QodGhpcy5vdXRwdXQpOyBcblxuICAgIHRoaXMubWV0ZXIgPSBhdWRpb2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgIHRoaXMuZmZ0TWV0ZXIgPSBhdWRpb2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgIHRoaXMub3V0cHV0LmNvbm5lY3QodGhpcy5tZXRlcik7XG4gICAgdGhpcy5vdXRwdXQuY29ubmVjdCh0aGlzLmZmdE1ldGVyKTsgXG5cbiAgICB0aGlzLm91dHB1dC5jb25uZWN0KHRoaXMuYXVkaW9jb250ZXh0LmRlc3RpbmF0aW9uKTsgXG5cbiAgICB0aGlzLnNvdW5kQXJyYXkgPSBbXTsgXG5cbiAgICB0aGlzLnBhcnRzID0gW107IFxuXG4gICAgdGhpcy5leHRlbnNpb25zID0gW107XG4gIH07IFxuXG5cbiAgdmFyIHA1c291bmQgPSBuZXcgTWFzdGVyKCk7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgbWFzdGVyIGFtcGxpdHVkZSAodm9sdW1lKSBmb3Igc291bmRcbiAgICogaW4gdGhpcyBza2V0Y2guXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0TWFzdGVyVm9sdW1lXG4gICAqIEByZXR1cm4ge051bWJlcn0gTWFzdGVyIGFtcGxpdHVkZSAodm9sdW1lKSBmb3Igc291bmQgaW4gdGhpcyBza2V0Y2guXG4gICAqICAgICAgICAgICAgICAgICAgU2hvdWxkIGJlIGJldHdlZW4gMC4wIChzaWxlbmNlKSBhbmQgMS4wLlxuICAgKi9cblxuICBwNS5wcm90b3R5cGUuZ2V0TWFzdGVyVm9sdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwNXNvdW5kLm91dHB1dC5nYWluLnZhbHVlO1xuICB9O1xuICAvKipcbiAgICogIDxwPlNjYWxlIHRoZSBvdXRwdXQgb2YgYWxsIHNvdW5kIGluIHRoaXMgc2tldGNoPC9wPlxuICAgKiAgU2NhbGVkIGJldHdlZW4gMC4wIChzaWxlbmNlKSBhbmQgMS4wIChmdWxsIHZvbHVtZSkuXG4gICAqICAxLjAgaXMgdGhlIG1heGltdW0gYW1wbGl0dWRlIG9mIGEgZGlnaXRhbCBzb3VuZCwgc28gbXVsdGlwbHlpbmdcbiAgICogIGJ5IGdyZWF0ZXIgdGhhbiAxLjAgbWF5IGNhdXNlIGRpZ2l0YWwgZGlzdG9ydGlvbi4gVG9cbiAgICogIGZhZGUsIHByb3ZpZGUgYSA8Y29kZT5yYW1wVGltZTwvY29kZT4gcGFyYW1ldGVyLiBGb3IgbW9yZVxuICAgKiAgY29tcGxleCBmYWRlcywgc2VlIHRoZSBFbnZlbG9wZSBjbGFzcy5cbiAgICpcbiAgICogIEFsdGVybmF0ZWx5LCB5b3UgY2FuIHBhc3MgaW4gYSBzaWduYWwgc291cmNlIHN1Y2ggYXMgYW5cbiAgICogIG9zY2lsbGF0b3IgdG8gbW9kdWxhdGUgdGhlIGFtcGxpdHVkZSB3aXRoIGFuIGF1ZGlvIHNpZ25hbC5cbiAgICpcbiAgICogIDxwPjxiPkhvdyBUaGlzIFdvcmtzPC9iPjogV2hlbiB5b3UgbG9hZCB0aGUgcDUuc291bmQgbW9kdWxlLCBpdFxuICAgKiAgY3JlYXRlcyBhIHNpbmdsZSBpbnN0YW5jZSBvZiBwNXNvdW5kLiBBbGwgc291bmQgb2JqZWN0cyBpbiB0aGlzXG4gICAqICBtb2R1bGUgb3V0cHV0IHRvIHA1c291bmQgYmVmb3JlIHJlYWNoaW5nIHlvdXIgY29tcHV0ZXIncyBvdXRwdXQuXG4gICAqICBTbyBpZiB5b3UgY2hhbmdlIHRoZSBhbXBsaXR1ZGUgb2YgcDVzb3VuZCwgaXQgaW1wYWN0cyBhbGwgb2YgdGhlXG4gICAqICBzb3VuZCBpbiB0aGlzIG1vZHVsZS48L3A+XG4gICAqXG4gICAqICA8cD5JZiBubyB2YWx1ZSBpcyBwcm92aWRlZCwgcmV0dXJucyBhIFdlYiBBdWRpbyBBUEkgR2FpbiBOb2RlPC9wPlxuICAgKlxuICAgKiAgQG1ldGhvZCAgbWFzdGVyVm9sdW1lXG4gICAqICBAcGFyYW0ge051bWJlcnxPYmplY3R9IHZvbHVtZSAgVm9sdW1lIChhbXBsaXR1ZGUpIGJldHdlZW4gMC4wXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCAxLjAgb3IgbW9kdWxhdGluZyBzaWduYWwvb3NjaWxsYXRvclxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtyYW1wVGltZV0gIEZhZGUgZm9yIHQgc2Vjb25kc1xuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFt0aW1lRnJvbU5vd10gIFNjaGVkdWxlIHRoaXMgZXZlbnQgdG8gaGFwcGVuIGF0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCBzZWNvbmRzIGluIHRoZSBmdXR1cmVcbiAgICovXG5cblxuICBwNS5wcm90b3R5cGUubWFzdGVyVm9sdW1lID0gZnVuY3Rpb24gKHZvbCwgcmFtcFRpbWUsIHRGcm9tTm93KSB7XG4gICAgaWYgKHR5cGVvZiB2b2wgPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgcmFtcFRpbWUgPSByYW1wVGltZSB8fCAwO1xuICAgICAgdmFyIHRGcm9tTm93ID0gdEZyb21Ob3cgfHwgMDtcbiAgICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICAgIHZhciBjdXJyZW50Vm9sID0gcDVzb3VuZC5vdXRwdXQuZ2Fpbi52YWx1ZTtcbiAgICAgIHA1c291bmQub3V0cHV0LmdhaW4uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKG5vdyArIHRGcm9tTm93KTtcbiAgICAgIHA1c291bmQub3V0cHV0LmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoY3VycmVudFZvbCwgbm93ICsgdEZyb21Ob3cpO1xuICAgICAgcDVzb3VuZC5vdXRwdXQuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh2b2wsIG5vdyArIHRGcm9tTm93ICsgcmFtcFRpbWUpO1xuICAgIH0gZWxzZSBpZiAodm9sKSB7XG4gICAgICB2b2wuY29ubmVjdChwNXNvdW5kLm91dHB1dC5nYWluKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHA1c291bmQub3V0cHV0LmdhaW47XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIGBwNS5zb3VuZE91dGAgaXMgdGhlIHA1LnNvdW5kIG1hc3RlciBvdXRwdXQuIEl0IHNlbmRzIG91dHB1dCB0b1xuICAgKiAgdGhlIGRlc3RpbmF0aW9uIG9mIHRoaXMgd2luZG93J3Mgd2ViIGF1ZGlvIGNvbnRleHQuIEl0IGNvbnRhaW5zXG4gICAqICBXZWIgQXVkaW8gQVBJIG5vZGVzIGluY2x1ZGluZyBhIGR5YW5taWNzQ29tcHJlc3NvciAoPGNvZGU+LmxpbWl0ZXI8L2NvZGU+KSxcbiAgICogIGFuZCBHYWluIE5vZGVzIGZvciA8Y29kZT4uaW5wdXQ8L2NvZGU+IGFuZCA8Y29kZT4ub3V0cHV0PC9jb2RlPi5cbiAgICpcbiAgICogIEBwcm9wZXJ0eSB7T2JqZWN0fSBzb3VuZE91dFxuICAgKi9cblxuXG4gIHA1LnByb3RvdHlwZS5zb3VuZE91dCA9IHA1LnNvdW5kT3V0ID0gcDVzb3VuZDsgXG5cbiAgcDUuc291bmRPdXQuX3NpbGVudE5vZGUgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHA1LnNvdW5kT3V0Ll9zaWxlbnROb2RlLmdhaW4udmFsdWUgPSAwO1xuXG4gIHA1LnNvdW5kT3V0Ll9zaWxlbnROb2RlLmNvbm5lY3QocDVzb3VuZC5hdWRpb2NvbnRleHQuZGVzdGluYXRpb24pO1xuXG4gIHJldHVybiBwNXNvdW5kO1xufSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9fd2VicGFja19yZXF1aXJlX18oNSksX193ZWJwYWNrX3JlcXVpcmVfXyg4KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDkpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24obil7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIG4uU2lnbmFsPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cyxbXCJ2YWx1ZVwiLFwidW5pdHNcIl0sbi5TaWduYWwuZGVmYXVsdHMpO3RoaXMub3V0cHV0PXRoaXMuX2dhaW49dGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKSx0LnBhcmFtPXRoaXMuX2dhaW4uZ2FpbixuLlBhcmFtLmNhbGwodGhpcyx0KSx0aGlzLmlucHV0PXRoaXMuX3BhcmFtPXRoaXMuX2dhaW4uZ2Fpbix0aGlzLmNvbnRleHQuZ2V0Q29uc3RhbnQoMSkuY2hhaW4odGhpcy5fZ2Fpbil9LG4uZXh0ZW5kKG4uU2lnbmFsLG4uUGFyYW0pLG4uU2lnbmFsLmRlZmF1bHRzPXt2YWx1ZTowLHVuaXRzOm4uVHlwZS5EZWZhdWx0LGNvbnZlcnQ6ITB9LG4uU2lnbmFsLnByb3RvdHlwZS5jb25uZWN0PW4uU2lnbmFsQmFzZS5wcm90b3R5cGUuY29ubmVjdCxuLlNpZ25hbC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3JldHVybiBuLlBhcmFtLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksdGhpcy5fcGFyYW09bnVsbCx0aGlzLl9nYWluLmRpc2Nvbm5lY3QoKSx0aGlzLl9nYWluPW51bGwsdGhpc30sbi5TaWduYWx9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXygyKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDkpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24oaSl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIGkuTXVsdGlwbHk9ZnVuY3Rpb24odCl7dGhpcy5jcmVhdGVJbnNPdXRzKDIsMCksdGhpcy5fbXVsdD10aGlzLmlucHV0WzBdPXRoaXMub3V0cHV0PW5ldyBpLkdhaW4sdGhpcy5fcGFyYW09dGhpcy5pbnB1dFsxXT10aGlzLm91dHB1dC5nYWluLHRoaXMuX3BhcmFtLnZhbHVlPXRoaXMuZGVmYXVsdEFyZyh0LDApfSxpLmV4dGVuZChpLk11bHRpcGx5LGkuU2lnbmFsKSxpLk11bHRpcGx5LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7cmV0dXJuIGkucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKSx0aGlzLl9tdWx0LmRpc3Bvc2UoKSx0aGlzLl9tdWx0PW51bGwsdGhpcy5fcGFyYW09bnVsbCx0aGlzfSxpLk11bHRpcGx5fSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgdmFyIHA1c291bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBDcm9zc0ZhZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcbiAgLyoqXG4gICAqIEVmZmVjdCBpcyBhIGJhc2UgY2xhc3MgZm9yIGF1ZGlvIGVmZmVjdHMgaW4gcDUuIDxicj5cbiAgICogVGhpcyBtb2R1bGUgaGFuZGxlcyB0aGUgbm9kZXMgYW5kIG1ldGhvZHMgdGhhdCBhcmVcbiAgICogY29tbW9uIGFuZCB1c2VmdWwgZm9yIGN1cnJlbnQgYW5kIGZ1dHVyZSBlZmZlY3RzLlxuICAgKlxuICAgKlxuICAgKiBUaGlzIGNsYXNzIGlzIGV4dGVuZGVkIGJ5IDxhIGhyZWY9XCIvcmVmZXJlbmNlLyMvcDUuRGlzdG9ydGlvblwiPnA1LkRpc3RvcnRpb248L2E+LFxuICAgKiA8YSBocmVmPVwiL3JlZmVyZW5jZS8jL3A1LkNvbXByZXNzb3JcIj5wNS5Db21wcmVzc29yPC9hPixcbiAgICogPGEgaHJlZj1cIi9yZWZlcmVuY2UvIy9wNS5EZWxheVwiPnA1LkRlbGF5PC9hPixcbiAgICogPGEgaHJlZj1cIi9yZWZlcmVuY2UvIy9wNS5GaWx0ZXJcIj5wNS5GaWx0ZXI8L2E+LFxuICAgKiA8YSBocmVmPVwiL3JlZmVyZW5jZS8jL3A1LlJldmVyYlwiPnA1LlJldmVyYjwvYT4uXG4gICAqXG4gICAqIEBjbGFzcyAgcDUuRWZmZWN0XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2FjXSAgIFJlZmVyZW5jZSB0byB0aGUgYXVkaW8gY29udGV4dCBvZiB0aGUgcDUgb2JqZWN0XG4gICAqIEBwYXJhbSB7QXVkaW9Ob2RlfSBbaW5wdXRdICBHYWluIE5vZGUgZWZmZWN0IHdyYXBwZXJcbiAgICogQHBhcmFtIHtBdWRpb05vZGV9IFtvdXRwdXRdIEdhaW4gTm9kZSBlZmZlY3Qgd3JhcHBlclxuICAgKiBAcGFyYW0ge09iamVjdH0gW19kcnl3ZXRdICAgVG9uZS5KUyBDcm9zc0ZhZGUgbm9kZSAoZGVmYXVsdHMgdG8gdmFsdWU6IDEpXG4gICAqIEBwYXJhbSB7QXVkaW9Ob2RlfSBbd2V0XSAgRWZmZWN0cyB0aGF0IGV4dGVuZCB0aGlzIGNsYXNzIHNob3VsZCBjb25uZWN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gdGhlIHdldCBzaWduYWwgdG8gdGhpcyBnYWluIG5vZGUsIHNvIHRoYXQgZHJ5IGFuZCB3ZXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWxzIGFyZSBtaXhlZCBwcm9wZXJseS5cbiAgICovXG5cblxuICBwNS5FZmZlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hYyA9IHA1c291bmQuYXVkaW9jb250ZXh0O1xuICAgIHRoaXMuaW5wdXQgPSB0aGlzLmFjLmNyZWF0ZUdhaW4oKTtcbiAgICB0aGlzLm91dHB1dCA9IHRoaXMuYWMuY3JlYXRlR2FpbigpO1xuICAgIC8qKlxuICAgICAqXHRUaGUgcDUuRWZmZWN0IGNsYXNzIGlzIGJ1aWx0XG4gICAgICogXHR1c2luZyBUb25lLmpzIENyb3NzRmFkZVxuICAgICAqIFx0QHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuX2RyeXdldCA9IG5ldyBDcm9zc0ZhZGUoMSk7XG4gICAgLyoqXG4gICAgICpcdEluIGNsYXNzZXMgdGhhdCBleHRlbmRcbiAgICAgKlx0cDUuRWZmZWN0LCBjb25uZWN0IGVmZmVjdCBub2Rlc1xuICAgICAqXHR0byB0aGUgd2V0IHBhcmFtZXRlclxuICAgICAqL1xuXG4gICAgdGhpcy53ZXQgPSB0aGlzLmFjLmNyZWF0ZUdhaW4oKTtcbiAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fZHJ5d2V0LmEpO1xuICAgIHRoaXMud2V0LmNvbm5lY3QodGhpcy5fZHJ5d2V0LmIpO1xuXG4gICAgdGhpcy5fZHJ5d2V0LmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXG4gICAgdGhpcy5jb25uZWN0KCk7IFxuXG4gICAgcDVzb3VuZC5zb3VuZEFycmF5LnB1c2godGhpcyk7XG4gIH07XG4gIC8qKlxuICAgKiAgU2V0IHRoZSBvdXRwdXQgdm9sdW1lIG9mIHRoZSBmaWx0ZXIuXG4gICAqXG4gICAqICBAbWV0aG9kICBhbXBcbiAgICogIEBmb3IgcDUuRWZmZWN0XG4gICAqICBAcGFyYW0ge051bWJlcn0gW3ZvbF0gYW1wbGl0dWRlIGJldHdlZW4gMCBhbmQgMS4wXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3JhbXBUaW1lXSBjcmVhdGUgYSBmYWRlIHRoYXQgbGFzdHMgdW50aWwgcmFtcFRpbWVcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbdEZyb21Ob3ddIHNjaGVkdWxlIHRoaXMgZXZlbnQgdG8gaGFwcGVuIGluIHRGcm9tTm93IHNlY29uZHNcbiAgICovXG5cblxuICBwNS5FZmZlY3QucHJvdG90eXBlLmFtcCA9IGZ1bmN0aW9uICh2b2wsIHJhbXBUaW1lLCB0RnJvbU5vdykge1xuICAgIHZhciByYW1wVGltZSA9IHJhbXBUaW1lIHx8IDA7XG4gICAgdmFyIHRGcm9tTm93ID0gdEZyb21Ob3cgfHwgMDtcbiAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgdmFyIGN1cnJlbnRWb2wgPSB0aGlzLm91dHB1dC5nYWluLnZhbHVlO1xuICAgIHRoaXMub3V0cHV0LmdhaW4uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKG5vdyk7XG4gICAgdGhpcy5vdXRwdXQuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShjdXJyZW50Vm9sLCBub3cgKyB0RnJvbU5vdyArIC4wMDEpO1xuICAgIHRoaXMub3V0cHV0LmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodm9sLCBub3cgKyB0RnJvbU5vdyArIHJhbXBUaW1lICsgLjAwMSk7XG4gIH07XG4gIC8qKlxuICAgKiAgTGluayBlZmZlY3RzIHRvZ2V0aGVyIGluIGEgY2hhaW5cbiAgICogIEV4YW1wbGUgdXNhZ2U6IGZpbHRlci5jaGFpbihyZXZlcmIsIGRlbGF5LCBwYW5uZXIpO1xuICAgKiAgTWF5IGJlIHVzZWQgd2l0aCBhbiBvcGVuLWVuZGVkIG51bWJlciBvZiBhcmd1bWVudHNcbiAgICpcbiAgICogIEBtZXRob2QgY2hhaW5cbiAgICogIEBmb3IgcDUuRWZmZWN0XG4gICAqICBAcGFyYW0ge09iamVjdH0gW2FyZ3VtZW50c10gIENoYWluIHRvZ2V0aGVyIG11bHRpcGxlIHNvdW5kIG9iamVjdHNcbiAgICovXG5cblxuICBwNS5FZmZlY3QucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5jb25uZWN0KGFyZ3VtZW50c1swXSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGFyZ3VtZW50c1tpIC0gMV0uY29ubmVjdChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogIEFkanVzdCB0aGUgZHJ5L3dldCB2YWx1ZS5cbiAgICpcbiAgICogIEBtZXRob2QgZHJ5d2V0XG4gICAqICBAZm9yIHA1LkVmZmVjdFxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtmYWRlXSBUaGUgZGVzaXJlZCBkcnl3ZXQgdmFsdWUgKDAgLSAxLjApXG4gICAqL1xuXG5cbiAgcDUuRWZmZWN0LnByb3RvdHlwZS5kcnl3ZXQgPSBmdW5jdGlvbiAoZmFkZSkge1xuICAgIGlmICh0eXBlb2YgZmFkZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy5fZHJ5d2V0LmZhZGUudmFsdWUgPSBmYWRlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9kcnl3ZXQuZmFkZS52YWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqICBTZW5kIG91dHB1dCB0byBhIHA1LmpzLXNvdW5kLCBXZWIgQXVkaW8gTm9kZSwgb3IgdXNlIHNpZ25hbCB0b1xuICAgKiAgY29udHJvbCBhbiBBdWRpb1BhcmFtXG4gICAqXG4gICAqICBAbWV0aG9kIGNvbm5lY3RcbiAgICogIEBmb3IgcDUuRWZmZWN0XG4gICAqICBAcGFyYW0ge09iamVjdH0gdW5pdFxuICAgKi9cblxuXG4gIHA1LkVmZmVjdC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh1bml0KSB7XG4gICAgdmFyIHUgPSB1bml0IHx8IHA1LnNvdW5kT3V0LmlucHV0O1xuICAgIHRoaXMub3V0cHV0LmNvbm5lY3QodS5pbnB1dCA/IHUuaW5wdXQgOiB1KTtcbiAgfTtcbiAgLyoqXG4gICAqIERpc2Nvbm5lY3QgYWxsIG91dHB1dC5cbiAgICogQG1ldGhvZCBkaXNjb25uZWN0XG4gICAqIEBmb3IgcDUuRWZmZWN0XG4gICAqL1xuXG5cbiAgcDUuRWZmZWN0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm91dHB1dCkge1xuICAgICAgdGhpcy5vdXRwdXQuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfTtcblxuICBwNS5FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluZGV4ID0gcDVzb3VuZC5zb3VuZEFycmF5LmluZGV4T2YodGhpcyk7XG4gICAgcDVzb3VuZC5zb3VuZEFycmF5LnNwbGljZShpbmRleCwgMSk7XG5cbiAgICBpZiAodGhpcy5pbnB1dCkge1xuICAgICAgdGhpcy5pbnB1dC5kaXNjb25uZWN0KCk7XG4gICAgICBkZWxldGUgdGhpcy5pbnB1dDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vdXRwdXQpIHtcbiAgICAgIHRoaXMub3V0cHV0LmRpc2Nvbm5lY3QoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLm91dHB1dDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZHJ5d2V0KSB7XG4gICAgICB0aGlzLl9kcnl3ZXQuZGlzY29ubmVjdCgpO1xuXG4gICAgICBkZWxldGUgdGhpcy5fZHJ5d2V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLndldCkge1xuICAgICAgdGhpcy53ZXQuZGlzY29ubmVjdCgpO1xuICAgICAgZGVsZXRlIHRoaXMud2V0O1xuICAgIH1cblxuICAgIHRoaXMuYWMgPSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgcmV0dXJuIHA1LkVmZmVjdDtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXygxOSldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihlKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gZS5XYXZlU2hhcGVyPWZ1bmN0aW9uKGUsdCl7dGhpcy5fc2hhcGVyPXRoaXMuaW5wdXQ9dGhpcy5vdXRwdXQ9dGhpcy5jb250ZXh0LmNyZWF0ZVdhdmVTaGFwZXIoKSx0aGlzLl9jdXJ2ZT1udWxsLEFycmF5LmlzQXJyYXkoZSk/dGhpcy5jdXJ2ZT1lOmlzRmluaXRlKGUpfHx0aGlzLmlzVW5kZWYoZSk/dGhpcy5fY3VydmU9bmV3IEZsb2F0MzJBcnJheSh0aGlzLmRlZmF1bHRBcmcoZSwxMDI0KSk6dGhpcy5pc0Z1bmN0aW9uKGUpJiYodGhpcy5fY3VydmU9bmV3IEZsb2F0MzJBcnJheSh0aGlzLmRlZmF1bHRBcmcodCwxMDI0KSksdGhpcy5zZXRNYXAoZSkpfSxlLmV4dGVuZChlLldhdmVTaGFwZXIsZS5TaWduYWxCYXNlKSxlLldhdmVTaGFwZXIucHJvdG90eXBlLnNldE1hcD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MCxyPXRoaXMuX2N1cnZlLmxlbmd0aDt0PHI7dCsrKXt2YXIgcz10LyhyLTEpKjItMTt0aGlzLl9jdXJ2ZVt0XT1lKHMsdCl9cmV0dXJuIHRoaXMuX3NoYXBlci5jdXJ2ZT10aGlzLl9jdXJ2ZSx0aGlzfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5XYXZlU2hhcGVyLnByb3RvdHlwZSxcImN1cnZlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zaGFwZXIuY3VydmV9LHNldDpmdW5jdGlvbihlKXt0aGlzLl9jdXJ2ZT1uZXcgRmxvYXQzMkFycmF5KGUpLHRoaXMuX3NoYXBlci5jdXJ2ZT10aGlzLl9jdXJ2ZX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5XYXZlU2hhcGVyLnByb3RvdHlwZSxcIm92ZXJzYW1wbGVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NoYXBlci5vdmVyc2FtcGxlfSxzZXQ6ZnVuY3Rpb24oZSl7aWYoLTE9PT1bXCJub25lXCIsXCIyeFwiLFwiNHhcIl0uaW5kZXhPZihlKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRvbmUuV2F2ZVNoYXBlcjogb3ZlcnNhbXBsaW5nIG11c3QgYmUgZWl0aGVyICdub25lJywgJzJ4Jywgb3IgJzR4J1wiKTt0aGlzLl9zaGFwZXIub3ZlcnNhbXBsZT1lfX0pLGUuV2F2ZVNoYXBlci5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3JldHVybiBlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksdGhpcy5fc2hhcGVyLmRpc2Nvbm5lY3QoKSx0aGlzLl9zaGFwZXI9bnVsbCx0aGlzLl9jdXJ2ZT1udWxsLHRoaXN9LGUuV2F2ZVNoYXBlcn0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gIHZhciBwNXNvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgcHJvY2Vzc29yTmFtZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbiAgLyoqXG4gICAqIEBmb3IgcDVcbiAgICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBzYW1wbGUgcmF0ZSwgaW4gc2FtcGxlcyBwZXIgc2Vjb25kLFxuICAgKiBvZiBhbGwgc291bmQgb2JqZWN0cyBpbiB0aGlzIGF1ZGlvIGNvbnRleHQuIEl0IGlzIGRldGVybWluZWQgYnkgdGhlXG4gICAqIHNhbXBsaW5nIHJhdGUgb2YgeW91ciBvcGVyYXRpbmcgc3lzdGVtJ3Mgc291bmQgY2FyZCwgYW5kIGl0IGlzIG5vdFxuICAgKiBjdXJyZW50bHkgcG9zc2lsZSB0byBjaGFuZ2UuXG4gICAqIEl0IGlzIG9mdGVuIDQ0MTAwLCBvciB0d2ljZSB0aGUgcmFuZ2Ugb2YgaHVtYW4gaGVhcmluZy5cbiAgICpcbiAgICogQG1ldGhvZCBzYW1wbGVSYXRlXG4gICAqIEByZXR1cm4ge051bWJlcn0gc2FtcGxlcmF0ZSBzYW1wbGVzIHBlciBzZWNvbmRcbiAgICovXG5cblxuICBwNS5wcm90b3R5cGUuc2FtcGxlUmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcDVzb3VuZC5hdWRpb2NvbnRleHQuc2FtcGxlUmF0ZTtcbiAgfTtcbiAgLyoqXG4gICAqICBSZXR1cm5zIHRoZSBjbG9zZXN0IE1JREkgbm90ZSB2YWx1ZSBmb3JcbiAgICogIGEgZ2l2ZW4gZnJlcXVlbmN5LlxuICAgKlxuICAgKiAgQG1ldGhvZCBmcmVxVG9NaWRpXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IGZyZXF1ZW5jeSBBIGZyZXFldW5jeSwgZm9yIGV4YW1wbGUsIHRoZSBcIkFcIlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvdmUgTWlkZGxlIEMgaXMgNDQwSHpcbiAgICogIEByZXR1cm4ge051bWJlcn0gICBNSURJIG5vdGUgdmFsdWVcbiAgICovXG5cblxuICBwNS5wcm90b3R5cGUuZnJlcVRvTWlkaSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgdmFyIG1hdGhsb2cyID0gTWF0aC5sb2coZiAvIDQ0MCkgLyBNYXRoLmxvZygyKTtcbiAgICB2YXIgbSA9IE1hdGgucm91bmQoMTIgKiBtYXRobG9nMikgKyA2OTtcbiAgICByZXR1cm4gbTtcbiAgfTtcbiAgLyoqXG4gICAqICBSZXR1cm5zIHRoZSBmcmVxdWVuY3kgdmFsdWUgb2YgYSBNSURJIG5vdGUgdmFsdWUuXG4gICAqICBHZW5lcmFsIE1JREkgdHJlYXRzIG5vdGVzIGFzIGludGVnZXJzIHdoZXJlIG1pZGRsZSBDXG4gICAqICBpcyA2MCwgQyMgaXMgNjEsIEQgaXMgNjIgZXRjLiBVc2VmdWwgZm9yIGdlbmVyYXRpbmdcbiAgICogIG11c2ljYWwgZnJlcXVlbmNpZXMgd2l0aCBvc2NpbGxhdG9ycy5cbiAgICpcbiAgICogIEBtZXRob2QgIG1pZGlUb0ZyZXFcbiAgICogIEBwYXJhbSAge051bWJlcn0gbWlkaU5vdGUgVGhlIG51bWJlciBvZiBhIE1JREkgbm90ZVxuICAgKiAgQHJldHVybiB7TnVtYmVyfSBGcmVxdWVuY3kgdmFsdWUgb2YgdGhlIGdpdmVuIE1JREkgbm90ZVxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgbWlkaU5vdGVzID0gWzYwLCA2NCwgNjcsIDcyXTtcbiAgICogIGxldCBub3RlSW5kZXggPSAwO1xuICAgKiAgbGV0IG1pZGlWYWwsIGZyZXE7XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQoc3RhcnRTb3VuZCk7XG4gICAqICAgIG9zYyA9IG5ldyBwNS5UcmlPc2MoKTtcbiAgICogICAgZW52ID0gbmV3IHA1LkVudmVsb3BlKCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBkcmF3KCkge1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ3RhcCB0byBwbGF5JywgMTAsIDIwKTtcbiAgICogICAgaWYgKG1pZGlWYWwpIHtcbiAgICogICAgICB0ZXh0KCdNSURJOiAnICsgbWlkaVZhbCwgMTAsIDQwKTtcbiAgICogICAgICB0ZXh0KCdGcmVxOiAnICsgZnJlcSwgMTAsIDYwKTtcbiAgICogICAgfVxuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gc3RhcnRTb3VuZCgpIHtcbiAgICogICAgLy8gc2VlIGFsc286IHVzZXJTdGFydEF1ZGlvKCk7XG4gICAqICAgIG9zYy5zdGFydCgpO1xuICAgKlxuICAgKiAgICBtaWRpVmFsID0gbWlkaU5vdGVzW25vdGVJbmRleCAlIG1pZGlOb3Rlcy5sZW5ndGhdO1xuICAgKiAgICBmcmVxID0gbWlkaVRvRnJlcShtaWRpVmFsKTtcbiAgICogICAgb3NjLmZyZXEoZnJlcSk7XG4gICAqICAgIGVudi5yYW1wKG9zYywgMCwgMS4wLCAwKTtcbiAgICpcbiAgICogICAgbm90ZUluZGV4Kys7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgdmFyIG1pZGlUb0ZyZXEgPSBwNS5wcm90b3R5cGUubWlkaVRvRnJlcSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIDQ0MCAqIE1hdGgucG93KDIsIChtIC0gNjkpIC8gMTIuMCk7XG4gIH07IFxuXG5cbiAgdmFyIG5vdGVUb0ZyZXEgPSBmdW5jdGlvbiBub3RlVG9GcmVxKG5vdGUpIHtcbiAgICBpZiAodHlwZW9mIG5vdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbm90ZTtcbiAgICB9XG5cbiAgICB2YXIgd2hvbGVOb3RlcyA9IHtcbiAgICAgIEE6IDIxLFxuICAgICAgQjogMjMsXG4gICAgICBDOiAyNCxcbiAgICAgIEQ6IDI2LFxuICAgICAgRTogMjgsXG4gICAgICBGOiAyOSxcbiAgICAgIEc6IDMxXG4gICAgfTtcbiAgICB2YXIgdmFsdWUgPSB3aG9sZU5vdGVzW25vdGVbMF0udG9VcHBlckNhc2UoKV07XG4gICAgdmFyIG9jdGF2ZSA9IH5+bm90ZS5zbGljZSgtMSk7XG4gICAgdmFsdWUgKz0gMTIgKiAob2N0YXZlIC0gMSk7XG5cbiAgICBzd2l0Y2ggKG5vdGVbMV0pIHtcbiAgICAgIGNhc2UgJyMnOlxuICAgICAgICB2YWx1ZSArPSAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYic6XG4gICAgICAgIHZhbHVlIC09IDE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gbWlkaVRvRnJlcSh2YWx1ZSk7XG4gIH07XG4gIC8qKlxuICAgKiAgTGlzdCB0aGUgU291bmRGaWxlIGZvcm1hdHMgdGhhdCB5b3Ugd2lsbCBpbmNsdWRlLiBMb2FkU291bmRcbiAgICogIHdpbGwgc2VhcmNoIHlvdXIgZGlyZWN0b3J5IGZvciB0aGVzZSBleHRlbnNpb25zLCBhbmQgd2lsbCBwaWNrXG4gICAqICBhIGZvcm1hdCB0aGF0IGlzIGNvbXBhdGFibGUgd2l0aCB0aGUgY2xpZW50J3Mgd2ViIGJyb3dzZXIuXG4gICAqICA8YSBocmVmPVwiaHR0cDovL21lZGlhLmlvL1wiPkhlcmU8L2E+IGlzIGEgZnJlZSBvbmxpbmUgZmlsZVxuICAgKiAgY29udmVydGVyLlxuICAgKlxuICAgKiAgQG1ldGhvZCBzb3VuZEZvcm1hdHNcbiAgICogIEBwYXJhbSB7U3RyaW5nfSBbLi4uZm9ybWF0c10gaS5lLiAnbXAzJywgJ3dhdicsICdvZ2cnXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGZ1bmN0aW9uIHByZWxvYWQoKSB7XG4gICAqICAgIC8vIHNldCB0aGUgZ2xvYmFsIHNvdW5kIGZvcm1hdHNcbiAgICogICAgc291bmRGb3JtYXRzKCdtcDMnLCAnb2dnJyk7XG4gICAqXG4gICAqICAgIC8vIGxvYWQgZWl0aGVyIGJlYXRib3gubXAzLCBvciAub2dnLCBkZXBlbmRpbmcgb24gYnJvd3NlclxuICAgKiAgICBteVNvdW5kID0gbG9hZFNvdW5kKCdhc3NldHMvYmVhdGJveC5tcDMnKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICAgICB0ZXh0KCdzb3VuZCBsb2FkZWQhIHRhcCB0byBwbGF5JywgMTAsIDIwLCB3aWR0aCAtIDIwKTtcbiAgICogICAgICAgY252Lm1vdXNlUHJlc3NlZChmdW5jdGlvbigpIHtcbiAgICogICAgICAgICBteVNvdW5kLnBsYXkoKTtcbiAgICogICAgICAgfSk7XG4gICAqICAgICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUucHJvdG90eXBlLnNvdW5kRm9ybWF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwNXNvdW5kLmV4dGVuc2lvbnMgPSBbXTsgXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJndW1lbnRzW2ldID0gYXJndW1lbnRzW2ldLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmIChbJ21wMycsICd3YXYnLCAnb2dnJywgJ200YScsICdhYWMnXS5pbmRleE9mKGFyZ3VtZW50c1tpXSkgPiAtMSkge1xuICAgICAgICBwNXNvdW5kLmV4dGVuc2lvbnMucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgYXJndW1lbnRzW2ldICsgJyBpcyBub3QgYSB2YWxpZCBzb3VuZCBmb3JtYXQhJztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcDUucHJvdG90eXBlLmRpc3Bvc2VTb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHA1c291bmQuc291bmRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgcDVzb3VuZC5zb3VuZEFycmF5W2ldLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH07IFxuXG5cbiAgcDUucHJvdG90eXBlLnJlZ2lzdGVyTWV0aG9kKCdyZW1vdmUnLCBwNS5wcm90b3R5cGUuZGlzcG9zZVNvdW5kKTtcblxuICBwNS5wcm90b3R5cGUuX2NoZWNrRmlsZUZvcm1hdHMgPSBmdW5jdGlvbiAocGF0aHMpIHtcbiAgICB2YXIgcGF0aDsgXG5cbiAgICBpZiAodHlwZW9mIHBhdGhzID09PSAnc3RyaW5nJykge1xuICAgICAgcGF0aCA9IHBhdGhzOyBcblxuICAgICAgdmFyIGV4dFRlc3QgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7IFxuXG4gICAgICBpZiAoWydtcDMnLCAnd2F2JywgJ29nZycsICdtNGEnLCAnYWFjJ10uaW5kZXhPZihleHRUZXN0KSA+IC0xKSB7XG4gICAgICAgIGlmIChwNS5wcm90b3R5cGUuaXNGaWxlU3VwcG9ydGVkKGV4dFRlc3QpKSB7XG4gICAgICAgICAgcGF0aCA9IHBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHBhdGhTcGxpdCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgICB2YXIgcGF0aENvcmUgPSBwYXRoU3BsaXRbcGF0aFNwbGl0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwNXNvdW5kLmV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBleHRlbnNpb24gPSBwNXNvdW5kLmV4dGVuc2lvbnNbaV07XG4gICAgICAgICAgICB2YXIgc3VwcG9ydGVkID0gcDUucHJvdG90eXBlLmlzRmlsZVN1cHBvcnRlZChleHRlbnNpb24pO1xuXG4gICAgICAgICAgICBpZiAoc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgIHBhdGhDb3JlID0gJyc7XG5cbiAgICAgICAgICAgICAgaWYgKHBhdGhTcGxpdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBwYXRoQ29yZSArPSBwYXRoU3BsaXRbMF07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBwYXRoU3BsaXQubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwYXRoU3BsaXRbaV07XG4gICAgICAgICAgICAgICAgcGF0aENvcmUgKz0gJy4nICsgcDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHBhdGggPSBwYXRoQ29yZSArPSAnLic7XG4gICAgICAgICAgICAgIHBhdGggPSBwYXRoICs9IGV4dGVuc2lvbjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IFxuICAgICAgZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwNXNvdW5kLmV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBleHRlbnNpb24gPSBwNXNvdW5kLmV4dGVuc2lvbnNbaV07XG4gICAgICAgICAgICB2YXIgc3VwcG9ydGVkID0gcDUucHJvdG90eXBlLmlzRmlsZVN1cHBvcnRlZChleHRlbnNpb24pO1xuXG4gICAgICAgICAgICBpZiAoc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgIHBhdGggPSBwYXRoICsgJy4nICsgZXh0ZW5zaW9uO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IFxuICAgIGVsc2UgaWYgKF90eXBlb2YocGF0aHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGV4dGVuc2lvbiA9IHBhdGhzW2ldLnNwbGl0KCcuJykucG9wKCk7XG4gICAgICAgICAgdmFyIHN1cHBvcnRlZCA9IHA1LnByb3RvdHlwZS5pc0ZpbGVTdXBwb3J0ZWQoZXh0ZW5zaW9uKTtcblxuICAgICAgICAgIGlmIChzdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoc1tpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG4gIC8qKlxuICAgKiAgVXNlZCBieSBPc2MgYW5kIEVudmVsb3BlIHRvIGNoYWluIHNpZ25hbCBtYXRoXG4gICAqL1xuXG5cbiAgcDUucHJvdG90eXBlLl9tYXRoQ2hhaW4gPSBmdW5jdGlvbiAobywgbWF0aCwgdGhpc0NoYWluLCBuZXh0Q2hhaW4sIHR5cGUpIHtcbiAgICBmb3IgKHZhciBpIGluIG8ubWF0aE9wcykge1xuICAgICAgaWYgKG8ubWF0aE9wc1tpXSBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICAgICAgby5tYXRoT3BzW2ldLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpc0NoYWluID0gaTtcblxuICAgICAgICBpZiAodGhpc0NoYWluIDwgby5tYXRoT3BzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBuZXh0Q2hhaW4gPSBvLm1hdGhPcHNbaSArIDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgby5tYXRoT3BzW3RoaXNDaGFpbiAtIDFdLmRpc2Nvbm5lY3QoKTtcbiAgICBvLm1hdGhPcHNbdGhpc0NoYWluIC0gMV0uY29ubmVjdChtYXRoKTtcbiAgICBtYXRoLmNvbm5lY3QobmV4dENoYWluKTtcbiAgICBvLm1hdGhPcHNbdGhpc0NoYWluXSA9IG1hdGg7XG4gICAgcmV0dXJuIG87XG4gIH07IFxuXG5cbiAgZnVuY3Rpb24gY29udmVydFRvV2F2KGF1ZGlvQnVmZmVyKSB7XG4gICAgdmFyIGxlZnRDaGFubmVsLCByaWdodENoYW5uZWw7XG4gICAgbGVmdENoYW5uZWwgPSBhdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTsgXG5cbiAgICBpZiAoYXVkaW9CdWZmZXIubnVtYmVyT2ZDaGFubmVscyA+IDEpIHtcbiAgICAgIHJpZ2h0Q2hhbm5lbCA9IGF1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByaWdodENoYW5uZWwgPSBsZWZ0Q2hhbm5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW50ZXJsZWF2ZWQgPSBpbnRlcmxlYXZlKGxlZnRDaGFubmVsLCByaWdodENoYW5uZWwpOyBcblxuICAgIHZhciBidWZmZXIgPSBuZXcgd2luZG93LkFycmF5QnVmZmVyKDQ0ICsgaW50ZXJsZWF2ZWQubGVuZ3RoICogMik7XG4gICAgdmFyIHZpZXcgPSBuZXcgd2luZG93LkRhdGFWaWV3KGJ1ZmZlcik7IFxuXG4gICAgd3JpdGVVVEZCeXRlcyh2aWV3LCAwLCAnUklGRicpO1xuICAgIHZpZXcuc2V0VWludDMyKDQsIDM2ICsgaW50ZXJsZWF2ZWQubGVuZ3RoICogMiwgdHJ1ZSk7XG4gICAgd3JpdGVVVEZCeXRlcyh2aWV3LCA4LCAnV0FWRScpOyBcblxuICAgIHdyaXRlVVRGQnl0ZXModmlldywgMTIsICdmbXQgJyk7XG4gICAgdmlldy5zZXRVaW50MzIoMTYsIDE2LCB0cnVlKTtcbiAgICB2aWV3LnNldFVpbnQxNigyMCwgMSwgdHJ1ZSk7IFxuXG4gICAgdmlldy5zZXRVaW50MTYoMjIsIDIsIHRydWUpO1xuICAgIHZpZXcuc2V0VWludDMyKDI0LCBwNXNvdW5kLmF1ZGlvY29udGV4dC5zYW1wbGVSYXRlLCB0cnVlKTtcbiAgICB2aWV3LnNldFVpbnQzMigyOCwgcDVzb3VuZC5hdWRpb2NvbnRleHQuc2FtcGxlUmF0ZSAqIDQsIHRydWUpO1xuICAgIHZpZXcuc2V0VWludDE2KDMyLCA0LCB0cnVlKTtcbiAgICB2aWV3LnNldFVpbnQxNigzNCwgMTYsIHRydWUpOyBcblxuICAgIHdyaXRlVVRGQnl0ZXModmlldywgMzYsICdkYXRhJyk7XG4gICAgdmlldy5zZXRVaW50MzIoNDAsIGludGVybGVhdmVkLmxlbmd0aCAqIDIsIHRydWUpOyBcblxuICAgIHZhciBsbmcgPSBpbnRlcmxlYXZlZC5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gNDQ7XG4gICAgdmFyIHZvbHVtZSA9IDE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxuZzsgaSsrKSB7XG4gICAgICB2aWV3LnNldEludDE2KGluZGV4LCBpbnRlcmxlYXZlZFtpXSAqICgweDdGRkYgKiB2b2x1bWUpLCB0cnVlKTtcbiAgICAgIGluZGV4ICs9IDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZXc7XG4gIH0gXG5cblxuICBmdW5jdGlvbiBpbnRlcmxlYXZlKGxlZnRDaGFubmVsLCByaWdodENoYW5uZWwpIHtcbiAgICB2YXIgbGVuZ3RoID0gbGVmdENoYW5uZWwubGVuZ3RoICsgcmlnaHRDaGFubmVsLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpO1xuICAgIHZhciBpbnB1dEluZGV4ID0gMDtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICByZXN1bHRbaW5kZXgrK10gPSBsZWZ0Q2hhbm5lbFtpbnB1dEluZGV4XTtcbiAgICAgIHJlc3VsdFtpbmRleCsrXSA9IHJpZ2h0Q2hhbm5lbFtpbnB1dEluZGV4XTtcbiAgICAgIGlucHV0SW5kZXgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGVVVEZCeXRlcyh2aWV3LCBvZmZzZXQsIHN0cmluZykge1xuICAgIHZhciBsbmcgPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsbmc7IGkrKykge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQgKyBpLCBzdHJpbmcuY2hhckNvZGVBdChpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2FmZUJ1ZmZlclNpemUoaWRlYWxCdWZmZXJTaXplKSB7XG4gICAgdmFyIGJ1ZmZlclNpemUgPSBpZGVhbEJ1ZmZlclNpemU7IFxuXG4gICAgdmFyIHRlbXBBdWRpb1dvcmtsZXROb2RlID0gbmV3IEF1ZGlvV29ya2xldE5vZGUocDVzb3VuZC5hdWRpb2NvbnRleHQsIHByb2Nlc3Nvck5hbWVzLnNvdW5kRmlsZVByb2Nlc3Nvcik7XG5cbiAgICBpZiAodGVtcEF1ZGlvV29ya2xldE5vZGUgaW5zdGFuY2VvZiBTY3JpcHRQcm9jZXNzb3JOb2RlKSB7XG4gICAgICBidWZmZXJTaXplID0gdGVtcEF1ZGlvV29ya2xldE5vZGUuYnVmZmVyU2l6ZTtcbiAgICB9XG5cbiAgICB0ZW1wQXVkaW9Xb3JrbGV0Tm9kZS5kaXNjb25uZWN0KCk7XG4gICAgdGVtcEF1ZGlvV29ya2xldE5vZGUgPSBudWxsO1xuICAgIHJldHVybiBidWZmZXJTaXplO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb252ZXJ0VG9XYXY6IGNvbnZlcnRUb1dhdixcbiAgICBtaWRpVG9GcmVxOiBtaWRpVG9GcmVxLFxuICAgIG5vdGVUb0ZyZXE6IG5vdGVUb0ZyZXEsXG4gICAgc2FmZUJ1ZmZlclNpemU6IHNhZmVCdWZmZXJTaXplXG4gIH07XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9fd2VicGFja19yZXF1aXJlX18oMiksX193ZWJwYWNrX3JlcXVpcmVfXyg5KV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKGkpe1widXNlIHN0cmljdFwiO3JldHVybiBpLkFkZD1mdW5jdGlvbih0KXt0aGlzLmNyZWF0ZUluc091dHMoMiwwKSx0aGlzLl9zdW09dGhpcy5pbnB1dFswXT10aGlzLmlucHV0WzFdPXRoaXMub3V0cHV0PW5ldyBpLkdhaW4sdGhpcy5fcGFyYW09dGhpcy5pbnB1dFsxXT1uZXcgaS5TaWduYWwodCksdGhpcy5fcGFyYW0uY29ubmVjdCh0aGlzLl9zdW0pfSxpLmV4dGVuZChpLkFkZCxpLlNpZ25hbCksaS5BZGQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm4gaS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpLHRoaXMuX3N1bS5kaXNwb3NlKCksdGhpcy5fc3VtPW51bGwsdGhpcy5fcGFyYW0uZGlzcG9zZSgpLHRoaXMuX3BhcmFtPW51bGwsdGhpc30saS5BZGR9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXygyMCksX193ZWJwYWNrX3JlcXVpcmVfXyg0NSksX193ZWJwYWNrX3JlcXVpcmVfXyg0NiksX193ZWJwYWNrX3JlcXVpcmVfXygxMildLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbih0KXtyZXR1cm4gdC5UeXBlPXtEZWZhdWx0OlwibnVtYmVyXCIsVGltZTpcInRpbWVcIixGcmVxdWVuY3k6XCJmcmVxdWVuY3lcIixUcmFuc3BvcnRUaW1lOlwidHJhbnNwb3J0VGltZVwiLFRpY2tzOlwidGlja3NcIixOb3JtYWxSYW5nZTpcIm5vcm1hbFJhbmdlXCIsQXVkaW9SYW5nZTpcImF1ZGlvUmFuZ2VcIixEZWNpYmVsczpcImRiXCIsSW50ZXJ2YWw6XCJpbnRlcnZhbFwiLEJQTTpcImJwbVwiLFBvc2l0aXZlOlwicG9zaXRpdmVcIixDZW50czpcImNlbnRzXCIsRGVncmVlczpcImRlZ3JlZXNcIixNSURJOlwibWlkaVwiLEJhcnNCZWF0c1NpeHRlZW50aHM6XCJiYXJzQmVhdHNTaXh0ZWVudGhzXCIsU2FtcGxlczpcInNhbXBsZXNcIixIZXJ0ejpcImhlcnR6XCIsTm90ZTpcIm5vdGVcIixNaWxsaXNlY29uZHM6XCJtaWxsaXNlY29uZHNcIixTZWNvbmRzOlwic2Vjb25kc1wiLE5vdGF0aW9uOlwibm90YXRpb25cIn0sdC5wcm90b3R5cGUudG9TZWNvbmRzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmlzTnVtYmVyKGUpP2U6dGhpcy5pc1VuZGVmKGUpP3RoaXMubm93KCk6dGhpcy5pc1N0cmluZyhlKT9uZXcgdC5UaW1lKGUpLnRvU2Vjb25kcygpOmUgaW5zdGFuY2VvZiB0LlRpbWVCYXNlP2UudG9TZWNvbmRzKCk6dm9pZCAwfSx0LnByb3RvdHlwZS50b0ZyZXF1ZW5jeT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5pc051bWJlcihlKT9lOnRoaXMuaXNTdHJpbmcoZSl8fHRoaXMuaXNVbmRlZihlKT9uZXcgdC5GcmVxdWVuY3koZSkudmFsdWVPZigpOmUgaW5zdGFuY2VvZiB0LlRpbWVCYXNlP2UudG9GcmVxdWVuY3koKTp2b2lkIDB9LHQucHJvdG90eXBlLnRvVGlja3M9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuaXNOdW1iZXIoZSl8fHRoaXMuaXNTdHJpbmcoZSk/bmV3IHQuVHJhbnNwb3J0VGltZShlKS50b1RpY2tzKCk6dGhpcy5pc1VuZGVmKGUpP3QuVHJhbnNwb3J0LnRpY2tzOmUgaW5zdGFuY2VvZiB0LlRpbWVCYXNlP2UudG9UaWNrcygpOnZvaWQgMH0sdH0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygwKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDgpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24oaSl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIHdpbmRvdy5HYWluTm9kZSYmIUF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2FpbiYmKEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2Fpbj1BdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUdhaW5Ob2RlKSxpLkdhaW49ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLFtcImdhaW5cIixcInVuaXRzXCJdLGkuR2Fpbi5kZWZhdWx0cyk7dGhpcy5pbnB1dD10aGlzLm91dHB1dD10aGlzLl9nYWluTm9kZT10aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpLHRoaXMuZ2Fpbj1uZXcgaS5QYXJhbSh7cGFyYW06dGhpcy5fZ2Fpbk5vZGUuZ2Fpbix1bml0czp0LnVuaXRzLHZhbHVlOnQuZ2Fpbixjb252ZXJ0OnQuY29udmVydH0pLHRoaXMuX3JlYWRPbmx5KFwiZ2FpblwiKX0saS5leHRlbmQoaS5HYWluKSxpLkdhaW4uZGVmYXVsdHM9e2dhaW46MSxjb252ZXJ0OiEwfSxpLkdhaW4ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtpLlBhcmFtLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksdGhpcy5fZ2Fpbk5vZGUuZGlzY29ubmVjdCgpLHRoaXMuX2dhaW5Ob2RlPW51bGwsdGhpcy5fd3JpdGFibGUoXCJnYWluXCIpLHRoaXMuZ2Fpbi5kaXNwb3NlKCksdGhpcy5nYWluPW51bGx9LGkucHJvdG90eXBlLmNyZWF0ZUluc091dHM9ZnVuY3Rpb24odCxuKXsxPT09dD90aGlzLmlucHV0PW5ldyBpLkdhaW46MTx0JiYodGhpcy5pbnB1dD1uZXcgQXJyYXkodCkpLDE9PT1uP3RoaXMub3V0cHV0PW5ldyBpLkdhaW46MTxuJiYodGhpcy5vdXRwdXQ9bmV3IEFycmF5KHQpKX0saS5HYWlufSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlY29yZGVyUHJvY2Vzc29yOiAncmVjb3JkZXItcHJvY2Vzc29yJyxcbiAgc291bmRGaWxlUHJvY2Vzc29yOiAnc291bmQtZmlsZS1wcm9jZXNzb3InLFxuICBhbXBsaXR1ZGVQcm9jZXNzb3I6ICdhbXBsaXR1ZGUtcHJvY2Vzc29yJ1xufTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgQ3VzdG9tRXJyb3IgPSBmdW5jdGlvbiBDdXN0b21FcnJvcihuYW1lLCBlcnJvclRyYWNlLCBmYWlsZWRQYXRoKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuICAgIHZhciB0ZW1wU3RhY2ssIHNwbGl0U3RhY2s7XG4gICAgZXJyLm5hbWUgPSBuYW1lO1xuICAgIGVyci5vcmlnaW5hbFN0YWNrID0gZXJyLnN0YWNrICsgZXJyb3JUcmFjZTtcbiAgICB0ZW1wU3RhY2sgPSBlcnIuc3RhY2sgKyBlcnJvclRyYWNlO1xuICAgIGVyci5mYWlsZWRQYXRoID0gZmFpbGVkUGF0aDsgXG5cbiAgICB2YXIgc3BsaXRTdGFjayA9IHRlbXBTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgc3BsaXRTdGFjayA9IHNwbGl0U3RhY2suZmlsdGVyKGZ1bmN0aW9uIChsbikge1xuICAgICAgcmV0dXJuICFsbi5tYXRjaCgvKHA1LnxuYXRpdmUgY29kZXxnbG9iYWxJbml0KS9nKTtcbiAgICB9KTtcbiAgICBlcnIuc3RhY2sgPSBzcGxpdFN0YWNrLmpvaW4oJ1xcbicpO1xuICAgIHJldHVybiBlcnI7IFxuICB9O1xuXG4gIHJldHVybiBDdXN0b21FcnJvcjtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXygxOCldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihvKXtmdW5jdGlvbiB0KGUsdCxuKXtpZihlLmlucHV0KUFycmF5LmlzQXJyYXkoZS5pbnB1dCk/KG8ucHJvdG90eXBlLmlzVW5kZWYobikmJihuPTApLHRoaXMuY29ubmVjdChlLmlucHV0W25dKSk6dGhpcy5jb25uZWN0KGUuaW5wdXQsdCxuKTtlbHNlIHRyeXtlIGluc3RhbmNlb2YgQXVkaW9Ob2RlP2kuY2FsbCh0aGlzLGUsdCxuKTppLmNhbGwodGhpcyxlLHQpfWNhdGNoKHQpe3Rocm93IG5ldyBFcnJvcihcImVycm9yIGNvbm5lY3RpbmcgdG8gbm9kZTogXCIrZStcIlxcblwiK3QpfX12YXIgaSxyO3JldHVybiF3aW5kb3cuaGFzT3duUHJvcGVydHkoXCJBdWRpb0NvbnRleHRcIikmJndpbmRvdy5oYXNPd25Qcm9wZXJ0eShcIndlYmtpdEF1ZGlvQ29udGV4dFwiKSYmKHdpbmRvdy5BdWRpb0NvbnRleHQ9d2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCksby5Db250ZXh0PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiBvLkVtaXR0ZXIuY2FsbCh0aGlzKSx0PXR8fG5ldyB3aW5kb3cuQXVkaW9Db250ZXh0LHRoaXMuX2NvbnRleHQ9dCx0aGlzLl9jb250ZXh0KXRoaXMuX2RlZmluZVByb3BlcnR5KHRoaXMuX2NvbnRleHQsZSk7dGhpcy5fbGF0ZW5jeUhpbnQ9XCJpbnRlcmFjdGl2ZVwiLHRoaXMuX2xvb2tBaGVhZD0uMSx0aGlzLl91cGRhdGVJbnRlcnZhbD10aGlzLl9sb29rQWhlYWQvMyx0aGlzLl9jb21wdXRlZFVwZGF0ZUludGVydmFsPTAsdGhpcy5fd29ya2VyPXRoaXMuX2NyZWF0ZVdvcmtlcigpLHRoaXMuX2NvbnN0YW50cz17fX0sby5leHRlbmQoby5Db250ZXh0LG8uRW1pdHRlciksby5FbWl0dGVyLm1peGluKG8uQ29udGV4dCksby5Db250ZXh0LnByb3RvdHlwZS5fZGVmaW5lUHJvcGVydHk9ZnVuY3Rpb24oZSxuKXt0aGlzLmlzVW5kZWYodGhpc1tuXSkmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLG4se2dldDpmdW5jdGlvbigpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGVbbl0/ZVtuXS5iaW5kKGUpOmVbbl19LHNldDpmdW5jdGlvbih0KXtlW25dPXR9fSl9LG8uQ29udGV4dC5wcm90b3R5cGUubm93PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvbnRleHQuY3VycmVudFRpbWV9LG8uQ29udGV4dC5wcm90b3R5cGUuX2NyZWF0ZVdvcmtlcj1mdW5jdGlvbigpe3dpbmRvdy5VUkw9d2luZG93LlVSTHx8d2luZG93LndlYmtpdFVSTDt2YXIgdD1uZXcgQmxvYihbXCJ2YXIgdGltZW91dFRpbWUgPSBcIisoMWUzKnRoaXMuX3VwZGF0ZUludGVydmFsKS50b0ZpeGVkKDEpK1wiO3NlbGYub25tZXNzYWdlID0gZnVuY3Rpb24obXNnKXtcXHR0aW1lb3V0VGltZSA9IHBhcnNlSW50KG1zZy5kYXRhKTt9O2Z1bmN0aW9uIHRpY2soKXtcXHRzZXRUaW1lb3V0KHRpY2ssIHRpbWVvdXRUaW1lKTtcXHRzZWxmLnBvc3RNZXNzYWdlKCd0aWNrJyk7fXRpY2soKTtcIl0pLGU9VVJMLmNyZWF0ZU9iamVjdFVSTCh0KSxuPW5ldyBXb3JrZXIoZSk7cmV0dXJuIG4uYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixmdW5jdGlvbigpe3RoaXMuZW1pdChcInRpY2tcIil9LmJpbmQodGhpcykpLG4uYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixmdW5jdGlvbigpe3ZhciB0PXRoaXMubm93KCk7aWYodGhpcy5pc051bWJlcih0aGlzLl9sYXN0VXBkYXRlKSl7dmFyIGU9dC10aGlzLl9sYXN0VXBkYXRlO3RoaXMuX2NvbXB1dGVkVXBkYXRlSW50ZXJ2YWw9TWF0aC5tYXgoZSwuOTcqdGhpcy5fY29tcHV0ZWRVcGRhdGVJbnRlcnZhbCl9dGhpcy5fbGFzdFVwZGF0ZT10fS5iaW5kKHRoaXMpKSxufSxvLkNvbnRleHQucHJvdG90eXBlLmdldENvbnN0YW50PWZ1bmN0aW9uKHQpe2lmKHRoaXMuX2NvbnN0YW50c1t0XSlyZXR1cm4gdGhpcy5fY29uc3RhbnRzW3RdO2Zvcih2YXIgZT10aGlzLl9jb250ZXh0LmNyZWF0ZUJ1ZmZlcigxLDEyOCx0aGlzLl9jb250ZXh0LnNhbXBsZVJhdGUpLG49ZS5nZXRDaGFubmVsRGF0YSgwKSxvPTA7bzxuLmxlbmd0aDtvKyspbltvXT10O3ZhciBpPXRoaXMuX2NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7cmV0dXJuIGkuY2hhbm5lbENvdW50PTEsaS5jaGFubmVsQ291bnRNb2RlPVwiZXhwbGljaXRcIixpLmJ1ZmZlcj1lLGkubG9vcD0hMCxpLnN0YXJ0KDApLHRoaXMuX2NvbnN0YW50c1t0XT1pfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoby5Db250ZXh0LnByb3RvdHlwZSxcImxhZ1wiLHtnZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9jb21wdXRlZFVwZGF0ZUludGVydmFsLXRoaXMuX3VwZGF0ZUludGVydmFsO3JldHVybiB0PU1hdGgubWF4KHQsMCl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KG8uQ29udGV4dC5wcm90b3R5cGUsXCJsb29rQWhlYWRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xvb2tBaGVhZH0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX2xvb2tBaGVhZD10fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLkNvbnRleHQucHJvdG90eXBlLFwidXBkYXRlSW50ZXJ2YWxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3VwZGF0ZUludGVydmFsfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fdXBkYXRlSW50ZXJ2YWw9TWF0aC5tYXgodCxvLnByb3RvdHlwZS5ibG9ja1RpbWUpLHRoaXMuX3dvcmtlci5wb3N0TWVzc2FnZShNYXRoLm1heCgxZTMqdCwxKSl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KG8uQ29udGV4dC5wcm90b3R5cGUsXCJsYXRlbmN5SGludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbGF0ZW5jeUhpbnR9LHNldDpmdW5jdGlvbih0KXt2YXIgZT10O2lmKHRoaXMuX2xhdGVuY3lIaW50PXQsdGhpcy5pc1N0cmluZyh0KSlzd2l0Y2godCl7Y2FzZVwiaW50ZXJhY3RpdmVcIjplPS4xLHRoaXMuX2NvbnRleHQubGF0ZW5jeUhpbnQ9dDticmVhaztjYXNlXCJwbGF5YmFja1wiOmU9LjgsdGhpcy5fY29udGV4dC5sYXRlbmN5SGludD10O2JyZWFrO2Nhc2VcImJhbGFuY2VkXCI6ZT0uMjUsdGhpcy5fY29udGV4dC5sYXRlbmN5SGludD10O2JyZWFrO2Nhc2VcImZhc3Rlc3RcIjplPS4wMX10aGlzLmxvb2tBaGVhZD1lLHRoaXMudXBkYXRlSW50ZXJ2YWw9ZS8zfX0pLG8uc3VwcG9ydGVkPyhpPUF1ZGlvTm9kZS5wcm90b3R5cGUuY29ubmVjdCxyPUF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzY29ubmVjdCxBdWRpb05vZGUucHJvdG90eXBlLmNvbm5lY3QhPT10JiYoQXVkaW9Ob2RlLnByb3RvdHlwZS5jb25uZWN0PXQsQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNjb25uZWN0PWZ1bmN0aW9uKGUsdCxuKXtpZihlJiZlLmlucHV0JiZBcnJheS5pc0FycmF5KGUuaW5wdXQpKW8ucHJvdG90eXBlLmlzVW5kZWYobikmJihuPTApLHRoaXMuZGlzY29ubmVjdChlLmlucHV0W25dLHQsbik7ZWxzZSBpZihlJiZlLmlucHV0KXRoaXMuZGlzY29ubmVjdChlLmlucHV0LHQsbik7ZWxzZSB0cnl7ci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y2F0Y2godCl7dGhyb3cgbmV3IEVycm9yKFwiZXJyb3IgZGlzY29ubmVjdGluZyBub2RlOiBcIitlK1wiXFxuXCIrdCl9fSksby5jb250ZXh0PW5ldyBvLkNvbnRleHQpOmNvbnNvbGUud2FybihcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFRvbmUuanNcIiksby5Db250ZXh0fSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9fd2VicGFja19yZXF1aXJlX18oNyksX193ZWJwYWNrX3JlcXVpcmVfXygzKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDIpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24oaSl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIGkuU2NhbGU9ZnVuY3Rpb24odCxlKXt0aGlzLl9vdXRwdXRNaW49dGhpcy5kZWZhdWx0QXJnKHQsMCksdGhpcy5fb3V0cHV0TWF4PXRoaXMuZGVmYXVsdEFyZyhlLDEpLHRoaXMuX3NjYWxlPXRoaXMuaW5wdXQ9bmV3IGkuTXVsdGlwbHkoMSksdGhpcy5fYWRkPXRoaXMub3V0cHV0PW5ldyBpLkFkZCgwKSx0aGlzLl9zY2FsZS5jb25uZWN0KHRoaXMuX2FkZCksdGhpcy5fc2V0UmFuZ2UoKX0saS5leHRlbmQoaS5TY2FsZSxpLlNpZ25hbEJhc2UpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLlNjYWxlLnByb3RvdHlwZSxcIm1pblwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fb3V0cHV0TWlufSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fb3V0cHV0TWluPXQsdGhpcy5fc2V0UmFuZ2UoKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaS5TY2FsZS5wcm90b3R5cGUsXCJtYXhcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX291dHB1dE1heH0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX291dHB1dE1heD10LHRoaXMuX3NldFJhbmdlKCl9fSksaS5TY2FsZS5wcm90b3R5cGUuX3NldFJhbmdlPWZ1bmN0aW9uKCl7dGhpcy5fYWRkLnZhbHVlPXRoaXMuX291dHB1dE1pbix0aGlzLl9zY2FsZS52YWx1ZT10aGlzLl9vdXRwdXRNYXgtdGhpcy5fb3V0cHV0TWlufSxpLlNjYWxlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7cmV0dXJuIGkucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKSx0aGlzLl9hZGQuZGlzcG9zZSgpLHRoaXMuX2FkZD1udWxsLHRoaXMuX3NjYWxlLmRpc3Bvc2UoKSx0aGlzLl9zY2FsZT1udWxsLHRoaXN9LGkuU2NhbGV9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXygyKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKG8pe1widXNlIHN0cmljdFwiO3JldHVybiBvLlRpbWVsaW5lU2lnbmFsPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5vcHRpb25zT2JqZWN0KGFyZ3VtZW50cyxbXCJ2YWx1ZVwiLFwidW5pdHNcIl0sby5TaWduYWwuZGVmYXVsdHMpO3RoaXMuX2V2ZW50cz1uZXcgby5UaW1lbGluZSgxMCksby5TaWduYWwuYXBwbHkodGhpcyxlKSxlLnBhcmFtPXRoaXMuX3BhcmFtLG8uUGFyYW0uY2FsbCh0aGlzLGUpLHRoaXMuX2luaXRpYWw9dGhpcy5fZnJvbVVuaXRzKHRoaXMuX3BhcmFtLnZhbHVlKX0sby5leHRlbmQoby5UaW1lbGluZVNpZ25hbCxvLlBhcmFtKSxvLlRpbWVsaW5lU2lnbmFsLlR5cGU9e0xpbmVhcjpcImxpbmVhclwiLEV4cG9uZW50aWFsOlwiZXhwb25lbnRpYWxcIixUYXJnZXQ6XCJ0YXJnZXRcIixDdXJ2ZTpcImN1cnZlXCIsU2V0Olwic2V0XCJ9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZSxcInZhbHVlXCIse2dldDpmdW5jdGlvbigpe3ZhciBlPXRoaXMubm93KCksdD10aGlzLmdldFZhbHVlQXRUaW1lKGUpO3JldHVybiB0aGlzLl90b1VuaXRzKHQpfSxzZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5fZnJvbVVuaXRzKGUpO3RoaXMuX2luaXRpYWw9dCx0aGlzLmNhbmNlbFNjaGVkdWxlZFZhbHVlcygpLHRoaXMuX3BhcmFtLnZhbHVlPXR9fSksby5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuc2V0VmFsdWVBdFRpbWU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT10aGlzLl9mcm9tVW5pdHMoZSksdD10aGlzLnRvU2Vjb25kcyh0KSx0aGlzLl9ldmVudHMuYWRkKHt0eXBlOm8uVGltZWxpbmVTaWduYWwuVHlwZS5TZXQsdmFsdWU6ZSx0aW1lOnR9KSx0aGlzLl9wYXJhbS5zZXRWYWx1ZUF0VGltZShlLHQpLHRoaXN9LG8uVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU9dGhpcy5fZnJvbVVuaXRzKGUpLHQ9dGhpcy50b1NlY29uZHModCksdGhpcy5fZXZlbnRzLmFkZCh7dHlwZTpvLlRpbWVsaW5lU2lnbmFsLlR5cGUuTGluZWFyLHZhbHVlOmUsdGltZTp0fSksdGhpcy5fcGFyYW0ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoZSx0KSx0aGlzfSxvLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lPWZ1bmN0aW9uKGUsdCl7dD10aGlzLnRvU2Vjb25kcyh0KTt2YXIgaT10aGlzLl9zZWFyY2hCZWZvcmUodCk7aSYmMD09PWkudmFsdWUmJnRoaXMuc2V0VmFsdWVBdFRpbWUodGhpcy5fbWluT3V0cHV0LGkudGltZSksZT10aGlzLl9mcm9tVW5pdHMoZSk7dmFyIG49TWF0aC5tYXgoZSx0aGlzLl9taW5PdXRwdXQpO3JldHVybiB0aGlzLl9ldmVudHMuYWRkKHt0eXBlOm8uVGltZWxpbmVTaWduYWwuVHlwZS5FeHBvbmVudGlhbCx2YWx1ZTpuLHRpbWU6dH0pLGU8dGhpcy5fbWluT3V0cHV0Pyh0aGlzLl9wYXJhbS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuX21pbk91dHB1dCx0LXRoaXMuc2FtcGxlVGltZSksdGhpcy5zZXRWYWx1ZUF0VGltZSgwLHQpKTp0aGlzLl9wYXJhbS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKGUsdCksdGhpc30sby5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuc2V0VGFyZ2V0QXRUaW1lPWZ1bmN0aW9uKGUsdCxpKXtyZXR1cm4gZT10aGlzLl9mcm9tVW5pdHMoZSksZT1NYXRoLm1heCh0aGlzLl9taW5PdXRwdXQsZSksaT1NYXRoLm1heCh0aGlzLl9taW5PdXRwdXQsaSksdD10aGlzLnRvU2Vjb25kcyh0KSx0aGlzLl9ldmVudHMuYWRkKHt0eXBlOm8uVGltZWxpbmVTaWduYWwuVHlwZS5UYXJnZXQsdmFsdWU6ZSx0aW1lOnQsY29uc3RhbnQ6aX0pLHRoaXMuX3BhcmFtLnNldFRhcmdldEF0VGltZShlLHQsaSksdGhpc30sby5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuc2V0VmFsdWVDdXJ2ZUF0VGltZT1mdW5jdGlvbihlLHQsaSxuKXtuPXRoaXMuZGVmYXVsdEFyZyhuLDEpO2Zvcih2YXIgYT1uZXcgQXJyYXkoZS5sZW5ndGgpLGw9MDtsPGEubGVuZ3RoO2wrKylhW2xdPXRoaXMuX2Zyb21Vbml0cyhlW2xdKSpuO3Q9dGhpcy50b1NlY29uZHModCksaT10aGlzLnRvU2Vjb25kcyhpKSx0aGlzLl9ldmVudHMuYWRkKHt0eXBlOm8uVGltZWxpbmVTaWduYWwuVHlwZS5DdXJ2ZSx2YWx1ZTphLHRpbWU6dCxkdXJhdGlvbjppfSksdGhpcy5fcGFyYW0uc2V0VmFsdWVBdFRpbWUoYVswXSx0KTtmb3IodmFyIHM9MTtzPGEubGVuZ3RoO3MrKyl7dmFyIHI9dCtzLyhhLmxlbmd0aC0xKSppO3RoaXMuX3BhcmFtLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKGFbc10scil9cmV0dXJuIHRoaXN9LG8uVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmNhbmNlbFNjaGVkdWxlZFZhbHVlcz1mdW5jdGlvbihlKXtyZXR1cm4gZT10aGlzLnRvU2Vjb25kcyhlKSx0aGlzLl9ldmVudHMuY2FuY2VsKGUpLHRoaXMuX3BhcmFtLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhlKSx0aGlzfSxvLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5zZXRSYW1wUG9pbnQ9ZnVuY3Rpb24oZSl7ZT10aGlzLnRvU2Vjb25kcyhlKTt2YXIgdD10aGlzLl90b1VuaXRzKHRoaXMuZ2V0VmFsdWVBdFRpbWUoZSkpLGk9dGhpcy5fc2VhcmNoQmVmb3JlKGUpO2lmKGkmJmkudGltZT09PWUpdGhpcy5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoZSt0aGlzLnNhbXBsZVRpbWUpO2Vsc2UgaWYoaSYmaS50eXBlPT09by5UaW1lbGluZVNpZ25hbC5UeXBlLkN1cnZlJiZpLnRpbWUraS5kdXJhdGlvbj5lKXRoaXMuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKGUpLHRoaXMubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodCxlKTtlbHNle3ZhciBuPXRoaXMuX3NlYXJjaEFmdGVyKGUpO24mJih0aGlzLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhlKSxuLnR5cGU9PT1vLlRpbWVsaW5lU2lnbmFsLlR5cGUuTGluZWFyP3RoaXMubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodCxlKTpuLnR5cGU9PT1vLlRpbWVsaW5lU2lnbmFsLlR5cGUuRXhwb25lbnRpYWwmJnRoaXMuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh0LGUpKSx0aGlzLnNldFZhbHVlQXRUaW1lKHQsZSl9cmV0dXJuIHRoaXN9LG8uVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmxpbmVhclJhbXBUb1ZhbHVlQmV0d2Vlbj1mdW5jdGlvbihlLHQsaSl7cmV0dXJuIHRoaXMuc2V0UmFtcFBvaW50KHQpLHRoaXMubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoZSxpKSx0aGlzfSxvLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQmV0d2Vlbj1mdW5jdGlvbihlLHQsaSl7cmV0dXJuIHRoaXMuc2V0UmFtcFBvaW50KHQpLHRoaXMuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZShlLGkpLHRoaXN9LG8uVGltZWxpbmVTaWduYWwucHJvdG90eXBlLl9zZWFyY2hCZWZvcmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX2V2ZW50cy5nZXQoZSl9LG8uVGltZWxpbmVTaWduYWwucHJvdG90eXBlLl9zZWFyY2hBZnRlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fZXZlbnRzLmdldEFmdGVyKGUpfSxvLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5nZXRWYWx1ZUF0VGltZT1mdW5jdGlvbihlKXtlPXRoaXMudG9TZWNvbmRzKGUpO3ZhciB0PXRoaXMuX3NlYXJjaEFmdGVyKGUpLGk9dGhpcy5fc2VhcmNoQmVmb3JlKGUpLG49dGhpcy5faW5pdGlhbDtpZihudWxsPT09aSluPXRoaXMuX2luaXRpYWw7ZWxzZSBpZihpLnR5cGU9PT1vLlRpbWVsaW5lU2lnbmFsLlR5cGUuVGFyZ2V0KXt2YXIgYSxsPXRoaXMuX2V2ZW50cy5nZXRCZWZvcmUoaS50aW1lKTthPW51bGw9PT1sP3RoaXMuX2luaXRpYWw6bC52YWx1ZSxuPXRoaXMuX2V4cG9uZW50aWFsQXBwcm9hY2goaS50aW1lLGEsaS52YWx1ZSxpLmNvbnN0YW50LGUpfWVsc2Ugbj1pLnR5cGU9PT1vLlRpbWVsaW5lU2lnbmFsLlR5cGUuQ3VydmU/dGhpcy5fY3VydmVJbnRlcnBvbGF0ZShpLnRpbWUsaS52YWx1ZSxpLmR1cmF0aW9uLGUpOm51bGw9PT10P2kudmFsdWU6dC50eXBlPT09by5UaW1lbGluZVNpZ25hbC5UeXBlLkxpbmVhcj90aGlzLl9saW5lYXJJbnRlcnBvbGF0ZShpLnRpbWUsaS52YWx1ZSx0LnRpbWUsdC52YWx1ZSxlKTp0LnR5cGU9PT1vLlRpbWVsaW5lU2lnbmFsLlR5cGUuRXhwb25lbnRpYWw/dGhpcy5fZXhwb25lbnRpYWxJbnRlcnBvbGF0ZShpLnRpbWUsaS52YWx1ZSx0LnRpbWUsdC52YWx1ZSxlKTppLnZhbHVlO3JldHVybiBufSxvLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5jb25uZWN0PW8uU2lnbmFsQmFzZS5wcm90b3R5cGUuY29ubmVjdCxvLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5fZXhwb25lbnRpYWxBcHByb2FjaD1mdW5jdGlvbihlLHQsaSxuLGEpe3JldHVybiBpKyh0LWkpKk1hdGguZXhwKC0oYS1lKS9uKX0sby5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuX2xpbmVhckludGVycG9sYXRlPWZ1bmN0aW9uKGUsdCxpLG4sYSl7cmV0dXJuIHQrKGEtZSkvKGktZSkqKG4tdCl9LG8uVGltZWxpbmVTaWduYWwucHJvdG90eXBlLl9leHBvbmVudGlhbEludGVycG9sYXRlPWZ1bmN0aW9uKGUsdCxpLG4sYSl7cmV0dXJuKHQ9TWF0aC5tYXgodGhpcy5fbWluT3V0cHV0LHQpKSpNYXRoLnBvdyhuL3QsKGEtZSkvKGktZSkpfSxvLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5fY3VydmVJbnRlcnBvbGF0ZT1mdW5jdGlvbihlLHQsaSxuKXt2YXIgYT10Lmxlbmd0aDtpZihlK2k8PW4pcmV0dXJuIHRbYS0xXTtpZihuPD1lKXJldHVybiB0WzBdO3ZhciBsPShuLWUpL2kscz1NYXRoLmZsb29yKChhLTEpKmwpLHI9TWF0aC5jZWlsKChhLTEpKmwpLG89dFtzXSxwPXRbcl07cmV0dXJuIHI9PT1zP286dGhpcy5fbGluZWFySW50ZXJwb2xhdGUocyxvLHIscCxsKihhLTEpKX0sby5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe28uU2lnbmFsLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksby5QYXJhbS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpLHRoaXMuX2V2ZW50cy5kaXNwb3NlKCksdGhpcy5fZXZlbnRzPW51bGx9LG8uVGltZWxpbmVTaWduYWx9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICB2YXIgRWZmZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbiAgLyoqXG4gICAqICA8cD5BIHA1LkZpbHRlciB1c2VzIGEgV2ViIEF1ZGlvIEJpcXVhZCBGaWx0ZXIgdG8gZmlsdGVyXG4gICAqICB0aGUgZnJlcXVlbmN5IHJlc3BvbnNlIG9mIGFuIGlucHV0IHNvdXJjZS4gU3ViY2xhc3Nlc1xuICAgKiAgaW5jbHVkZTo8L3A+XG4gICAqICA8YSBocmVmPVwiL3JlZmVyZW5jZS8jL3A1Lkxvd1Bhc3NcIj48Y29kZT5wNS5Mb3dQYXNzPC9jb2RlPjwvYT46XG4gICAqICBBbGxvd3MgZnJlcXVlbmNpZXMgYmVsb3cgdGhlIGN1dG9mZiBmcmVxdWVuY3kgdG8gcGFzcyB0aHJvdWdoLFxuICAgKiAgYW5kIGF0dGVudWF0ZXMgZnJlcXVlbmNpZXMgYWJvdmUgdGhlIGN1dG9mZi48YnIvPlxuICAgKiAgPGEgaHJlZj1cIi9yZWZlcmVuY2UvIy9wNS5IaWdoUGFzc1wiPjxjb2RlPnA1LkhpZ2hQYXNzPC9jb2RlPjwvYT46XG4gICAqICBUaGUgb3Bwb3NpdGUgb2YgYSBsb3dwYXNzIGZpbHRlci4gPGJyLz5cbiAgICogIDxhIGhyZWY9XCIvcmVmZXJlbmNlLyMvcDUuQmFuZFBhc3NcIj48Y29kZT5wNS5CYW5kUGFzczwvY29kZT48L2E+OlxuICAgKiAgQWxsb3dzIGEgcmFuZ2Ugb2YgZnJlcXVlbmNpZXMgdG8gcGFzcyB0aHJvdWdoIGFuZCBhdHRlbnVhdGVzXG4gICAqICB0aGUgZnJlcXVlbmNpZXMgYmVsb3cgYW5kIGFib3ZlIHRoaXMgZnJlcXVlbmN5IHJhbmdlLjxici8+XG4gICAqXG4gICAqICBUaGUgPGNvZGU+LnJlcygpPC9jb2RlPiBtZXRob2QgY29udHJvbHMgZWl0aGVyIHdpZHRoIG9mIHRoZVxuICAgKiAgYmFuZHBhc3MsIG9yIHJlc29uYW5jZSBvZiB0aGUgbG93L2hpZ2hwYXNzIGN1dG9mZiBmcmVxdWVuY3kuXG4gICAqXG4gICAqICBUaGlzIGNsYXNzIGV4dGVuZHMgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdFwiPnA1LkVmZmVjdDwvYT4uXG4gICAqICBNZXRob2RzIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvYW1wXCI+YW1wKCk8L2E+LCA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2NoYWluXCI+Y2hhaW4oKTwvYT4sXG4gICAqICA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2RyeXdldFwiPmRyeXdldCgpPC9hPiwgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9jb25uZWN0XCI+Y29ubmVjdCgpPC9hPiwgYW5kXG4gICAqICA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2Rpc2Nvbm5lY3RcIj5kaXNjb25uZWN0KCk8L2E+IGFyZSBhdmFpbGFibGUuXG4gICAqXG4gICAqICBAY2xhc3MgcDUuRmlsdGVyXG4gICAqICBAZXh0ZW5kcyBwNS5FZmZlY3RcbiAgICogIEBjb25zdHJ1Y3RvclxuICAgKiAgQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSAnbG93cGFzcycgKGRlZmF1bHQpLCAnaGlnaHBhc3MnLCAnYmFuZHBhc3MnXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgKiAgbGV0IGZmdCwgbm9pc2UsIGZpbHRlcjtcbiAgKlxuICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwxMDApO1xuICAqICAgIGNudi5tb3VzZVByZXNzZWQobWFrZU5vaXNlKTtcbiAgKiAgICBmaWxsKDI1NSwgMCwgMjU1KTtcbiAgKlxuICAqICAgIGZpbHRlciA9IG5ldyBwNS5CYW5kUGFzcygpO1xuICAqICAgIG5vaXNlID0gbmV3IHA1Lk5vaXNlKCk7XG4gICogICAgbm9pc2UuZGlzY29ubmVjdCgpO1xuICAqICAgIG5vaXNlLmNvbm5lY3QoZmlsdGVyKTtcbiAgKlxuICAqICAgIGZmdCA9IG5ldyBwNS5GRlQoKTtcbiAgKiAgfVxuICAqXG4gICogIGZ1bmN0aW9uIGRyYXcoKSB7XG4gICogICAgYmFja2dyb3VuZCgyMjApO1xuICAqXG4gICogICAgLy8gc2V0IHRoZSBCYW5kUGFzcyBmcmVxdWVuY3kgYmFzZWQgb24gbW91c2VYXG4gICogICAgbGV0IGZyZXEgPSBtYXAobW91c2VYLCAwLCB3aWR0aCwgMjAsIDEwMDAwKTtcbiAgKiAgICBmcmVxID0gY29uc3RyYWluKGZyZXEsIDAsIDIyMDUwKTtcbiAgKiAgICBmaWx0ZXIuZnJlcShmcmVxKTtcbiAgKiAgICAvLyBnaXZlIHRoZSBmaWx0ZXIgYSBuYXJyb3cgYmFuZCAobG93ZXIgcmVzID0gd2lkZXIgYmFuZHBhc3MpXG4gICogICAgZmlsdGVyLnJlcyg1MCk7XG4gICpcbiAgKiAgICAvLyBkcmF3IGZpbHRlcmVkIHNwZWN0cnVtXG4gICogICAgbGV0IHNwZWN0cnVtID0gZmZ0LmFuYWx5emUoKTtcbiAgKiAgICBub1N0cm9rZSgpO1xuICAqICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BlY3RydW0ubGVuZ3RoOyBpKyspIHtcbiAgKiAgICAgIGxldCB4ID0gbWFwKGksIDAsIHNwZWN0cnVtLmxlbmd0aCwgMCwgd2lkdGgpO1xuICAqICAgICAgbGV0IGggPSAtaGVpZ2h0ICsgbWFwKHNwZWN0cnVtW2ldLCAwLCAyNTUsIGhlaWdodCwgMCk7XG4gICogICAgICByZWN0KHgsIGhlaWdodCwgd2lkdGgvc3BlY3RydW0ubGVuZ3RoLCBoKTtcbiAgKiAgICB9XG4gICogICAgaWYgKCFub2lzZS5zdGFydGVkKSB7XG4gICogICAgICB0ZXh0KCd0YXAgaGVyZSBhbmQgZHJhZyB0byBjaGFuZ2UgZnJlcXVlbmN5JywgMTAsIDIwLCB3aWR0aCAtIDIwKTtcbiAgKiAgICB9IGVsc2Uge1xuICAqICAgICAgdGV4dCgnRnJlcXVlbmN5OiAnICsgcm91bmQoZnJlcSkrJ0h6JywgMjAsIDIwLCB3aWR0aCAtIDIwKTtcbiAgKiAgICB9XG4gICogIH1cbiAgKlxuICAqICBmdW5jdGlvbiBtYWtlTm9pc2UoKSB7XG4gICogICAgLy8gc2VlIGFsc286IGB1c2VyU3RhcnRBdWRpbygpYFxuICAqICAgIG5vaXNlLnN0YXJ0KCk7XG4gICogICAgbm9pc2UuYW1wKDAuNSwgMC4yKTtcbiAgKiAgfVxuICAqXG4gICogIGZ1bmN0aW9uIG1vdXNlUmVsZWFzZWQoKSB7XG4gICogICAgbm9pc2UuYW1wKDAsIDAuMik7XG4gICogIH1cbiAgKlxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LkZpbHRlciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgRWZmZWN0LmNhbGwodGhpcyk7IFxuXG4gICAgLyoqXG4gICAgICAqICBUaGUgcDUuRmlsdGVyIGlzIGJ1aWx0IHdpdGggYVxuICAgICAgKiAgPGEgaHJlZj1cImh0dHA6Ly93d3cudzMub3JnL1RSL3dlYmF1ZGlvLyNCaXF1YWRGaWx0ZXJOb2RlXCI+XG4gICAgICAqICBXZWIgQXVkaW8gQmlxdWFkRmlsdGVyIE5vZGU8L2E+LlxuICAgICAgKlxuICAgICAgKiAgQHByb3BlcnR5IHtEZWxheU5vZGV9IGJpcXVhZEZpbHRlclxuICAgICovXG5cbiAgICB0aGlzLmJpcXVhZCA9IHRoaXMuYWMuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG4gICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuYmlxdWFkKTtcbiAgICB0aGlzLmJpcXVhZC5jb25uZWN0KHRoaXMud2V0KTtcblxuICAgIGlmICh0eXBlKSB7XG4gICAgICB0aGlzLnNldFR5cGUodHlwZSk7XG4gICAgfSBcblxuXG4gICAgdGhpcy5fb24gPSB0cnVlO1xuICAgIHRoaXMuX3VudG9nZ2xlZFR5cGUgPSB0aGlzLmJpcXVhZC50eXBlO1xuICB9O1xuXG4gIHA1LkZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVmZmVjdC5wcm90b3R5cGUpO1xuICAvKipcbiAgICogIEZpbHRlciBhbiBhdWRpbyBzaWduYWwgYWNjb3JkaW5nIHRvIGEgc2V0XG4gICAqICBvZiBmaWx0ZXIgcGFyYW1ldGVycy5cbiAgICpcbiAgICogIEBtZXRob2QgIHByb2Nlc3NcbiAgICogIEBwYXJhbSAge09iamVjdH0gU2lnbmFsICBBbiBvYmplY3QgdGhhdCBvdXRwdXRzIGF1ZGlvXG4gICAqICBAcGFyYW0ge051bWJlcn0gW2ZyZXFdIEZyZXF1ZW5jeSBpbiBIeiwgZnJvbSAxMCB0byAyMjA1MFxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtyZXNdIFJlc29uYW5jZS9XaWR0aCBvZiB0aGUgZmlsdGVyIGZyZXF1ZW5jeVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gMC4wMDEgdG8gMTAwMFxuICAgKi9cblxuICBwNS5GaWx0ZXIucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoc3JjLCBmcmVxLCByZXMsIHRpbWUpIHtcbiAgICBzcmMuY29ubmVjdCh0aGlzLmlucHV0KTtcbiAgICB0aGlzLnNldChmcmVxLCByZXMsIHRpbWUpO1xuICB9O1xuICAvKipcbiAgICogIFNldCB0aGUgZnJlcXVlbmN5IGFuZCB0aGUgcmVzb25hbmNlIG9mIHRoZSBmaWx0ZXIuXG4gICAqXG4gICAqICBAbWV0aG9kICBzZXRcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbZnJlcV0gRnJlcXVlbmN5IGluIEh6LCBmcm9tIDEwIHRvIDIyMDUwXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3Jlc10gIFJlc29uYW5jZSAoUSkgZnJvbSAwLjAwMSB0byAxMDAwXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3RpbWVGcm9tTm93XSBzY2hlZHVsZSB0aGlzIGV2ZW50IHRvIGhhcHBlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyBmcm9tIG5vd1xuICAgKi9cblxuXG4gIHA1LkZpbHRlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGZyZXEsIHJlcywgdGltZSkge1xuICAgIGlmIChmcmVxKSB7XG4gICAgICB0aGlzLmZyZXEoZnJlcSwgdGltZSk7XG4gICAgfVxuXG4gICAgaWYgKHJlcykge1xuICAgICAgdGhpcy5yZXMocmVzLCB0aW1lKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgU2V0IHRoZSBmaWx0ZXIgZnJlcXVlbmN5LCBpbiBIeiwgZnJvbSAxMCB0byAyMjA1MCAodGhlIHJhbmdlIG9mXG4gICAqICBodW1hbiBoZWFyaW5nLCBhbHRob3VnaCBpbiByZWFsaXR5IG1vc3QgcGVvcGxlIGhlYXIgaW4gYSBuYXJyb3dlclxuICAgKiAgcmFuZ2UpLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgZnJlcVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBmcmVxIEZpbHRlciBGcmVxdWVuY3lcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbdGltZUZyb21Ob3ddIHNjaGVkdWxlIHRoaXMgZXZlbnQgdG8gaGFwcGVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRzIGZyb20gbm93XG4gICAqICBAcmV0dXJuIHtOdW1iZXJ9IHZhbHVlICBSZXR1cm5zIHRoZSBjdXJyZW50IGZyZXF1ZW5jeSB2YWx1ZVxuICAgKi9cblxuXG4gIHA1LkZpbHRlci5wcm90b3R5cGUuZnJlcSA9IGZ1bmN0aW9uIChmcmVxLCB0aW1lKSB7XG4gICAgdmFyIHQgPSB0aW1lIHx8IDA7XG5cbiAgICBpZiAoZnJlcSA8PSAwKSB7XG4gICAgICBmcmVxID0gMTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZyZXEgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmJpcXVhZC5mcmVxdWVuY3kuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAxICsgdCk7XG4gICAgICB0aGlzLmJpcXVhZC5mcmVxdWVuY3kuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZShmcmVxLCB0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMiArIHQpO1xuICAgIH0gZWxzZSBpZiAoZnJlcSkge1xuICAgICAgZnJlcS5jb25uZWN0KHRoaXMuYmlxdWFkLmZyZXF1ZW5jeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYmlxdWFkLmZyZXF1ZW5jeS52YWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqICBDb250cm9scyBlaXRoZXIgd2lkdGggb2YgYSBiYW5kcGFzcyBmcmVxdWVuY3ksXG4gICAqICBvciB0aGUgcmVzb25hbmNlIG9mIGEgbG93L2hpZ2hwYXNzIGN1dG9mZiBmcmVxdWVuY3kuXG4gICAqXG4gICAqICBAbWV0aG9kICByZXNcbiAgICogIEBwYXJhbSB7TnVtYmVyfSByZXMgIFJlc29uYW5jZS9XaWR0aCBvZiBmaWx0ZXIgZnJlcVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgZnJvbSAwLjAwMSB0byAxMDAwXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3RpbWVGcm9tTm93XSBzY2hlZHVsZSB0aGlzIGV2ZW50IHRvIGhhcHBlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyBmcm9tIG5vd1xuICAgKiAgQHJldHVybiB7TnVtYmVyfSB2YWx1ZSBSZXR1cm5zIHRoZSBjdXJyZW50IHJlcyB2YWx1ZVxuICAgKi9cblxuXG4gIHA1LkZpbHRlci5wcm90b3R5cGUucmVzID0gZnVuY3Rpb24gKHJlcywgdGltZSkge1xuICAgIHZhciB0ID0gdGltZSB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZiByZXMgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmJpcXVhZC5RLnZhbHVlID0gcmVzO1xuICAgICAgdGhpcy5iaXF1YWQuUS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDEgKyB0KTtcbiAgICAgIHRoaXMuYmlxdWFkLlEubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUocmVzLCB0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMiArIHQpO1xuICAgIH0gZWxzZSBpZiAocmVzKSB7XG4gICAgICByZXMuY29ubmVjdCh0aGlzLmJpcXVhZC5RKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5iaXF1YWQuUS52YWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbnRyb2xzIHRoZSBnYWluIGF0dHJpYnV0ZSBvZiBhIEJpcXVhZCBGaWx0ZXIuXG4gICAqIFRoaXMgaXMgZGlzdGluY3RseSBkaWZmZXJlbnQgZnJvbSAuYW1wKCkgd2hpY2ggaXMgaW5oZXJpdGVkIGZyb20gcDUuRWZmZWN0XG4gICAqIC5hbXAoKSBjb250cm9scyB0aGUgdm9sdW1lIHZpYSB0aGUgb3V0cHV0IGdhaW4gbm9kZVxuICAgKiBwNS5GaWx0ZXIuZ2FpbigpIGNvbnRyb2xzIHRoZSBnYWluIHBhcmFtZXRlciBvZiBhIEJpcXVhZCBGaWx0ZXIgbm9kZS5cbiAgICpcbiAgICogQG1ldGhvZCBnYWluXG4gICAqIEBwYXJhbSAge051bWJlcn0gZ2FpblxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIGN1cnJlbnQgb3IgdXBkYXRlZCBnYWluIHZhbHVlXG4gICAqL1xuXG5cbiAgcDUuRmlsdGVyLnByb3RvdHlwZS5nYWluID0gZnVuY3Rpb24gKGdhaW4sIHRpbWUpIHtcbiAgICB2YXIgdCA9IHRpbWUgfHwgMDtcblxuICAgIGlmICh0eXBlb2YgZ2FpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuYmlxdWFkLmdhaW4udmFsdWUgPSBnYWluO1xuICAgICAgdGhpcy5iaXF1YWQuZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDEgKyB0KTtcbiAgICAgIHRoaXMuYmlxdWFkLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoZ2FpbiwgdGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDIgKyB0KTtcbiAgICB9IGVsc2UgaWYgKGdhaW4pIHtcbiAgICAgIGdhaW4uY29ubmVjdCh0aGlzLmJpcXVhZC5nYWluKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5iaXF1YWQuZ2Fpbi52YWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIFRvZ2dsZSBmdW5jdGlvbi4gU3dpdGNoZXMgYmV0d2VlbiB0aGUgc3BlY2lmaWVkIHR5cGUgYW5kIGFsbHBhc3NcbiAgICpcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gW1RvZ2dsZSB2YWx1ZV1cbiAgICovXG5cblxuICBwNS5GaWx0ZXIucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9vbiA9ICF0aGlzLl9vbjtcblxuICAgIGlmICh0aGlzLl9vbiA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5iaXF1YWQudHlwZSA9IHRoaXMuX3VudG9nZ2xlZFR5cGU7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vbiA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYmlxdWFkLnR5cGUgPSAnYWxscGFzcyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX29uO1xuICB9O1xuICAvKipcbiAgICogIFNldCB0aGUgdHlwZSBvZiBhIHA1LkZpbHRlci4gUG9zc2libGUgdHlwZXMgaW5jbHVkZTpcbiAgICogIFwibG93cGFzc1wiIChkZWZhdWx0KSwgXCJoaWdocGFzc1wiLCBcImJhbmRwYXNzXCIsXG4gICAqICBcImxvd3NoZWxmXCIsIFwiaGlnaHNoZWxmXCIsIFwicGVha2luZ1wiLCBcIm5vdGNoXCIsXG4gICAqICBcImFsbHBhc3NcIi5cbiAgICpcbiAgICogIEBtZXRob2QgIHNldFR5cGVcbiAgICogIEBwYXJhbSB7U3RyaW5nfSB0XG4gICAqL1xuXG5cbiAgcDUuRmlsdGVyLnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24gKHQpIHtcbiAgICB0aGlzLmJpcXVhZC50eXBlID0gdDtcbiAgICB0aGlzLl91bnRvZ2dsZWRUeXBlID0gdGhpcy5iaXF1YWQudHlwZTtcbiAgfTtcblxuICBwNS5GaWx0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmFwcGx5KHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuYmlxdWFkKSB7XG4gICAgICB0aGlzLmJpcXVhZC5kaXNjb25uZWN0KCk7XG4gICAgICBkZWxldGUgdGhpcy5iaXF1YWQ7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIENvbnN0cnVjdG9yOiA8Y29kZT5uZXcgcDUuTG93UGFzcygpPC9jb2RlPiBGaWx0ZXIuXG4gICAqICBUaGlzIGlzIHRoZSBzYW1lIGFzIGNyZWF0aW5nIGEgcDUuRmlsdGVyIGFuZCB0aGVuIGNhbGxpbmdcbiAgICogIGl0cyBtZXRob2QgPGNvZGU+c2V0VHlwZSgnbG93cGFzcycpPC9jb2RlPi5cbiAgICogIFNlZSBwNS5GaWx0ZXIgZm9yIG1ldGhvZHMuXG4gICAqXG4gICAqICBAY2xhc3MgcDUuTG93UGFzc1xuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAZXh0ZW5kcyBwNS5GaWx0ZXJcbiAgICovXG5cblxuICBwNS5Mb3dQYXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHA1LkZpbHRlci5jYWxsKHRoaXMsICdsb3dwYXNzJyk7XG4gIH07XG5cbiAgcDUuTG93UGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHA1LkZpbHRlci5wcm90b3R5cGUpO1xuICAvKipcbiAgICogIENvbnN0cnVjdG9yOiA8Y29kZT5uZXcgcDUuSGlnaFBhc3MoKTwvY29kZT4gRmlsdGVyLlxuICAgKiAgVGhpcyBpcyB0aGUgc2FtZSBhcyBjcmVhdGluZyBhIHA1LkZpbHRlciBhbmQgdGhlbiBjYWxsaW5nXG4gICAqICBpdHMgbWV0aG9kIDxjb2RlPnNldFR5cGUoJ2hpZ2hwYXNzJyk8L2NvZGU+LlxuICAgKiAgU2VlIHA1LkZpbHRlciBmb3IgbWV0aG9kcy5cbiAgICpcbiAgICogIEBjbGFzcyBwNS5IaWdoUGFzc1xuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAZXh0ZW5kcyBwNS5GaWx0ZXJcbiAgICovXG5cbiAgcDUuSGlnaFBhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcDUuRmlsdGVyLmNhbGwodGhpcywgJ2hpZ2hwYXNzJyk7XG4gIH07XG5cbiAgcDUuSGlnaFBhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwNS5GaWx0ZXIucHJvdG90eXBlKTtcbiAgLyoqXG4gICAqICBDb25zdHJ1Y3RvcjogPGNvZGU+bmV3IHA1LkJhbmRQYXNzKCk8L2NvZGU+IEZpbHRlci5cbiAgICogIFRoaXMgaXMgdGhlIHNhbWUgYXMgY3JlYXRpbmcgYSBwNS5GaWx0ZXIgYW5kIHRoZW4gY2FsbGluZ1xuICAgKiAgaXRzIG1ldGhvZCA8Y29kZT5zZXRUeXBlKCdiYW5kcGFzcycpPC9jb2RlPi5cbiAgICogIFNlZSBwNS5GaWx0ZXIgZm9yIG1ldGhvZHMuXG4gICAqXG4gICAqICBAY2xhc3MgcDUuQmFuZFBhc3NcbiAgICogIEBjb25zdHJ1Y3RvclxuICAgKiAgQGV4dGVuZHMgcDUuRmlsdGVyXG4gICAqL1xuXG4gIHA1LkJhbmRQYXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHA1LkZpbHRlci5jYWxsKHRoaXMsICdiYW5kcGFzcycpO1xuICB9O1xuXG4gIHA1LkJhbmRQYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocDUuRmlsdGVyLnByb3RvdHlwZSk7XG4gIHJldHVybiBwNS5GaWx0ZXI7XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9fd2VicGFja19yZXF1aXJlX18oNyksX193ZWJwYWNrX3JlcXVpcmVfXygyNSksX193ZWJwYWNrX3JlcXVpcmVfXygyKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDkpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24obil7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIG4uU3VidHJhY3Q9ZnVuY3Rpb24odCl7dGhpcy5jcmVhdGVJbnNPdXRzKDIsMCksdGhpcy5fc3VtPXRoaXMuaW5wdXRbMF09dGhpcy5vdXRwdXQ9bmV3IG4uR2Fpbix0aGlzLl9uZWc9bmV3IG4uTmVnYXRlLHRoaXMuX3BhcmFtPXRoaXMuaW5wdXRbMV09bmV3IG4uU2lnbmFsKHQpLHRoaXMuX3BhcmFtLmNoYWluKHRoaXMuX25lZyx0aGlzLl9zdW0pfSxuLmV4dGVuZChuLlN1YnRyYWN0LG4uU2lnbmFsKSxuLlN1YnRyYWN0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7cmV0dXJuIG4ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKSx0aGlzLl9uZWcuZGlzcG9zZSgpLHRoaXMuX25lZz1udWxsLHRoaXMuX3N1bS5kaXNjb25uZWN0KCksdGhpcy5fc3VtPW51bGwsdGhpcy5fcGFyYW0uZGlzcG9zZSgpLHRoaXMuX3BhcmFtPW51bGwsdGhpc30sbi5TdWJ0cmFjdH0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuKGZ1bmN0aW9uKGdsb2JhbCkge3ZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuZ2xvYmFsLlRPTkVfU0lMRU5DRV9WRVJTSU9OX0xPR0dJTkcgPSB0cnVlO1xuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMzUpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSwgX193ZWJwYWNrX3JlcXVpcmVfXygwKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChTdGFydEF1ZGlvQ29udGV4dCwgQ29udGV4dCwgVG9uZSkge1xuICB2YXIgYXVkaW9jb250ZXh0ID0gbmV3IHdpbmRvdy5BdWRpb0NvbnRleHQoKTsgXG5cbiAgVG9uZS5jb250ZXh0LmRpc3Bvc2UoKTtcbiAgVG9uZS5zZXRDb250ZXh0KGF1ZGlvY29udGV4dCk7XG4gIC8qKlxuICAgKiA8cD5SZXR1cm5zIHRoZSBBdWRpbyBDb250ZXh0IGZvciB0aGlzIHNrZXRjaC4gVXNlZnVsIGZvciB1c2Vyc1xuICAgKiB3aG8gd291bGQgbGlrZSB0byBkaWcgZGVlcGVyIGludG8gdGhlIDxhIHRhcmdldD0nX2JsYW5rJyBocmVmPVxuICAgKiAnaHR0cDovL3dlYmF1ZGlvLmdpdGh1Yi5pby93ZWItYXVkaW8tYXBpLyc+V2ViIEF1ZGlvIEFQSVxuICAgKiA8L2E+LjwvcD5cbiAgICpcbiAgICogPHA+U29tZSBicm93c2VycyByZXF1aXJlIHVzZXJzIHRvIHN0YXJ0QXVkaW9Db250ZXh0XG4gICAqIHdpdGggYSB1c2VyIGdlc3R1cmUsIHN1Y2ggYXMgdG91Y2hTdGFydGVkIGluIHRoZSBleGFtcGxlIGJlbG93LjwvcD5cbiAgICpcbiAgICogQGZvciBwNVxuICAgKiBAbWV0aG9kIGdldEF1ZGlvQ29udGV4dFxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgIEF1ZGlvQ29udGV4dCBmb3IgdGhpcyBza2V0Y2hcbiAgICogQGV4YW1wbGVcbiAgICogPGRpdj48Y29kZT5cbiAgICogIGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAqICAgIGJhY2tncm91bmQoMjU1KTtcbiAgICogICAgdGV4dEFsaWduKENFTlRFUik7XG4gICAqXG4gICAqICAgIGlmIChnZXRBdWRpb0NvbnRleHQoKS5zdGF0ZSAhPT0gJ3J1bm5pbmcnKSB7XG4gICAqICAgICAgdGV4dCgnY2xpY2sgdG8gc3RhcnQgYXVkaW8nLCB3aWR0aC8yLCBoZWlnaHQvMik7XG4gICAqICAgIH0gZWxzZSB7XG4gICAqICAgICAgdGV4dCgnYXVkaW8gaXMgZW5hYmxlZCcsIHdpZHRoLzIsIGhlaWdodC8yKTtcbiAgICogICAgfVxuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gdG91Y2hTdGFydGVkKCkge1xuICAgKiAgICBpZiAoZ2V0QXVkaW9Db250ZXh0KCkuc3RhdGUgIT09ICdydW5uaW5nJykge1xuICAgKiAgICAgIGdldEF1ZGlvQ29udGV4dCgpLnJlc3VtZSgpO1xuICAgKiAgICB9XG4gICAqICAgIHZhciBzeW50aCA9IG5ldyBwNS5Nb25vU3ludGgoKTtcbiAgICogICAgc3ludGgucGxheSgnQTQnLCAwLjUsIDAsIDAuMik7XG4gICAqICB9XG4gICAqXG4gICAqIDwvZGl2PjwvY29kZT5cbiAgICovXG5cbiAgcDUucHJvdG90eXBlLmdldEF1ZGlvQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXVkaW9jb250ZXh0O1xuICB9O1xuICAvKipcbiAgICogIDxwPkl0IGlzIG5vdCBvbmx5IGEgZ29vZCBwcmFjdGljZSB0byBnaXZlIHVzZXJzIGNvbnRyb2wgb3ZlciBzdGFydGluZ1xuICAgKiAgYXVkaW8uIFRoaXMgcG9saWN5IGlzIGVuZm9yY2VkIGJ5IG1hbnkgd2ViIGJyb3dzZXJzLCBpbmNsdWRpbmcgaU9TIGFuZFxuICAgKiAgPGEgaHJlZj1cImh0dHBzOi8vZ29vLmdsLzdLN1dMdVwiIHRpdGxlPVwiR29vZ2xlIENocm9tZSdzIGF1dG9wbGF5XG4gICAqICBwb2xpY3lcIj5Hb29nbGUgQ2hyb21lPC9hPiwgd2hpY2ggY3JlYXRlIHRoZSBXZWIgQXVkaW8gQVBJJ3NcbiAgICogIDxhIGhyZWY9XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Db250ZXh0XCJcbiAgICogIHRpdGxlPVwiQXVkaW8gQ29udGV4dCBAIE1ETlwiPkF1ZGlvIENvbnRleHQ8L2E+XG4gICAqICBpbiBhIHN1c3BlbmRlZCBzdGF0ZS48L3A+XG4gICAqXG4gICAqICA8cD5JbiB0aGVzZSBicm93c2VyLXNwZWNpZmljIHBvbGljaWVzLCBzb3VuZCB3aWxsIG5vdCBwbGF5IHVudGlsIGEgdXNlclxuICAgKiAgaW50ZXJhY3Rpb24gZXZlbnQgKGkuZS4gPGNvZGU+bW91c2VQcmVzc2VkKCk8L2NvZGU+KSBleHBsaWNpdGx5IHJlc3VtZXNcbiAgICogIHRoZSBBdWRpb0NvbnRleHQsIG9yIHN0YXJ0cyBhbiBhdWRpbyBub2RlLiBUaGlzIGNhbiBiZSBhY2NvbXBsaXNoZWQgYnlcbiAgICogIGNhbGxpbmcgPGNvZGU+c3RhcnQoKTwvY29kZT4gb24gYSA8Y29kZT5wNS5Pc2NpbGxhdG9yPC9jb2RlPixcbiAgICogIDxjb2RlPiBwbGF5KCk8L2NvZGU+IG9uIGEgPGNvZGU+cDUuU291bmRGaWxlPC9jb2RlPiwgb3Igc2ltcGx5XG4gICAqICA8Y29kZT51c2VyU3RhcnRBdWRpbygpPC9jb2RlPi48L3A+XG4gICAqXG4gICAqICA8cD48Y29kZT51c2VyU3RhcnRBdWRpbygpPC9jb2RlPiBzdGFydHMgdGhlIEF1ZGlvQ29udGV4dCBvbiBhIHVzZXJcbiAgICogIGdlc3R1cmUuIFRoZSBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgZW5hYmxlIGF1ZGlvIG9uIGFueVxuICAgKiAgbW91c2VVcCBvciB0b3VjaEVuZCBldmVudC4gSXQgY2FuIGFsc28gYmUgcGxhY2VkIGluIGEgc3BlY2lmaWNcbiAgICogIGludGVyYWN0aW9uIGZ1bmN0aW9uLCBzdWNoIGFzIDxjb2RlPm1vdXNlUHJlc3NlZCgpPC9jb2RlPiBhcyBpbiB0aGVcbiAgICogIGV4YW1wbGUgYmVsb3cuIFRoaXMgbWV0aG9kIHV0aWxpemVzXG4gICAqICA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL3RhbWJpZW4vU3RhcnRBdWRpb0NvbnRleHRcIj5TdGFydEF1ZGlvQ29udGV4dFxuICAgKiAgPC9hPiwgYSBsaWJyYXJ5IGJ5IFlvdGFtIE1hbm4gKE1JVCBMaWNlbmNlLCAyMDE2KS48L3A+XG4gICAqICBAcGFyYW0gIHtFbGVtZW50fEFycmF5fSAgIFtlbGVtZW50KHMpXSBUaGlzIGFyZ3VtZW50IGNhbiBiZSBhbiBFbGVtZW50LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VsZWN0b3IgU3RyaW5nLCBOb2RlTGlzdCwgcDUuRWxlbWVudCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeSBFbGVtZW50LCBvciBhbiBBcnJheSBvZiBhbnkgb2YgdGhvc2UuXG4gICAqICBAcGFyYW0gIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiB0aGUgQXVkaW9Db250ZXh0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXMgc3RhcnRlZFxuICAgKiAgQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgQXVkaW9Db250ZXh0IHN0YXRlIGlzICdydW5uaW5nJ1xuICAgKiAgQG1ldGhvZCB1c2VyU3RhcnRBdWRpb1xuICAgKiAgQGZvciBwNVxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgLy8gbWltaWNzIHRoZSBhdXRvcGxheSBwb2xpY3lcbiAgICogICAgZ2V0QXVkaW9Db250ZXh0KCkuc3VzcGVuZCgpO1xuICAgKlxuICAgKiAgICBsZXQgbXlTeW50aCA9IG5ldyBwNS5Nb25vU3ludGgoKTtcbiAgICpcbiAgICogICAgLy8gVGhpcyB3b24ndCBwbGF5IHVudGlsIHRoZSBjb250ZXh0IGhhcyByZXN1bWVkXG4gICAqICAgIG15U3ludGgucGxheSgnQTYnKTtcbiAgICogIH1cbiAgICogIGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dEFsaWduKENFTlRFUiwgQ0VOVEVSKTtcbiAgICogICAgdGV4dChnZXRBdWRpb0NvbnRleHQoKS5zdGF0ZSwgd2lkdGgvMiwgaGVpZ2h0LzIpO1xuICAgKiAgfVxuICAgKiAgZnVuY3Rpb24gbW91c2VQcmVzc2VkKCkge1xuICAgKiAgICB1c2VyU3RhcnRBdWRpbygpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LnByb3RvdHlwZS51c2VyU3RhcnRBdWRpbyA9IGZ1bmN0aW9uIChlbGVtZW50cywgY2FsbGJhY2spIHtcbiAgICB2YXIgZWx0ID0gZWxlbWVudHM7XG5cbiAgICBpZiAoZWxlbWVudHMgaW5zdGFuY2VvZiBwNS5FbGVtZW50KSB7XG4gICAgICBlbHQgPSBlbGVtZW50cy5lbHQ7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50cyBpbnN0YW5jZW9mIEFycmF5ICYmIGVsZW1lbnRzWzBdIGluc3RhbmNlb2YgcDUuRWxlbWVudCkge1xuICAgICAgZWx0ID0gZWxlbWVudHMubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLmVsdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBTdGFydEF1ZGlvQ29udGV4dChhdWRpb2NvbnRleHQsIGVsdCwgY2FsbGJhY2spO1xuICB9O1xuXG4gIHJldHVybiBhdWRpb2NvbnRleHQ7XG59KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xufS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMzQpKSlcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24obyl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIG8uRW1pdHRlcj1mdW5jdGlvbigpe3RoaXMuX2V2ZW50cz17fX0sby5leHRlbmQoby5FbWl0dGVyKSxvLkVtaXR0ZXIucHJvdG90eXBlLm9uPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpPXQuc3BsaXQoL1xcVysvKSxyPTA7cjxpLmxlbmd0aDtyKyspe3ZhciBuPWlbcl07dGhpcy5fZXZlbnRzLmhhc093blByb3BlcnR5KG4pfHwodGhpcy5fZXZlbnRzW25dPVtdKSx0aGlzLl9ldmVudHNbbl0ucHVzaChlKX1yZXR1cm4gdGhpc30sby5FbWl0dGVyLnByb3RvdHlwZS5vZmY9ZnVuY3Rpb24odCxlKXtmb3IodmFyIGk9dC5zcGxpdCgvXFxXKy8pLHI9MDtyPGkubGVuZ3RoO3IrKylpZih0PWlbcl0sdGhpcy5fZXZlbnRzLmhhc093blByb3BlcnR5KHQpKWlmKG8ucHJvdG90eXBlLmlzVW5kZWYoZSkpdGhpcy5fZXZlbnRzW3RdPVtdO2Vsc2UgZm9yKHZhciBuPXRoaXMuX2V2ZW50c1t0XSxzPTA7czxuLmxlbmd0aDtzKyspbltzXT09PWUmJm4uc3BsaWNlKHMsMSk7cmV0dXJuIHRoaXN9LG8uRW1pdHRlci5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbih0KXtpZih0aGlzLl9ldmVudHMpe3ZhciBlPUFycmF5LmFwcGx5KG51bGwsYXJndW1lbnRzKS5zbGljZSgxKTtpZih0aGlzLl9ldmVudHMuaGFzT3duUHJvcGVydHkodCkpZm9yKHZhciBpPXRoaXMuX2V2ZW50c1t0XSxyPTAsbj1pLmxlbmd0aDtyPG47cisrKWlbcl0uYXBwbHkodGhpcyxlKX1yZXR1cm4gdGhpc30sby5FbWl0dGVyLm1peGluPWZ1bmN0aW9uKHQpe3ZhciBlPVtcIm9uXCIsXCJvZmZcIixcImVtaXRcIl07dC5fZXZlbnRzPXt9O2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgcj1lW2ldLG49by5FbWl0dGVyLnByb3RvdHlwZVtyXTt0W3JdPW59fSxvLkVtaXR0ZXIucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm4gby5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpLHRoaXMuX2V2ZW50cz1udWxsLHRoaXN9LG8uRW1pdHRlcn0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygwKV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKGMpe1widXNlIHN0cmljdFwiO3JldHVybiBjLlNpZ25hbEJhc2U9ZnVuY3Rpb24oKXt9LGMuZXh0ZW5kKGMuU2lnbmFsQmFzZSksYy5TaWduYWxCYXNlLnByb3RvdHlwZS5jb25uZWN0PWZ1bmN0aW9uKGUsbixhKXtyZXR1cm4gYy5TaWduYWwmJmMuU2lnbmFsPT09ZS5jb25zdHJ1Y3Rvcnx8Yy5QYXJhbSYmYy5QYXJhbT09PWUuY29uc3RydWN0b3J8fGMuVGltZWxpbmVTaWduYWwmJmMuVGltZWxpbmVTaWduYWw9PT1lLmNvbnN0cnVjdG9yPyhlLl9wYXJhbS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoMCksZS5fcGFyYW0udmFsdWU9MCxlLm92ZXJyaWRkZW49ITApOmUgaW5zdGFuY2VvZiBBdWRpb1BhcmFtJiYoZS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoMCksZS52YWx1ZT0wKSxjLnByb3RvdHlwZS5jb25uZWN0LmNhbGwodGhpcyxlLG4sYSksdGhpc30sYy5TaWduYWxCYXNlfSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9fd2VicGFja19yZXF1aXJlX18oMjEpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24obyl7cmV0dXJuIG8uVGltZT1mdW5jdGlvbih0LGUpe2lmKCEodGhpcyBpbnN0YW5jZW9mIG8uVGltZSkpcmV0dXJuIG5ldyBvLlRpbWUodCxlKTt0aGlzLl9wbHVzTm93PSExLG8uVGltZUJhc2UuY2FsbCh0aGlzLHQsZSl9LG8uZXh0ZW5kKG8uVGltZSxvLlRpbWVCYXNlKSxvLlRpbWUucHJvdG90eXBlLl91bmFyeUV4cHJlc3Npb25zPU9iamVjdC5jcmVhdGUoby5UaW1lQmFzZS5wcm90b3R5cGUuX3VuYXJ5RXhwcmVzc2lvbnMpLG8uVGltZS5wcm90b3R5cGUuX3VuYXJ5RXhwcmVzc2lvbnMucXVhbnRpemU9e3JlZ2V4cDovXkAvLG1ldGhvZDpmdW5jdGlvbih0KXtyZXR1cm4gby5UcmFuc3BvcnQubmV4dFN1YmRpdmlzaW9uKHQoKSl9fSxvLlRpbWUucHJvdG90eXBlLl91bmFyeUV4cHJlc3Npb25zLm5vdz17cmVnZXhwOi9eXFwrLyxtZXRob2Q6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3BsdXNOb3c9ITAsdCgpfX0sby5UaW1lLnByb3RvdHlwZS5xdWFudGl6ZT1mdW5jdGlvbih0LGUpe3JldHVybiBlPXRoaXMuZGVmYXVsdEFyZyhlLDEpLHRoaXMuX2V4cHI9ZnVuY3Rpb24odCxlLG8pe3JldHVybiB0PXQoKSxlPWUudG9TZWNvbmRzKCksdCsoTWF0aC5yb3VuZCh0L2UpKmUtdCkqb30uYmluZCh0aGlzLHRoaXMuX2V4cHIsbmV3IHRoaXMuY29uc3RydWN0b3IodCksZSksdGhpc30sby5UaW1lLnByb3RvdHlwZS5hZGROb3c9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGx1c05vdz0hMCx0aGlzfSxvLlRpbWUucHJvdG90eXBlLl9kZWZhdWx0RXhwcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9wbHVzTm93PSEwLHRoaXMuX25vT3B9LG8uVGltZS5wcm90b3R5cGUuY29weT1mdW5jdGlvbih0KXtyZXR1cm4gby5UaW1lQmFzZS5wcm90b3R5cGUuY29weS5jYWxsKHRoaXMsdCksdGhpcy5fcGx1c05vdz10Ll9wbHVzTm93LHRoaXN9LG8uVGltZS5wcm90b3R5cGUudG9Ob3RhdGlvbj1mdW5jdGlvbigpe3ZhciB0PXRoaXMudG9TZWNvbmRzKCksZT10aGlzLl90b05vdGF0aW9uSGVscGVyKHQsW1wiMW1cIixcIjJuXCIsXCI0blwiLFwiOG5cIixcIjE2blwiLFwiMzJuXCIsXCI2NG5cIixcIjEyOG5cIl0pLG89dGhpcy5fdG9Ob3RhdGlvbkhlbHBlcih0LFtcIjFtXCIsXCIyblwiLFwiMnRcIixcIjRuXCIsXCI0dFwiLFwiOG5cIixcIjh0XCIsXCIxNm5cIixcIjE2dFwiLFwiMzJuXCIsXCIzMnRcIixcIjY0blwiLFwiNjR0XCIsXCIxMjhuXCJdKTtyZXR1cm4gby5zcGxpdChcIitcIikubGVuZ3RoPGUuc3BsaXQoXCIrXCIpLmxlbmd0aD9vOmV9LG8uVGltZS5wcm90b3R5cGUuX3RvTm90YXRpb25IZWxwZXI9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG89dGhpcy5fbm90YXRpb25Ub1VuaXRzKGVbZS5sZW5ndGgtMV0pLG49XCJcIixpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciByPXRoaXMuX25vdGF0aW9uVG9Vbml0cyhlW2ldKSxzPXQvcjtpZigxLXMlMTwxZS02JiYocys9MWUtNiksMDwocz1NYXRoLmZsb29yKHMpKSl7aWYobis9MT09PXM/ZVtpXTpzLnRvU3RyaW5nKCkrXCIqXCIrZVtpXSwodC09cypyKTxvKWJyZWFrO24rPVwiICsgXCJ9fXJldHVyblwiXCI9PT1uJiYobj1cIjBcIiksbn0sby5UaW1lLnByb3RvdHlwZS5fbm90YXRpb25Ub1VuaXRzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLl9wcmltYXJ5RXhwcmVzc2lvbnMsbz1bZS5uLGUudCxlLm1dLG49MDtuPG8ubGVuZ3RoO24rKyl7dmFyIGk9b1tuXSxyPXQubWF0Y2goaS5yZWdleHApO2lmKHIpcmV0dXJuIGkubWV0aG9kLmNhbGwodGhpcyxyWzFdKX19LG8uVGltZS5wcm90b3R5cGUudG9CYXJzQmVhdHNTaXh0ZWVudGhzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fYmVhdHNUb1VuaXRzKDEpLGU9dGhpcy50b1NlY29uZHMoKS90LG89TWF0aC5mbG9vcihlL3RoaXMuX3RpbWVTaWduYXR1cmUoKSksbj1lJTEqNDtyZXR1cm4gZT1NYXRoLmZsb29yKGUpJXRoaXMuX3RpbWVTaWduYXR1cmUoKSwzPChuPW4udG9TdHJpbmcoKSkubGVuZ3RoJiYobj1wYXJzZUZsb2F0KG4pLnRvRml4ZWQoMykpLFtvLGUsbl0uam9pbihcIjpcIil9LG8uVGltZS5wcm90b3R5cGUudG9UaWNrcz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuX2JlYXRzVG9Vbml0cygxKSxlPXRoaXMudmFsdWVPZigpL3Q7cmV0dXJuIE1hdGguZmxvb3IoZSpvLlRyYW5zcG9ydC5QUFEpfSxvLlRpbWUucHJvdG90eXBlLnRvU2FtcGxlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRvU2Vjb25kcygpKnRoaXMuY29udGV4dC5zYW1wbGVSYXRlfSxvLlRpbWUucHJvdG90eXBlLnRvRnJlcXVlbmN5PWZ1bmN0aW9uKCl7cmV0dXJuIDEvdGhpcy50b1NlY29uZHMoKX0sby5UaW1lLnByb3RvdHlwZS50b1NlY29uZHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZU9mKCl9LG8uVGltZS5wcm90b3R5cGUudG9NaWxsaXNlY29uZHM9ZnVuY3Rpb24oKXtyZXR1cm4gMWUzKnRoaXMudG9TZWNvbmRzKCl9LG8uVGltZS5wcm90b3R5cGUudmFsdWVPZj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9leHByKCkrKHRoaXMuX3BsdXNOb3c/dGhpcy5ub3coKTowKX0sby5UaW1lfSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24obil7cmV0dXJuIG4uVGltZUJhc2U9ZnVuY3Rpb24oZSx0KXtpZighKHRoaXMgaW5zdGFuY2VvZiBuLlRpbWVCYXNlKSlyZXR1cm4gbmV3IG4uVGltZUJhc2UoZSx0KTtpZih0aGlzLl9leHByPXRoaXMuX25vT3AsZSBpbnN0YW5jZW9mIG4uVGltZUJhc2UpdGhpcy5jb3B5KGUpO2Vsc2UgaWYoIXRoaXMuaXNVbmRlZih0KXx8dGhpcy5pc051bWJlcihlKSl7dD10aGlzLmRlZmF1bHRBcmcodCx0aGlzLl9kZWZhdWx0VW5pdHMpO3ZhciByPXRoaXMuX3ByaW1hcnlFeHByZXNzaW9uc1t0XS5tZXRob2Q7dGhpcy5fZXhwcj1yLmJpbmQodGhpcyxlKX1lbHNlIHRoaXMuaXNTdHJpbmcoZSk/dGhpcy5zZXQoZSk6dGhpcy5pc1VuZGVmKGUpJiYodGhpcy5fZXhwcj10aGlzLl9kZWZhdWx0RXhwcigpKX0sbi5leHRlbmQobi5UaW1lQmFzZSksbi5UaW1lQmFzZS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9leHByPXRoaXMuX3BhcnNlRXhwclN0cmluZyhlKSx0aGlzfSxuLlRpbWVCYXNlLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBlPW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBlLmNvcHkodGhpcyksZX0sbi5UaW1lQmFzZS5wcm90b3R5cGUuY29weT1mdW5jdGlvbihlKXt2YXIgdD1lLl9leHByKCk7cmV0dXJuIHRoaXMuc2V0KHQpfSxuLlRpbWVCYXNlLnByb3RvdHlwZS5fcHJpbWFyeUV4cHJlc3Npb25zPXtuOntyZWdleHA6L14oXFxkKyluL2ksbWV0aG9kOmZ1bmN0aW9uKGUpe3JldHVybiAxPT09KGU9cGFyc2VJbnQoZSkpP3RoaXMuX2JlYXRzVG9Vbml0cyh0aGlzLl90aW1lU2lnbmF0dXJlKCkpOnRoaXMuX2JlYXRzVG9Vbml0cyg0L2UpfX0sdDp7cmVnZXhwOi9eKFxcZCspdC9pLG1ldGhvZDpmdW5jdGlvbihlKXtyZXR1cm4gZT1wYXJzZUludChlKSx0aGlzLl9iZWF0c1RvVW5pdHMoOC8oMypwYXJzZUludChlKSkpfX0sbTp7cmVnZXhwOi9eKFxcZCspbS9pLG1ldGhvZDpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fYmVhdHNUb1VuaXRzKHBhcnNlSW50KGUpKnRoaXMuX3RpbWVTaWduYXR1cmUoKSl9fSxpOntyZWdleHA6L14oXFxkKylpL2ksbWV0aG9kOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl90aWNrc1RvVW5pdHMocGFyc2VJbnQoZSkpfX0saHo6e3JlZ2V4cDovXihcXGQrKD86XFwuXFxkKyk/KWh6L2ksbWV0aG9kOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9mcmVxdWVuY3lUb1VuaXRzKHBhcnNlRmxvYXQoZSkpfX0sdHI6e3JlZ2V4cDovXihcXGQrKD86XFwuXFxkKyk/KTooXFxkKyg/OlxcLlxcZCspPyk6PyhcXGQrKD86XFwuXFxkKyk/KT8vLG1ldGhvZDpmdW5jdGlvbihlLHQscil7dmFyIG49MDtyZXR1cm4gZSYmXCIwXCIhPT1lJiYobis9dGhpcy5fYmVhdHNUb1VuaXRzKHRoaXMuX3RpbWVTaWduYXR1cmUoKSpwYXJzZUZsb2F0KGUpKSksdCYmXCIwXCIhPT10JiYobis9dGhpcy5fYmVhdHNUb1VuaXRzKHBhcnNlRmxvYXQodCkpKSxyJiZcIjBcIiE9PXImJihuKz10aGlzLl9iZWF0c1RvVW5pdHMocGFyc2VGbG9hdChyKS80KSksbn19LHM6e3JlZ2V4cDovXihcXGQrKD86XFwuXFxkKyk/cykvLG1ldGhvZDpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fc2Vjb25kc1RvVW5pdHMocGFyc2VGbG9hdChlKSl9fSxzYW1wbGVzOntyZWdleHA6L14oXFxkKylzYW1wbGVzLyxtZXRob2Q6ZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUpL3RoaXMuY29udGV4dC5zYW1wbGVSYXRlfX0sZGVmYXVsdDp7cmVnZXhwOi9eKFxcZCsoPzpcXC5cXGQrKT8pLyxtZXRob2Q6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX3ByaW1hcnlFeHByZXNzaW9uc1t0aGlzLl9kZWZhdWx0VW5pdHNdLm1ldGhvZC5jYWxsKHRoaXMsZSl9fX0sbi5UaW1lQmFzZS5wcm90b3R5cGUuX2JpbmFyeUV4cHJlc3Npb25zPXtcIitcIjp7cmVnZXhwOi9eXFwrLyxwcmVjZWRlbmNlOjIsbWV0aG9kOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUoKSt0KCl9fSxcIi1cIjp7cmVnZXhwOi9eXFwtLyxwcmVjZWRlbmNlOjIsbWV0aG9kOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUoKS10KCl9fSxcIipcIjp7cmVnZXhwOi9eXFwqLyxwcmVjZWRlbmNlOjEsbWV0aG9kOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUoKSp0KCl9fSxcIi9cIjp7cmVnZXhwOi9eXFwvLyxwcmVjZWRlbmNlOjEsbWV0aG9kOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUoKS90KCl9fX0sbi5UaW1lQmFzZS5wcm90b3R5cGUuX3VuYXJ5RXhwcmVzc2lvbnM9e25lZzp7cmVnZXhwOi9eXFwtLyxtZXRob2Q6ZnVuY3Rpb24oZSl7cmV0dXJuLWUoKX19fSxuLlRpbWVCYXNlLnByb3RvdHlwZS5fc3ludGF4R2x1ZT17XCIoXCI6e3JlZ2V4cDovXlxcKC99LFwiKVwiOntyZWdleHA6L15cXCkvfX0sbi5UaW1lQmFzZS5wcm90b3R5cGUuX3Rva2VuaXplPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0tMSxyPVtdOzA8ZS5sZW5ndGg7KXt2YXIgbj1pKGU9ZS50cmltKCksdGhpcyk7ci5wdXNoKG4pLGU9ZS5zdWJzdHIobi52YWx1ZS5sZW5ndGgpfWZ1bmN0aW9uIGkoZSx0KXtmb3IodmFyIHI9W1wiX2JpbmFyeUV4cHJlc3Npb25zXCIsXCJfdW5hcnlFeHByZXNzaW9uc1wiLFwiX3ByaW1hcnlFeHByZXNzaW9uc1wiLFwiX3N5bnRheEdsdWVcIl0sbj0wO248ci5sZW5ndGg7bisrKXt2YXIgaT10W3Jbbl1dO2Zvcih2YXIgcyBpbiBpKXt2YXIgbz1pW3NdLHA9by5yZWdleHAsYT1lLm1hdGNoKHApO2lmKG51bGwhPT1hKXJldHVybnttZXRob2Q6by5tZXRob2QscHJlY2VkZW5jZTpvLnByZWNlZGVuY2UscmVnZXhwOm8ucmVnZXhwLHZhbHVlOmFbMF19fX10aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUb25lLlRpbWVCYXNlOiBVbmV4cGVjdGVkIHRva2VuIFwiK2UpfXJldHVybntuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHJbKyt0XX0scGVlazpmdW5jdGlvbigpe3JldHVybiByW3QrMV19fX0sbi5UaW1lQmFzZS5wcm90b3R5cGUuX21hdGNoR3JvdXA9ZnVuY3Rpb24oZSx0LHIpe2lmKCF0aGlzLmlzVW5kZWYoZSkpZm9yKHZhciBuIGluIHQpe3ZhciBpPXRbbl07aWYoaS5yZWdleHAudGVzdChlLnZhbHVlKSl7aWYodGhpcy5pc1VuZGVmKHIpKXJldHVybiBpO2lmKGkucHJlY2VkZW5jZT09PXIpcmV0dXJuIGl9fXJldHVybiExfSxuLlRpbWVCYXNlLnByb3RvdHlwZS5fcGFyc2VCaW5hcnk9ZnVuY3Rpb24oZSx0KXt2YXIgcjt0aGlzLmlzVW5kZWYodCkmJih0PTIpLHI9dDwwP3RoaXMuX3BhcnNlVW5hcnkoZSk6dGhpcy5fcGFyc2VCaW5hcnkoZSx0LTEpO2Zvcih2YXIgbj1lLnBlZWsoKTtuJiZ0aGlzLl9tYXRjaEdyb3VwKG4sdGhpcy5fYmluYXJ5RXhwcmVzc2lvbnMsdCk7KXI9KG49ZS5uZXh0KCkpLm1ldGhvZC5iaW5kKHRoaXMscix0aGlzLl9wYXJzZUJpbmFyeShlLHQtMSkpLG49ZS5wZWVrKCk7cmV0dXJuIHJ9LG4uVGltZUJhc2UucHJvdG90eXBlLl9wYXJzZVVuYXJ5PWZ1bmN0aW9uKGUpe3ZhciB0LHI7dD1lLnBlZWsoKTt2YXIgbj10aGlzLl9tYXRjaEdyb3VwKHQsdGhpcy5fdW5hcnlFeHByZXNzaW9ucyk7cmV0dXJuIG4/KHQ9ZS5uZXh0KCkscj10aGlzLl9wYXJzZVVuYXJ5KGUpLG4ubWV0aG9kLmJpbmQodGhpcyxyKSk6dGhpcy5fcGFyc2VQcmltYXJ5KGUpfSxuLlRpbWVCYXNlLnByb3RvdHlwZS5fcGFyc2VQcmltYXJ5PWZ1bmN0aW9uKGUpe3ZhciB0LHI7aWYodD1lLnBlZWsoKSx0aGlzLmlzVW5kZWYodCkpdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVG9uZS5UaW1lQmFzZTogVW5leHBlY3RlZCBlbmQgb2YgZXhwcmVzc2lvblwiKTtpZih0aGlzLl9tYXRjaEdyb3VwKHQsdGhpcy5fcHJpbWFyeUV4cHJlc3Npb25zKSl7dmFyIG49KHQ9ZS5uZXh0KCkpLnZhbHVlLm1hdGNoKHQucmVnZXhwKTtyZXR1cm4gdC5tZXRob2QuYmluZCh0aGlzLG5bMV0sblsyXSxuWzNdKX1pZih0JiZcIihcIj09PXQudmFsdWUpe2lmKGUubmV4dCgpLHI9dGhpcy5fcGFyc2VCaW5hcnkoZSksISh0PWUubmV4dCgpKXx8XCIpXCIhPT10LnZhbHVlKXRocm93IG5ldyBTeW50YXhFcnJvcihcIkV4cGVjdGVkIClcIik7cmV0dXJuIHJ9dGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVG9uZS5UaW1lQmFzZTogQ2Fubm90IHByb2Nlc3MgdG9rZW4gXCIrdC52YWx1ZSl9LG4uVGltZUJhc2UucHJvdG90eXBlLl9wYXJzZUV4cHJTdHJpbmc9ZnVuY3Rpb24oZSl7dGhpcy5pc1N0cmluZyhlKXx8KGU9ZS50b1N0cmluZygpKTt2YXIgdD10aGlzLl90b2tlbml6ZShlKTtyZXR1cm4gdGhpcy5fcGFyc2VCaW5hcnkodCl9LG4uVGltZUJhc2UucHJvdG90eXBlLl9ub09wPWZ1bmN0aW9uKCl7cmV0dXJuIDB9LG4uVGltZUJhc2UucHJvdG90eXBlLl9kZWZhdWx0RXhwcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9ub09wfSxuLlRpbWVCYXNlLnByb3RvdHlwZS5fZGVmYXVsdFVuaXRzPVwic1wiLG4uVGltZUJhc2UucHJvdG90eXBlLl9mcmVxdWVuY3lUb1VuaXRzPWZ1bmN0aW9uKGUpe3JldHVybiAxL2V9LG4uVGltZUJhc2UucHJvdG90eXBlLl9iZWF0c1RvVW5pdHM9ZnVuY3Rpb24oZSl7cmV0dXJuIDYwL24uVHJhbnNwb3J0LmJwbS52YWx1ZSplfSxuLlRpbWVCYXNlLnByb3RvdHlwZS5fc2Vjb25kc1RvVW5pdHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LG4uVGltZUJhc2UucHJvdG90eXBlLl90aWNrc1RvVW5pdHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGUqKHRoaXMuX2JlYXRzVG9Vbml0cygxKS9uLlRyYW5zcG9ydC5QUFEpfSxuLlRpbWVCYXNlLnByb3RvdHlwZS5fdGltZVNpZ25hdHVyZT1mdW5jdGlvbigpe3JldHVybiBuLlRyYW5zcG9ydC50aW1lU2lnbmF0dXJlfSxuLlRpbWVCYXNlLnByb3RvdHlwZS5fcHVzaEV4cHI9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBlIGluc3RhbmNlb2Ygbi5UaW1lQmFzZXx8KGU9bmV3IHRoaXMuY29uc3RydWN0b3IoZSxyKSksdGhpcy5fZXhwcj10aGlzLl9iaW5hcnlFeHByZXNzaW9uc1t0XS5tZXRob2QuYmluZCh0aGlzLHRoaXMuX2V4cHIsZS5fZXhwciksdGhpc30sbi5UaW1lQmFzZS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuX3B1c2hFeHByKGUsXCIrXCIsdCl9LG4uVGltZUJhc2UucHJvdG90eXBlLnN1Yj1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl9wdXNoRXhwcihlLFwiLVwiLHQpfSxuLlRpbWVCYXNlLnByb3RvdHlwZS5tdWx0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuX3B1c2hFeHByKGUsXCIqXCIsdCl9LG4uVGltZUJhc2UucHJvdG90eXBlLmRpdj1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl9wdXNoRXhwcihlLFwiL1wiLHQpfSxuLlRpbWVCYXNlLnByb3RvdHlwZS52YWx1ZU9mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2V4cHIoKX0sbi5UaW1lQmFzZS5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuX2V4cHI9bnVsbH0sbi5UaW1lQmFzZX0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygwKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDgpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIGEuUGFyYW09ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLFtcInBhcmFtXCIsXCJ1bml0c1wiLFwiY29udmVydFwiXSxhLlBhcmFtLmRlZmF1bHRzKTt0aGlzLl9wYXJhbT10aGlzLmlucHV0PXQucGFyYW0sdGhpcy51bml0cz10LnVuaXRzLHRoaXMuY29udmVydD10LmNvbnZlcnQsdGhpcy5vdmVycmlkZGVuPSExLHRoaXMuX2xmbz1udWxsLHRoaXMuaXNPYmplY3QodC5sZm8pP3RoaXMudmFsdWU9dC5sZm86dGhpcy5pc1VuZGVmKHQudmFsdWUpfHwodGhpcy52YWx1ZT10LnZhbHVlKX0sYS5leHRlbmQoYS5QYXJhbSksYS5QYXJhbS5kZWZhdWx0cz17dW5pdHM6YS5UeXBlLkRlZmF1bHQsY29udmVydDohMCxwYXJhbTp2b2lkIDB9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLlBhcmFtLnByb3RvdHlwZSxcInZhbHVlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl90b1VuaXRzKHRoaXMuX3BhcmFtLnZhbHVlKX0sc2V0OmZ1bmN0aW9uKHQpe2lmKHRoaXMuaXNPYmplY3QodCkpe2lmKHRoaXMuaXNVbmRlZihhLkxGTykpdGhyb3cgbmV3IEVycm9yKFwiSW5jbHVkZSAnVG9uZS5MRk8nIHRvIHVzZSBhbiBMRk8gYXMgYSBQYXJhbSB2YWx1ZS5cIik7dGhpcy5fbGZvJiZ0aGlzLl9sZm8uZGlzcG9zZSgpLHRoaXMuX2xmbz1uZXcgYS5MRk8odCkuc3RhcnQoKSx0aGlzLl9sZm8uY29ubmVjdCh0aGlzLmlucHV0KX1lbHNle3ZhciBlPXRoaXMuX2Zyb21Vbml0cyh0KTt0aGlzLl9wYXJhbS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoMCksdGhpcy5fcGFyYW0udmFsdWU9ZX19fSksYS5QYXJhbS5wcm90b3R5cGUuX2Zyb21Vbml0cz1mdW5jdGlvbih0KXtpZighdGhpcy5jb252ZXJ0JiYhdGhpcy5pc1VuZGVmKHRoaXMuY29udmVydCkpcmV0dXJuIHQ7c3dpdGNoKHRoaXMudW5pdHMpe2Nhc2UgYS5UeXBlLlRpbWU6cmV0dXJuIHRoaXMudG9TZWNvbmRzKHQpO2Nhc2UgYS5UeXBlLkZyZXF1ZW5jeTpyZXR1cm4gdGhpcy50b0ZyZXF1ZW5jeSh0KTtjYXNlIGEuVHlwZS5EZWNpYmVsczpyZXR1cm4gdGhpcy5kYlRvR2Fpbih0KTtjYXNlIGEuVHlwZS5Ob3JtYWxSYW5nZTpyZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodCwwKSwxKTtjYXNlIGEuVHlwZS5BdWRpb1JhbmdlOnJldHVybiBNYXRoLm1pbihNYXRoLm1heCh0LC0xKSwxKTtjYXNlIGEuVHlwZS5Qb3NpdGl2ZTpyZXR1cm4gTWF0aC5tYXgodCwwKTtkZWZhdWx0OnJldHVybiB0fX0sYS5QYXJhbS5wcm90b3R5cGUuX3RvVW5pdHM9ZnVuY3Rpb24odCl7aWYoIXRoaXMuY29udmVydCYmIXRoaXMuaXNVbmRlZih0aGlzLmNvbnZlcnQpKXJldHVybiB0O3N3aXRjaCh0aGlzLnVuaXRzKXtjYXNlIGEuVHlwZS5EZWNpYmVsczpyZXR1cm4gdGhpcy5nYWluVG9EYih0KTtkZWZhdWx0OnJldHVybiB0fX0sYS5QYXJhbS5wcm90b3R5cGUuX21pbk91dHB1dD0xZS01LGEuUGFyYW0ucHJvdG90eXBlLnNldFZhbHVlQXRUaW1lPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ9dGhpcy5fZnJvbVVuaXRzKHQpLChlPXRoaXMudG9TZWNvbmRzKGUpKTw9dGhpcy5ub3coKSt0aGlzLmJsb2NrVGltZT90aGlzLl9wYXJhbS52YWx1ZT10OnRoaXMuX3BhcmFtLnNldFZhbHVlQXRUaW1lKHQsZSksdGhpc30sYS5QYXJhbS5wcm90b3R5cGUuc2V0UmFtcFBvaW50PWZ1bmN0aW9uKHQpe3Q9dGhpcy5kZWZhdWx0QXJnKHQsdGhpcy5ub3coKSk7dmFyIGU9dGhpcy5fcGFyYW0udmFsdWU7cmV0dXJuIDA9PT1lJiYoZT10aGlzLl9taW5PdXRwdXQpLHRoaXMuX3BhcmFtLnNldFZhbHVlQXRUaW1lKGUsdCksdGhpc30sYS5QYXJhbS5wcm90b3R5cGUubGluZWFyUmFtcFRvVmFsdWVBdFRpbWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD10aGlzLl9mcm9tVW5pdHModCksdGhpcy5fcGFyYW0ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodCx0aGlzLnRvU2Vjb25kcyhlKSksdGhpc30sYS5QYXJhbS5wcm90b3R5cGUuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZT1mdW5jdGlvbih0LGUpe3JldHVybiB0PXRoaXMuX2Zyb21Vbml0cyh0KSx0PU1hdGgubWF4KHRoaXMuX21pbk91dHB1dCx0KSx0aGlzLl9wYXJhbS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHQsdGhpcy50b1NlY29uZHMoZSkpLHRoaXN9LGEuUGFyYW0ucHJvdG90eXBlLmV4cG9uZW50aWFsUmFtcFRvVmFsdWU9ZnVuY3Rpb24odCxlLGkpe3JldHVybiBpPXRoaXMudG9TZWNvbmRzKGkpLHRoaXMuc2V0UmFtcFBvaW50KGkpLHRoaXMuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh0LGkrdGhpcy50b1NlY29uZHMoZSkpLHRoaXN9LGEuUGFyYW0ucHJvdG90eXBlLmxpbmVhclJhbXBUb1ZhbHVlPWZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gaT10aGlzLnRvU2Vjb25kcyhpKSx0aGlzLnNldFJhbXBQb2ludChpKSx0aGlzLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHQsaSt0aGlzLnRvU2Vjb25kcyhlKSksdGhpc30sYS5QYXJhbS5wcm90b3R5cGUuc2V0VGFyZ2V0QXRUaW1lPWZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gdD10aGlzLl9mcm9tVW5pdHModCksdD1NYXRoLm1heCh0aGlzLl9taW5PdXRwdXQsdCksaT1NYXRoLm1heCh0aGlzLl9taW5PdXRwdXQsaSksdGhpcy5fcGFyYW0uc2V0VGFyZ2V0QXRUaW1lKHQsdGhpcy50b1NlY29uZHMoZSksaSksdGhpc30sYS5QYXJhbS5wcm90b3R5cGUuc2V0VmFsdWVDdXJ2ZUF0VGltZT1mdW5jdGlvbih0LGUsaSl7Zm9yKHZhciBhPTA7YTx0Lmxlbmd0aDthKyspdFthXT10aGlzLl9mcm9tVW5pdHModFthXSk7cmV0dXJuIHRoaXMuX3BhcmFtLnNldFZhbHVlQ3VydmVBdFRpbWUodCx0aGlzLnRvU2Vjb25kcyhlKSx0aGlzLnRvU2Vjb25kcyhpKSksdGhpc30sYS5QYXJhbS5wcm90b3R5cGUuY2FuY2VsU2NoZWR1bGVkVmFsdWVzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wYXJhbS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy50b1NlY29uZHModCkpLHRoaXN9LGEuUGFyYW0ucHJvdG90eXBlLnJhbXBUbz1mdW5jdGlvbih0LGUsaSl7cmV0dXJuIGU9dGhpcy5kZWZhdWx0QXJnKGUsMCksdGhpcy51bml0cz09PWEuVHlwZS5GcmVxdWVuY3l8fHRoaXMudW5pdHM9PT1hLlR5cGUuQlBNfHx0aGlzLnVuaXRzPT09YS5UeXBlLkRlY2liZWxzP3RoaXMuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZSh0LGUsaSk6dGhpcy5saW5lYXJSYW1wVG9WYWx1ZSh0LGUsaSksdGhpc30sT2JqZWN0LmRlZmluZVByb3BlcnR5KGEuUGFyYW0ucHJvdG90eXBlLFwibGZvXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9sZm99fSksYS5QYXJhbS5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3JldHVybiBhLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksdGhpcy5fcGFyYW09bnVsbCx0aGlzLl9sZm8mJih0aGlzLl9sZm8uZGlzcG9zZSgpLHRoaXMuX2xmbz1udWxsKSx0aGlzfSxhLlBhcmFtfSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgdmFyIHA1c291bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBBZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG4gIHZhciBNdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuICB2YXIgU2NhbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbiAgLyoqXG4gICAqICA8cD5DcmVhdGVzIGEgc2lnbmFsIHRoYXQgb3NjaWxsYXRlcyBiZXR3ZWVuIC0xLjAgYW5kIDEuMC5cbiAgICogIEJ5IGRlZmF1bHQsIHRoZSBvc2NpbGxhdGlvbiB0YWtlcyB0aGUgZm9ybSBvZiBhIHNpbnVzb2lkYWxcbiAgICogIHNoYXBlICgnc2luZScpLiBBZGRpdGlvbmFsIHR5cGVzIGluY2x1ZGUgJ3RyaWFuZ2xlJyxcbiAgICogICdzYXd0b290aCcgYW5kICdzcXVhcmUnLiBUaGUgZnJlcXVlbmN5IGRlZmF1bHRzIHRvXG4gICAqICA0NDAgb3NjaWxsYXRpb25zIHBlciBzZWNvbmQgKDQ0MEh6LCBlcXVhbCB0byB0aGUgcGl0Y2ggb2YgYW5cbiAgICogICdBJyBub3RlKS48L3A+XG4gICAqXG4gICAqICA8cD5TZXQgdGhlIHR5cGUgb2Ygb3NjaWxsYXRpb24gd2l0aCBzZXRUeXBlKCksIG9yIGJ5IGluc3RhbnRpYXRpbmcgYVxuICAgKiAgc3BlY2lmaWMgb3NjaWxsYXRvcjogPGEgaHJlZj1cIi9yZWZlcmVuY2UvIy9wNS5TaW5Pc2NcIj5wNS5TaW5Pc2M8L2E+LCA8YVxuICAgKiAgaHJlZj1cIi9yZWZlcmVuY2UvIy9wNS5UcmlPc2NcIj5wNS5UcmlPc2M8L2E+LCA8YVxuICAgKiAgaHJlZj1cIi9yZWZlcmVuY2UvIy9wNS5TcXJPc2NcIj5wNS5TcXJPc2M8L2E+LCBvciA8YVxuICAgKiAgaHJlZj1cIi9yZWZlcmVuY2UvIy9wNS5TYXdPc2NcIj5wNS5TYXdPc2M8L2E+LlxuICAgKiAgPC9wPlxuICAgKlxuICAgKiAgQGNsYXNzIHA1Lk9zY2lsbGF0b3JcbiAgICogIEBjb25zdHJ1Y3RvclxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtmcmVxXSBmcmVxdWVuY3kgZGVmYXVsdHMgdG8gNDQwSHpcbiAgICogIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gdHlwZSBvZiBvc2NpbGxhdG9yLiBPcHRpb25zOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAnc2luZScgKGRlZmF1bHQpLCAndHJpYW5nbGUnLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAnc2F3dG9vdGgnLCAnc3F1YXJlJ1xuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgb3NjLCBwbGF5aW5nLCBmcmVxLCBhbXA7XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQocGxheU9zY2lsbGF0b3IpO1xuICAgKiAgICBvc2MgPSBuZXcgcDUuT3NjaWxsYXRvcignc2luZScpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gZHJhdygpIHtcbiAgICogICAgYmFja2dyb3VuZCgyMjApXG4gICAqICAgIGZyZXEgPSBjb25zdHJhaW4obWFwKG1vdXNlWCwgMCwgd2lkdGgsIDEwMCwgNTAwKSwgMTAwLCA1MDApO1xuICAgKiAgICBhbXAgPSBjb25zdHJhaW4obWFwKG1vdXNlWSwgaGVpZ2h0LCAwLCAwLCAxKSwgMCwgMSk7XG4gICAqXG4gICAqICAgIHRleHQoJ3RhcCB0byBwbGF5JywgMjAsIDIwKTtcbiAgICogICAgdGV4dCgnZnJlcTogJyArIGZyZXEsIDIwLCA0MCk7XG4gICAqICAgIHRleHQoJ2FtcDogJyArIGFtcCwgMjAsIDYwKTtcbiAgICpcbiAgICogICAgaWYgKHBsYXlpbmcpIHtcbiAgICogICAgICAvLyBzbW9vdGggdGhlIHRyYW5zaXRpb25zIGJ5IDAuMSBzZWNvbmRzXG4gICAqICAgICAgb3NjLmZyZXEoZnJlcSwgMC4xKTtcbiAgICogICAgICBvc2MuYW1wKGFtcCwgMC4xKTtcbiAgICogICAgfVxuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gcGxheU9zY2lsbGF0b3IoKSB7XG4gICAqICAgIC8vIHN0YXJ0aW5nIGFuIG9zY2lsbGF0b3Igb24gYSB1c2VyIGdlc3R1cmUgd2lsbCBlbmFibGUgYXVkaW9cbiAgICogICAgLy8gaW4gYnJvd3NlcnMgdGhhdCBoYXZlIGEgc3RyaWN0IGF1dG9wbGF5IHBvbGljeS5cbiAgICogICAgLy8gU2VlIGFsc286IHVzZXJTdGFydEF1ZGlvKCk7XG4gICAqICAgIG9zYy5zdGFydCgpO1xuICAgKiAgICBwbGF5aW5nID0gdHJ1ZTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIG1vdXNlUmVsZWFzZWQoKSB7XG4gICAqICAgIC8vIHJhbXAgYW1wbGl0dWRlIHRvIDAgb3ZlciAwLjUgc2Vjb25kc1xuICAgKiAgICBvc2MuYW1wKDAsIDAuNSk7XG4gICAqICAgIHBsYXlpbmcgPSBmYWxzZTtcbiAgICogIH1cbiAgICogIDwvY29kZT4gPC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuT3NjaWxsYXRvciA9IGZ1bmN0aW9uIChmcmVxLCB0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiBmcmVxID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGYgPSB0eXBlO1xuICAgICAgdHlwZSA9IGZyZXE7XG4gICAgICBmcmVxID0gZjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgZiA9IHR5cGU7XG4gICAgICB0eXBlID0gZnJlcTtcbiAgICAgIGZyZXEgPSBmO1xuICAgIH1cblxuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlOyBcblxuICAgIHRoaXMucGhhc2VBbW91bnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vc2NpbGxhdG9yID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgIHRoaXMuZiA9IGZyZXEgfHwgNDQwLjA7IFxuXG4gICAgdGhpcy5vc2NpbGxhdG9yLnR5cGUgPSB0eXBlIHx8ICdzaW5lJztcbiAgICB0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5LnNldFZhbHVlQXRUaW1lKHRoaXMuZiwgcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWUpOyBcblxuICAgIHRoaXMub3V0cHV0ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgIHRoaXMuX2ZyZXFNb2RzID0gW107IFxuXG4gICAgdGhpcy5vdXRwdXQuZ2Fpbi52YWx1ZSA9IDAuNTtcbiAgICB0aGlzLm91dHB1dC5nYWluLnNldFZhbHVlQXRUaW1lKDAuNSwgcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWUpO1xuICAgIHRoaXMub3NjaWxsYXRvci5jb25uZWN0KHRoaXMub3V0cHV0KTsgXG5cbiAgICB0aGlzLnBhblBvc2l0aW9uID0gMC4wO1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IHA1c291bmQuaW5wdXQ7IFxuXG4gICAgdGhpcy5wYW5uZXIgPSBuZXcgcDUuUGFubmVyKHRoaXMub3V0cHV0LCB0aGlzLmNvbm5lY3Rpb24sIDEpOyBcblxuICAgIHRoaXMubWF0aE9wcyA9IFt0aGlzLm91dHB1dF07IFxuXG4gICAgcDVzb3VuZC5zb3VuZEFycmF5LnB1c2godGhpcyk7XG4gIH07XG4gIC8qKlxuICAgKiAgU3RhcnQgYW4gb3NjaWxsYXRvci5cbiAgICpcbiAgICogIFN0YXJ0aW5nIGFuIG9zY2lsbGF0b3Igb24gYSB1c2VyIGdlc3R1cmUgd2lsbCBlbmFibGUgYXVkaW8gaW4gYnJvd3NlcnNcbiAgICogIHRoYXQgaGF2ZSBhIHN0cmljdCBhdXRvcGxheSBwb2xpY3ksIGluY2x1ZGluZyBDaHJvbWUgYW5kIG1vc3QgbW9iaWxlXG4gICAqICBkZXZpY2VzLiBTZWUgYWxzbzogYHVzZXJTdGFydEF1ZGlvKClgLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgc3RhcnRcbiAgICogIEBmb3IgcDUuT3NjaWxsYXRvclxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbdGltZV0gc3RhcnRUaW1lIGluIHNlY29uZHMgZnJvbSBub3cuXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFtmcmVxdWVuY3ldIGZyZXF1ZW5jeSBpbiBIei5cbiAgICovXG5cblxuICBwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICh0aW1lLCBmKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5zdG9wKG5vdyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHZhciBmcmVxID0gZiB8fCB0aGlzLmY7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMub3NjaWxsYXRvci50eXBlOyBcblxuICAgICAgaWYgKHRoaXMub3NjaWxsYXRvcikge1xuICAgICAgICB0aGlzLm9zY2lsbGF0b3IuZGlzY29ubmVjdCgpO1xuICAgICAgICBkZWxldGUgdGhpcy5vc2NpbGxhdG9yO1xuICAgICAgfSBcblxuXG4gICAgICB0aGlzLm9zY2lsbGF0b3IgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jcmVhdGVPc2NpbGxhdG9yKCk7XG4gICAgICB0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5LnZhbHVlID0gTWF0aC5hYnMoZnJlcSk7XG4gICAgICB0aGlzLm9zY2lsbGF0b3IudHlwZSA9IHR5cGU7IFxuXG4gICAgICB0aGlzLm9zY2lsbGF0b3IuY29ubmVjdCh0aGlzLm91dHB1dCk7XG4gICAgICB0aW1lID0gdGltZSB8fCAwO1xuICAgICAgdGhpcy5vc2NpbGxhdG9yLnN0YXJ0KHRpbWUgKyBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgICB0aGlzLmZyZXFOb2RlID0gdGhpcy5vc2NpbGxhdG9yLmZyZXF1ZW5jeTsgXG5cbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fZnJlcU1vZHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9mcmVxTW9kc1tpXS5jb25uZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRoaXMuX2ZyZXFNb2RzW2ldLmNvbm5lY3QodGhpcy5vc2NpbGxhdG9yLmZyZXF1ZW5jeSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgU3RvcCBhbiBvc2NpbGxhdG9yLiBBY2NlcHRzIGFuIG9wdGlvbmFsIHBhcmFtZXRlclxuICAgKiAgdG8gZGV0ZXJtaW5lIGhvdyBsb25nIChpbiBzZWNvbmRzIGZyb20gbm93KSB1bnRpbCB0aGVcbiAgICogIG9zY2lsbGF0b3Igc3RvcHMuXG4gICAqXG4gICAqICBAbWV0aG9kICBzdG9wXG4gICAqICBAZm9yIHA1Lk9zY2lsbGF0b3JcbiAgICogIEBwYXJhbSAge051bWJlcn0gc2Vjb25kc0Zyb21Ob3cgVGltZSwgaW4gc2Vjb25kcyBmcm9tIG5vdy5cbiAgICovXG5cblxuICBwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICB2YXIgdCA9IHRpbWUgfHwgMDtcbiAgICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICAgIHRoaXMub3NjaWxsYXRvci5zdG9wKHQgKyBub3cpO1xuICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIFNldCB0aGUgYW1wbGl0dWRlIGJldHdlZW4gMCBhbmQgMS4wLiBPciwgcGFzcyBpbiBhbiBvYmplY3RcbiAgICogIHN1Y2ggYXMgYW4gb3NjaWxsYXRvciB0byBtb2R1bGF0ZSBhbXBsaXR1ZGUgd2l0aCBhbiBhdWRpbyBzaWduYWwuXG4gICAqXG4gICAqICBAbWV0aG9kICBhbXBcbiAgICogIEBmb3IgcDUuT3NjaWxsYXRvclxuICAgKiAgQHBhcmFtICB7TnVtYmVyfE9iamVjdH0gdm9sIGJldHdlZW4gMCBhbmQgMS4wXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgYSBtb2R1bGF0aW5nIHNpZ25hbC9vc2NpbGxhdG9yXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3JhbXBUaW1lXSBjcmVhdGUgYSBmYWRlIHRoYXQgbGFzdHMgcmFtcFRpbWVcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbdGltZUZyb21Ob3ddIHNjaGVkdWxlIHRoaXMgZXZlbnQgdG8gaGFwcGVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRzIGZyb20gbm93XG4gICAqICBAcmV0dXJuICB7QXVkaW9QYXJhbX0gZ2FpbiAgSWYgbm8gdmFsdWUgaXMgcHJvdmlkZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJucyB0aGUgV2ViIEF1ZGlvIEFQSVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1ZGlvUGFyYW0gdGhhdCBjb250cm9sc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgb3NjaWxsYXRvcidzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2Fpbi9hbXBsaXR1ZGUvdm9sdW1lKVxuICAgKi9cblxuXG4gIHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlLmFtcCA9IGZ1bmN0aW9uICh2b2wsIHJhbXBUaW1lLCB0RnJvbU5vdykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0eXBlb2Ygdm9sID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHJhbXBUaW1lID0gcmFtcFRpbWUgfHwgMDtcbiAgICAgIHZhciB0RnJvbU5vdyA9IHRGcm9tTm93IHx8IDA7XG4gICAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICB0aGlzLm91dHB1dC5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZvbCwgbm93ICsgdEZyb21Ob3cgKyByYW1wVGltZSk7XG4gICAgfSBlbHNlIGlmICh2b2wpIHtcbiAgICAgIHZvbC5jb25uZWN0KHNlbGYub3V0cHV0LmdhaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5vdXRwdXQuZ2FpbjtcbiAgICB9XG4gIH07IFxuXG5cbiAgcDUuT3NjaWxsYXRvci5wcm90b3R5cGUuZmFkZSA9IHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlLmFtcDtcblxuICBwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5nZXRBbXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0LmdhaW4udmFsdWU7XG4gIH07XG4gIC8qKlxuICAgKiAgU2V0IGZyZXF1ZW5jeSBvZiBhbiBvc2NpbGxhdG9yIHRvIGEgdmFsdWUuIE9yLCBwYXNzIGluIGFuIG9iamVjdFxuICAgKiAgc3VjaCBhcyBhbiBvc2NpbGxhdG9yIHRvIG1vZHVsYXRlIHRoZSBmcmVxdWVuY3kgd2l0aCBhbiBhdWRpbyBzaWduYWwuXG4gICAqXG4gICAqICBAbWV0aG9kICBmcmVxXG4gICAqICBAZm9yIHA1Lk9zY2lsbGF0b3JcbiAgICogIEBwYXJhbSAge051bWJlcnxPYmplY3R9IEZyZXF1ZW5jeSBGcmVxdWVuY3kgaW4gSHpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgbW9kdWxhdGluZyBzaWduYWwvb3NjaWxsYXRvclxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbcmFtcFRpbWVdIFJhbXAgdGltZSAoaW4gc2Vjb25kcylcbiAgICogIEBwYXJhbSAge051bWJlcn0gW3RpbWVGcm9tTm93XSBTY2hlZHVsZSB0aGlzIGV2ZW50IHRvIGhhcHBlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXQgeCBzZWNvbmRzIGZyb20gbm93XG4gICAqICBAcmV0dXJuICB7QXVkaW9QYXJhbX0gRnJlcXVlbmN5IElmIG5vIHZhbHVlIGlzIHByb3ZpZGVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5zIHRoZSBXZWIgQXVkaW8gQVBJXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1ZGlvUGFyYW0gdGhhdCBjb250cm9sc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIG9zY2lsbGF0b3IncyBmcmVxdWVuY3lcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IG9zYztcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChwbGF5T3NjaWxsYXRvcik7XG4gICAqICAgIG9zYyA9IG5ldyBwNS5Pc2NpbGxhdG9yKDMwMCk7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCAyMCwgMjApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gcGxheU9zY2lsbGF0b3IoKSB7XG4gICAqICAgIG9zYy5zdGFydCgpO1xuICAgKiAgICBvc2MuYW1wKDAuNSk7XG4gICAqICAgIC8vIHN0YXJ0IGF0IDcwMEh6XG4gICAqICAgIG9zYy5mcmVxKDcwMCk7XG4gICAqICAgIC8vIHJhbXAgdG8gNjBIeiBvdmVyIDAuNyBzZWNvbmRzXG4gICAqICAgIG9zYy5mcmVxKDYwLCAwLjcpO1xuICAgKiAgICBvc2MuYW1wKDAsIDAuMSwgMC43KTtcbiAgICogIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5mcmVxID0gZnVuY3Rpb24gKHZhbCwgcmFtcFRpbWUsIHRGcm9tTm93KSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpKSB7XG4gICAgICB0aGlzLmYgPSB2YWw7XG4gICAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICB2YXIgcmFtcFRpbWUgPSByYW1wVGltZSB8fCAwO1xuICAgICAgdmFyIHRGcm9tTm93ID0gdEZyb21Ob3cgfHwgMDtcbiAgICAgIHZhciB0ID0gbm93ICsgdEZyb21Ob3cgKyByYW1wVGltZTsgXG5cbiAgICAgIGlmIChyYW1wVGltZSA9PT0gMCkge1xuICAgICAgICB0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5LnNldFZhbHVlQXRUaW1lKHZhbCwgdEZyb21Ob3cgKyBub3cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHZhbCA+IDApIHtcbiAgICAgICAgICB0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5LmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodmFsLCB0RnJvbU5vdyArIHJhbXBUaW1lICsgbm93KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5LmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZhbCwgdEZyb21Ob3cgKyByYW1wVGltZSArIG5vdyk7XG4gICAgICAgIH1cbiAgICAgIH0gXG5cblxuICAgICAgaWYgKHRoaXMucGhhc2VBbW91bnQpIHtcbiAgICAgICAgdGhpcy5waGFzZSh0aGlzLnBoYXNlQW1vdW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbCkge1xuICAgICAgaWYgKHZhbC5vdXRwdXQpIHtcbiAgICAgICAgdmFsID0gdmFsLm91dHB1dDtcbiAgICAgIH1cblxuICAgICAgdmFsLmNvbm5lY3QodGhpcy5vc2NpbGxhdG9yLmZyZXF1ZW5jeSk7IFxuXG4gICAgICB0aGlzLl9mcmVxTW9kcy5wdXNoKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5O1xuICAgIH1cbiAgfTtcblxuICBwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5nZXRGcmVxID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5LnZhbHVlO1xuICB9O1xuICAvKipcbiAgICogIFNldCB0eXBlIHRvICdzaW5lJywgJ3RyaWFuZ2xlJywgJ3Nhd3Rvb3RoJyBvciAnc3F1YXJlJy5cbiAgICpcbiAgICogIEBtZXRob2QgIHNldFR5cGVcbiAgICogIEBmb3IgcDUuT3NjaWxsYXRvclxuICAgKiAgQHBhcmFtIHtTdHJpbmd9IHR5cGUgJ3NpbmUnLCAndHJpYW5nbGUnLCAnc2F3dG9vdGgnIG9yICdzcXVhcmUnLlxuICAgKi9cblxuXG4gIHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlLnNldFR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHRoaXMub3NjaWxsYXRvci50eXBlID0gdHlwZTtcbiAgfTtcblxuICBwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm9zY2lsbGF0b3IudHlwZTtcbiAgfTtcbiAgLyoqXG4gICAqICBDb25uZWN0IHRvIGEgcDUuc291bmQgLyBXZWIgQXVkaW8gb2JqZWN0LlxuICAgKlxuICAgKiAgQG1ldGhvZCAgY29ubmVjdFxuICAgKiAgQGZvciBwNS5Pc2NpbGxhdG9yXG4gICAqICBAcGFyYW0gIHtPYmplY3R9IHVuaXQgQSBwNS5zb3VuZCBvciBXZWIgQXVkaW8gb2JqZWN0XG4gICAqL1xuXG5cbiAgcDUuT3NjaWxsYXRvci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh1bml0KSB7XG4gICAgaWYgKCF1bml0KSB7XG4gICAgICB0aGlzLnBhbm5lci5jb25uZWN0KHA1c291bmQuaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAodW5pdC5oYXNPd25Qcm9wZXJ0eSgnaW5wdXQnKSkge1xuICAgICAgdGhpcy5wYW5uZXIuY29ubmVjdCh1bml0LmlucHV0KTtcbiAgICAgIHRoaXMuY29ubmVjdGlvbiA9IHVuaXQuaW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFubmVyLmNvbm5lY3QodW5pdCk7XG4gICAgICB0aGlzLmNvbm5lY3Rpb24gPSB1bml0O1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBEaXNjb25uZWN0IGFsbCBvdXRwdXRzXG4gICAqXG4gICAqICBAbWV0aG9kICBkaXNjb25uZWN0XG4gICAqICBAZm9yIHA1Lk9zY2lsbGF0b3JcbiAgICovXG5cblxuICBwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm91dHB1dCkge1xuICAgICAgdGhpcy5vdXRwdXQuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhbm5lcikge1xuICAgICAgdGhpcy5wYW5uZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICBpZiAodGhpcy5vdXRwdXQpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQuY29ubmVjdCh0aGlzLnBhbm5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5vc2NNb2RzID0gW107XG4gIH07XG4gIC8qKlxuICAgKiAgUGFuIGJldHdlZW4gTGVmdCAoLTEpIGFuZCBSaWdodCAoMSlcbiAgICpcbiAgICogIEBtZXRob2QgIHBhblxuICAgKiAgQGZvciBwNS5Pc2NpbGxhdG9yXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IHBhbm5pbmcgTnVtYmVyIGJldHdlZW4gLTEgYW5kIDFcbiAgICogIEBwYXJhbSAge051bWJlcn0gdGltZUZyb21Ob3cgc2NoZWR1bGUgdGhpcyBldmVudCB0byBoYXBwZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZHMgZnJvbSBub3dcbiAgICovXG5cblxuICBwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5wYW4gPSBmdW5jdGlvbiAocHZhbCwgdEZyb21Ob3cpIHtcbiAgICB0aGlzLnBhblBvc2l0aW9uID0gcHZhbDtcbiAgICB0aGlzLnBhbm5lci5wYW4ocHZhbCwgdEZyb21Ob3cpO1xuICB9O1xuXG4gIHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlLmdldFBhbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYW5Qb3NpdGlvbjtcbiAgfTsgXG5cblxuICBwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmRleCA9IHA1c291bmQuc291bmRBcnJheS5pbmRleE9mKHRoaXMpO1xuICAgIHA1c291bmQuc291bmRBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgaWYgKHRoaXMub3NjaWxsYXRvcikge1xuICAgICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5zdG9wKG5vdyk7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMucGFubmVyID0gbnVsbDtcbiAgICAgIHRoaXMub3NjaWxsYXRvciA9IG51bGw7XG4gICAgfSBcblxuXG4gICAgaWYgKHRoaXMub3NjMikge1xuICAgICAgdGhpcy5vc2MyLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgU2V0IHRoZSBwaGFzZSBvZiBhbiBvc2NpbGxhdG9yIGJldHdlZW4gMC4wIGFuZCAxLjAuXG4gICAqICBJbiB0aGlzIGltcGxlbWVudGF0aW9uLCBwaGFzZSBpcyBhIGRlbGF5IHRpbWVcbiAgICogIGJhc2VkIG9uIHRoZSBvc2NpbGxhdG9yJ3MgY3VycmVudCBmcmVxdWVuY3kuXG4gICAqXG4gICAqICBAbWV0aG9kICBwaGFzZVxuICAgKiAgQGZvciBwNS5Pc2NpbGxhdG9yXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IHBoYXNlIGZsb2F0IGJldHdlZW4gMC4wIGFuZCAxLjBcbiAgICovXG5cblxuICBwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5waGFzZSA9IGZ1bmN0aW9uIChwKSB7XG4gICAgdmFyIGRlbGF5QW10ID0gcDUucHJvdG90eXBlLm1hcChwLCAwLCAxLjAsIDAsIDEgLyB0aGlzLmYpO1xuICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICB0aGlzLnBoYXNlQW1vdW50ID0gcDtcblxuICAgIGlmICghdGhpcy5kTm9kZSkge1xuICAgICAgdGhpcy5kTm9kZSA9IHA1c291bmQuYXVkaW9jb250ZXh0LmNyZWF0ZURlbGF5KCk7IFxuXG4gICAgICB0aGlzLm9zY2lsbGF0b3IuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5vc2NpbGxhdG9yLmNvbm5lY3QodGhpcy5kTm9kZSk7XG4gICAgICB0aGlzLmROb2RlLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuICAgIH0gXG5cblxuICAgIHRoaXMuZE5vZGUuZGVsYXlUaW1lLnNldFZhbHVlQXRUaW1lKGRlbGF5QW10LCBub3cpO1xuICB9OyBcblxuXG4gIHZhciBzaWdDaGFpbiA9IGZ1bmN0aW9uIHNpZ0NoYWluKG8sIG1hdGhPYmosIHRoaXNDaGFpbiwgbmV4dENoYWluLCB0eXBlKSB7XG4gICAgdmFyIGNoYWluU291cmNlID0gby5vc2NpbGxhdG9yOyBcblxuICAgIGZvciAodmFyIGkgaW4gby5tYXRoT3BzKSB7XG4gICAgICBpZiAoby5tYXRoT3BzW2ldIGluc3RhbmNlb2YgdHlwZSkge1xuICAgICAgICBjaGFpblNvdXJjZS5kaXNjb25uZWN0KCk7XG4gICAgICAgIG8ubWF0aE9wc1tpXS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXNDaGFpbiA9IGk7IFxuXG4gICAgICAgIGlmICh0aGlzQ2hhaW4gPCBvLm1hdGhPcHMubGVuZ3RoIC0gMikge1xuICAgICAgICAgIG5leHRDaGFpbiA9IG8ubWF0aE9wc1tpICsgMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpc0NoYWluID09PSBvLm1hdGhPcHMubGVuZ3RoIC0gMSkge1xuICAgICAgby5tYXRoT3BzLnB1c2gobmV4dENoYWluKTtcbiAgICB9IFxuXG5cbiAgICBpZiAoaSA+IDApIHtcbiAgICAgIGNoYWluU291cmNlID0gby5tYXRoT3BzW2kgLSAxXTtcbiAgICB9XG5cbiAgICBjaGFpblNvdXJjZS5kaXNjb25uZWN0KCk7XG4gICAgY2hhaW5Tb3VyY2UuY29ubmVjdChtYXRoT2JqKTtcbiAgICBtYXRoT2JqLmNvbm5lY3QobmV4dENoYWluKTtcbiAgICBvLm1hdGhPcHNbdGhpc0NoYWluXSA9IG1hdGhPYmo7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIC8qKlxuICAgKiAgQWRkIGEgdmFsdWUgdG8gdGhlIHA1Lk9zY2lsbGF0b3IncyBvdXRwdXQgYW1wbGl0dWRlLFxuICAgKiAgYW5kIHJldHVybiB0aGUgb3NjaWxsYXRvci4gQ2FsbGluZyB0aGlzIG1ldGhvZCBhZ2FpblxuICAgKiAgd2lsbCBvdmVycmlkZSB0aGUgaW5pdGlhbCBhZGQoKSB3aXRoIGEgbmV3IHZhbHVlLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgYWRkXG4gICAqICBAZm9yIHA1Lk9zY2lsbGF0b3JcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgQ29uc3RhbnQgbnVtYmVyIHRvIGFkZFxuICAgKiAgQHJldHVybiB7cDUuT3NjaWxsYXRvcn0gT3NjaWxsYXRvciBSZXR1cm5zIHRoaXMgb3NjaWxsYXRvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHNjYWxlZCBvdXRwdXRcbiAgICpcbiAgICovXG5cblxuICBwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgdmFyIGFkZCA9IG5ldyBBZGQobnVtKTtcbiAgICB2YXIgdGhpc0NoYWluID0gdGhpcy5tYXRoT3BzLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5leHRDaGFpbiA9IHRoaXMub3V0cHV0O1xuICAgIHJldHVybiBzaWdDaGFpbih0aGlzLCBhZGQsIHRoaXNDaGFpbiwgbmV4dENoYWluLCBBZGQpO1xuICB9O1xuICAvKipcbiAgICogIE11bHRpcGx5IHRoZSBwNS5Pc2NpbGxhdG9yJ3Mgb3V0cHV0IGFtcGxpdHVkZVxuICAgKiAgYnkgYSBmaXhlZCB2YWx1ZSAoaS5lLiB0dXJuIGl0IHVwISkuIENhbGxpbmcgdGhpcyBtZXRob2RcbiAgICogIGFnYWluIHdpbGwgb3ZlcnJpZGUgdGhlIGluaXRpYWwgbXVsdCgpIHdpdGggYSBuZXcgdmFsdWUuXG4gICAqXG4gICAqICBAbWV0aG9kICBtdWx0XG4gICAqICBAZm9yIHA1Lk9zY2lsbGF0b3JcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgQ29uc3RhbnQgbnVtYmVyIHRvIG11bHRpcGx5XG4gICAqICBAcmV0dXJuIHtwNS5Pc2NpbGxhdG9yfSBPc2NpbGxhdG9yIFJldHVybnMgdGhpcyBvc2NpbGxhdG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggbXVsdGlwbGllZCBvdXRwdXRcbiAgICovXG5cblxuICBwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5tdWx0ID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHZhciBtdWx0ID0gbmV3IE11bHQobnVtKTtcbiAgICB2YXIgdGhpc0NoYWluID0gdGhpcy5tYXRoT3BzLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5leHRDaGFpbiA9IHRoaXMub3V0cHV0O1xuICAgIHJldHVybiBzaWdDaGFpbih0aGlzLCBtdWx0LCB0aGlzQ2hhaW4sIG5leHRDaGFpbiwgTXVsdCk7XG4gIH07XG4gIC8qKlxuICAgKiAgU2NhbGUgdGhpcyBvc2NpbGxhdG9yJ3MgYW1wbGl0dWRlIHZhbHVlcyB0byBhIGdpdmVuXG4gICAqICByYW5nZSwgYW5kIHJldHVybiB0aGUgb3NjaWxsYXRvci4gQ2FsbGluZyB0aGlzIG1ldGhvZFxuICAgKiAgYWdhaW4gd2lsbCBvdmVycmlkZSB0aGUgaW5pdGlhbCBzY2FsZSgpIHdpdGggbmV3IHZhbHVlcy5cbiAgICpcbiAgICogIEBtZXRob2QgIHNjYWxlXG4gICAqICBAZm9yIHA1Lk9zY2lsbGF0b3JcbiAgICogIEBwYXJhbSAge051bWJlcn0gaW5NaW4gIGlucHV0IHJhbmdlIG1pbnVtdW1cbiAgICogIEBwYXJhbSAge051bWJlcn0gaW5NYXggIGlucHV0IHJhbmdlIG1heGltdW1cbiAgICogIEBwYXJhbSAge051bWJlcn0gb3V0TWluIGlucHV0IHJhbmdlIG1pbnVtdW1cbiAgICogIEBwYXJhbSAge051bWJlcn0gb3V0TWF4IGlucHV0IHJhbmdlIG1heGltdW1cbiAgICogIEByZXR1cm4ge3A1Lk9zY2lsbGF0b3J9IE9zY2lsbGF0b3IgUmV0dXJucyB0aGlzIG9zY2lsbGF0b3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBzY2FsZWQgb3V0cHV0XG4gICAqL1xuXG5cbiAgcDUuT3NjaWxsYXRvci5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbiAoaW5NaW4sIGluTWF4LCBvdXRNaW4sIG91dE1heCkge1xuICAgIHZhciBtYXBPdXRNaW4sIG1hcE91dE1heDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICBtYXBPdXRNaW4gPSBwNS5wcm90b3R5cGUubWFwKG91dE1pbiwgaW5NaW4sIGluTWF4LCAwLCAxKSAtIDAuNTtcbiAgICAgIG1hcE91dE1heCA9IHA1LnByb3RvdHlwZS5tYXAob3V0TWF4LCBpbk1pbiwgaW5NYXgsIDAsIDEpIC0gMC41O1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXBPdXRNaW4gPSBhcmd1bWVudHNbMF07XG4gICAgICBtYXBPdXRNYXggPSBhcmd1bWVudHNbMV07XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlID0gbmV3IFNjYWxlKG1hcE91dE1pbiwgbWFwT3V0TWF4KTtcbiAgICB2YXIgdGhpc0NoYWluID0gdGhpcy5tYXRoT3BzLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5leHRDaGFpbiA9IHRoaXMub3V0cHV0O1xuICAgIHJldHVybiBzaWdDaGFpbih0aGlzLCBzY2FsZSwgdGhpc0NoYWluLCBuZXh0Q2hhaW4sIFNjYWxlKTsgXG4gIH07IFxuXG4gIC8qKlxuICAgKiAgQ29uc3RydWN0b3I6IDxjb2RlPm5ldyBwNS5TaW5Pc2MoKTwvY29kZT4uXG4gICAqICBUaGlzIGNyZWF0ZXMgYSBTaW5lIFdhdmUgT3NjaWxsYXRvciBhbmQgaXNcbiAgICogIGVxdWl2YWxlbnQgdG8gPGNvZGU+IG5ldyBwNS5Pc2NpbGxhdG9yKCdzaW5lJylcbiAgICogIDwvY29kZT4gb3IgY3JlYXRpbmcgYSBwNS5Pc2NpbGxhdG9yIGFuZCB0aGVuIGNhbGxpbmdcbiAgICogIGl0cyBtZXRob2QgPGNvZGU+c2V0VHlwZSgnc2luZScpPC9jb2RlPi5cbiAgICogIFNlZSBwNS5Pc2NpbGxhdG9yIGZvciBtZXRob2RzLlxuICAgKlxuICAgKiAgQGNsYXNzICBwNS5TaW5Pc2NcbiAgICogIEBjb25zdHJ1Y3RvclxuICAgKiAgQGV4dGVuZHMgcDUuT3NjaWxsYXRvclxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtmcmVxXSBTZXQgdGhlIGZyZXF1ZW5jeVxuICAgKi9cblxuXG4gIHA1LlNpbk9zYyA9IGZ1bmN0aW9uIChmcmVxKSB7XG4gICAgcDUuT3NjaWxsYXRvci5jYWxsKHRoaXMsIGZyZXEsICdzaW5lJyk7XG4gIH07XG5cbiAgcDUuU2luT3NjLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocDUuT3NjaWxsYXRvci5wcm90b3R5cGUpO1xuICAvKipcbiAgICogIENvbnN0cnVjdG9yOiA8Y29kZT5uZXcgcDUuVHJpT3NjKCk8L2NvZGU+LlxuICAgKiAgVGhpcyBjcmVhdGVzIGEgVHJpYW5nbGUgV2F2ZSBPc2NpbGxhdG9yIGFuZCBpc1xuICAgKiAgZXF1aXZhbGVudCB0byA8Y29kZT5uZXcgcDUuT3NjaWxsYXRvcigndHJpYW5nbGUnKVxuICAgKiAgPC9jb2RlPiBvciBjcmVhdGluZyBhIHA1Lk9zY2lsbGF0b3IgYW5kIHRoZW4gY2FsbGluZ1xuICAgKiAgaXRzIG1ldGhvZCA8Y29kZT5zZXRUeXBlKCd0cmlhbmdsZScpPC9jb2RlPi5cbiAgICogIFNlZSBwNS5Pc2NpbGxhdG9yIGZvciBtZXRob2RzLlxuICAgKlxuICAgKiAgQGNsYXNzICBwNS5UcmlPc2NcbiAgICogIEBjb25zdHJ1Y3RvclxuICAgKiAgQGV4dGVuZHMgcDUuT3NjaWxsYXRvclxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtmcmVxXSBTZXQgdGhlIGZyZXF1ZW5jeVxuICAgKi9cblxuICBwNS5UcmlPc2MgPSBmdW5jdGlvbiAoZnJlcSkge1xuICAgIHA1Lk9zY2lsbGF0b3IuY2FsbCh0aGlzLCBmcmVxLCAndHJpYW5nbGUnKTtcbiAgfTtcblxuICBwNS5UcmlPc2MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZSk7XG4gIC8qKlxuICAgKiAgQ29uc3RydWN0b3I6IDxjb2RlPm5ldyBwNS5TYXdPc2MoKTwvY29kZT4uXG4gICAqICBUaGlzIGNyZWF0ZXMgYSBTYXdUb290aCBXYXZlIE9zY2lsbGF0b3IgYW5kIGlzXG4gICAqICBlcXVpdmFsZW50IHRvIDxjb2RlPiBuZXcgcDUuT3NjaWxsYXRvcignc2F3dG9vdGgnKVxuICAgKiAgPC9jb2RlPiBvciBjcmVhdGluZyBhIHA1Lk9zY2lsbGF0b3IgYW5kIHRoZW4gY2FsbGluZ1xuICAgKiAgaXRzIG1ldGhvZCA8Y29kZT5zZXRUeXBlKCdzYXd0b290aCcpPC9jb2RlPi5cbiAgICogIFNlZSBwNS5Pc2NpbGxhdG9yIGZvciBtZXRob2RzLlxuICAgKlxuICAgKiAgQGNsYXNzICBwNS5TYXdPc2NcbiAgICogIEBjb25zdHJ1Y3RvclxuICAgKiAgQGV4dGVuZHMgcDUuT3NjaWxsYXRvclxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtmcmVxXSBTZXQgdGhlIGZyZXF1ZW5jeVxuICAgKi9cblxuICBwNS5TYXdPc2MgPSBmdW5jdGlvbiAoZnJlcSkge1xuICAgIHA1Lk9zY2lsbGF0b3IuY2FsbCh0aGlzLCBmcmVxLCAnc2F3dG9vdGgnKTtcbiAgfTtcblxuICBwNS5TYXdPc2MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZSk7XG4gIC8qKlxuICAgKiAgQ29uc3RydWN0b3I6IDxjb2RlPm5ldyBwNS5TcXJPc2MoKTwvY29kZT4uXG4gICAqICBUaGlzIGNyZWF0ZXMgYSBTcXVhcmUgV2F2ZSBPc2NpbGxhdG9yIGFuZCBpc1xuICAgKiAgZXF1aXZhbGVudCB0byA8Y29kZT4gbmV3IHA1Lk9zY2lsbGF0b3IoJ3NxdWFyZScpXG4gICAqICA8L2NvZGU+IG9yIGNyZWF0aW5nIGEgcDUuT3NjaWxsYXRvciBhbmQgdGhlbiBjYWxsaW5nXG4gICAqICBpdHMgbWV0aG9kIDxjb2RlPnNldFR5cGUoJ3NxdWFyZScpPC9jb2RlPi5cbiAgICogIFNlZSBwNS5Pc2NpbGxhdG9yIGZvciBtZXRob2RzLlxuICAgKlxuICAgKiAgQGNsYXNzICBwNS5TcXJPc2NcbiAgICogIEBjb25zdHJ1Y3RvclxuICAgKiAgQGV4dGVuZHMgcDUuT3NjaWxsYXRvclxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtmcmVxXSBTZXQgdGhlIGZyZXF1ZW5jeVxuICAgKi9cblxuICBwNS5TcXJPc2MgPSBmdW5jdGlvbiAoZnJlcSkge1xuICAgIHA1Lk9zY2lsbGF0b3IuY2FsbCh0aGlzLCBmcmVxLCAnc3F1YXJlJyk7XG4gIH07XG5cbiAgcDUuU3FyT3NjLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocDUuT3NjaWxsYXRvci5wcm90b3R5cGUpO1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygwKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDgpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24oaSl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIGkuVGltZWxpbmU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm9wdGlvbnNPYmplY3QoYXJndW1lbnRzLFtcIm1lbW9yeVwiXSxpLlRpbWVsaW5lLmRlZmF1bHRzKTt0aGlzLl90aW1lbGluZT1bXSx0aGlzLl90b1JlbW92ZT1bXSx0aGlzLl9pdGVyYXRpbmc9ITEsdGhpcy5tZW1vcnk9ZS5tZW1vcnl9LGkuZXh0ZW5kKGkuVGltZWxpbmUpLGkuVGltZWxpbmUuZGVmYXVsdHM9e21lbW9yeToxLzB9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLlRpbWVsaW5lLnByb3RvdHlwZSxcImxlbmd0aFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdGltZWxpbmUubGVuZ3RofX0pLGkuVGltZWxpbmUucHJvdG90eXBlLmFkZD1mdW5jdGlvbihlKXtpZih0aGlzLmlzVW5kZWYoZS50aW1lKSl0aHJvdyBuZXcgRXJyb3IoXCJUb25lLlRpbWVsaW5lOiBldmVudHMgbXVzdCBoYXZlIGEgdGltZSBhdHRyaWJ1dGVcIik7aWYodGhpcy5fdGltZWxpbmUubGVuZ3RoKXt2YXIgaT10aGlzLl9zZWFyY2goZS50aW1lKTt0aGlzLl90aW1lbGluZS5zcGxpY2UoaSsxLDAsZSl9ZWxzZSB0aGlzLl90aW1lbGluZS5wdXNoKGUpO2lmKHRoaXMubGVuZ3RoPnRoaXMubWVtb3J5KXt2YXIgdD10aGlzLmxlbmd0aC10aGlzLm1lbW9yeTt0aGlzLl90aW1lbGluZS5zcGxpY2UoMCx0KX1yZXR1cm4gdGhpc30saS5UaW1lbGluZS5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKGUpe2lmKHRoaXMuX2l0ZXJhdGluZyl0aGlzLl90b1JlbW92ZS5wdXNoKGUpO2Vsc2V7dmFyIGk9dGhpcy5fdGltZWxpbmUuaW5kZXhPZihlKTstMSE9PWkmJnRoaXMuX3RpbWVsaW5lLnNwbGljZShpLDEpfXJldHVybiB0aGlzfSxpLlRpbWVsaW5lLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oZSl7dmFyIGk9dGhpcy5fc2VhcmNoKGUpO3JldHVybi0xIT09aT90aGlzLl90aW1lbGluZVtpXTpudWxsfSxpLlRpbWVsaW5lLnByb3RvdHlwZS5wZWVrPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RpbWVsaW5lWzBdfSxpLlRpbWVsaW5lLnByb3RvdHlwZS5zaGlmdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl90aW1lbGluZS5zaGlmdCgpfSxpLlRpbWVsaW5lLnByb3RvdHlwZS5nZXRBZnRlcj1mdW5jdGlvbihlKXt2YXIgaT10aGlzLl9zZWFyY2goZSk7cmV0dXJuIGkrMTx0aGlzLl90aW1lbGluZS5sZW5ndGg/dGhpcy5fdGltZWxpbmVbaSsxXTpudWxsfSxpLlRpbWVsaW5lLnByb3RvdHlwZS5nZXRCZWZvcmU9ZnVuY3Rpb24oZSl7dmFyIGk9dGhpcy5fdGltZWxpbmUubGVuZ3RoO2lmKDA8aSYmdGhpcy5fdGltZWxpbmVbaS0xXS50aW1lPGUpcmV0dXJuIHRoaXMuX3RpbWVsaW5lW2ktMV07dmFyIHQ9dGhpcy5fc2VhcmNoKGUpO3JldHVybiAwPD10LTE/dGhpcy5fdGltZWxpbmVbdC0xXTpudWxsfSxpLlRpbWVsaW5lLnByb3RvdHlwZS5jYW5jZWw9ZnVuY3Rpb24oZSl7aWYoMTx0aGlzLl90aW1lbGluZS5sZW5ndGgpe3ZhciBpPXRoaXMuX3NlYXJjaChlKTtpZigwPD1pKWlmKHRoaXMuX3RpbWVsaW5lW2ldLnRpbWU9PT1lKXtmb3IodmFyIHQ9aTswPD10JiZ0aGlzLl90aW1lbGluZVt0XS50aW1lPT09ZTt0LS0paT10O3RoaXMuX3RpbWVsaW5lPXRoaXMuX3RpbWVsaW5lLnNsaWNlKDAsaSl9ZWxzZSB0aGlzLl90aW1lbGluZT10aGlzLl90aW1lbGluZS5zbGljZSgwLGkrMSk7ZWxzZSB0aGlzLl90aW1lbGluZT1bXX1lbHNlIDE9PT10aGlzLl90aW1lbGluZS5sZW5ndGgmJnRoaXMuX3RpbWVsaW5lWzBdLnRpbWU+PWUmJih0aGlzLl90aW1lbGluZT1bXSk7cmV0dXJuIHRoaXN9LGkuVGltZWxpbmUucHJvdG90eXBlLmNhbmNlbEJlZm9yZT1mdW5jdGlvbihlKXtpZih0aGlzLl90aW1lbGluZS5sZW5ndGgpe3ZhciBpPXRoaXMuX3NlYXJjaChlKTswPD1pJiYodGhpcy5fdGltZWxpbmU9dGhpcy5fdGltZWxpbmUuc2xpY2UoaSsxKSl9cmV0dXJuIHRoaXN9LGkuVGltZWxpbmUucHJvdG90eXBlLl9zZWFyY2g9ZnVuY3Rpb24oZSl7dmFyIGk9MCx0PXRoaXMuX3RpbWVsaW5lLmxlbmd0aCxuPXQ7aWYoMDx0JiZ0aGlzLl90aW1lbGluZVt0LTFdLnRpbWU8PWUpcmV0dXJuIHQtMTtmb3IoO2k8bjspe3ZhciByPU1hdGguZmxvb3IoaSsobi1pKS8yKSxzPXRoaXMuX3RpbWVsaW5lW3JdLGg9dGhpcy5fdGltZWxpbmVbcisxXTtpZihzLnRpbWU9PT1lKXtmb3IodmFyIGw9cjtsPHRoaXMuX3RpbWVsaW5lLmxlbmd0aDtsKyspe3RoaXMuX3RpbWVsaW5lW2xdLnRpbWU9PT1lJiYocj1sKX1yZXR1cm4gcn1pZihzLnRpbWU8ZSYmaC50aW1lPmUpcmV0dXJuIHI7cy50aW1lPmU/bj1yOnMudGltZTxlJiYoaT1yKzEpfXJldHVybi0xfSxpLlRpbWVsaW5lLnByb3RvdHlwZS5faXRlcmF0ZT1mdW5jdGlvbihlLGksdCl7dGhpcy5faXRlcmF0aW5nPSEwLGk9dGhpcy5kZWZhdWx0QXJnKGksMCksdD10aGlzLmRlZmF1bHRBcmcodCx0aGlzLl90aW1lbGluZS5sZW5ndGgtMSk7Zm9yKHZhciBuPWk7bjw9dDtuKyspZSh0aGlzLl90aW1lbGluZVtuXSk7aWYodGhpcy5faXRlcmF0aW5nPSExLDA8dGhpcy5fdG9SZW1vdmUubGVuZ3RoKXtmb3IodmFyIHI9MDtyPHRoaXMuX3RvUmVtb3ZlLmxlbmd0aDtyKyspe3ZhciBzPXRoaXMuX3RpbWVsaW5lLmluZGV4T2YodGhpcy5fdG9SZW1vdmVbcl0pOy0xIT09cyYmdGhpcy5fdGltZWxpbmUuc3BsaWNlKHMsMSl9dGhpcy5fdG9SZW1vdmU9W119fSxpLlRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9pdGVyYXRlKGUpLHRoaXN9LGkuVGltZWxpbmUucHJvdG90eXBlLmZvckVhY2hCZWZvcmU9ZnVuY3Rpb24oZSxpKXt2YXIgdD10aGlzLl9zZWFyY2goZSk7cmV0dXJuLTEhPT10JiZ0aGlzLl9pdGVyYXRlKGksMCx0KSx0aGlzfSxpLlRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoQWZ0ZXI9ZnVuY3Rpb24oZSxpKXt2YXIgdD10aGlzLl9zZWFyY2goZSk7cmV0dXJuIHRoaXMuX2l0ZXJhdGUoaSx0KzEpLHRoaXN9LGkuVGltZWxpbmUucHJvdG90eXBlLmZvckVhY2hGcm9tPWZ1bmN0aW9uKGUsaSl7Zm9yKHZhciB0PXRoaXMuX3NlYXJjaChlKTswPD10JiZ0aGlzLl90aW1lbGluZVt0XS50aW1lPj1lOyl0LS07cmV0dXJuIHRoaXMuX2l0ZXJhdGUoaSx0KzEpLHRoaXN9LGkuVGltZWxpbmUucHJvdG90eXBlLmZvckVhY2hBdFRpbWU9ZnVuY3Rpb24oaSx0KXt2YXIgZT10aGlzLl9zZWFyY2goaSk7cmV0dXJuLTEhPT1lJiZ0aGlzLl9pdGVyYXRlKGZ1bmN0aW9uKGUpe2UudGltZT09PWkmJnQoZSl9LDAsZSksdGhpc30saS5UaW1lbGluZS5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe2kucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKSx0aGlzLl90aW1lbGluZT1udWxsLHRoaXMuX3RvUmVtb3ZlPW51bGx9LGkuVGltZWxpbmV9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXygzKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDIpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIHQuTmVnYXRlPWZ1bmN0aW9uKCl7dGhpcy5fbXVsdGlwbHk9dGhpcy5pbnB1dD10aGlzLm91dHB1dD1uZXcgdC5NdWx0aXBseSgtMSl9LHQuZXh0ZW5kKHQuTmVnYXRlLHQuU2lnbmFsQmFzZSksdC5OZWdhdGUucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm4gdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpLHRoaXMuX211bHRpcGx5LmRpc3Bvc2UoKSx0aGlzLl9tdWx0aXBseT1udWxsLHRoaXN9LHQuTmVnYXRlfSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9fd2VicGFja19yZXF1aXJlX18oMiksX193ZWJwYWNrX3JlcXVpcmVfXygzKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDUpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24oZSl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIGUuR3JlYXRlclRoYW5aZXJvPWZ1bmN0aW9uKCl7dGhpcy5fdGhyZXNoPXRoaXMub3V0cHV0PW5ldyBlLldhdmVTaGFwZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGU8PTA/MDoxfSwxMjcpLHRoaXMuX3NjYWxlPXRoaXMuaW5wdXQ9bmV3IGUuTXVsdGlwbHkoMWU0KSx0aGlzLl9zY2FsZS5jb25uZWN0KHRoaXMuX3RocmVzaCl9LGUuZXh0ZW5kKGUuR3JlYXRlclRoYW5aZXJvLGUuU2lnbmFsQmFzZSksZS5HcmVhdGVyVGhhblplcm8ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm4gZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpLHRoaXMuX3NjYWxlLmRpc3Bvc2UoKSx0aGlzLl9zY2FsZT1udWxsLHRoaXMuX3RocmVzaC5kaXNwb3NlKCksdGhpcy5fdGhyZXNoPW51bGwsdGhpc30sZS5HcmVhdGVyVGhhblplcm99KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXygxNCksX193ZWJwYWNrX3JlcXVpcmVfXyg2NiksX193ZWJwYWNrX3JlcXVpcmVfXygxOCksX193ZWJwYWNrX3JlcXVpcmVfXygxMildLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihvKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gby5DbG9jaz1mdW5jdGlvbigpe28uRW1pdHRlci5jYWxsKHRoaXMpO3ZhciB0PXRoaXMub3B0aW9uc09iamVjdChhcmd1bWVudHMsW1wiY2FsbGJhY2tcIixcImZyZXF1ZW5jeVwiXSxvLkNsb2NrLmRlZmF1bHRzKTt0aGlzLmNhbGxiYWNrPXQuY2FsbGJhY2ssdGhpcy5fbmV4dFRpY2s9MCx0aGlzLl9sYXN0U3RhdGU9by5TdGF0ZS5TdG9wcGVkLHRoaXMuZnJlcXVlbmN5PW5ldyBvLlRpbWVsaW5lU2lnbmFsKHQuZnJlcXVlbmN5LG8uVHlwZS5GcmVxdWVuY3kpLHRoaXMuX3JlYWRPbmx5KFwiZnJlcXVlbmN5XCIpLHRoaXMudGlja3M9MCx0aGlzLl9zdGF0ZT1uZXcgby5UaW1lbGluZVN0YXRlKG8uU3RhdGUuU3RvcHBlZCksdGhpcy5fYm91bmRMb29wPXRoaXMuX2xvb3AuYmluZCh0aGlzKSx0aGlzLmNvbnRleHQub24oXCJ0aWNrXCIsdGhpcy5fYm91bmRMb29wKX0sby5leHRlbmQoby5DbG9jayxvLkVtaXR0ZXIpLG8uQ2xvY2suZGVmYXVsdHM9e2NhbGxiYWNrOm8ubm9PcCxmcmVxdWVuY3k6MSxsb29rQWhlYWQ6XCJhdXRvXCJ9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLkNsb2NrLnByb3RvdHlwZSxcInN0YXRlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aGlzLm5vdygpKX19KSxvLkNsb2NrLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbih0LGUpe3JldHVybiB0PXRoaXMudG9TZWNvbmRzKHQpLHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKHQpIT09by5TdGF0ZS5TdGFydGVkJiZ0aGlzLl9zdGF0ZS5hZGQoe3N0YXRlOm8uU3RhdGUuU3RhcnRlZCx0aW1lOnQsb2Zmc2V0OmV9KSx0aGlzfSxvLkNsb2NrLnByb3RvdHlwZS5zdG9wPWZ1bmN0aW9uKHQpe3JldHVybiB0PXRoaXMudG9TZWNvbmRzKHQpLHRoaXMuX3N0YXRlLmNhbmNlbCh0KSx0aGlzLl9zdGF0ZS5zZXRTdGF0ZUF0VGltZShvLlN0YXRlLlN0b3BwZWQsdCksdGhpc30sby5DbG9jay5wcm90b3R5cGUucGF1c2U9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9dGhpcy50b1NlY29uZHModCksdGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodCk9PT1vLlN0YXRlLlN0YXJ0ZWQmJnRoaXMuX3N0YXRlLnNldFN0YXRlQXRUaW1lKG8uU3RhdGUuUGF1c2VkLHQpLHRoaXN9LG8uQ2xvY2sucHJvdG90eXBlLl9sb29wPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubm93KCkrdGhpcy5jb250ZXh0Lmxvb2tBaGVhZCt0aGlzLmNvbnRleHQudXBkYXRlSW50ZXJ2YWwrMip0aGlzLmNvbnRleHQubGFnO3Q+dGhpcy5fbmV4dFRpY2smJnRoaXMuX3N0YXRlOyl7dmFyIGU9dGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGhpcy5fbmV4dFRpY2spO2lmKGUhPT10aGlzLl9sYXN0U3RhdGUpe3RoaXMuX2xhc3RTdGF0ZT1lO3ZhciBpPXRoaXMuX3N0YXRlLmdldCh0aGlzLl9uZXh0VGljayk7ZT09PW8uU3RhdGUuU3RhcnRlZD8odGhpcy5fbmV4dFRpY2s9aS50aW1lLHRoaXMuaXNVbmRlZihpLm9mZnNldCl8fCh0aGlzLnRpY2tzPWkub2Zmc2V0KSx0aGlzLmVtaXQoXCJzdGFydFwiLGkudGltZSx0aGlzLnRpY2tzKSk6ZT09PW8uU3RhdGUuU3RvcHBlZD8odGhpcy50aWNrcz0wLHRoaXMuZW1pdChcInN0b3BcIixpLnRpbWUpKTplPT09by5TdGF0ZS5QYXVzZWQmJnRoaXMuZW1pdChcInBhdXNlXCIsaS50aW1lKX12YXIgcz10aGlzLl9uZXh0VGljazt0aGlzLmZyZXF1ZW5jeSYmKHRoaXMuX25leHRUaWNrKz0xL3RoaXMuZnJlcXVlbmN5LmdldFZhbHVlQXRUaW1lKHRoaXMuX25leHRUaWNrKSxlPT09by5TdGF0ZS5TdGFydGVkJiYodGhpcy5jYWxsYmFjayhzKSx0aGlzLnRpY2tzKyspKX19LG8uQ2xvY2sucHJvdG90eXBlLmdldFN0YXRlQXRUaW1lPWZ1bmN0aW9uKHQpe3JldHVybiB0PXRoaXMudG9TZWNvbmRzKHQpLHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKHQpfSxvLkNsb2NrLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7by5FbWl0dGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksdGhpcy5jb250ZXh0Lm9mZihcInRpY2tcIix0aGlzLl9ib3VuZExvb3ApLHRoaXMuX3dyaXRhYmxlKFwiZnJlcXVlbmN5XCIpLHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKSx0aGlzLmZyZXF1ZW5jeT1udWxsLHRoaXMuX2JvdW5kTG9vcD1udWxsLHRoaXMuX25leHRUaWNrPTEvMCx0aGlzLmNhbGxiYWNrPW51bGwsdGhpcy5fc3RhdGUuZGlzcG9zZSgpLHRoaXMuX3N0YXRlPW51bGx9LG8uQ2xvY2t9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICB2YXIgcDVzb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIEF1ZGlvVm9pY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblxuICB2YXIgbm90ZVRvRnJlcSA9IF9fd2VicGFja19yZXF1aXJlX18oNikubm90ZVRvRnJlcTtcblxuICB2YXIgREVGQVVMVF9TVVNUQUlOID0gMC4xNTtcbiAgLyoqXG4gICAgKiAgQSBNb25vU3ludGggaXMgdXNlZCBhcyBhIHNpbmdsZSB2b2ljZSBmb3Igc291bmQgc3ludGhlc2lzLlxuICAgICogIFRoaXMgaXMgYSBjbGFzcyB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIFBvbHlTeW50aFxuICAgICogIGNsYXNzLiBDdXN0b20gc3ludGhldGlzZXJzIHNob3VsZCBiZSBidWlsdCBpbmhlcml0aW5nIGZyb21cbiAgICAqICB0aGlzIGNsYXNzLlxuICAgICpcbiAgICAqICBAY2xhc3MgcDUuTW9ub1N5bnRoXG4gICAgKiAgQGNvbnN0cnVjdG9yXG4gICAgKiAgQGV4YW1wbGVcbiAgICAqICA8ZGl2Pjxjb2RlPlxuICAgICogIGxldCBtb25vU3ludGg7XG4gICAgKlxuICAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHBsYXlTeW50aCk7XG4gICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAgKiAgICB0ZXh0QWxpZ24oQ0VOVEVSKTtcbiAgICAqICAgIHRleHQoJ3RhcCB0byBwbGF5Jywgd2lkdGgvMiwgaGVpZ2h0LzIpO1xuICAgICpcbiAgICAqICAgIG1vbm9TeW50aCA9IG5ldyBwNS5Nb25vU3ludGgoKTtcbiAgICAqICB9XG4gICAgKlxuICAgICogIGZ1bmN0aW9uIHBsYXlTeW50aCgpIHtcbiAgICAqICAgIHVzZXJTdGFydEF1ZGlvKCk7XG4gICAgKlxuICAgICogICAgbGV0IG5vdGUgPSByYW5kb20oWydGYjQnLCAnRzQnXSk7XG4gICAgKiAgICAvLyBub3RlIHZlbG9jaXR5ICh2b2x1bWUsIGZyb20gMCB0byAxKVxuICAgICogICAgbGV0IHZlbG9jaXR5ID0gcmFuZG9tKCk7XG4gICAgKiAgICAvLyB0aW1lIGZyb20gbm93IChpbiBzZWNvbmRzKVxuICAgICogICAgbGV0IHRpbWUgPSAwO1xuICAgICogICAgLy8gbm90ZSBkdXJhdGlvbiAoaW4gc2Vjb25kcylcbiAgICAqICAgIGxldCBkdXIgPSAxLzY7XG4gICAgKlxuICAgICogICAgbW9ub1N5bnRoLnBsYXkobm90ZSwgdmVsb2NpdHksIHRpbWUsIGR1cik7XG4gICAgKiAgfVxuICAgICogIDwvY29kZT48L2Rpdj5cbiAgICAqKi9cblxuICBwNS5Nb25vU3ludGggPSBmdW5jdGlvbiAoKSB7XG4gICAgQXVkaW9Wb2ljZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMub3NjaWxsYXRvciA9IG5ldyBwNS5Pc2NpbGxhdG9yKCk7XG4gICAgdGhpcy5lbnYgPSBuZXcgcDUuRW52ZWxvcGUoKTtcbiAgICB0aGlzLmVudi5zZXRSYW5nZSgxLCAwKTtcbiAgICB0aGlzLmVudi5zZXRFeHAodHJ1ZSk7IFxuXG4gICAgdGhpcy5zZXRBRFNSKDAuMDIsIDAuMjUsIDAuMDUsIDAuMzUpOyBcblxuICAgIHRoaXMub3NjaWxsYXRvci5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5vc2NpbGxhdG9yLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuICAgIHRoaXMuZW52LmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLmVudi5zZXRJbnB1dCh0aGlzLm91dHB1dC5nYWluKTsgXG5cbiAgICB0aGlzLm9zY2lsbGF0b3Iub3V0cHV0LmdhaW4udmFsdWUgPSAxLjA7XG4gICAgdGhpcy5vc2NpbGxhdG9yLnN0YXJ0KCk7XG4gICAgdGhpcy5jb25uZWN0KCk7XG4gICAgcDVzb3VuZC5zb3VuZEFycmF5LnB1c2godGhpcyk7XG4gIH07XG5cbiAgcDUuTW9ub1N5bnRoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocDUuQXVkaW9Wb2ljZS5wcm90b3R5cGUpO1xuICAvKipcbiAgICAqICBQbGF5IHRlbGxzIHRoZSBNb25vU3ludGggdG8gc3RhcnQgcGxheWluZyBhIG5vdGUuIFRoaXMgbWV0aG9kIHNjaGVkdWxlc1xuICAgICogIHRoZSBjYWxsaW5nIG9mIC50cmlnZ2VyQXR0YWNrIGFuZCAudHJpZ2dlclJlbGVhc2UuXG4gICAgKlxuICAgICogIEBtZXRob2QgcGxheVxuICAgICogIEBmb3IgcDUuTW9ub1N5bnRoXG4gICAgKiAgQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IG5vdGUgdGhlIG5vdGUgeW91IHdhbnQgdG8gcGxheSwgc3BlY2lmaWVkIGFzIGFcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJlcXVlbmN5IGluIEhlcnR6IChOdW1iZXIpIG9yIGFzIGEgbWlkaVxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSBpbiBOb3RlL09jdGF2ZSBmb3JtYXQgKFwiQzRcIiwgXCJFYjNcIi4uLmV0Y1wiKVxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgPGEgaHJlZiA9IFwiaHR0cHM6Ly9naXRodWIuY29tL1RvbmVqcy9Ub25lLmpzL3dpa2kvSW5zdHJ1bWVudHNcIj5cbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVG9uZTwvYT4uIERlZmF1bHRzIHRvIDQ0MCBoei5cbiAgICAqICBAcGFyYW0gIHtOdW1iZXJ9IFt2ZWxvY2l0eV0gdmVsb2NpdHkgb2YgdGhlIG5vdGUgdG8gcGxheSAocmFuZ2luZyBmcm9tIDAgdG8gMSlcbiAgICAqICBAcGFyYW0gIHtOdW1iZXJ9IFtzZWNvbmRzRnJvbU5vd10gIHRpbWUgZnJvbSBub3cgKGluIHNlY29uZHMpIGF0IHdoaWNoIHRvIHBsYXlcbiAgICAqICBAcGFyYW0gIHtOdW1iZXJ9IFtzdXN0YWluVGltZV0gdGltZSB0byBzdXN0YWluIGJlZm9yZSByZWxlYXNpbmcgdGhlIGVudmVsb3BlLiBEZWZhdWx0cyB0byAwLjE1IHNlY29uZHMuXG4gICAgKiAgQGV4YW1wbGVcbiAgICAqICA8ZGl2Pjxjb2RlPlxuICAgICogIGxldCBtb25vU3ludGg7XG4gICAgKlxuICAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHBsYXlTeW50aCk7XG4gICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAgKiAgICB0ZXh0QWxpZ24oQ0VOVEVSKTtcbiAgICAqICAgIHRleHQoJ3RhcCB0byBwbGF5Jywgd2lkdGgvMiwgaGVpZ2h0LzIpO1xuICAgICpcbiAgICAqICAgIG1vbm9TeW50aCA9IG5ldyBwNS5Nb25vU3ludGgoKTtcbiAgICAqICB9XG4gICAgKlxuICAgICogIGZ1bmN0aW9uIHBsYXlTeW50aCgpIHtcbiAgICAqICAgIHVzZXJTdGFydEF1ZGlvKCk7XG4gICAgKlxuICAgICogICAgbGV0IG5vdGUgPSByYW5kb20oWydGYjQnLCAnRzQnXSk7XG4gICAgKiAgICAvLyBub3RlIHZlbG9jaXR5ICh2b2x1bWUsIGZyb20gMCB0byAxKVxuICAgICogICAgbGV0IHZlbG9jaXR5ID0gcmFuZG9tKCk7XG4gICAgKiAgICAvLyB0aW1lIGZyb20gbm93IChpbiBzZWNvbmRzKVxuICAgICogICAgbGV0IHRpbWUgPSAwO1xuICAgICogICAgLy8gbm90ZSBkdXJhdGlvbiAoaW4gc2Vjb25kcylcbiAgICAqICAgIGxldCBkdXIgPSAxLzY7XG4gICAgKlxuICAgICogICAgbW9ub1N5bnRoLnBsYXkobm90ZSwgdmVsb2NpdHksIHRpbWUsIGR1cik7XG4gICAgKiAgfVxuICAgICogIDwvY29kZT48L2Rpdj5cbiAgICAqXG4gICAgKi9cblxuICBwNS5Nb25vU3ludGgucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAobm90ZSwgdmVsb2NpdHksIHNlY29uZHNGcm9tTm93LCBzdXNUaW1lKSB7XG4gICAgdGhpcy50cmlnZ2VyQXR0YWNrKG5vdGUsIHZlbG9jaXR5LCB+fnNlY29uZHNGcm9tTm93KTtcbiAgICB0aGlzLnRyaWdnZXJSZWxlYXNlKH5+c2Vjb25kc0Zyb21Ob3cgKyAoc3VzVGltZSB8fCBERUZBVUxUX1NVU1RBSU4pKTtcbiAgfTtcbiAgLyoqXG4gICAgICogIFRyaWdnZXIgdGhlIEF0dGFjaywgYW5kIERlY2F5IHBvcnRpb24gb2YgdGhlIEVudmVsb3BlLlxuICAgICAqICBTaW1pbGFyIHRvIGhvbGRpbmcgZG93biBhIGtleSBvbiBhIHBpYW5vLCBidXQgaXQgd2lsbFxuICAgICAqICBob2xkIHRoZSBzdXN0YWluIGxldmVsIHVudGlsIHlvdSBsZXQgZ28uXG4gICAgICpcbiAgICAgKiAgQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IG5vdGUgdGhlIG5vdGUgeW91IHdhbnQgdG8gcGxheSwgc3BlY2lmaWVkIGFzIGFcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyZXF1ZW5jeSBpbiBIZXJ0eiAoTnVtYmVyKSBvciBhcyBhIG1pZGlcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIGluIE5vdGUvT2N0YXZlIGZvcm1hdCAoXCJDNFwiLCBcIkViM1wiLi4uZXRjXCIpXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgPGEgaHJlZiA9IFwiaHR0cHM6Ly9naXRodWIuY29tL1RvbmVqcy9Ub25lLmpzL3dpa2kvSW5zdHJ1bWVudHNcIj5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRvbmU8L2E+LiBEZWZhdWx0cyB0byA0NDAgaHpcbiAgICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbdmVsb2NpdHldIHZlbG9jaXR5IG9mIHRoZSBub3RlIHRvIHBsYXkgKHJhbmdpbmcgZnJvbSAwIHRvIDEpXG4gICAgICogIEBwYXJhbSAge051bWJlcn0gW3NlY29uZHNGcm9tTm93XSAgdGltZSBmcm9tIG5vdyAoaW4gc2Vjb25kcykgYXQgd2hpY2ggdG8gcGxheVxuICAgICAqICBAbWV0aG9kICB0cmlnZ2VyQXR0YWNrXG4gICAgICogIEBmb3IgcDUuTW9ub1N5bnRoXG4gICAgICogIEBleGFtcGxlXG4gICAgICogIDxkaXY+PGNvZGU+XG4gICAgICogIGxldCBtb25vU3ludGg7XG4gICAgICpcbiAgICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAgICogICAgY252Lm1vdXNlUHJlc3NlZCh0cmlnZ2VyQXR0YWNrKTtcbiAgICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAgICogICAgdGV4dCgndGFwIGhlcmUgZm9yIGF0dGFjaywgbGV0IGdvIHRvIHJlbGVhc2UnLCA1LCAyMCwgd2lkdGggLSAyMCk7XG4gICAgICogICAgbW9ub1N5bnRoID0gbmV3IHA1Lk1vbm9TeW50aCgpO1xuICAgICAqICB9XG4gICAgICpcbiAgICAgKiAgZnVuY3Rpb24gdHJpZ2dlckF0dGFjaygpIHtcbiAgICAgKiAgICB1c2VyU3RhcnRBdWRpbygpO1xuICAgICAqXG4gICAgICogICAgbW9ub1N5bnRoLnRyaWdnZXJBdHRhY2soXCJFM1wiKTtcbiAgICAgKiAgfVxuICAgICAqXG4gICAgICogIGZ1bmN0aW9uIG1vdXNlUmVsZWFzZWQoKSB7XG4gICAgICogICAgbW9ub1N5bnRoLnRyaWdnZXJSZWxlYXNlKCk7XG4gICAgICogIH1cbiAgICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgICAqL1xuXG5cbiAgcDUuTW9ub1N5bnRoLnByb3RvdHlwZS50cmlnZ2VyQXR0YWNrID0gZnVuY3Rpb24gKG5vdGUsIHZlbG9jaXR5LCBzZWNvbmRzRnJvbU5vdykge1xuICAgIHZhciBzZWNvbmRzRnJvbU5vdyA9IH5+c2Vjb25kc0Zyb21Ob3c7XG4gICAgdmFyIGZyZXEgPSBub3RlVG9GcmVxKG5vdGUpO1xuICAgIHZhciB2ZWwgPSB2ZWxvY2l0eSB8fCAwLjE7XG4gICAgdGhpcy5vc2NpbGxhdG9yLmZyZXEoZnJlcSwgMCwgc2Vjb25kc0Zyb21Ob3cpO1xuICAgIHRoaXMuZW52LnJhbXAodGhpcy5vdXRwdXQuZ2Fpbiwgc2Vjb25kc0Zyb21Ob3csIHZlbCk7XG4gIH07XG4gIC8qKlxuICAgICAqICBUcmlnZ2VyIHRoZSByZWxlYXNlIG9mIHRoZSBFbnZlbG9wZS4gVGhpcyBpcyBzaW1pbGFyIHRvIHJlbGVhc2luZ1xuICAgICAqICB0aGUga2V5IG9uIGEgcGlhbm8gYW5kIGxldHRpbmcgdGhlIHNvdW5kIGZhZGUgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAqICByZWxlYXNlIGxldmVsIGFuZCByZWxlYXNlIHRpbWUuXG4gICAgICpcbiAgICAgKiAgQHBhcmFtICB7TnVtYmVyfSBzZWNvbmRzRnJvbU5vdyB0aW1lIHRvIHRyaWdnZXIgdGhlIHJlbGVhc2VcbiAgICAgKiAgQG1ldGhvZCAgdHJpZ2dlclJlbGVhc2VcbiAgICAgKiAgQGZvciBwNS5Nb25vU3ludGhcbiAgICAgKiAgQGV4YW1wbGVcbiAgICAgKiAgPGRpdj48Y29kZT5cbiAgICAgKiAgbGV0IG1vbm9TeW50aDtcbiAgICAgKlxuICAgICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHRyaWdnZXJBdHRhY2spO1xuICAgICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICAgKiAgICB0ZXh0KCd0YXAgaGVyZSBmb3IgYXR0YWNrLCBsZXQgZ28gdG8gcmVsZWFzZScsIDUsIDIwLCB3aWR0aCAtIDIwKTtcbiAgICAgKiAgICBtb25vU3ludGggPSBuZXcgcDUuTW9ub1N5bnRoKCk7XG4gICAgICogIH1cbiAgICAgKlxuICAgICAqICBmdW5jdGlvbiB0cmlnZ2VyQXR0YWNrKCkge1xuICAgICAqICAgIHVzZXJTdGFydEF1ZGlvKCk7XG4gICAgICpcbiAgICAgKiAgICBtb25vU3ludGgudHJpZ2dlckF0dGFjayhcIkUzXCIpO1xuICAgICAqICB9XG4gICAgICpcbiAgICAgKiAgZnVuY3Rpb24gbW91c2VSZWxlYXNlZCgpIHtcbiAgICAgKiAgICBtb25vU3ludGgudHJpZ2dlclJlbGVhc2UoKTtcbiAgICAgKiAgfVxuICAgICAqICA8L2NvZGU+PC9kaXY+XG4gICAgICovXG5cblxuICBwNS5Nb25vU3ludGgucHJvdG90eXBlLnRyaWdnZXJSZWxlYXNlID0gZnVuY3Rpb24gKHNlY29uZHNGcm9tTm93KSB7XG4gICAgdmFyIHNlY29uZHNGcm9tTm93ID0gc2Vjb25kc0Zyb21Ob3cgfHwgMDtcbiAgICB0aGlzLmVudi5yYW1wKHRoaXMub3V0cHV0LmdhaW4sIHNlY29uZHNGcm9tTm93LCAwKTtcbiAgfTtcbiAgLyoqXG4gICAgICogIFNldCB2YWx1ZXMgbGlrZSBhIHRyYWRpdGlvbmFsXG4gICAgICogIDxhIGhyZWY9XCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW50aGVzaXplciMvbWVkaWEvRmlsZTpBRFNSX3BhcmFtZXRlci5zdmdcIj5cbiAgICAgKiAgQURTUiBlbnZlbG9wZVxuICAgICAqICA8L2E+LlxuICAgICAqXG4gICAgICogIEBtZXRob2QgIHNldEFEU1JcbiAgICAgKiAgQGZvciBwNS5Nb25vU3ludGhcbiAgICAgKiAgQHBhcmFtIHtOdW1iZXJ9IGF0dGFja1RpbWUgICAgVGltZSAoaW4gc2Vjb25kcyBiZWZvcmUgZW52ZWxvcGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhY2hlcyBBdHRhY2sgTGV2ZWxcbiAgICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtkZWNheVRpbWVdICAgIFRpbWUgKGluIHNlY29uZHMpIGJlZm9yZSBlbnZlbG9wZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFjaGVzIERlY2F5L1N1c3RhaW4gTGV2ZWxcbiAgICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtzdXNSYXRpb10gICAgUmF0aW8gYmV0d2VlbiBhdHRhY2tMZXZlbCBhbmQgcmVsZWFzZUxldmVsLCBvbiBhIHNjYWxlIGZyb20gMCB0byAxLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVyZSAxLjAgPSBhdHRhY2tMZXZlbCwgMC4wID0gcmVsZWFzZUxldmVsLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgc3VzUmF0aW8gZGV0ZXJtaW5lcyB0aGUgZGVjYXlMZXZlbCBhbmQgdGhlIGxldmVsIGF0IHdoaWNoIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXN0YWluIHBvcnRpb24gb2YgdGhlIGVudmVsb3BlIHdpbGwgc3VzdGFpbi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUsIGlmIGF0dGFja0xldmVsIGlzIDAuNCwgcmVsZWFzZUxldmVsIGlzIDAsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBzdXNBbXQgaXMgMC41LCB0aGUgZGVjYXlMZXZlbCB3b3VsZCBiZSAwLjIuIElmIGF0dGFja0xldmVsIGlzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlYXNlZCB0byAxLjAgKHVzaW5nIDxjb2RlPnNldFJhbmdlPC9jb2RlPiksXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gZGVjYXlMZXZlbCB3b3VsZCBpbmNyZWFzZSBwcm9wb3J0aW9uYWxseSwgdG8gYmVjb21lIDAuNS5cbiAgICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtyZWxlYXNlVGltZV0gICBUaW1lIGluIHNlY29uZHMgZnJvbSBub3cgKGRlZmF1bHRzIHRvIDApXG4gICAgICovXG5cblxuICBwNS5Nb25vU3ludGgucHJvdG90eXBlLnNldEFEU1IgPSBmdW5jdGlvbiAoYXR0YWNrLCBkZWNheSwgc3VzdGFpbiwgcmVsZWFzZSkge1xuICAgIHRoaXMuZW52LnNldEFEU1IoYXR0YWNrLCBkZWNheSwgc3VzdGFpbiwgcmVsZWFzZSk7XG4gIH07XG4gIC8qKlxuICAgKiBHZXR0ZXJzIGFuZCBTZXR0ZXJzXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBhdHRhY2tcbiAgICogQGZvciBwNS5Nb25vU3ludGhcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZWNheVxuICAgKiBAZm9yIHA1Lk1vbm9TeW50aFxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHN1c3RhaW5cbiAgICogQGZvciBwNS5Nb25vU3ludGhcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByZWxlYXNlXG4gICAqIEBmb3IgcDUuTW9ub1N5bnRoXG4gICAqL1xuXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocDUuTW9ub1N5bnRoLnByb3RvdHlwZSwge1xuICAgICdhdHRhY2snOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW52LmFUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGF0dGFjaykge1xuICAgICAgICB0aGlzLmVudi5zZXRBRFNSKGF0dGFjaywgdGhpcy5lbnYuZFRpbWUsIHRoaXMuZW52LnNQZXJjZW50LCB0aGlzLmVudi5yVGltZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnZGVjYXknOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW52LmRUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGRlY2F5KSB7XG4gICAgICAgIHRoaXMuZW52LnNldEFEU1IodGhpcy5lbnYuYVRpbWUsIGRlY2F5LCB0aGlzLmVudi5zUGVyY2VudCwgdGhpcy5lbnYuclRpbWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3N1c3RhaW4nOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW52LnNQZXJjZW50O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHN1c3RhaW4pIHtcbiAgICAgICAgdGhpcy5lbnYuc2V0QURTUih0aGlzLmVudi5hVGltZSwgdGhpcy5lbnYuZFRpbWUsIHN1c3RhaW4sIHRoaXMuZW52LnJUaW1lKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdyZWxlYXNlJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudi5yVGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChyZWxlYXNlKSB7XG4gICAgICAgIHRoaXMuZW52LnNldEFEU1IodGhpcy5lbnYuYVRpbWUsIHRoaXMuZW52LmRUaW1lLCB0aGlzLmVudi5zUGVyY2VudCwgcmVsZWFzZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIE1vbm9TeW50aCBhbXBcbiAgICogQG1ldGhvZCAgYW1wXG4gICAqIEBmb3IgcDUuTW9ub1N5bnRoXG4gICAqIEBwYXJhbSAge051bWJlcn0gdm9sICAgICAgZGVzaXJlZCB2b2x1bWVcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbcmFtcFRpbWVdIFRpbWUgdG8gcmVhY2ggbmV3IHZvbHVtZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgIG5ldyB2b2x1bWUgdmFsdWVcbiAgICovXG5cbiAgcDUuTW9ub1N5bnRoLnByb3RvdHlwZS5hbXAgPSBmdW5jdGlvbiAodm9sLCByYW1wVGltZSkge1xuICAgIHZhciB0ID0gcmFtcFRpbWUgfHwgMDtcblxuICAgIGlmICh0eXBlb2Ygdm9sICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5vc2NpbGxhdG9yLmFtcCh2b2wsIHQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm9zY2lsbGF0b3IuYW1wKCkudmFsdWU7XG4gIH07XG4gIC8qKlxuICAgKiAgQ29ubmVjdCB0byBhIHA1LnNvdW5kIC8gV2ViIEF1ZGlvIG9iamVjdC5cbiAgICpcbiAgICogIEBtZXRob2QgIGNvbm5lY3RcbiAgICogIEBmb3IgcDUuTW9ub1N5bnRoXG4gICAqICBAcGFyYW0gIHtPYmplY3R9IHVuaXQgQSBwNS5zb3VuZCBvciBXZWIgQXVkaW8gb2JqZWN0XG4gICAqL1xuXG5cbiAgcDUuTW9ub1N5bnRoLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICB2YXIgdSA9IHVuaXQgfHwgcDVzb3VuZC5pbnB1dDtcbiAgICB0aGlzLm91dHB1dC5jb25uZWN0KHUuaW5wdXQgPyB1LmlucHV0IDogdSk7XG4gIH07XG4gIC8qKlxuICAgKiAgRGlzY29ubmVjdCBhbGwgb3V0cHV0c1xuICAgKlxuICAgKiAgQG1ldGhvZCAgZGlzY29ubmVjdFxuICAgKiAgQGZvciBwNS5Nb25vU3ludGhcbiAgICovXG5cblxuICBwNS5Nb25vU3ludGgucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3V0cHV0KSB7XG4gICAgICB0aGlzLm91dHB1dC5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIEdldCByaWQgb2YgdGhlIE1vbm9TeW50aCBhbmQgZnJlZSB1cCBpdHMgcmVzb3VyY2VzIC8gbWVtb3J5LlxuICAgKlxuICAgKiAgQG1ldGhvZCAgZGlzcG9zZVxuICAgKiAgQGZvciBwNS5Nb25vU3ludGhcbiAgICovXG5cblxuICBwNS5Nb25vU3ludGgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgQXVkaW9Wb2ljZS5wcm90b3R5cGUuZGlzcG9zZS5hcHBseSh0aGlzKTtcblxuICAgIGlmICh0aGlzLmVudikge1xuICAgICAgdGhpcy5lbnYuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9zY2lsbGF0b3IpIHtcbiAgICAgIHRoaXMub3NjaWxsYXRvci5kaXNwb3NlKCk7XG4gICAgfVxuICB9O1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHA1c291bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICAvKipcbiAgICogQmFzZSBjbGFzcyBmb3IgbW9ub3Bob25pYyBzeW50aGVzaXplcnMuIEFueSBleHRlbnNpb25zIG9mIHRoaXMgY2xhc3NcbiAgICogc2hvdWxkIGZvbGxvdyB0aGUgQVBJIGFuZCBpbXBsZW1lbnQgdGhlIG1ldGhvZHMgYmVsb3cgaW4gb3JkZXIgdG9cbiAgICogcmVtYWluIGNvbXBhdGlibGUgd2l0aCBwNS5Qb2x5U3ludGgoKTtcbiAgICpcbiAgICogQGNsYXNzIHA1LkF1ZGlvVm9pY2VcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuXG5cbiAgcDUuQXVkaW9Wb2ljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFjID0gcDVzb3VuZC5hdWRpb2NvbnRleHQ7XG4gICAgdGhpcy5vdXRwdXQgPSB0aGlzLmFjLmNyZWF0ZUdhaW4oKTtcbiAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICBwNXNvdW5kLnNvdW5kQXJyYXkucHVzaCh0aGlzKTtcbiAgfTtcblxuICBwNS5BdWRpb1ZvaWNlLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKG5vdGUsIHZlbG9jaXR5LCBzZWNvbmRzRnJvbU5vdywgc3VzdGltZSkge307XG5cbiAgcDUuQXVkaW9Wb2ljZS5wcm90b3R5cGUudHJpZ2dlckF0dGFjayA9IGZ1bmN0aW9uIChub3RlLCB2ZWxvY2l0eSwgc2Vjb25kc0Zyb21Ob3cpIHt9O1xuXG4gIHA1LkF1ZGlvVm9pY2UucHJvdG90eXBlLnRyaWdnZXJSZWxlYXNlID0gZnVuY3Rpb24gKHNlY29uZHNGcm9tTm93KSB7fTtcblxuICBwNS5BdWRpb1ZvaWNlLnByb3RvdHlwZS5hbXAgPSBmdW5jdGlvbiAodm9sLCByYW1wVGltZSkge307XG4gIC8qKlxuICAgKiBDb25uZWN0IHRvIHA1IG9iamVjdHMgb3IgV2ViIEF1ZGlvIE5vZGVzXG4gICAqIEBtZXRob2QgIGNvbm5lY3RcbiAgICogQGZvciBwNS5BdWRpb1ZvaWNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1bml0XG4gICAqL1xuXG5cbiAgcDUuQXVkaW9Wb2ljZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh1bml0KSB7XG4gICAgdmFyIHUgPSB1bml0IHx8IHA1c291bmQuaW5wdXQ7XG4gICAgdGhpcy5vdXRwdXQuY29ubmVjdCh1LmlucHV0ID8gdS5pbnB1dCA6IHUpO1xuICB9O1xuICAvKipcbiAgICogRGlzY29ubmVjdCBmcm9tIHNvdW5kT3V0XG4gICAqIEBtZXRob2QgIGRpc2Nvbm5lY3RcbiAgICogQGZvciBwNS5BdWRpb1ZvaWNlXG4gICAqL1xuXG5cbiAgcDUuQXVkaW9Wb2ljZS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm91dHB1dC5kaXNjb25uZWN0KCk7XG4gIH07XG5cbiAgcDUuQXVkaW9Wb2ljZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vdXRwdXQpIHtcbiAgICAgIHRoaXMub3V0cHV0LmRpc2Nvbm5lY3QoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLm91dHB1dDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHA1LkF1ZGlvVm9pY2U7XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgdmFyIHA1c291bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBUaW1lbGluZVNpZ25hbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG4gIHZhciBub3RlVG9GcmVxID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KS5ub3RlVG9GcmVxO1xuICAvKipcbiAgICAqICBBbiBBdWRpb1ZvaWNlIGlzIHVzZWQgYXMgYSBzaW5nbGUgdm9pY2UgZm9yIHNvdW5kIHN5bnRoZXNpcy5cbiAgICAqICBUaGUgUG9seVN5bnRoIGNsYXNzIGhvbGRzIGFuIGFycmF5IG9mIEF1ZGlvVm9pY2UsIGFuZCBkZWFsc1xuICAgICogIHdpdGggdm9pY2VzIGFsbG9jYXRpb25zLCB3aXRoIHNldHRpbmcgbm90ZXMgdG8gYmUgcGxheWVkLCBhbmRcbiAgICAqICBwYXJhbWV0ZXJzIHRvIGJlIHNldC5cbiAgICAqXG4gICAgKiAgQGNsYXNzIHA1LlBvbHlTeW50aFxuICAgICogIEBjb25zdHJ1Y3RvclxuICAgICpcbiAgICAqICBAcGFyYW0ge051bWJlcn0gW3N5bnRoVm9pY2VdICAgQSBtb25vcGhvbmljIHN5bnRoIHZvaWNlIGluaGVyaXRpbmdcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIEF1ZGlvVm9pY2UgY2xhc3MuIERlZmF1bHRzIHRvIHA1Lk1vbm9TeW50aFxuICAgICogIEBwYXJhbSB7TnVtYmVyfSBbbWF4Vm9pY2VzXSBOdW1iZXIgb2Ygdm9pY2VzLCBkZWZhdWx0cyB0byA4O1xuICAgICogIEBleGFtcGxlXG4gICAgKiAgPGRpdj48Y29kZT5cbiAgICAqICBsZXQgcG9seVN5bnRoO1xuICAgICpcbiAgICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgICogICAgY252Lm1vdXNlUHJlc3NlZChwbGF5U3ludGgpO1xuICAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgICogICAgdGV4dCgnY2xpY2sgdG8gcGxheScsIDIwLCAyMCk7XG4gICAgKlxuICAgICogICAgcG9seVN5bnRoID0gbmV3IHA1LlBvbHlTeW50aCgpO1xuICAgICogIH1cbiAgICAqXG4gICAgKiAgZnVuY3Rpb24gcGxheVN5bnRoKCkge1xuICAgICogICAgdXNlclN0YXJ0QXVkaW8oKTtcbiAgICAqXG4gICAgKiAgICAvLyBub3RlIGR1cmF0aW9uIChpbiBzZWNvbmRzKVxuICAgICogICAgbGV0IGR1ciA9IDEuNTtcbiAgICAqXG4gICAgKiAgICAvLyB0aW1lIGZyb20gbm93IChpbiBzZWNvbmRzKVxuICAgICogICAgbGV0IHRpbWUgPSAwO1xuICAgICpcbiAgICAqICAgIC8vIHZlbG9jaXR5ICh2b2x1bWUsIGZyb20gMCB0byAxKVxuICAgICogICAgbGV0IHZlbCA9IDAuMTtcbiAgICAqXG4gICAgKiAgICAvLyBub3RlcyBjYW4gb3ZlcmxhcCB3aXRoIGVhY2ggb3RoZXJcbiAgICAqICAgIHBvbHlTeW50aC5wbGF5KCdHMicsIHZlbCwgMCwgZHVyKTtcbiAgICAqICAgIHBvbHlTeW50aC5wbGF5KCdDMycsIHZlbCwgdGltZSArPSAxLzMsIGR1cik7XG4gICAgKiAgICBwb2x5U3ludGgucGxheSgnRzMnLCB2ZWwsIHRpbWUgKz0gMS8zLCBkdXIpO1xuICAgICogIH1cbiAgICAqICA8L2NvZGU+PC9kaXY+XG4gICAgKiovXG5cblxuICBwNS5Qb2x5U3ludGggPSBmdW5jdGlvbiAoYXVkaW9Wb2ljZSwgbWF4Vm9pY2VzKSB7XG4gICAgdGhpcy5hdWRpb3ZvaWNlcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCB0aGF0IGhvbGRzIGluZm9ybWF0aW9uIGFib3V0IHdoaWNoIG5vdGVzIGhhdmUgYmVlbiBwbGF5ZWQgYW5kXG4gICAgICogd2hpY2ggbm90ZXMgYXJlIGN1cnJlbnRseSBiZWluZyBwbGF5ZWQuIE5ldyBub3RlcyBhcmUgYWRkZWQgYXMga2V5c1xuICAgICAqIG9uIHRoZSBmbHkuIFdoaWxlIGEgbm90ZSBoYXMgYmVlbiBhdHRhY2tlZCwgYnV0IG5vdCByZWxlYXNlZCwgdGhlIHZhbHVlIG9mIHRoZVxuICAgICAqIGtleSBpcyB0aGUgYXVkaW92b2ljZSB3aGljaCBpcyBnZW5lcmF0aW5nIHRoYXQgbm90ZS4gV2hlbiBub3RlcyBhcmUgcmVsZWFzZWQsXG4gICAgICogdGhlIHZhbHVlIG9mIHRoZSBrZXkgYmVjb21lcyB1bmRlZmluZWQuXG4gICAgICogQHByb3BlcnR5IG5vdGVzXG4gICAgICovXG5cbiAgICB0aGlzLm5vdGVzID0ge307IFxuXG4gICAgdGhpcy5fbmV3ZXN0ID0gMDtcbiAgICB0aGlzLl9vbGRlc3QgPSAwO1xuICAgIC8qKlxuICAgICAqIEEgUG9seVN5bnRoIG11c3QgaGF2ZSBhdCBsZWFzdCAxIHZvaWNlLCBkZWZhdWx0cyB0byA4XG4gICAgICogQHByb3BlcnR5IHBvbHl2YWx1ZVxuICAgICAqL1xuXG4gICAgdGhpcy5tYXhWb2ljZXMgPSBtYXhWb2ljZXMgfHwgODtcbiAgICAvKipcbiAgICAgKiBNb25vc3ludGggdGhhdCBnZW5lcmF0ZXMgdGhlIHNvdW5kIGZvciBlYWNoIG5vdGUgdGhhdCBpcyB0cmlnZ2VyZWQuIFRoZVxuICAgICAqIHA1LlBvbHlTeW50aCBkZWZhdWx0cyB0byB1c2luZyB0aGUgcDUuTW9ub1N5bnRoIGFzIGl0cyB2b2ljZS5cbiAgICAgKiBAcHJvcGVydHkgQXVkaW9Wb2ljZVxuICAgICAqL1xuXG4gICAgdGhpcy5BdWRpb1ZvaWNlID0gYXVkaW9Wb2ljZSA9PT0gdW5kZWZpbmVkID8gcDUuTW9ub1N5bnRoIDogYXVkaW9Wb2ljZTtcbiAgICAvKipcbiAgICAgKiBUaGlzIHZhbHVlIG11c3Qgb25seSBjaGFuZ2UgYXMgYSBub3RlIGlzIGF0dGFja2VkIG9yIHJlbGVhc2VkLiBEdWUgdG8gZGVsYXlcbiAgICAgKiBhbmQgc3VzdGFpbiB0aW1lcywgVG9uZS5UaW1lbGluZVNpZ25hbCBpcyByZXF1aXJlZCB0byBzY2hlZHVsZSB0aGUgY2hhbmdlIGluIHZhbHVlLlxuICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge1RvbmUuVGltZWxpbmVTaWduYWx9IF92b2ljZXNJblVzZVxuICAgICAqL1xuXG4gICAgdGhpcy5fdm9pY2VzSW5Vc2UgPSBuZXcgVGltZWxpbmVTaWduYWwoMCk7XG4gICAgdGhpcy5vdXRwdXQgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgdGhpcy5jb25uZWN0KCk7IFxuXG4gICAgdGhpcy5fYWxsb2NhdGVWb2ljZXMoKTtcblxuICAgIHA1c291bmQuc291bmRBcnJheS5wdXNoKHRoaXMpO1xuICB9O1xuICAvKipcbiAgICogQ29uc3RydWN0IHRoZSBhcHByb3ByaWF0ZSBudW1iZXIgb2YgYXVkaW92b2ljZXNcbiAgICogQHByaXZhdGVcbiAgICogQGZvciBwNS5Qb2x5U3ludGhcbiAgICogQG1ldGhvZCAgX2FsbG9jYXRlVm9pY2VzXG4gICAqL1xuXG5cbiAgcDUuUG9seVN5bnRoLnByb3RvdHlwZS5fYWxsb2NhdGVWb2ljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1heFZvaWNlczsgaSsrKSB7XG4gICAgICB0aGlzLmF1ZGlvdm9pY2VzLnB1c2gobmV3IHRoaXMuQXVkaW9Wb2ljZSgpKTtcbiAgICAgIHRoaXMuYXVkaW92b2ljZXNbaV0uZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5hdWRpb3ZvaWNlc1tpXS5jb25uZWN0KHRoaXMub3V0cHV0KTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgUGxheSBhIG5vdGUgYnkgdHJpZ2dlcmluZyBub3RlQXR0YWNrIGFuZCBub3RlUmVsZWFzZSB3aXRoIHN1c3RhaW4gdGltZVxuICAgKlxuICAgKiAgQG1ldGhvZCAgcGxheVxuICAgKiAgQGZvciBwNS5Qb2x5U3ludGhcbiAgICogIEBwYXJhbSAge051bWJlcn0gW25vdGVdIG1pZGkgbm90ZSB0byBwbGF5IChyYW5naW5nIGZyb20gMCB0byAxMjcgLSA2MCBiZWluZyBhIG1pZGRsZSBDKVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbdmVsb2NpdHldIHZlbG9jaXR5IG9mIHRoZSBub3RlIHRvIHBsYXkgKHJhbmdpbmcgZnJvbSAwIHRvIDEpXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFtzZWNvbmRzRnJvbU5vd10gIHRpbWUgZnJvbSBub3cgKGluIHNlY29uZHMpIGF0IHdoaWNoIHRvIHBsYXlcbiAgICogIEBwYXJhbSAge051bWJlcn0gW3N1c3RhaW5UaW1lXSB0aW1lIHRvIHN1c3RhaW4gYmVmb3JlIHJlbGVhc2luZyB0aGUgZW52ZWxvcGVcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IHBvbHlTeW50aDtcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChwbGF5U3ludGgpO1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ2NsaWNrIHRvIHBsYXknLCAyMCwgMjApO1xuICAgKlxuICAgKiAgICBwb2x5U3ludGggPSBuZXcgcDUuUG9seVN5bnRoKCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBwbGF5U3ludGgoKSB7XG4gICAqICAgIHVzZXJTdGFydEF1ZGlvKCk7XG4gICAqXG4gICAqICAgIC8vIG5vdGUgZHVyYXRpb24gKGluIHNlY29uZHMpXG4gICAqICAgIGxldCBkdXIgPSAxLjU7XG4gICAqXG4gICAqICAgIC8vIHRpbWUgZnJvbSBub3cgKGluIHNlY29uZHMpXG4gICAqICAgIGxldCB0aW1lID0gMDtcbiAgICpcbiAgICogICAgLy8gdmVsb2NpdHkgKHZvbHVtZSwgZnJvbSAwIHRvIDEpXG4gICAqICAgIGxldCB2ZWwgPSAwLjE7XG4gICAqXG4gICAqICAgIC8vIG5vdGVzIGNhbiBvdmVybGFwIHdpdGggZWFjaCBvdGhlclxuICAgKiAgICBwb2x5U3ludGgucGxheSgnRzInLCB2ZWwsIDAsIGR1cik7XG4gICAqICAgIHBvbHlTeW50aC5wbGF5KCdDMycsIHZlbCwgdGltZSArPSAxLzMsIGR1cik7XG4gICAqICAgIHBvbHlTeW50aC5wbGF5KCdHMycsIHZlbCwgdGltZSArPSAxLzMsIGR1cik7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuUG9seVN5bnRoLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKG5vdGUsIHZlbG9jaXR5LCBzZWNvbmRzRnJvbU5vdywgc3VzVGltZSkge1xuICAgIHZhciBzdXNUaW1lID0gc3VzVGltZSB8fCAxO1xuICAgIHRoaXMubm90ZUF0dGFjayhub3RlLCB2ZWxvY2l0eSwgc2Vjb25kc0Zyb21Ob3cpO1xuICAgIHRoaXMubm90ZVJlbGVhc2Uobm90ZSwgc2Vjb25kc0Zyb21Ob3cgKyBzdXNUaW1lKTtcbiAgfTtcbiAgLyoqXG4gICAqICBub3RlQURTUiBzZXRzIHRoZSBlbnZlbG9wZSBmb3IgYSBzcGVjaWZpYyBub3RlIHRoYXQgaGFzIGp1c3QgYmVlbiB0cmlnZ2VyZWQuXG4gICAqICBVc2luZyB0aGlzIG1ldGhvZCBtb2RpZmllcyB0aGUgZW52ZWxvcGUgb2Ygd2hpY2hldmVyIGF1ZGlvdm9pY2UgaXMgYmVpbmcgdXNlZFxuICAgKiAgdG8gcGxheSB0aGUgZGVzaXJlZCBub3RlLiBUaGUgZW52ZWxvcGUgc2hvdWxkIGJlIHJlc2V0IGJlZm9yZSBub3RlUmVsZWFzZSBpcyBjYWxsZWRcbiAgICogIGluIG9yZGVyIHRvIHByZXZlbnQgdGhlIG1vZGlmaWVkIGVudmVsb3BlIGZyb20gYmVpbmcgdXNlZCBvbiBvdGhlciBub3Rlcy5cbiAgICpcbiAgICogIEBtZXRob2QgIG5vdGVBRFNSXG4gICAqICBAZm9yIHA1LlBvbHlTeW50aFxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtub3RlXSAgICAgICAgTWlkaSBub3RlIG9uIHdoaWNoIEFEU1Igc2hvdWxkIGJlIHNldC5cbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbYXR0YWNrVGltZV0gIFRpbWUgKGluIHNlY29uZHMgYmVmb3JlIGVudmVsb3BlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFjaGVzIEF0dGFjayBMZXZlbFxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtkZWNheVRpbWVdICAgVGltZSAoaW4gc2Vjb25kcykgYmVmb3JlIGVudmVsb3BlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFjaGVzIERlY2F5L1N1c3RhaW4gTGV2ZWxcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbc3VzUmF0aW9dICAgIFJhdGlvIGJldHdlZW4gYXR0YWNrTGV2ZWwgYW5kIHJlbGVhc2VMZXZlbCwgb24gYSBzY2FsZSBmcm9tIDAgdG8gMSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlIDEuMCA9IGF0dGFja0xldmVsLCAwLjAgPSByZWxlYXNlTGV2ZWwuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgc3VzUmF0aW8gZGV0ZXJtaW5lcyB0aGUgZGVjYXlMZXZlbCBhbmQgdGhlIGxldmVsIGF0IHdoaWNoIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VzdGFpbiBwb3J0aW9uIG9mIHRoZSBlbnZlbG9wZSB3aWxsIHN1c3RhaW4uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgZXhhbXBsZSwgaWYgYXR0YWNrTGV2ZWwgaXMgMC40LCByZWxlYXNlTGV2ZWwgaXMgMCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBzdXNBbXQgaXMgMC41LCB0aGUgZGVjYXlMZXZlbCB3b3VsZCBiZSAwLjIuIElmIGF0dGFja0xldmVsIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNyZWFzZWQgdG8gMS4wICh1c2luZyA8Y29kZT5zZXRSYW5nZTwvY29kZT4pLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBkZWNheUxldmVsIHdvdWxkIGluY3JlYXNlIHByb3BvcnRpb25hbGx5LCB0byBiZWNvbWUgMC41LlxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtyZWxlYXNlVGltZV0gICBUaW1lIGluIHNlY29uZHMgZnJvbSBub3cgKGRlZmF1bHRzIHRvIDApXG4gICAqKi9cblxuXG4gIHA1LlBvbHlTeW50aC5wcm90b3R5cGUubm90ZUFEU1IgPSBmdW5jdGlvbiAobm90ZSwgYSwgZCwgcywgciwgdGltZUZyb21Ob3cpIHtcbiAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgdmFyIHRpbWVGcm9tTm93ID0gdGltZUZyb21Ob3cgfHwgMDtcbiAgICB2YXIgdCA9IG5vdyArIHRpbWVGcm9tTm93O1xuICAgIHRoaXMuYXVkaW92b2ljZXNbdGhpcy5ub3Rlc1tub3RlXS5nZXRWYWx1ZUF0VGltZSh0KV0uc2V0QURTUihhLCBkLCBzLCByKTtcbiAgfTtcbiAgLyoqXG4gICAqIFNldCB0aGUgUG9seVN5bnRocyBnbG9iYWwgZW52ZWxvcGUuIFRoaXMgbWV0aG9kIG1vZGlmaWVzIHRoZSBlbnZlbG9wZXMgb2YgZWFjaFxuICAgKiBtb25vc3ludGggc28gdGhhdCBhbGwgbm90ZXMgYXJlIHBsYXllZCB3aXRoIHRoaXMgZW52ZWxvcGUuXG4gICAqXG4gICAqICBAbWV0aG9kICBzZXRBRFNSXG4gICAqICBAZm9yIHA1LlBvbHlTeW50aFxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFthdHRhY2tUaW1lXSAgVGltZSAoaW4gc2Vjb25kcyBiZWZvcmUgZW52ZWxvcGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWNoZXMgQXR0YWNrIExldmVsXG4gICAqICBAcGFyYW0ge051bWJlcn0gW2RlY2F5VGltZV0gICBUaW1lIChpbiBzZWNvbmRzKSBiZWZvcmUgZW52ZWxvcGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWNoZXMgRGVjYXkvU3VzdGFpbiBMZXZlbFxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtzdXNSYXRpb10gICAgUmF0aW8gYmV0d2VlbiBhdHRhY2tMZXZlbCBhbmQgcmVsZWFzZUxldmVsLCBvbiBhIHNjYWxlIGZyb20gMCB0byAxLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmUgMS4wID0gYXR0YWNrTGV2ZWwsIDAuMCA9IHJlbGVhc2VMZXZlbC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBzdXNSYXRpbyBkZXRlcm1pbmVzIHRoZSBkZWNheUxldmVsIGFuZCB0aGUgbGV2ZWwgYXQgd2hpY2ggdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXN0YWluIHBvcnRpb24gb2YgdGhlIGVudmVsb3BlIHdpbGwgc3VzdGFpbi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZvciBleGFtcGxlLCBpZiBhdHRhY2tMZXZlbCBpcyAwLjQsIHJlbGVhc2VMZXZlbCBpcyAwLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHN1c0FtdCBpcyAwLjUsIHRoZSBkZWNheUxldmVsIHdvdWxkIGJlIDAuMi4gSWYgYXR0YWNrTGV2ZWwgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlYXNlZCB0byAxLjAgKHVzaW5nIDxjb2RlPnNldFJhbmdlPC9jb2RlPiksXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIGRlY2F5TGV2ZWwgd291bGQgaW5jcmVhc2UgcHJvcG9ydGlvbmFsbHksIHRvIGJlY29tZSAwLjUuXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3JlbGVhc2VUaW1lXSAgIFRpbWUgaW4gc2Vjb25kcyBmcm9tIG5vdyAoZGVmYXVsdHMgdG8gMClcbiAgICoqL1xuXG5cbiAgcDUuUG9seVN5bnRoLnByb3RvdHlwZS5zZXRBRFNSID0gZnVuY3Rpb24gKGEsIGQsIHMsIHIpIHtcbiAgICB0aGlzLmF1ZGlvdm9pY2VzLmZvckVhY2goZnVuY3Rpb24gKHZvaWNlKSB7XG4gICAgICB2b2ljZS5zZXRBRFNSKGEsIGQsIHMsIHIpO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogIFRyaWdnZXIgdGhlIEF0dGFjaywgYW5kIERlY2F5IHBvcnRpb24gb2YgYSBNb25vU3ludGguXG4gICAqICBTaW1pbGFyIHRvIGhvbGRpbmcgZG93biBhIGtleSBvbiBhIHBpYW5vLCBidXQgaXQgd2lsbFxuICAgKiAgaG9sZCB0aGUgc3VzdGFpbiBsZXZlbCB1bnRpbCB5b3UgbGV0IGdvLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgbm90ZUF0dGFja1xuICAgKiAgQGZvciBwNS5Qb2x5U3ludGhcbiAgICogIEBwYXJhbSAge051bWJlcn0gW25vdGVdICAgICAgICAgICBtaWRpIG5vdGUgb24gd2hpY2ggYXR0YWNrIHNob3VsZCBiZSB0cmlnZ2VyZWQuXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFt2ZWxvY2l0eV0gICAgICAgdmVsb2NpdHkgb2YgdGhlIG5vdGUgdG8gcGxheSAocmFuZ2luZyBmcm9tIDAgdG8gMSkvXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFtzZWNvbmRzRnJvbU5vd10gdGltZSBmcm9tIG5vdyAoaW4gc2Vjb25kcylcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IHBvbHlTeW50aCA9IG5ldyBwNS5Qb2x5U3ludGgoKTtcbiAgICogIGxldCBwaXRjaGVzID0gWydHJywgJ0QnLCAnRycsICdDJ107XG4gICAqICBsZXQgb2N0YXZlcyA9IFsyLCAzLCA0XTtcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChwbGF5Q2hvcmQpO1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ3RhcCB0byBwbGF5JywgMjAsIDIwKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHBsYXlDaG9yZCgpIHtcbiAgICogICAgdXNlclN0YXJ0QXVkaW8oKTtcbiAgICpcbiAgICogICAgLy8gcGxheSBhIGNob3JkOiBtdWx0aXBsZSBub3RlcyBhdCB0aGUgc2FtZSB0aW1lXG4gICAqICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAqICAgICAgbGV0IG5vdGUgPSByYW5kb20ocGl0Y2hlcykgKyByYW5kb20ob2N0YXZlcyk7XG4gICAqICAgICAgcG9seVN5bnRoLm5vdGVBdHRhY2sobm90ZSwgMC4xKTtcbiAgICogICAgfVxuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gbW91c2VSZWxlYXNlZCgpIHtcbiAgICogICAgLy8gcmVsZWFzZSBhbGwgdm9pY2VzXG4gICAqICAgIHBvbHlTeW50aC5ub3RlUmVsZWFzZSgpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LlBvbHlTeW50aC5wcm90b3R5cGUubm90ZUF0dGFjayA9IGZ1bmN0aW9uIChfbm90ZSwgX3ZlbG9jaXR5LCBzZWNvbmRzRnJvbU5vdykge1xuICAgIHZhciBzZWNvbmRzRnJvbU5vdyA9IH5+c2Vjb25kc0Zyb21Ob3c7IFxuXG4gICAgdmFyIGFjVGltZSA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lICsgc2Vjb25kc0Zyb21Ob3c7IFxuXG4gICAgdmFyIG5vdGUgPSBub3RlVG9GcmVxKF9ub3RlKTtcbiAgICB2YXIgdmVsb2NpdHkgPSBfdmVsb2NpdHkgfHwgMC4xO1xuICAgIHZhciBjdXJyZW50Vm9pY2U7IFxuXG4gICAgaWYgKHRoaXMubm90ZXNbbm90ZV0gJiYgdGhpcy5ub3Rlc1tub3RlXS5nZXRWYWx1ZUF0VGltZShhY1RpbWUpICE9PSBudWxsKSB7XG4gICAgICB0aGlzLm5vdGVSZWxlYXNlKG5vdGUsIDApO1xuICAgIH0gXG5cblxuICAgIGlmICh0aGlzLl92b2ljZXNJblVzZS5nZXRWYWx1ZUF0VGltZShhY1RpbWUpIDwgdGhpcy5tYXhWb2ljZXMpIHtcbiAgICAgIGN1cnJlbnRWb2ljZSA9IE1hdGgubWF4KH5+dGhpcy5fdm9pY2VzSW5Vc2UuZ2V0VmFsdWVBdFRpbWUoYWNUaW1lKSwgMCk7XG4gICAgfSBcbiAgICBlbHNlIHtcbiAgICAgICAgY3VycmVudFZvaWNlID0gdGhpcy5fb2xkZXN0O1xuICAgICAgICB2YXIgb2xkZXN0Tm90ZSA9IHA1LnByb3RvdHlwZS5mcmVxVG9NaWRpKHRoaXMuYXVkaW92b2ljZXNbdGhpcy5fb2xkZXN0XS5vc2NpbGxhdG9yLmZyZXEoKS52YWx1ZSk7XG4gICAgICAgIHRoaXMubm90ZVJlbGVhc2Uob2xkZXN0Tm90ZSk7XG4gICAgICAgIHRoaXMuX29sZGVzdCA9ICh0aGlzLl9vbGRlc3QgKyAxKSAlICh0aGlzLm1heFZvaWNlcyAtIDEpO1xuICAgICAgfSBcblxuXG4gICAgdGhpcy5ub3Rlc1tub3RlXSA9IG5ldyBUaW1lbGluZVNpZ25hbCgpO1xuICAgIHRoaXMubm90ZXNbbm90ZV0uc2V0VmFsdWVBdFRpbWUoY3VycmVudFZvaWNlLCBhY1RpbWUpOyBcblxuICAgIHZhciBwcmV2aW91c1ZhbCA9IHRoaXMuX3ZvaWNlc0luVXNlLl9zZWFyY2hCZWZvcmUoYWNUaW1lKSA9PT0gbnVsbCA/IDAgOiB0aGlzLl92b2ljZXNJblVzZS5fc2VhcmNoQmVmb3JlKGFjVGltZSkudmFsdWU7XG5cbiAgICB0aGlzLl92b2ljZXNJblVzZS5zZXRWYWx1ZUF0VGltZShwcmV2aW91c1ZhbCArIDEsIGFjVGltZSk7IFxuXG5cbiAgICB0aGlzLl91cGRhdGVBZnRlcihhY1RpbWUsIDEpO1xuXG4gICAgdGhpcy5fbmV3ZXN0ID0gY3VycmVudFZvaWNlOyBcblxuICAgIGlmICh0eXBlb2YgdmVsb2NpdHkgPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgbWF4UmFuZ2UgPSAxIC8gdGhpcy5fdm9pY2VzSW5Vc2UuZ2V0VmFsdWVBdFRpbWUoYWNUaW1lKSAqIDI7XG4gICAgICB2ZWxvY2l0eSA9IHZlbG9jaXR5ID4gbWF4UmFuZ2UgPyBtYXhSYW5nZSA6IHZlbG9jaXR5O1xuICAgIH1cblxuICAgIHRoaXMuYXVkaW92b2ljZXNbY3VycmVudFZvaWNlXS50cmlnZ2VyQXR0YWNrKG5vdGUsIHZlbG9jaXR5LCBzZWNvbmRzRnJvbU5vdyk7XG4gIH07XG4gIC8qKlxuICAgKiBQcml2YXRlIG1ldGhvZCB0byBlbnN1cmUgYWNjdXJhdGUgdmFsdWVzIG9mIHRoaXMuX3ZvaWNlc0luVXNlXG4gICAqIEFueSB0aW1lIGEgbmV3IHZhbHVlIGlzIHNjaGVkdWxlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGluY3JlbWVudCBhbGwgc3Vic2VxdWVudFxuICAgKiBzY2hlZHVsZWRWYWx1ZXMgYWZ0ZXIgYXR0YWNrLCBhbmQgZGVjcmVtZW50IGFsbCBzdWJzZXF1ZW50XG4gICAqIHNjaGVkdWxlZFZhbHVlcyBhZnRlciByZWxlYXNlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmb3IgcDUuUG9seVN5bnRoXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gdGltZSAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IHZhbHVlIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuXG5cbiAgcDUuUG9seVN5bnRoLnByb3RvdHlwZS5fdXBkYXRlQWZ0ZXIgPSBmdW5jdGlvbiAodGltZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5fdm9pY2VzSW5Vc2UuX3NlYXJjaEFmdGVyKHRpbWUpID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3ZvaWNlc0luVXNlLl9zZWFyY2hBZnRlcih0aW1lKS52YWx1ZSArPSB2YWx1ZTtcblxuICAgICAgdmFyIG5leHRUaW1lID0gdGhpcy5fdm9pY2VzSW5Vc2UuX3NlYXJjaEFmdGVyKHRpbWUpLnRpbWU7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZUFmdGVyKG5leHRUaW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIFRyaWdnZXIgdGhlIFJlbGVhc2Ugb2YgYW4gQXVkaW9Wb2ljZSBub3RlLiBUaGlzIGlzIHNpbWlsYXIgdG8gcmVsZWFzaW5nXG4gICAqICB0aGUga2V5IG9uIGEgcGlhbm8gYW5kIGxldHRpbmcgdGhlIHNvdW5kIGZhZGUgYWNjb3JkaW5nIHRvIHRoZVxuICAgKiAgcmVsZWFzZSBsZXZlbCBhbmQgcmVsZWFzZSB0aW1lLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgbm90ZVJlbGVhc2VcbiAgICogIEBmb3IgcDUuUG9seVN5bnRoXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFtub3RlXSAgICAgICAgICAgbWlkaSBub3RlIG9uIHdoaWNoIGF0dGFjayBzaG91bGQgYmUgdHJpZ2dlcmVkLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vIHZhbHVlIGlzIHByb3ZpZGVkLCBhbGwgbm90ZXMgd2lsbCBiZSByZWxlYXNlZC5cbiAgICogIEBwYXJhbSAge051bWJlcn0gW3NlY29uZHNGcm9tTm93XSB0aW1lIHRvIHRyaWdnZXIgdGhlIHJlbGVhc2VcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IHBvbHlTeW50aCA9IG5ldyBwNS5Qb2x5U3ludGgoKTtcbiAgICogIGxldCBwaXRjaGVzID0gWydHJywgJ0QnLCAnRycsICdDJ107XG4gICAqICBsZXQgb2N0YXZlcyA9IFsyLCAzLCA0XTtcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChwbGF5Q2hvcmQpO1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ3RhcCB0byBwbGF5JywgMjAsIDIwKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHBsYXlDaG9yZCgpIHtcbiAgICogICAgdXNlclN0YXJ0QXVkaW8oKTtcbiAgICpcbiAgICogICAgLy8gcGxheSBhIGNob3JkOiBtdWx0aXBsZSBub3RlcyBhdCB0aGUgc2FtZSB0aW1lXG4gICAqICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAqICAgICAgbGV0IG5vdGUgPSByYW5kb20ocGl0Y2hlcykgKyByYW5kb20ob2N0YXZlcyk7XG4gICAqICAgICAgcG9seVN5bnRoLm5vdGVBdHRhY2sobm90ZSwgMC4xKTtcbiAgICogICAgfVxuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gbW91c2VSZWxlYXNlZCgpIHtcbiAgICogICAgLy8gcmVsZWFzZSBhbGwgdm9pY2VzXG4gICAqICAgIHBvbHlTeW50aC5ub3RlUmVsZWFzZSgpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKlxuICAgKi9cblxuXG4gIHA1LlBvbHlTeW50aC5wcm90b3R5cGUubm90ZVJlbGVhc2UgPSBmdW5jdGlvbiAoX25vdGUsIHNlY29uZHNGcm9tTm93KSB7XG4gICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgIHZhciB0RnJvbU5vdyA9IHNlY29uZHNGcm9tTm93IHx8IDA7XG4gICAgdmFyIHQgPSBub3cgKyB0RnJvbU5vdzsgXG5cbiAgICBpZiAoIV9ub3RlKSB7XG4gICAgICB0aGlzLmF1ZGlvdm9pY2VzLmZvckVhY2goZnVuY3Rpb24gKHZvaWNlKSB7XG4gICAgICAgIHZvaWNlLnRyaWdnZXJSZWxlYXNlKHRGcm9tTm93KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl92b2ljZXNJblVzZS5zZXRWYWx1ZUF0VGltZSgwLCB0KTtcblxuICAgICAgZm9yICh2YXIgbiBpbiB0aGlzLm5vdGVzKSB7XG4gICAgICAgIHRoaXMubm90ZXNbbl0uZGlzcG9zZSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5ub3Rlc1tuXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH0gXG5cblxuICAgIHZhciBub3RlID0gbm90ZVRvRnJlcShfbm90ZSk7XG5cbiAgICBpZiAoIXRoaXMubm90ZXNbbm90ZV0gfHwgdGhpcy5ub3Rlc1tub3RlXS5nZXRWYWx1ZUF0VGltZSh0KSA9PT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKCdDYW5ub3QgcmVsZWFzZSBhIG5vdGUgdGhhdCBpcyBub3QgYWxyZWFkeSBwbGF5aW5nJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmV2aW91c1ZhbCA9IE1hdGgubWF4KH5+dGhpcy5fdm9pY2VzSW5Vc2UuZ2V0VmFsdWVBdFRpbWUodCkudmFsdWUsIDEpO1xuXG4gICAgICB0aGlzLl92b2ljZXNJblVzZS5zZXRWYWx1ZUF0VGltZShwcmV2aW91c1ZhbCAtIDEsIHQpOyBcblxuXG4gICAgICBpZiAocHJldmlvdXNWYWwgPiAwKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUFmdGVyKHQsIC0xKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hdWRpb3ZvaWNlc1t0aGlzLm5vdGVzW25vdGVdLmdldFZhbHVlQXRUaW1lKHQpXS50cmlnZ2VyUmVsZWFzZSh0RnJvbU5vdyk7XG4gICAgICB0aGlzLm5vdGVzW25vdGVdLmRpc3Bvc2UoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLm5vdGVzW25vdGVdO1xuICAgICAgdGhpcy5fbmV3ZXN0ID0gdGhpcy5fbmV3ZXN0ID09PSAwID8gMCA6ICh0aGlzLl9uZXdlc3QgLSAxKSAlICh0aGlzLm1heFZvaWNlcyAtIDEpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAgKiAgQ29ubmVjdCB0byBhIHA1LnNvdW5kIC8gV2ViIEF1ZGlvIG9iamVjdC5cbiAgICAqXG4gICAgKiAgQG1ldGhvZCAgY29ubmVjdFxuICAgICogIEBmb3IgcDUuUG9seVN5bnRoXG4gICAgKiAgQHBhcmFtICB7T2JqZWN0fSB1bml0IEEgcDUuc291bmQgb3IgV2ViIEF1ZGlvIG9iamVjdFxuICAgICovXG5cblxuICBwNS5Qb2x5U3ludGgucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAodW5pdCkge1xuICAgIHZhciB1ID0gdW5pdCB8fCBwNXNvdW5kLmlucHV0O1xuICAgIHRoaXMub3V0cHV0LmNvbm5lY3QodS5pbnB1dCA/IHUuaW5wdXQgOiB1KTtcbiAgfTtcbiAgLyoqXG4gICogIERpc2Nvbm5lY3QgYWxsIG91dHB1dHNcbiAgKlxuICAqICBAbWV0aG9kICBkaXNjb25uZWN0XG4gICogIEBmb3IgcDUuUG9seVN5bnRoXG4gICovXG5cblxuICBwNS5Qb2x5U3ludGgucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3V0cHV0KSB7XG4gICAgICB0aGlzLm91dHB1dC5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICAqICBHZXQgcmlkIG9mIHRoZSBNb25vU3ludGggYW5kIGZyZWUgdXAgaXRzIHJlc291cmNlcyAvIG1lbW9yeS5cbiAgICAqXG4gICAgKiAgQG1ldGhvZCAgZGlzcG9zZVxuICAgICogIEBmb3IgcDUuUG9seVN5bnRoXG4gICAgKi9cblxuXG4gIHA1LlBvbHlTeW50aC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmF1ZGlvdm9pY2VzLmZvckVhY2goZnVuY3Rpb24gKHZvaWNlKSB7XG4gICAgICB2b2ljZS5kaXNwb3NlKCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5vdXRwdXQpIHtcbiAgICAgIHRoaXMub3V0cHV0LmRpc2Nvbm5lY3QoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLm91dHB1dDtcbiAgICB9XG4gIH07XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbiAgdmFyIHA1U09VTkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg2Mik7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg2Myk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg2NSk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg2OCk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg3Mik7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG5cbiAgcmV0dXJuIHA1U09VTkQ7XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuIWZ1bmN0aW9uKCl7dmFyIGwscz1bXTtmdW5jdGlvbiBwKGUpe3ZhciBvPXRoaXMsbj17fSxpPS0xO3RoaXMucGFyYW1ldGVycy5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7dmFyIHI9c1srK2ldfHwoc1tpXT1uZXcgRmxvYXQzMkFycmF5KG8uYnVmZmVyU2l6ZSkpO3IuZmlsbChlLnZhbHVlKSxuW3RdPXJ9KSx0aGlzLnByb2Nlc3Nvci5yZWFsbS5leGVjKFwic2VsZi5zYW1wbGVSYXRlPXNhbXBsZVJhdGU9XCIrdGhpcy5jb250ZXh0LnNhbXBsZVJhdGUrXCI7c2VsZi5jdXJyZW50VGltZT1jdXJyZW50VGltZT1cIit0aGlzLmNvbnRleHQuY3VycmVudFRpbWUpO3ZhciB0PWEoZS5pbnB1dEJ1ZmZlcikscj1hKGUub3V0cHV0QnVmZmVyKTt0aGlzLmluc3RhbmNlLnByb2Nlc3MoW3RdLFtyXSxuKX1mdW5jdGlvbiBhKGUpe2Zvcih2YXIgdD1bXSxyPTA7cjxlLm51bWJlck9mQ2hhbm5lbHM7cisrKXRbcl09ZS5nZXRDaGFubmVsRGF0YShyKTtyZXR1cm4gdH1mdW5jdGlvbiBmKGUpe3JldHVybiBlLiQkcHJvY2Vzc29yc3x8KGUuJCRwcm9jZXNzb3JzPXt9KX1mdW5jdGlvbiBlKGUpe3RoaXMuJCRjb250ZXh0PWV9XCJmdW5jdGlvblwiIT10eXBlb2YgQXVkaW9Xb3JrbGV0Tm9kZSYmKHNlbGYuQXVkaW9Xb3JrbGV0Tm9kZT1mdW5jdGlvbihlLHQscil7dmFyIG89ZihlKVt0XSxuPWUuY3JlYXRlU2NyaXB0UHJvY2Vzc29yKHZvaWQgMCwyLHImJnIub3V0cHV0Q2hhbm5lbENvdW50P3Iub3V0cHV0Q2hhbm5lbENvdW50WzBdOjIpO2lmKG4ucGFyYW1ldGVycz1uZXcgTWFwLG8ucHJvcGVydGllcylmb3IodmFyIGk9MDtpPG8ucHJvcGVydGllcy5sZW5ndGg7aSsrKXt2YXIgcz1vLnByb3BlcnRpZXNbaV0sYT1lLmNyZWF0ZUdhaW4oKS5nYWluO2EudmFsdWU9cy5kZWZhdWx0VmFsdWUsbi5wYXJhbWV0ZXJzLnNldChzLm5hbWUsYSl9dmFyIHU9bmV3IE1lc3NhZ2VDaGFubmVsO2w9dS5wb3J0Mjt2YXIgYz1uZXcgby5Qcm9jZXNzb3Iocnx8e30pO3JldHVybiBsPW51bGwsbi5wb3J0PXUucG9ydDEsbi5wcm9jZXNzb3I9byxuLmluc3RhbmNlPWMsbi5vbmF1ZGlvcHJvY2Vzcz1wLG59LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgoc2VsZi5BdWRpb0NvbnRleHR8fHNlbGYud2Via2l0QXVkaW9Db250ZXh0KS5wcm90b3R5cGUsXCJhdWRpb1dvcmtsZXRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJCRhdWRpb1dvcmtsZXR8fCh0aGlzLiQkYXVkaW9Xb3JrbGV0PW5ldyBzZWxmLkF1ZGlvV29ya2xldCh0aGlzKSl9fSksc2VsZi5BdWRpb1dvcmtsZXQ9KGUucHJvdG90eXBlLmFkZE1vZHVsZT1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIGZldGNoKGUpLnRoZW4oZnVuY3Rpb24oZSl7aWYoIWUub2spdGhyb3cgRXJyb3IoZS5zdGF0dXMpO3JldHVybiBlLnRleHQoKX0pLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHI9e3NhbXBsZVJhdGU6MCxjdXJyZW50VGltZTowLEF1ZGlvV29ya2xldFByb2Nlc3NvcjpmdW5jdGlvbigpe3RoaXMucG9ydD1sfSxyZWdpc3RlclByb2Nlc3NvcjpmdW5jdGlvbihlLHQpe2Yobi4kJGNvbnRleHQpW2VdPXtyZWFsbTpvLGNvbnRleHQ6cixQcm9jZXNzb3I6dCxwcm9wZXJ0aWVzOnQucGFyYW1ldGVyRGVzY3JpcHRvcnN8fFtdfX19LG89bmV3IGZ1bmN0aW9uKGUsdCl7dmFyIHI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtyLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOi05OTlweDt3aWR0aDoxcHg7aGVpZ2h0OjFweDtcIix0LmFwcGVuZENoaWxkKHIpO3ZhciBvPXIuY29udGVudFdpbmRvdyxuPW8uZG9jdW1lbnQsaT1cInZhciB3aW5kb3csJGhvb2tcIjtmb3IodmFyIHMgaW4gbylzIGluIGV8fFwiZXZhbFwiPT09c3x8KGkrPVwiLFwiLGkrPXMpO2Zvcih2YXIgYSBpbiBlKWkrPVwiLFwiLGkrPWEsaSs9XCI9c2VsZi5cIixpKz1hO3ZhciB1PW4uY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTt1LmFwcGVuZENoaWxkKG4uY3JlYXRlVGV4dE5vZGUoJ2Z1bmN0aW9uICRob29rKHNlbGYsY29uc29sZSkge1widXNlIHN0cmljdFwiO1xcbiAgICAgICAgJytpK1wiO3JldHVybiBmdW5jdGlvbigpIHtyZXR1cm4gZXZhbChhcmd1bWVudHNbMF0pfX1cIikpLG4uYm9keS5hcHBlbmRDaGlsZCh1KSx0aGlzLmV4ZWM9by4kaG9vayhlLGNvbnNvbGUpfShyLnNlbGY9cixkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO3JldHVybiBvLmV4ZWMoKHQmJnQudHJhbnNwaWxlfHxTdHJpbmcpKGUpKSxudWxsfSl9LGUpKX0oKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG4vKipcbiAqIFRoaXMgbW9kdWxlIGhhcyBzaGltc1xuICovXG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKCkge1xuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGZpeFNldFRhcmdldChwYXJhbSkge1xuICAgICAgaWYgKCFwYXJhbSkgXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICghcGFyYW0uc2V0VGFyZ2V0QXRUaW1lKSBwYXJhbS5zZXRUYXJnZXRBdFRpbWUgPSBwYXJhbS5zZXRUYXJnZXRWYWx1ZUF0VGltZTtcbiAgICB9XG5cbiAgICBpZiAod2luZG93Lmhhc093blByb3BlcnR5KCd3ZWJraXRBdWRpb0NvbnRleHQnKSAmJiAhd2luZG93Lmhhc093blByb3BlcnR5KCdBdWRpb0NvbnRleHQnKSkge1xuICAgICAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XG4gICAgICBpZiAodHlwZW9mIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2FpbiAhPT0gJ2Z1bmN0aW9uJykgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluTm9kZTtcbiAgICAgIGlmICh0eXBlb2YgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheSAhPT0gJ2Z1bmN0aW9uJykgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheSA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRGVsYXlOb2RlO1xuICAgICAgaWYgKHR5cGVvZiBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZVNjcmlwdFByb2Nlc3NvciAhPT0gJ2Z1bmN0aW9uJykgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVTY3JpcHRQcm9jZXNzb3IgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUphdmFTY3JpcHROb2RlO1xuICAgICAgaWYgKHR5cGVvZiBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZVBlcmlvZGljV2F2ZSAhPT0gJ2Z1bmN0aW9uJykgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVQZXJpb2RpY1dhdmUgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZVdhdmVUYWJsZTtcbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlR2FpbiA9IEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlR2FpbjtcblxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlR2FpbigpO1xuICAgICAgICBmaXhTZXRUYXJnZXQobm9kZS5nYWluKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9O1xuXG4gICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmludGVybmFsX2NyZWF0ZURlbGF5ID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheTtcblxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheSA9IGZ1bmN0aW9uIChtYXhEZWxheVRpbWUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBtYXhEZWxheVRpbWUgPyB0aGlzLmludGVybmFsX2NyZWF0ZURlbGF5KG1heERlbGF5VGltZSkgOiB0aGlzLmludGVybmFsX2NyZWF0ZURlbGF5KCk7XG4gICAgICAgIGZpeFNldFRhcmdldChub2RlLmRlbGF5VGltZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfTtcblxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5pbnRlcm5hbF9jcmVhdGVCdWZmZXJTb3VyY2UgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZUJ1ZmZlclNvdXJjZTtcblxuICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVCdWZmZXJTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5pbnRlcm5hbF9jcmVhdGVCdWZmZXJTb3VyY2UoKTtcblxuICAgICAgICBpZiAoIW5vZGUuc3RhcnQpIHtcbiAgICAgICAgICBub2RlLnN0YXJ0ID0gZnVuY3Rpb24gKHdoZW4sIG9mZnNldCwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgfHwgZHVyYXRpb24pIHRoaXMubm90ZUdyYWluT24od2hlbiB8fCAwLCBvZmZzZXQsIGR1cmF0aW9uKTtlbHNlIHRoaXMubm90ZU9uKHdoZW4gfHwgMCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmludGVybmFsX3N0YXJ0ID0gbm9kZS5zdGFydDtcblxuICAgICAgICAgIG5vZGUuc3RhcnQgPSBmdW5jdGlvbiAod2hlbiwgb2Zmc2V0LCBkdXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkdXJhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIG5vZGUuaW50ZXJuYWxfc3RhcnQod2hlbiB8fCAwLCBvZmZzZXQsIGR1cmF0aW9uKTtlbHNlIG5vZGUuaW50ZXJuYWxfc3RhcnQod2hlbiB8fCAwLCBvZmZzZXQgfHwgMCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbm9kZS5zdG9wKSB7XG4gICAgICAgICAgbm9kZS5zdG9wID0gZnVuY3Rpb24gKHdoZW4pIHtcbiAgICAgICAgICAgIHRoaXMubm90ZU9mZih3aGVuIHx8IDApO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5pbnRlcm5hbF9zdG9wID0gbm9kZS5zdG9wO1xuXG4gICAgICAgICAgbm9kZS5zdG9wID0gZnVuY3Rpb24gKHdoZW4pIHtcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RvcCh3aGVuIHx8IDApO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmaXhTZXRUYXJnZXQobm9kZS5wbGF5YmFja1JhdGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH07XG5cbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlRHluYW1pY3NDb21wcmVzc29yID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEeW5hbWljc0NvbXByZXNzb3I7XG5cbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRHluYW1pY3NDb21wcmVzc29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlRHluYW1pY3NDb21wcmVzc29yKCk7XG4gICAgICAgIGZpeFNldFRhcmdldChub2RlLnRocmVzaG9sZCk7XG4gICAgICAgIGZpeFNldFRhcmdldChub2RlLmtuZWUpO1xuICAgICAgICBmaXhTZXRUYXJnZXQobm9kZS5yYXRpbyk7XG4gICAgICAgIGZpeFNldFRhcmdldChub2RlLnJlZHVjdGlvbik7XG4gICAgICAgIGZpeFNldFRhcmdldChub2RlLmF0dGFjayk7XG4gICAgICAgIGZpeFNldFRhcmdldChub2RlLnJlbGVhc2UpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH07XG5cbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuaW50ZXJuYWxfY3JlYXRlQmlxdWFkRmlsdGVyID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVCaXF1YWRGaWx0ZXI7XG5cbiAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQmlxdWFkRmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuaW50ZXJuYWxfY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG4gICAgICAgIGZpeFNldFRhcmdldChub2RlLmZyZXF1ZW5jeSk7XG4gICAgICAgIGZpeFNldFRhcmdldChub2RlLmRldHVuZSk7XG4gICAgICAgIGZpeFNldFRhcmdldChub2RlLlEpO1xuICAgICAgICBmaXhTZXRUYXJnZXQobm9kZS5nYWluKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9O1xuXG4gICAgICBpZiAodHlwZW9mIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlT3NjaWxsYXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBBdWRpb0NvbnRleHQucHJvdG90eXBlLmludGVybmFsX2NyZWF0ZU9zY2lsbGF0b3IgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZU9zY2lsbGF0b3I7XG5cbiAgICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVPc2NpbGxhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBub2RlID0gdGhpcy5pbnRlcm5hbF9jcmVhdGVPc2NpbGxhdG9yKCk7XG5cbiAgICAgICAgICBpZiAoIW5vZGUuc3RhcnQpIHtcbiAgICAgICAgICAgIG5vZGUuc3RhcnQgPSBmdW5jdGlvbiAod2hlbikge1xuICAgICAgICAgICAgICB0aGlzLm5vdGVPbih3aGVuIHx8IDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbF9zdGFydCA9IG5vZGUuc3RhcnQ7XG5cbiAgICAgICAgICAgIG5vZGUuc3RhcnQgPSBmdW5jdGlvbiAod2hlbikge1xuICAgICAgICAgICAgICBub2RlLmludGVybmFsX3N0YXJ0KHdoZW4gfHwgMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghbm9kZS5zdG9wKSB7XG4gICAgICAgICAgICBub2RlLnN0b3AgPSBmdW5jdGlvbiAod2hlbikge1xuICAgICAgICAgICAgICB0aGlzLm5vdGVPZmYod2hlbiB8fCAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxfc3RvcCA9IG5vZGUuc3RvcDtcblxuICAgICAgICAgICAgbm9kZS5zdG9wID0gZnVuY3Rpb24gKHdoZW4pIHtcbiAgICAgICAgICAgICAgbm9kZS5pbnRlcm5hbF9zdG9wKHdoZW4gfHwgMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghbm9kZS5zZXRQZXJpb2RpY1dhdmUpIG5vZGUuc2V0UGVyaW9kaWNXYXZlID0gbm9kZS5zZXRXYXZlVGFibGU7XG4gICAgICAgICAgZml4U2V0VGFyZ2V0KG5vZGUuZnJlcXVlbmN5KTtcbiAgICAgICAgICBmaXhTZXRUYXJnZXQobm9kZS5kZXR1bmUpO1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3aW5kb3cuaGFzT3duUHJvcGVydHkoJ3dlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQnKSAmJiAhd2luZG93Lmhhc093blByb3BlcnR5KCdPZmZsaW5lQXVkaW9Db250ZXh0JykpIHtcbiAgICAgIHdpbmRvdy5PZmZsaW5lQXVkaW9Db250ZXh0ID0gd2luZG93LndlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQ7XG4gICAgfVxuICB9KSh3aW5kb3cpOyBcblxuXG4gIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3IubXNHZXRVc2VyTWVkaWE7XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hpY2ggZmlsZXR5cGVzIGFyZSBzdXBwb3J0ZWQgKGluc3BpcmVkIGJ5IGJ1enouanMpXG4gICAqIFRoZSBhdWRpbyBlbGVtZW50IChlbCkgd2lsbCBvbmx5IGJlIHVzZWQgdG8gdGVzdCBicm93c2VyIHN1cHBvcnQgZm9yIHZhcmlvdXMgYXVkaW8gZm9ybWF0c1xuICAgKi9cblxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuXG4gIHA1LnByb3RvdHlwZS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISFlbC5jYW5QbGF5VHlwZTtcbiAgfTtcblxuICB2YXIgaXNPR0dTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc09HR1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gISFlbC5jYW5QbGF5VHlwZSAmJiBlbC5jYW5QbGF5VHlwZSgnYXVkaW8vb2dnOyBjb2RlY3M9XCJ2b3JiaXNcIicpO1xuICB9O1xuXG4gIHZhciBpc01QM1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzTVAzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAhIWVsLmNhblBsYXlUeXBlICYmIGVsLmNhblBsYXlUeXBlKCdhdWRpby9tcGVnOycpO1xuICB9O1xuXG4gIHZhciBpc1dBVlN1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzV0FWU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAhIWVsLmNhblBsYXlUeXBlICYmIGVsLmNhblBsYXlUeXBlKCdhdWRpby93YXY7IGNvZGVjcz1cIjFcIicpO1xuICB9O1xuXG4gIHZhciBpc0FBQ1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzQUFDU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAhIWVsLmNhblBsYXlUeXBlICYmIChlbC5jYW5QbGF5VHlwZSgnYXVkaW8veC1tNGE7JykgfHwgZWwuY2FuUGxheVR5cGUoJ2F1ZGlvL2FhYzsnKSk7XG4gIH07XG5cbiAgdmFyIGlzQUlGU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNBSUZTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICEhZWwuY2FuUGxheVR5cGUgJiYgZWwuY2FuUGxheVR5cGUoJ2F1ZGlvL3gtYWlmZjsnKTtcbiAgfTtcblxuICBwNS5wcm90b3R5cGUuaXNGaWxlU3VwcG9ydGVkID0gZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuICAgIHN3aXRjaCAoZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgIHJldHVybiBpc01QM1N1cHBvcnRlZCgpO1xuXG4gICAgICBjYXNlICd3YXYnOlxuICAgICAgICByZXR1cm4gaXNXQVZTdXBwb3J0ZWQoKTtcblxuICAgICAgY2FzZSAnb2dnJzpcbiAgICAgICAgcmV0dXJuIGlzT0dHU3VwcG9ydGVkKCk7XG5cbiAgICAgIGNhc2UgJ2FhYyc6XG4gICAgICBjYXNlICdtNGEnOlxuICAgICAgY2FzZSAnbXA0JzpcbiAgICAgICAgcmV0dXJuIGlzQUFDU3VwcG9ydGVkKCk7XG5cbiAgICAgIGNhc2UgJ2FpZic6XG4gICAgICBjYXNlICdhaWZmJzpcbiAgICAgICAgcmV0dXJuIGlzQUlGU3VwcG9ydGVkKCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGc7Zz1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpO3RyeXtnPWd8fG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCl9Y2F0Y2godCl7XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyYmKGc9d2luZG93KX1tb2R1bGUuZXhwb3J0cz1nO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshZnVuY3Rpb24oZSx0KXsgdHJ1ZT8hKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKHQpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID9cblx0XHRcdFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk6dW5kZWZpbmVkfSh0aGlzLGZ1bmN0aW9uKCl7dmFyIHI9ZnVuY3Rpb24oZSx0KXt0aGlzLl9kcmFnZ2VkPSExLHRoaXMuX2VsZW1lbnQ9ZSx0aGlzLl9iaW5kZWRNb3ZlPXRoaXMuX21vdmVkLmJpbmQodGhpcyksdGhpcy5fYmluZGVkRW5kPXRoaXMuX2VuZGVkLmJpbmQodGhpcyx0KSxlLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsdGhpcy5fYmluZGVkRW5kKSxlLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIix0aGlzLl9iaW5kZWRNb3ZlKSxlLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLHRoaXMuX2JpbmRlZEVuZCksZS5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHRoaXMuX2JpbmRlZEVuZCl9O2Z1bmN0aW9uIG8oZSl7cmV0dXJuXCJydW5uaW5nXCI9PT1lLnN0YXRlfXJldHVybiByLnByb3RvdHlwZS5fbW92ZWQ9ZnVuY3Rpb24oZSl7dGhpcy5fZHJhZ2dlZD0hMH0sci5wcm90b3R5cGUuX2VuZGVkPWZ1bmN0aW9uKGUpe3RoaXMuX2RyYWdnZWR8fGZ1bmN0aW9uKGUpe3ZhciB0PWUuY3JlYXRlQnVmZmVyKDEsMSxlLnNhbXBsZVJhdGUpLG49ZS5jcmVhdGVCdWZmZXJTb3VyY2UoKTtuLmJ1ZmZlcj10LG4uY29ubmVjdChlLmRlc3RpbmF0aW9uKSxuLnN0YXJ0KDApLGUucmVzdW1lJiZlLnJlc3VtZSgpfShlKSx0aGlzLl9kcmFnZ2VkPSExfSxyLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLHRoaXMuX2JpbmRlZEVuZCksdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsdGhpcy5fYmluZGVkTW92ZSksdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIix0aGlzLl9iaW5kZWRFbmQpLHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIix0aGlzLl9iaW5kZWRFbmQpLHRoaXMuX2JpbmRlZE1vdmU9bnVsbCx0aGlzLl9iaW5kZWRFbmQ9bnVsbCx0aGlzLl9lbGVtZW50PW51bGx9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgUHJvbWlzZShmdW5jdGlvbihlKXshZnVuY3Rpb24odCxuKXtvKHQpP24oKTpmdW5jdGlvbiBlKCl7byh0KT9uKCk6KHJlcXVlc3RBbmltYXRpb25GcmFtZShlKSx0LnJlc3VtZSYmdC5yZXN1bWUoKSl9KCl9KHQsZSl9KSxkPVtdO3JldHVybiBmdW5jdGlvbiBlKHQsbixpKXtpZihBcnJheS5pc0FycmF5KHQpfHxOb2RlTGlzdCYmdCBpbnN0YW5jZW9mIE5vZGVMaXN0KWZvcih2YXIgZD0wO2Q8dC5sZW5ndGg7ZCsrKWUodFtkXSxuLGkpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHQpLG4saSk7ZWxzZSBpZih0LmpxdWVyeSYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC50b0FycmF5KWUodC50b0FycmF5KCksbixpKTtlbHNlIGlmKEVsZW1lbnQmJnQgaW5zdGFuY2VvZiBFbGVtZW50KXt2YXIgbz1uZXcgcih0LGkpO24ucHVzaChvKX19KGU9ZXx8ZG9jdW1lbnQuYm9keSxkLHQpLGkudGhlbihmdW5jdGlvbigpe2Zvcih2YXIgZT0wO2U8ZC5sZW5ndGg7ZSsrKWRbZV0uZGlzcG9zZSgpO2Q9bnVsbCxuJiZuKCl9KSxpfX0pO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcDVzb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBtb2R1bGVTb3VyY2VzID0gW19fd2VicGFja19yZXF1aXJlX18oMzcpW1wiZGVmYXVsdFwiXSwgX193ZWJwYWNrX3JlcXVpcmVfXygzOClbXCJkZWZhdWx0XCJdLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KVtcImRlZmF1bHRcIl1dO1xudmFyIGFjID0gcDVzb3VuZC5hdWRpb2NvbnRleHQ7XG52YXIgaW5pdGlhbGl6ZWRBdWRpb1dvcmtsZXRzID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGxvYWRBdWRpb1dvcmtsZXRNb2R1bGVzKCkge1xuICByZXR1cm4gUHJvbWlzZS5hbGwobW9kdWxlU291cmNlcy5tYXAoZnVuY3Rpb24gKG1vZHVsZVNyYykge1xuICAgIHZhciBibG9iID0gbmV3IEJsb2IoW21vZHVsZVNyY10sIHtcbiAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J1xuICAgIH0pO1xuICAgIHZhciBvYmplY3RVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIHJldHVybiBhYy5hdWRpb1dvcmtsZXQuYWRkTW9kdWxlKG9iamVjdFVSTCk7XG4gIH0pKTtcbn1cblxucDUucHJvdG90eXBlLnJlZ2lzdGVyTWV0aG9kKCdpbml0JywgZnVuY3Rpb24gKCkge1xuICBpZiAoaW5pdGlhbGl6ZWRBdWRpb1dvcmtsZXRzKSByZXR1cm47IFxuXG4gIGlmICghdGhpcy5wcmVsb2FkICYmICF3aW5kb3cucHJlbG9hZCkge1xuICAgIHRoaXMucHJlbG9hZCA9IGZ1bmN0aW9uICgpIHt9O1xuICB9IFxuXG5cbiAgdGhpcy5faW5jcmVtZW50UHJlbG9hZCgpO1xuXG4gIHZhciBvbldvcmtsZXRNb2R1bGVzTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpbml0aWFsaXplZEF1ZGlvV29ya2xldHMgPSB0cnVlO1xuXG4gICAgdGhpcy5fZGVjcmVtZW50UHJlbG9hZCgpO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgbG9hZEF1ZGlvV29ya2xldE1vZHVsZXMoKS50aGVuKG9uV29ya2xldE1vZHVsZXNMb2FkKTtcbn0pO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbiBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChcImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXFxcImZ1bmN0aW9uXFxcIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblxcXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcXFwidW5kZWZpbmVkXFxcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFxcXCJ1bmRlZmluZWRcXFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcXFwiZnVuY3Rpb25cXFwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cXG5cXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cXG5cXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcXFwiW25hdGl2ZSBjb2RlXVxcXCIpICE9PSAtMTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG4vLyBpbXBvcnQgZGVwZW5kZW5jaWVzIHZpYSBwcmV2YWwucmVxdWlyZSBzbyB0aGF0IHRoZXkncmUgYXZhaWxhYmxlIGFzIHZhbHVlcyBhdCBjb21waWxlIHRpbWVcXG52YXIgcHJvY2Vzc29yTmFtZXMgPSB7XFxuICBcXFwicmVjb3JkZXJQcm9jZXNzb3JcXFwiOiBcXFwicmVjb3JkZXItcHJvY2Vzc29yXFxcIixcXG4gIFxcXCJzb3VuZEZpbGVQcm9jZXNzb3JcXFwiOiBcXFwic291bmQtZmlsZS1wcm9jZXNzb3JcXFwiLFxcbiAgXFxcImFtcGxpdHVkZVByb2Nlc3NvclxcXCI6IFxcXCJhbXBsaXR1ZGUtcHJvY2Vzc29yXFxcIlxcbn07XFxudmFyIFJpbmdCdWZmZXIgPSB7XFxuICBcXFwiZGVmYXVsdFxcXCI6XFxuICAvKiNfX1BVUkVfXyovXFxuICBmdW5jdGlvbiAoKSB7XFxuICAgIC8qKlxcbiAgICAgKiBAY29uc3RydWN0b3JcXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBsZW5ndGggQnVmZmVyIGxlbmd0aCBpbiBmcmFtZXMuXFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gY2hhbm5lbENvdW50IEJ1ZmZlciBjaGFubmVsIGNvdW50LlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gUmluZ0J1ZmZlcihsZW5ndGgsIGNoYW5uZWxDb3VudCkge1xcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSaW5nQnVmZmVyKTtcXG5cXG4gICAgICB0aGlzLl9yZWFkSW5kZXggPSAwO1xcbiAgICAgIHRoaXMuX3dyaXRlSW5kZXggPSAwO1xcbiAgICAgIHRoaXMuX2ZyYW1lc0F2YWlsYWJsZSA9IDA7XFxuICAgICAgdGhpcy5fY2hhbm5lbENvdW50ID0gY2hhbm5lbENvdW50O1xcbiAgICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aDtcXG4gICAgICB0aGlzLl9jaGFubmVsRGF0YSA9IFtdO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hhbm5lbENvdW50OyArK2kpIHtcXG4gICAgICAgIHRoaXMuX2NoYW5uZWxEYXRhW2ldID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogR2V0dGVyIGZvciBBdmFpbGFibGUgZnJhbWVzIGluIGJ1ZmZlci5cXG4gICAgICpcXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBBdmFpbGFibGUgZnJhbWVzIGluIGJ1ZmZlci5cXG4gICAgICovXFxuXFxuXFxuICAgIF9jcmVhdGVDbGFzcyhSaW5nQnVmZmVyLCBbe1xcbiAgICAgIGtleTogXFxcInB1c2hcXFwiLFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIFB1c2ggYSBzZXF1ZW5jZSBvZiBGbG9hdDMyQXJyYXlzIHRvIGJ1ZmZlci5cXG4gICAgICAgKlxcbiAgICAgICAqIEBwYXJhbSAge2FycmF5fSBhcnJheVNlcXVlbmNlIEEgc2VxdWVuY2Ugb2YgRmxvYXQzMkFycmF5cy5cXG4gICAgICAgKi9cXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChhcnJheVNlcXVlbmNlKSB7XFxuICAgICAgICAvLyBUaGUgY2hhbm5lbCBjb3VudCBvZiBhcnJheVNlcXVlbmNlIGFuZCB0aGUgbGVuZ3RoIG9mIGVhY2ggY2hhbm5lbCBtdXN0XFxuICAgICAgICAvLyBtYXRjaCB3aXRoIHRoaXMgYnVmZmVyIG9iZWpjdC5cXG4gICAgICAgIC8vIFRyYW5zZmVyIGRhdGEgZnJvbSB0aGUgfGFycmF5U2VxdWVuY2V8IHN0b3JhZ2UgdG8gdGhlIGludGVybmFsIGJ1ZmZlci5cXG4gICAgICAgIHZhciBzb3VyY2VMZW5ndGggPSBhcnJheVNlcXVlbmNlWzBdLmxlbmd0aDtcXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlTGVuZ3RoOyArK2kpIHtcXG4gICAgICAgICAgdmFyIHdyaXRlSW5kZXggPSAodGhpcy5fd3JpdGVJbmRleCArIGkpICUgdGhpcy5fbGVuZ3RoO1xcblxcbiAgICAgICAgICBmb3IgKHZhciBjaGFubmVsID0gMDsgY2hhbm5lbCA8IHRoaXMuX2NoYW5uZWxDb3VudDsgKytjaGFubmVsKSB7XFxuICAgICAgICAgICAgdGhpcy5fY2hhbm5lbERhdGFbY2hhbm5lbF1bd3JpdGVJbmRleF0gPSBhcnJheVNlcXVlbmNlW2NoYW5uZWxdW2ldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl93cml0ZUluZGV4ICs9IHNvdXJjZUxlbmd0aDtcXG5cXG4gICAgICAgIGlmICh0aGlzLl93cml0ZUluZGV4ID49IHRoaXMuX2xlbmd0aCkge1xcbiAgICAgICAgICB0aGlzLl93cml0ZUluZGV4ID0gMDtcXG4gICAgICAgIH0gLy8gRm9yIGV4Y2Vzc2l2ZSBmcmFtZXMsIHRoZSBidWZmZXIgd2lsbCBiZSBvdmVyd3JpdHRlbi5cXG5cXG5cXG4gICAgICAgIHRoaXMuX2ZyYW1lc0F2YWlsYWJsZSArPSBzb3VyY2VMZW5ndGg7XFxuXFxuICAgICAgICBpZiAodGhpcy5fZnJhbWVzQXZhaWxhYmxlID4gdGhpcy5fbGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMuX2ZyYW1lc0F2YWlsYWJsZSA9IHRoaXMuX2xlbmd0aDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgLyoqXFxuICAgICAgICogUHVsbCBkYXRhIG91dCBvZiBidWZmZXIgYW5kIGZpbGwgYSBnaXZlbiBzZXF1ZW5jZSBvZiBGbG9hdDMyQXJyYXlzLlxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtICB7YXJyYXl9IGFycmF5U2VxdWVuY2UgQW4gYXJyYXkgb2YgRmxvYXQzMkFycmF5cy5cXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogXFxcInB1bGxcXFwiLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdWxsKGFycmF5U2VxdWVuY2UpIHtcXG4gICAgICAgIC8vIFRoZSBjaGFubmVsIGNvdW50IG9mIGFycmF5U2VxdWVuY2UgYW5kIHRoZSBsZW5ndGggb2YgZWFjaCBjaGFubmVsIG11c3RcXG4gICAgICAgIC8vIG1hdGNoIHdpdGggdGhpcyBidWZmZXIgb2JlamN0LlxcbiAgICAgICAgLy8gSWYgdGhlIEZJRk8gaXMgY29tcGxldGVseSBlbXB0eSwgZG8gbm90aGluZy5cXG4gICAgICAgIGlmICh0aGlzLl9mcmFtZXNBdmFpbGFibGUgPT09IDApIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uTGVuZ3RoID0gYXJyYXlTZXF1ZW5jZVswXS5sZW5ndGg7IC8vIFRyYW5zZmVyIGRhdGEgZnJvbSB0aGUgaW50ZXJuYWwgYnVmZmVyIHRvIHRoZSB8YXJyYXlTZXF1ZW5jZXwgc3RvcmFnZS5cXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVzdGluYXRpb25MZW5ndGg7ICsraSkge1xcbiAgICAgICAgICB2YXIgcmVhZEluZGV4ID0gKHRoaXMuX3JlYWRJbmRleCArIGkpICUgdGhpcy5fbGVuZ3RoO1xcblxcbiAgICAgICAgICBmb3IgKHZhciBjaGFubmVsID0gMDsgY2hhbm5lbCA8IHRoaXMuX2NoYW5uZWxDb3VudDsgKytjaGFubmVsKSB7XFxuICAgICAgICAgICAgYXJyYXlTZXF1ZW5jZVtjaGFubmVsXVtpXSA9IHRoaXMuX2NoYW5uZWxEYXRhW2NoYW5uZWxdW3JlYWRJbmRleF07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX3JlYWRJbmRleCArPSBkZXN0aW5hdGlvbkxlbmd0aDtcXG5cXG4gICAgICAgIGlmICh0aGlzLl9yZWFkSW5kZXggPj0gdGhpcy5fbGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMuX3JlYWRJbmRleCA9IDA7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl9mcmFtZXNBdmFpbGFibGUgLT0gZGVzdGluYXRpb25MZW5ndGg7XFxuXFxuICAgICAgICBpZiAodGhpcy5fZnJhbWVzQXZhaWxhYmxlIDwgMCkge1xcbiAgICAgICAgICB0aGlzLl9mcmFtZXNBdmFpbGFibGUgPSAwO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgIGtleTogXFxcImZyYW1lc0F2YWlsYWJsZVxcXCIsXFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVzQXZhaWxhYmxlO1xcbiAgICAgIH1cXG4gICAgfV0pO1xcblxcbiAgICByZXR1cm4gUmluZ0J1ZmZlcjtcXG4gIH0oKVxcbn1bXFxcImRlZmF1bHRcXFwiXTtcXG5cXG52YXIgUmVjb3JkZXJQcm9jZXNzb3IgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX0F1ZGlvV29ya2xldFByb2Nlc3NvKSB7XFxuICBfaW5oZXJpdHMoUmVjb3JkZXJQcm9jZXNzb3IsIF9BdWRpb1dvcmtsZXRQcm9jZXNzbyk7XFxuXFxuICBmdW5jdGlvbiBSZWNvcmRlclByb2Nlc3NvcihvcHRpb25zKSB7XFxuICAgIHZhciBfdGhpcztcXG5cXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlY29yZGVyUHJvY2Vzc29yKTtcXG5cXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoUmVjb3JkZXJQcm9jZXNzb3IpLmNhbGwodGhpcykpO1xcbiAgICB2YXIgcHJvY2Vzc29yT3B0aW9ucyA9IG9wdGlvbnMucHJvY2Vzc29yT3B0aW9ucyB8fCB7fTtcXG4gICAgX3RoaXMubnVtT3V0cHV0Q2hhbm5lbHMgPSBvcHRpb25zLm91dHB1dENoYW5uZWxDb3VudCB8fCAyO1xcbiAgICBfdGhpcy5udW1JbnB1dENoYW5uZWxzID0gcHJvY2Vzc29yT3B0aW9ucy5udW1JbnB1dENoYW5uZWxzIHx8IDI7XFxuICAgIF90aGlzLmJ1ZmZlclNpemUgPSBwcm9jZXNzb3JPcHRpb25zLmJ1ZmZlclNpemUgfHwgMTAyNDtcXG4gICAgX3RoaXMucmVjb3JkaW5nID0gZmFsc2U7XFxuXFxuICAgIF90aGlzLmNsZWFyKCk7XFxuXFxuICAgIF90aGlzLnBvcnQub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xcblxcbiAgICAgIGlmIChkYXRhLm5hbWUgPT09ICdzdGFydCcpIHtcXG4gICAgICAgIF90aGlzLnJlY29yZChkYXRhLmR1cmF0aW9uKTtcXG4gICAgICB9IGVsc2UgaWYgKGRhdGEubmFtZSA9PT0gJ3N0b3AnKSB7XFxuICAgICAgICBfdGhpcy5zdG9wKCk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICByZXR1cm4gX3RoaXM7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoUmVjb3JkZXJQcm9jZXNzb3IsIFt7XFxuICAgIGtleTogXFxcInByb2Nlc3NcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2VzcyhpbnB1dHMpIHtcXG4gICAgICBpZiAoIXRoaXMucmVjb3JkaW5nKSB7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2FtcGxlTGltaXQgJiYgdGhpcy5yZWNvcmRlZFNhbXBsZXMgPj0gdGhpcy5zYW1wbGVMaW1pdCkge1xcbiAgICAgICAgdGhpcy5zdG9wKCk7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGlucHV0ID0gaW5wdXRzWzBdO1xcbiAgICAgIHRoaXMuaW5wdXRSaW5nQnVmZmVyLnB1c2goaW5wdXQpO1xcblxcbiAgICAgIGlmICh0aGlzLmlucHV0UmluZ0J1ZmZlci5mcmFtZXNBdmFpbGFibGUgPj0gdGhpcy5idWZmZXJTaXplKSB7XFxuICAgICAgICB0aGlzLmlucHV0UmluZ0J1ZmZlci5wdWxsKHRoaXMuaW5wdXRSaW5nQnVmZmVyQXJyYXlTZXF1ZW5jZSk7XFxuXFxuICAgICAgICBmb3IgKHZhciBjaGFubmVsID0gMDsgY2hhbm5lbCA8IHRoaXMubnVtT3V0cHV0Q2hhbm5lbHM7ICsrY2hhbm5lbCkge1xcbiAgICAgICAgICB2YXIgaW5wdXRDaGFubmVsQ29weSA9IHRoaXMuaW5wdXRSaW5nQnVmZmVyQXJyYXlTZXF1ZW5jZVtjaGFubmVsXS5zbGljZSgpO1xcblxcbiAgICAgICAgICBpZiAoY2hhbm5lbCA9PT0gMCkge1xcbiAgICAgICAgICAgIHRoaXMubGVmdEJ1ZmZlcnMucHVzaChpbnB1dENoYW5uZWxDb3B5KTtcXG5cXG4gICAgICAgICAgICBpZiAodGhpcy5udW1JbnB1dENoYW5uZWxzID09PSAxKSB7XFxuICAgICAgICAgICAgICB0aGlzLnJpZ2h0QnVmZmVycy5wdXNoKGlucHV0Q2hhbm5lbENvcHkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsID09PSAxICYmIHRoaXMubnVtSW5wdXRDaGFubmVscyA+IDEpIHtcXG4gICAgICAgICAgICB0aGlzLnJpZ2h0QnVmZmVycy5wdXNoKGlucHV0Q2hhbm5lbENvcHkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLnJlY29yZGVkU2FtcGxlcyArPSB0aGlzLmJ1ZmZlclNpemU7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcInJlY29yZFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvcmQoZHVyYXRpb24pIHtcXG4gICAgICBpZiAoZHVyYXRpb24pIHtcXG4gICAgICAgIHRoaXMuc2FtcGxlTGltaXQgPSBNYXRoLnJvdW5kKGR1cmF0aW9uICogc2FtcGxlUmF0ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMucmVjb3JkaW5nID0gdHJ1ZTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJzdG9wXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XFxuICAgICAgdGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcXG4gICAgICB2YXIgYnVmZmVycyA9IHRoaXMuZ2V0QnVmZmVycygpO1xcbiAgICAgIHZhciBsZWZ0QnVmZmVyID0gYnVmZmVyc1swXS5idWZmZXI7XFxuICAgICAgdmFyIHJpZ2h0QnVmZmVyID0gYnVmZmVyc1sxXS5idWZmZXI7XFxuICAgICAgdGhpcy5wb3J0LnBvc3RNZXNzYWdlKHtcXG4gICAgICAgIG5hbWU6ICdidWZmZXJzJyxcXG4gICAgICAgIGxlZnRCdWZmZXI6IGxlZnRCdWZmZXIsXFxuICAgICAgICByaWdodEJ1ZmZlcjogcmlnaHRCdWZmZXJcXG4gICAgICB9LCBbbGVmdEJ1ZmZlciwgcmlnaHRCdWZmZXJdKTtcXG4gICAgICB0aGlzLmNsZWFyKCk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0QnVmZmVyc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCdWZmZXJzKCkge1xcbiAgICAgIHZhciBidWZmZXJzID0gW107XFxuICAgICAgYnVmZmVycy5wdXNoKHRoaXMubWVyZ2VCdWZmZXJzKHRoaXMubGVmdEJ1ZmZlcnMpKTtcXG4gICAgICBidWZmZXJzLnB1c2godGhpcy5tZXJnZUJ1ZmZlcnModGhpcy5yaWdodEJ1ZmZlcnMpKTtcXG4gICAgICByZXR1cm4gYnVmZmVycztcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJtZXJnZUJ1ZmZlcnNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2VCdWZmZXJzKGNoYW5uZWxCdWZmZXIpIHtcXG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnJlY29yZGVkU2FtcGxlcyk7XFxuICAgICAgdmFyIG9mZnNldCA9IDA7XFxuICAgICAgdmFyIGxuZyA9IGNoYW5uZWxCdWZmZXIubGVuZ3RoO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG5nOyBpKyspIHtcXG4gICAgICAgIHZhciBidWZmZXIgPSBjaGFubmVsQnVmZmVyW2ldO1xcbiAgICAgICAgcmVzdWx0LnNldChidWZmZXIsIG9mZnNldCk7XFxuICAgICAgICBvZmZzZXQgKz0gYnVmZmVyLmxlbmd0aDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJjbGVhclxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcXG5cXG4gICAgICB0aGlzLmxlZnRCdWZmZXJzID0gW107XFxuICAgICAgdGhpcy5yaWdodEJ1ZmZlcnMgPSBbXTtcXG4gICAgICB0aGlzLmlucHV0UmluZ0J1ZmZlciA9IG5ldyBSaW5nQnVmZmVyKHRoaXMuYnVmZmVyU2l6ZSwgdGhpcy5udW1JbnB1dENoYW5uZWxzKTtcXG4gICAgICB0aGlzLmlucHV0UmluZ0J1ZmZlckFycmF5U2VxdWVuY2UgPSBuZXcgQXJyYXkodGhpcy5udW1JbnB1dENoYW5uZWxzKS5maWxsKG51bGwpLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShfdGhpczIuYnVmZmVyU2l6ZSk7XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy5yZWNvcmRlZFNhbXBsZXMgPSAwO1xcbiAgICAgIHRoaXMuc2FtcGxlTGltaXQgPSBudWxsO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gUmVjb3JkZXJQcm9jZXNzb3I7XFxufShfd3JhcE5hdGl2ZVN1cGVyKEF1ZGlvV29ya2xldFByb2Nlc3NvcikpO1xcblxcbnJlZ2lzdGVyUHJvY2Vzc29yKHByb2Nlc3Nvck5hbWVzLnJlY29yZGVyUHJvY2Vzc29yLCBSZWNvcmRlclByb2Nlc3Nvcik7XCIpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbiBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChcImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXFxcImZ1bmN0aW9uXFxcIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblxcXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcXFwidW5kZWZpbmVkXFxcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFxcXCJ1bmRlZmluZWRcXFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcXFwiZnVuY3Rpb25cXFwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cXG5cXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cXG5cXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcXFwiW25hdGl2ZSBjb2RlXVxcXCIpICE9PSAtMTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG4vLyBpbXBvcnQgZGVwZW5kZW5jaWVzIHZpYSBwcmV2YWwucmVxdWlyZSBzbyB0aGF0IHRoZXkncmUgYXZhaWxhYmxlIGFzIHZhbHVlcyBhdCBjb21waWxlIHRpbWVcXG52YXIgcHJvY2Vzc29yTmFtZXMgPSB7XFxuICBcXFwicmVjb3JkZXJQcm9jZXNzb3JcXFwiOiBcXFwicmVjb3JkZXItcHJvY2Vzc29yXFxcIixcXG4gIFxcXCJzb3VuZEZpbGVQcm9jZXNzb3JcXFwiOiBcXFwic291bmQtZmlsZS1wcm9jZXNzb3JcXFwiLFxcbiAgXFxcImFtcGxpdHVkZVByb2Nlc3NvclxcXCI6IFxcXCJhbXBsaXR1ZGUtcHJvY2Vzc29yXFxcIlxcbn07XFxudmFyIFJpbmdCdWZmZXIgPSB7XFxuICBcXFwiZGVmYXVsdFxcXCI6XFxuICAvKiNfX1BVUkVfXyovXFxuICBmdW5jdGlvbiAoKSB7XFxuICAgIC8qKlxcbiAgICAgKiBAY29uc3RydWN0b3JcXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBsZW5ndGggQnVmZmVyIGxlbmd0aCBpbiBmcmFtZXMuXFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gY2hhbm5lbENvdW50IEJ1ZmZlciBjaGFubmVsIGNvdW50LlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gUmluZ0J1ZmZlcihsZW5ndGgsIGNoYW5uZWxDb3VudCkge1xcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSaW5nQnVmZmVyKTtcXG5cXG4gICAgICB0aGlzLl9yZWFkSW5kZXggPSAwO1xcbiAgICAgIHRoaXMuX3dyaXRlSW5kZXggPSAwO1xcbiAgICAgIHRoaXMuX2ZyYW1lc0F2YWlsYWJsZSA9IDA7XFxuICAgICAgdGhpcy5fY2hhbm5lbENvdW50ID0gY2hhbm5lbENvdW50O1xcbiAgICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aDtcXG4gICAgICB0aGlzLl9jaGFubmVsRGF0YSA9IFtdO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hhbm5lbENvdW50OyArK2kpIHtcXG4gICAgICAgIHRoaXMuX2NoYW5uZWxEYXRhW2ldID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogR2V0dGVyIGZvciBBdmFpbGFibGUgZnJhbWVzIGluIGJ1ZmZlci5cXG4gICAgICpcXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBBdmFpbGFibGUgZnJhbWVzIGluIGJ1ZmZlci5cXG4gICAgICovXFxuXFxuXFxuICAgIF9jcmVhdGVDbGFzcyhSaW5nQnVmZmVyLCBbe1xcbiAgICAgIGtleTogXFxcInB1c2hcXFwiLFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIFB1c2ggYSBzZXF1ZW5jZSBvZiBGbG9hdDMyQXJyYXlzIHRvIGJ1ZmZlci5cXG4gICAgICAgKlxcbiAgICAgICAqIEBwYXJhbSAge2FycmF5fSBhcnJheVNlcXVlbmNlIEEgc2VxdWVuY2Ugb2YgRmxvYXQzMkFycmF5cy5cXG4gICAgICAgKi9cXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChhcnJheVNlcXVlbmNlKSB7XFxuICAgICAgICAvLyBUaGUgY2hhbm5lbCBjb3VudCBvZiBhcnJheVNlcXVlbmNlIGFuZCB0aGUgbGVuZ3RoIG9mIGVhY2ggY2hhbm5lbCBtdXN0XFxuICAgICAgICAvLyBtYXRjaCB3aXRoIHRoaXMgYnVmZmVyIG9iZWpjdC5cXG4gICAgICAgIC8vIFRyYW5zZmVyIGRhdGEgZnJvbSB0aGUgfGFycmF5U2VxdWVuY2V8IHN0b3JhZ2UgdG8gdGhlIGludGVybmFsIGJ1ZmZlci5cXG4gICAgICAgIHZhciBzb3VyY2VMZW5ndGggPSBhcnJheVNlcXVlbmNlWzBdLmxlbmd0aDtcXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlTGVuZ3RoOyArK2kpIHtcXG4gICAgICAgICAgdmFyIHdyaXRlSW5kZXggPSAodGhpcy5fd3JpdGVJbmRleCArIGkpICUgdGhpcy5fbGVuZ3RoO1xcblxcbiAgICAgICAgICBmb3IgKHZhciBjaGFubmVsID0gMDsgY2hhbm5lbCA8IHRoaXMuX2NoYW5uZWxDb3VudDsgKytjaGFubmVsKSB7XFxuICAgICAgICAgICAgdGhpcy5fY2hhbm5lbERhdGFbY2hhbm5lbF1bd3JpdGVJbmRleF0gPSBhcnJheVNlcXVlbmNlW2NoYW5uZWxdW2ldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl93cml0ZUluZGV4ICs9IHNvdXJjZUxlbmd0aDtcXG5cXG4gICAgICAgIGlmICh0aGlzLl93cml0ZUluZGV4ID49IHRoaXMuX2xlbmd0aCkge1xcbiAgICAgICAgICB0aGlzLl93cml0ZUluZGV4ID0gMDtcXG4gICAgICAgIH0gLy8gRm9yIGV4Y2Vzc2l2ZSBmcmFtZXMsIHRoZSBidWZmZXIgd2lsbCBiZSBvdmVyd3JpdHRlbi5cXG5cXG5cXG4gICAgICAgIHRoaXMuX2ZyYW1lc0F2YWlsYWJsZSArPSBzb3VyY2VMZW5ndGg7XFxuXFxuICAgICAgICBpZiAodGhpcy5fZnJhbWVzQXZhaWxhYmxlID4gdGhpcy5fbGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMuX2ZyYW1lc0F2YWlsYWJsZSA9IHRoaXMuX2xlbmd0aDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgLyoqXFxuICAgICAgICogUHVsbCBkYXRhIG91dCBvZiBidWZmZXIgYW5kIGZpbGwgYSBnaXZlbiBzZXF1ZW5jZSBvZiBGbG9hdDMyQXJyYXlzLlxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtICB7YXJyYXl9IGFycmF5U2VxdWVuY2UgQW4gYXJyYXkgb2YgRmxvYXQzMkFycmF5cy5cXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogXFxcInB1bGxcXFwiLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdWxsKGFycmF5U2VxdWVuY2UpIHtcXG4gICAgICAgIC8vIFRoZSBjaGFubmVsIGNvdW50IG9mIGFycmF5U2VxdWVuY2UgYW5kIHRoZSBsZW5ndGggb2YgZWFjaCBjaGFubmVsIG11c3RcXG4gICAgICAgIC8vIG1hdGNoIHdpdGggdGhpcyBidWZmZXIgb2JlamN0LlxcbiAgICAgICAgLy8gSWYgdGhlIEZJRk8gaXMgY29tcGxldGVseSBlbXB0eSwgZG8gbm90aGluZy5cXG4gICAgICAgIGlmICh0aGlzLl9mcmFtZXNBdmFpbGFibGUgPT09IDApIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uTGVuZ3RoID0gYXJyYXlTZXF1ZW5jZVswXS5sZW5ndGg7IC8vIFRyYW5zZmVyIGRhdGEgZnJvbSB0aGUgaW50ZXJuYWwgYnVmZmVyIHRvIHRoZSB8YXJyYXlTZXF1ZW5jZXwgc3RvcmFnZS5cXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVzdGluYXRpb25MZW5ndGg7ICsraSkge1xcbiAgICAgICAgICB2YXIgcmVhZEluZGV4ID0gKHRoaXMuX3JlYWRJbmRleCArIGkpICUgdGhpcy5fbGVuZ3RoO1xcblxcbiAgICAgICAgICBmb3IgKHZhciBjaGFubmVsID0gMDsgY2hhbm5lbCA8IHRoaXMuX2NoYW5uZWxDb3VudDsgKytjaGFubmVsKSB7XFxuICAgICAgICAgICAgYXJyYXlTZXF1ZW5jZVtjaGFubmVsXVtpXSA9IHRoaXMuX2NoYW5uZWxEYXRhW2NoYW5uZWxdW3JlYWRJbmRleF07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX3JlYWRJbmRleCArPSBkZXN0aW5hdGlvbkxlbmd0aDtcXG5cXG4gICAgICAgIGlmICh0aGlzLl9yZWFkSW5kZXggPj0gdGhpcy5fbGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMuX3JlYWRJbmRleCA9IDA7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl9mcmFtZXNBdmFpbGFibGUgLT0gZGVzdGluYXRpb25MZW5ndGg7XFxuXFxuICAgICAgICBpZiAodGhpcy5fZnJhbWVzQXZhaWxhYmxlIDwgMCkge1xcbiAgICAgICAgICB0aGlzLl9mcmFtZXNBdmFpbGFibGUgPSAwO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgIGtleTogXFxcImZyYW1lc0F2YWlsYWJsZVxcXCIsXFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVzQXZhaWxhYmxlO1xcbiAgICAgIH1cXG4gICAgfV0pO1xcblxcbiAgICByZXR1cm4gUmluZ0J1ZmZlcjtcXG4gIH0oKVxcbn1bXFxcImRlZmF1bHRcXFwiXTtcXG5cXG52YXIgU291bmRGaWxlUHJvY2Vzc29yID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKF9BdWRpb1dvcmtsZXRQcm9jZXNzbykge1xcbiAgX2luaGVyaXRzKFNvdW5kRmlsZVByb2Nlc3NvciwgX0F1ZGlvV29ya2xldFByb2Nlc3NvKTtcXG5cXG4gIGZ1bmN0aW9uIFNvdW5kRmlsZVByb2Nlc3NvcihvcHRpb25zKSB7XFxuICAgIHZhciBfdGhpcztcXG5cXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvdW5kRmlsZVByb2Nlc3Nvcik7XFxuXFxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFNvdW5kRmlsZVByb2Nlc3NvcikuY2FsbCh0aGlzKSk7XFxuICAgIHZhciBwcm9jZXNzb3JPcHRpb25zID0gb3B0aW9ucy5wcm9jZXNzb3JPcHRpb25zIHx8IHt9O1xcbiAgICBfdGhpcy5idWZmZXJTaXplID0gcHJvY2Vzc29yT3B0aW9ucy5idWZmZXJTaXplIHx8IDI1NjtcXG4gICAgX3RoaXMuaW5wdXRSaW5nQnVmZmVyID0gbmV3IFJpbmdCdWZmZXIoX3RoaXMuYnVmZmVyU2l6ZSwgMSk7XFxuICAgIF90aGlzLmlucHV0UmluZ0J1ZmZlckFycmF5U2VxdWVuY2UgPSBbbmV3IEZsb2F0MzJBcnJheShfdGhpcy5idWZmZXJTaXplKV07XFxuICAgIHJldHVybiBfdGhpcztcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhTb3VuZEZpbGVQcm9jZXNzb3IsIFt7XFxuICAgIGtleTogXFxcInByb2Nlc3NcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2VzcyhpbnB1dHMpIHtcXG4gICAgICB2YXIgaW5wdXQgPSBpbnB1dHNbMF07IC8vIHdlIG9ubHkgY2FyZSBhYm91dCB0aGUgZmlyc3QgaW5wdXQgY2hhbm5lbCwgYmVjYXVzZSB0aGF0IGNvbnRhaW5zIHRoZSBwb3NpdGlvbiBkYXRhXFxuXFxuICAgICAgdGhpcy5pbnB1dFJpbmdCdWZmZXIucHVzaChbaW5wdXRbMF1dKTtcXG5cXG4gICAgICBpZiAodGhpcy5pbnB1dFJpbmdCdWZmZXIuZnJhbWVzQXZhaWxhYmxlID49IHRoaXMuYnVmZmVyU2l6ZSkge1xcbiAgICAgICAgdGhpcy5pbnB1dFJpbmdCdWZmZXIucHVsbCh0aGlzLmlucHV0UmluZ0J1ZmZlckFycmF5U2VxdWVuY2UpO1xcbiAgICAgICAgdmFyIGlucHV0Q2hhbm5lbCA9IHRoaXMuaW5wdXRSaW5nQnVmZmVyQXJyYXlTZXF1ZW5jZVswXTtcXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGlucHV0Q2hhbm5lbFtpbnB1dENoYW5uZWwubGVuZ3RoIC0gMV0gfHwgMDtcXG4gICAgICAgIHRoaXMucG9ydC5wb3N0TWVzc2FnZSh7XFxuICAgICAgICAgIG5hbWU6ICdwb3NpdGlvbicsXFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gU291bmRGaWxlUHJvY2Vzc29yO1xcbn0oX3dyYXBOYXRpdmVTdXBlcihBdWRpb1dvcmtsZXRQcm9jZXNzb3IpKTtcXG5cXG5yZWdpc3RlclByb2Nlc3Nvcihwcm9jZXNzb3JOYW1lcy5zb3VuZEZpbGVQcm9jZXNzb3IsIFNvdW5kRmlsZVByb2Nlc3Nvcik7XCIpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbiBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChcImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxcblxcbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXFxcImZ1bmN0aW9uXFxcIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblxcXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcXFwidW5kZWZpbmVkXFxcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XFxuXFxuZnVuY3Rpb24gaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFxcXCJ1bmRlZmluZWRcXFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcXFwiZnVuY3Rpb25cXFwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cXG5cXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cXG5cXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcXFwiW25hdGl2ZSBjb2RlXVxcXCIpICE9PSAtMTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG4vLyBpbXBvcnQgZGVwZW5kZW5jaWVzIHZpYSBwcmV2YWwucmVxdWlyZSBzbyB0aGF0IHRoZXkncmUgYXZhaWxhYmxlIGFzIHZhbHVlcyBhdCBjb21waWxlIHRpbWVcXG52YXIgcHJvY2Vzc29yTmFtZXMgPSB7XFxuICBcXFwicmVjb3JkZXJQcm9jZXNzb3JcXFwiOiBcXFwicmVjb3JkZXItcHJvY2Vzc29yXFxcIixcXG4gIFxcXCJzb3VuZEZpbGVQcm9jZXNzb3JcXFwiOiBcXFwic291bmQtZmlsZS1wcm9jZXNzb3JcXFwiLFxcbiAgXFxcImFtcGxpdHVkZVByb2Nlc3NvclxcXCI6IFxcXCJhbXBsaXR1ZGUtcHJvY2Vzc29yXFxcIlxcbn07XFxudmFyIFJpbmdCdWZmZXIgPSB7XFxuICBcXFwiZGVmYXVsdFxcXCI6XFxuICAvKiNfX1BVUkVfXyovXFxuICBmdW5jdGlvbiAoKSB7XFxuICAgIC8qKlxcbiAgICAgKiBAY29uc3RydWN0b3JcXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBsZW5ndGggQnVmZmVyIGxlbmd0aCBpbiBmcmFtZXMuXFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gY2hhbm5lbENvdW50IEJ1ZmZlciBjaGFubmVsIGNvdW50LlxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gUmluZ0J1ZmZlcihsZW5ndGgsIGNoYW5uZWxDb3VudCkge1xcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSaW5nQnVmZmVyKTtcXG5cXG4gICAgICB0aGlzLl9yZWFkSW5kZXggPSAwO1xcbiAgICAgIHRoaXMuX3dyaXRlSW5kZXggPSAwO1xcbiAgICAgIHRoaXMuX2ZyYW1lc0F2YWlsYWJsZSA9IDA7XFxuICAgICAgdGhpcy5fY2hhbm5lbENvdW50ID0gY2hhbm5lbENvdW50O1xcbiAgICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aDtcXG4gICAgICB0aGlzLl9jaGFubmVsRGF0YSA9IFtdO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hhbm5lbENvdW50OyArK2kpIHtcXG4gICAgICAgIHRoaXMuX2NoYW5uZWxEYXRhW2ldID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogR2V0dGVyIGZvciBBdmFpbGFibGUgZnJhbWVzIGluIGJ1ZmZlci5cXG4gICAgICpcXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBBdmFpbGFibGUgZnJhbWVzIGluIGJ1ZmZlci5cXG4gICAgICovXFxuXFxuXFxuICAgIF9jcmVhdGVDbGFzcyhSaW5nQnVmZmVyLCBbe1xcbiAgICAgIGtleTogXFxcInB1c2hcXFwiLFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIFB1c2ggYSBzZXF1ZW5jZSBvZiBGbG9hdDMyQXJyYXlzIHRvIGJ1ZmZlci5cXG4gICAgICAgKlxcbiAgICAgICAqIEBwYXJhbSAge2FycmF5fSBhcnJheVNlcXVlbmNlIEEgc2VxdWVuY2Ugb2YgRmxvYXQzMkFycmF5cy5cXG4gICAgICAgKi9cXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChhcnJheVNlcXVlbmNlKSB7XFxuICAgICAgICAvLyBUaGUgY2hhbm5lbCBjb3VudCBvZiBhcnJheVNlcXVlbmNlIGFuZCB0aGUgbGVuZ3RoIG9mIGVhY2ggY2hhbm5lbCBtdXN0XFxuICAgICAgICAvLyBtYXRjaCB3aXRoIHRoaXMgYnVmZmVyIG9iZWpjdC5cXG4gICAgICAgIC8vIFRyYW5zZmVyIGRhdGEgZnJvbSB0aGUgfGFycmF5U2VxdWVuY2V8IHN0b3JhZ2UgdG8gdGhlIGludGVybmFsIGJ1ZmZlci5cXG4gICAgICAgIHZhciBzb3VyY2VMZW5ndGggPSBhcnJheVNlcXVlbmNlWzBdLmxlbmd0aDtcXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlTGVuZ3RoOyArK2kpIHtcXG4gICAgICAgICAgdmFyIHdyaXRlSW5kZXggPSAodGhpcy5fd3JpdGVJbmRleCArIGkpICUgdGhpcy5fbGVuZ3RoO1xcblxcbiAgICAgICAgICBmb3IgKHZhciBjaGFubmVsID0gMDsgY2hhbm5lbCA8IHRoaXMuX2NoYW5uZWxDb3VudDsgKytjaGFubmVsKSB7XFxuICAgICAgICAgICAgdGhpcy5fY2hhbm5lbERhdGFbY2hhbm5lbF1bd3JpdGVJbmRleF0gPSBhcnJheVNlcXVlbmNlW2NoYW5uZWxdW2ldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl93cml0ZUluZGV4ICs9IHNvdXJjZUxlbmd0aDtcXG5cXG4gICAgICAgIGlmICh0aGlzLl93cml0ZUluZGV4ID49IHRoaXMuX2xlbmd0aCkge1xcbiAgICAgICAgICB0aGlzLl93cml0ZUluZGV4ID0gMDtcXG4gICAgICAgIH0gLy8gRm9yIGV4Y2Vzc2l2ZSBmcmFtZXMsIHRoZSBidWZmZXIgd2lsbCBiZSBvdmVyd3JpdHRlbi5cXG5cXG5cXG4gICAgICAgIHRoaXMuX2ZyYW1lc0F2YWlsYWJsZSArPSBzb3VyY2VMZW5ndGg7XFxuXFxuICAgICAgICBpZiAodGhpcy5fZnJhbWVzQXZhaWxhYmxlID4gdGhpcy5fbGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMuX2ZyYW1lc0F2YWlsYWJsZSA9IHRoaXMuX2xlbmd0aDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgLyoqXFxuICAgICAgICogUHVsbCBkYXRhIG91dCBvZiBidWZmZXIgYW5kIGZpbGwgYSBnaXZlbiBzZXF1ZW5jZSBvZiBGbG9hdDMyQXJyYXlzLlxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtICB7YXJyYXl9IGFycmF5U2VxdWVuY2UgQW4gYXJyYXkgb2YgRmxvYXQzMkFycmF5cy5cXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogXFxcInB1bGxcXFwiLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdWxsKGFycmF5U2VxdWVuY2UpIHtcXG4gICAgICAgIC8vIFRoZSBjaGFubmVsIGNvdW50IG9mIGFycmF5U2VxdWVuY2UgYW5kIHRoZSBsZW5ndGggb2YgZWFjaCBjaGFubmVsIG11c3RcXG4gICAgICAgIC8vIG1hdGNoIHdpdGggdGhpcyBidWZmZXIgb2JlamN0LlxcbiAgICAgICAgLy8gSWYgdGhlIEZJRk8gaXMgY29tcGxldGVseSBlbXB0eSwgZG8gbm90aGluZy5cXG4gICAgICAgIGlmICh0aGlzLl9mcmFtZXNBdmFpbGFibGUgPT09IDApIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uTGVuZ3RoID0gYXJyYXlTZXF1ZW5jZVswXS5sZW5ndGg7IC8vIFRyYW5zZmVyIGRhdGEgZnJvbSB0aGUgaW50ZXJuYWwgYnVmZmVyIHRvIHRoZSB8YXJyYXlTZXF1ZW5jZXwgc3RvcmFnZS5cXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVzdGluYXRpb25MZW5ndGg7ICsraSkge1xcbiAgICAgICAgICB2YXIgcmVhZEluZGV4ID0gKHRoaXMuX3JlYWRJbmRleCArIGkpICUgdGhpcy5fbGVuZ3RoO1xcblxcbiAgICAgICAgICBmb3IgKHZhciBjaGFubmVsID0gMDsgY2hhbm5lbCA8IHRoaXMuX2NoYW5uZWxDb3VudDsgKytjaGFubmVsKSB7XFxuICAgICAgICAgICAgYXJyYXlTZXF1ZW5jZVtjaGFubmVsXVtpXSA9IHRoaXMuX2NoYW5uZWxEYXRhW2NoYW5uZWxdW3JlYWRJbmRleF07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX3JlYWRJbmRleCArPSBkZXN0aW5hdGlvbkxlbmd0aDtcXG5cXG4gICAgICAgIGlmICh0aGlzLl9yZWFkSW5kZXggPj0gdGhpcy5fbGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMuX3JlYWRJbmRleCA9IDA7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl9mcmFtZXNBdmFpbGFibGUgLT0gZGVzdGluYXRpb25MZW5ndGg7XFxuXFxuICAgICAgICBpZiAodGhpcy5fZnJhbWVzQXZhaWxhYmxlIDwgMCkge1xcbiAgICAgICAgICB0aGlzLl9mcmFtZXNBdmFpbGFibGUgPSAwO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgIGtleTogXFxcImZyYW1lc0F2YWlsYWJsZVxcXCIsXFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVzQXZhaWxhYmxlO1xcbiAgICAgIH1cXG4gICAgfV0pO1xcblxcbiAgICByZXR1cm4gUmluZ0J1ZmZlcjtcXG4gIH0oKVxcbn1bXFxcImRlZmF1bHRcXFwiXTtcXG5cXG52YXIgQW1wbGl0dWRlUHJvY2Vzc29yID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKF9BdWRpb1dvcmtsZXRQcm9jZXNzbykge1xcbiAgX2luaGVyaXRzKEFtcGxpdHVkZVByb2Nlc3NvciwgX0F1ZGlvV29ya2xldFByb2Nlc3NvKTtcXG5cXG4gIGZ1bmN0aW9uIEFtcGxpdHVkZVByb2Nlc3NvcihvcHRpb25zKSB7XFxuICAgIHZhciBfdGhpcztcXG5cXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFtcGxpdHVkZVByb2Nlc3Nvcik7XFxuXFxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFtcGxpdHVkZVByb2Nlc3NvcikuY2FsbCh0aGlzKSk7XFxuICAgIHZhciBwcm9jZXNzb3JPcHRpb25zID0gb3B0aW9ucy5wcm9jZXNzb3JPcHRpb25zIHx8IHt9O1xcbiAgICBfdGhpcy5udW1PdXRwdXRDaGFubmVscyA9IG9wdGlvbnMub3V0cHV0Q2hhbm5lbENvdW50IHx8IDE7XFxuICAgIF90aGlzLm51bUlucHV0Q2hhbm5lbHMgPSBwcm9jZXNzb3JPcHRpb25zLm51bUlucHV0Q2hhbm5lbHMgfHwgMjtcXG4gICAgX3RoaXMubm9ybWFsaXplID0gcHJvY2Vzc29yT3B0aW9ucy5ub3JtYWxpemUgfHwgZmFsc2U7XFxuICAgIF90aGlzLnNtb290aGluZyA9IHByb2Nlc3Nvck9wdGlvbnMuc21vb3RoaW5nIHx8IDA7XFxuICAgIF90aGlzLmJ1ZmZlclNpemUgPSBwcm9jZXNzb3JPcHRpb25zLmJ1ZmZlclNpemUgfHwgMjA0ODtcXG4gICAgX3RoaXMuaW5wdXRSaW5nQnVmZmVyID0gbmV3IFJpbmdCdWZmZXIoX3RoaXMuYnVmZmVyU2l6ZSwgX3RoaXMubnVtSW5wdXRDaGFubmVscyk7XFxuICAgIF90aGlzLm91dHB1dFJpbmdCdWZmZXIgPSBuZXcgUmluZ0J1ZmZlcihfdGhpcy5idWZmZXJTaXplLCBfdGhpcy5udW1PdXRwdXRDaGFubmVscyk7XFxuICAgIF90aGlzLmlucHV0UmluZ0J1ZmZlckFycmF5U2VxdWVuY2UgPSBuZXcgQXJyYXkoX3RoaXMubnVtSW5wdXRDaGFubmVscykuZmlsbChudWxsKS5tYXAoZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLmJ1ZmZlclNpemUpO1xcbiAgICB9KTtcXG4gICAgX3RoaXMuc3RlcmVvVm9sID0gWzAsIDBdO1xcbiAgICBfdGhpcy5zdGVyZW9Wb2xOb3JtID0gWzAsIDBdO1xcbiAgICBfdGhpcy52b2xNYXggPSAwLjAwMTtcXG5cXG4gICAgX3RoaXMucG9ydC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XFxuXFxuICAgICAgaWYgKGRhdGEubmFtZSA9PT0gJ3RvZ2dsZU5vcm1hbGl6ZScpIHtcXG4gICAgICAgIF90aGlzLm5vcm1hbGl6ZSA9IGRhdGEubm9ybWFsaXplO1xcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5uYW1lID09PSAnc21vb3RoaW5nJykge1xcbiAgICAgICAgX3RoaXMuc21vb3RoaW5nID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgZGF0YS5zbW9vdGhpbmcpKTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIHJldHVybiBfdGhpcztcXG4gIH0gLy8gVE8gRE8gbWFrZSB0aGlzIHN0ZXJlbyAvIGRlcGVuZGVudCBvbiAjIG9mIGF1ZGlvIGNoYW5uZWxzXFxuXFxuXFxuICBfY3JlYXRlQ2xhc3MoQW1wbGl0dWRlUHJvY2Vzc29yLCBbe1xcbiAgICBrZXk6IFxcXCJwcm9jZXNzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3MoaW5wdXRzLCBvdXRwdXRzKSB7XFxuICAgICAgdmFyIGlucHV0ID0gaW5wdXRzWzBdO1xcbiAgICAgIHZhciBvdXRwdXQgPSBvdXRwdXRzWzBdO1xcbiAgICAgIHZhciBzbW9vdGhpbmcgPSB0aGlzLnNtb290aGluZztcXG4gICAgICB0aGlzLmlucHV0UmluZ0J1ZmZlci5wdXNoKGlucHV0KTtcXG5cXG4gICAgICBpZiAodGhpcy5pbnB1dFJpbmdCdWZmZXIuZnJhbWVzQXZhaWxhYmxlID49IHRoaXMuYnVmZmVyU2l6ZSkge1xcbiAgICAgICAgdGhpcy5pbnB1dFJpbmdCdWZmZXIucHVsbCh0aGlzLmlucHV0UmluZ0J1ZmZlckFycmF5U2VxdWVuY2UpO1xcblxcbiAgICAgICAgZm9yICh2YXIgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCB0aGlzLm51bUlucHV0Q2hhbm5lbHM7ICsrY2hhbm5lbCkge1xcbiAgICAgICAgICB2YXIgaW5wdXRCdWZmZXIgPSB0aGlzLmlucHV0UmluZ0J1ZmZlckFycmF5U2VxdWVuY2VbY2hhbm5lbF07XFxuICAgICAgICAgIHZhciBidWZMZW5ndGggPSBpbnB1dEJ1ZmZlci5sZW5ndGg7XFxuICAgICAgICAgIHZhciBzdW0gPSAwO1xcblxcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zkxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgdmFyIHggPSBpbnB1dEJ1ZmZlcltpXTtcXG5cXG4gICAgICAgICAgICBpZiAodGhpcy5ub3JtYWxpemUpIHtcXG4gICAgICAgICAgICAgIHN1bSArPSBNYXRoLm1heChNYXRoLm1pbih4IC8gdGhpcy52b2xNYXgsIDEpLCAtMSkgKiBNYXRoLm1heChNYXRoLm1pbih4IC8gdGhpcy52b2xNYXgsIDEpLCAtMSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIHN1bSArPSB4ICogeDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gLy8gLi4uIHRoZW4gdGFrZSB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHN1bS5cXG5cXG5cXG4gICAgICAgICAgdmFyIHJtcyA9IE1hdGguc3FydChzdW0gLyBidWZMZW5ndGgpO1xcbiAgICAgICAgICB0aGlzLnN0ZXJlb1ZvbFtjaGFubmVsXSA9IE1hdGgubWF4KHJtcywgdGhpcy5zdGVyZW9Wb2xbY2hhbm5lbF0gKiBzbW9vdGhpbmcpO1xcbiAgICAgICAgICB0aGlzLnZvbE1heCA9IE1hdGgubWF4KHRoaXMuc3RlcmVvVm9sW2NoYW5uZWxdLCB0aGlzLnZvbE1heCk7XFxuICAgICAgICB9IC8vIGNhbGN1bGF0ZSBzdGVybyBub3JtYWxpemVkIHZvbHVtZSBhbmQgYWRkIHZvbHVtZSBmcm9tIGFsbCBjaGFubmVscyB0b2dldGhlclxcblxcblxcbiAgICAgICAgdmFyIHZvbFN1bSA9IDA7XFxuXFxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5zdGVyZW9Wb2wubGVuZ3RoOyBpbmRleCsrKSB7XFxuICAgICAgICAgIHRoaXMuc3RlcmVvVm9sTm9ybVtpbmRleF0gPSBNYXRoLm1heChNYXRoLm1pbih0aGlzLnN0ZXJlb1ZvbFtpbmRleF0gLyB0aGlzLnZvbE1heCwgMSksIDApO1xcbiAgICAgICAgICB2b2xTdW0gKz0gdGhpcy5zdGVyZW9Wb2xbaW5kZXhdO1xcbiAgICAgICAgfSAvLyB2b2x1bWUgaXMgYXZlcmFnZSBvZiBjaGFubmVsc1xcblxcblxcbiAgICAgICAgdmFyIHZvbHVtZSA9IHZvbFN1bSAvIHRoaXMuc3RlcmVvVm9sLmxlbmd0aDsgLy8gbm9ybWFsaXplZCB2YWx1ZVxcblxcbiAgICAgICAgdmFyIHZvbE5vcm0gPSBNYXRoLm1heChNYXRoLm1pbih2b2x1bWUgLyB0aGlzLnZvbE1heCwgMSksIDApO1xcbiAgICAgICAgdGhpcy5wb3J0LnBvc3RNZXNzYWdlKHtcXG4gICAgICAgICAgbmFtZTogJ2FtcGxpdHVkZScsXFxuICAgICAgICAgIHZvbHVtZTogdm9sdW1lLFxcbiAgICAgICAgICB2b2xOb3JtOiB2b2xOb3JtLFxcbiAgICAgICAgICBzdGVyZW9Wb2w6IHRoaXMuc3RlcmVvVm9sLFxcbiAgICAgICAgICBzdGVyZW9Wb2xOb3JtOiB0aGlzLnN0ZXJlb1ZvbE5vcm1cXG4gICAgICAgIH0pOyAvLyBwYXNzIGlucHV0IHRocm91Z2ggdG8gb3V0cHV0XFxuXFxuICAgICAgICB0aGlzLm91dHB1dFJpbmdCdWZmZXIucHVzaCh0aGlzLmlucHV0UmluZ0J1ZmZlckFycmF5U2VxdWVuY2UpO1xcbiAgICAgIH0gLy8gcHVsbCAxMjggZnJhbWVzIG91dCBvZiB0aGUgcmluZyBidWZmZXJcXG4gICAgICAvLyBpZiB0aGUgcmluZyBidWZmZXIgZG9lcyBub3QgaGF2ZSBlbm91Z2ggZnJhbWVzLCB0aGUgb3V0cHV0IHdpbGwgYmUgc2lsZW50XFxuXFxuXFxuICAgICAgdGhpcy5vdXRwdXRSaW5nQnVmZmVyLnB1bGwob3V0cHV0KTtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIEFtcGxpdHVkZVByb2Nlc3NvcjtcXG59KF93cmFwTmF0aXZlU3VwZXIoQXVkaW9Xb3JrbGV0UHJvY2Vzc29yKSk7XFxuXFxucmVnaXN0ZXJQcm9jZXNzb3IocHJvY2Vzc29yTmFtZXMuYW1wbGl0dWRlUHJvY2Vzc29yLCBBbXBsaXR1ZGVQcm9jZXNzb3IpO1wiKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgdmFyIHA1c291bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBhYyA9IHA1c291bmQuYXVkaW9jb250ZXh0OyBcblxuICBpZiAodHlwZW9mIGFjLmNyZWF0ZVN0ZXJlb1Bhbm5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBwNS5QYW5uZXIgPSBmdW5jdGlvbiAoaW5wdXQsIG91dHB1dCkge1xuICAgICAgdGhpcy5zdGVyZW9QYW5uZXIgPSB0aGlzLmlucHV0ID0gYWMuY3JlYXRlU3RlcmVvUGFubmVyKCk7XG4gICAgICBpbnB1dC5jb25uZWN0KHRoaXMuc3RlcmVvUGFubmVyKTtcbiAgICAgIHRoaXMuc3RlcmVvUGFubmVyLmNvbm5lY3Qob3V0cHV0KTtcbiAgICB9O1xuXG4gICAgcDUuUGFubmVyLnByb3RvdHlwZS5wYW4gPSBmdW5jdGlvbiAodmFsLCB0RnJvbU5vdykge1xuICAgICAgdmFyIHRpbWUgPSB0RnJvbU5vdyB8fCAwO1xuICAgICAgdmFyIHQgPSBhYy5jdXJyZW50VGltZSArIHRpbWU7XG4gICAgICB0aGlzLnN0ZXJlb1Bhbm5lci5wYW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsLCB0KTtcbiAgICB9OyBcblxuXG4gICAgcDUuUGFubmVyLnByb3RvdHlwZS5pbnB1dENoYW5uZWxzID0gZnVuY3Rpb24gKCkge307XG5cbiAgICBwNS5QYW5uZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICB0aGlzLnN0ZXJlb1Bhbm5lci5jb25uZWN0KG9iaik7XG4gICAgfTtcblxuICAgIHA1LlBhbm5lci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnN0ZXJlb1Bhbm5lcikge1xuICAgICAgICB0aGlzLnN0ZXJlb1Bhbm5lci5kaXNjb25uZWN0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBwNS5QYW5uZXIgPSBmdW5jdGlvbiAoaW5wdXQsIG91dHB1dCwgbnVtSW5wdXRDaGFubmVscykge1xuICAgICAgdGhpcy5pbnB1dCA9IGFjLmNyZWF0ZUdhaW4oKTtcbiAgICAgIGlucHV0LmNvbm5lY3QodGhpcy5pbnB1dCk7XG4gICAgICB0aGlzLmxlZnQgPSBhYy5jcmVhdGVHYWluKCk7XG4gICAgICB0aGlzLnJpZ2h0ID0gYWMuY3JlYXRlR2FpbigpO1xuICAgICAgdGhpcy5sZWZ0LmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9ICdkaXNjcmV0ZSc7XG4gICAgICB0aGlzLnJpZ2h0LmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9ICdkaXNjcmV0ZSc7IFxuXG4gICAgICBpZiAobnVtSW5wdXRDaGFubmVscyA+IDEpIHtcbiAgICAgICAgdGhpcy5zcGxpdHRlciA9IGFjLmNyZWF0ZUNoYW5uZWxTcGxpdHRlcigyKTtcbiAgICAgICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuc3BsaXR0ZXIpO1xuICAgICAgICB0aGlzLnNwbGl0dGVyLmNvbm5lY3QodGhpcy5sZWZ0LCAxKTtcbiAgICAgICAgdGhpcy5zcGxpdHRlci5jb25uZWN0KHRoaXMucmlnaHQsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMubGVmdCk7XG4gICAgICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLnJpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vdXRwdXQgPSBhYy5jcmVhdGVDaGFubmVsTWVyZ2VyKDIpO1xuICAgICAgdGhpcy5sZWZ0LmNvbm5lY3QodGhpcy5vdXRwdXQsIDAsIDEpO1xuICAgICAgdGhpcy5yaWdodC5jb25uZWN0KHRoaXMub3V0cHV0LCAwLCAwKTtcbiAgICAgIHRoaXMub3V0cHV0LmNvbm5lY3Qob3V0cHV0KTtcbiAgICB9OyBcblxuXG4gICAgcDUuUGFubmVyLnByb3RvdHlwZS5wYW4gPSBmdW5jdGlvbiAodmFsLCB0RnJvbU5vdykge1xuICAgICAgdmFyIHRpbWUgPSB0RnJvbU5vdyB8fCAwO1xuICAgICAgdmFyIHQgPSBhYy5jdXJyZW50VGltZSArIHRpbWU7XG4gICAgICB2YXIgdiA9ICh2YWwgKyAxKSAvIDI7XG4gICAgICB2YXIgcmlnaHRWYWwgPSBNYXRoLmNvcyh2ICogTWF0aC5QSSAvIDIpO1xuICAgICAgdmFyIGxlZnRWYWwgPSBNYXRoLnNpbih2ICogTWF0aC5QSSAvIDIpO1xuICAgICAgdGhpcy5sZWZ0LmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUobGVmdFZhbCwgdCk7XG4gICAgICB0aGlzLnJpZ2h0LmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUocmlnaHRWYWwsIHQpO1xuICAgIH07XG5cbiAgICBwNS5QYW5uZXIucHJvdG90eXBlLmlucHV0Q2hhbm5lbHMgPSBmdW5jdGlvbiAobnVtQ2hhbm5lbHMpIHtcbiAgICAgIGlmIChudW1DaGFubmVscyA9PT0gMSkge1xuICAgICAgICB0aGlzLmlucHV0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMubGVmdCk7XG4gICAgICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLnJpZ2h0KTtcbiAgICAgIH0gZWxzZSBpZiAobnVtQ2hhbm5lbHMgPT09IDIpIHtcbiAgICAgICAgaWYgKF90eXBlb2YodGhpcy5zcGxpdHRlciA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgdGhpcy5zcGxpdHRlciA9IGFjLmNyZWF0ZUNoYW5uZWxTcGxpdHRlcigyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5wdXQuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5zcGxpdHRlcik7XG4gICAgICAgIHRoaXMuc3BsaXR0ZXIuY29ubmVjdCh0aGlzLmxlZnQsIDEpO1xuICAgICAgICB0aGlzLnNwbGl0dGVyLmNvbm5lY3QodGhpcy5yaWdodCwgMCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHA1LlBhbm5lci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHRoaXMub3V0cHV0LmNvbm5lY3Qob2JqKTtcbiAgICB9O1xuXG4gICAgcDUuUGFubmVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMub3V0cHV0KSB7XG4gICAgICAgIHRoaXMub3V0cHV0LmRpc2Nvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgdmFyIEN1c3RvbUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbiAgdmFyIHA1c291bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBhYyA9IHA1c291bmQuYXVkaW9jb250ZXh0O1xuXG4gIHZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNiksXG4gICAgICBtaWRpVG9GcmVxID0gX3JlcXVpcmUubWlkaVRvRnJlcSxcbiAgICAgIGNvbnZlcnRUb1dhdiA9IF9yZXF1aXJlLmNvbnZlcnRUb1dhdixcbiAgICAgIHNhZmVCdWZmZXJTaXplID0gX3JlcXVpcmUuc2FmZUJ1ZmZlclNpemU7XG5cbiAgdmFyIHByb2Nlc3Nvck5hbWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG4gIC8qKlxuICAgKiAgPHA+U291bmRGaWxlIG9iamVjdCB3aXRoIGEgcGF0aCB0byBhIGZpbGUuPC9wPlxuICAgKlxuICAgKiAgPHA+VGhlIHA1LlNvdW5kRmlsZSBtYXkgbm90IGJlIGF2YWlsYWJsZSBpbW1lZGlhdGVseSBiZWNhdXNlXG4gICAqICBpdCBsb2FkcyB0aGUgZmlsZSBpbmZvcm1hdGlvbiBhc3luY2hyb25vdXNseS48L3A+XG4gICAqXG4gICAqICA8cD5UbyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgc291bmQgYXMgc29vbiBhcyBpdCBsb2Fkc1xuICAgKiAgcGFzcyB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLjwvcD5cbiAgICpcbiAgICogIDxwPk9ubHkgb25lIGZpbGUgcGF0aCBpcyByZXF1aXJlZC4gSG93ZXZlciwgYXVkaW8gZmlsZSBmb3JtYXRzXG4gICAqICAoaS5lLiBtcDMsIG9nZywgd2F2IGFuZCBtNGEvYWFjKSBhcmUgbm90IHN1cHBvcnRlZCBieSBhbGxcbiAgICogIHdlYiBicm93c2Vycy4gSWYgeW91IHdhbnQgdG8gZW5zdXJlIGNvbXBhdGFiaWxpdHksIGluc3RlYWQgb2YgYSBzaW5nbGVcbiAgICogIGZpbGUgcGF0aCwgeW91IG1heSBpbmNsdWRlIGFuIEFycmF5IG9mIGZpbGVwYXRocywgYW5kIHRoZSBicm93c2VyIHdpbGxcbiAgICogIGNob29zZSBhIGZvcm1hdCB0aGF0IHdvcmtzLjwvcD5cbiAgICpcbiAgICogIEBjbGFzcyBwNS5Tb3VuZEZpbGVcbiAgICogIEBjb25zdHJ1Y3RvclxuICAgKiAgQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBhdGggICBwYXRoIHRvIGEgc291bmQgZmlsZSAoU3RyaW5nKS4gT3B0aW9uYWxseSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeW91IG1heSBpbmNsdWRlIG11bHRpcGxlIGZpbGUgZm9ybWF0cyBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbiBhcnJheS4gQWx0ZXJuYXRlbHksIGFjY2VwdHMgYW4gb2JqZWN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gdGhlIEhUTUw1IEZpbGUgQVBJLCBvciBhIHA1LkZpbGUuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc0NhbGxiYWNrXSAgIE5hbWUgb2YgYSBmdW5jdGlvbiB0byBjYWxsIG9uY2UgZmlsZSBsb2Fkc1xuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yQ2FsbGJhY2tdICAgTmFtZSBvZiBhIGZ1bmN0aW9uIHRvIGNhbGwgaWYgZmlsZSBmYWlscyB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZC4gVGhpcyBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgYW4gZXJyb3Igb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0IHdpdGggaW5mb3JtYXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvdXQgd2hhdCB3ZW50IHdyb25nLlxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gW3doaWxlTG9hZGluZ0NhbGxiYWNrXSAgIE5hbWUgb2YgYSBmdW5jdGlvbiB0byBjYWxsIHdoaWxlIGZpbGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBsb2FkaW5nLiBUaGF0IGZ1bmN0aW9uIHdpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlIHByb2dyZXNzIG9mIHRoZSByZXF1ZXN0IHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZCB0aGUgc291bmQgZmlsZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChiZXR3ZWVuIDAgYW5kIDEpIGFzIGl0cyBmaXJzdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlci4gVGhpcyBwcm9ncmVzc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvZXMgbm90IGFjY291bnQgZm9yIHRoZSBhZGRpdGlvbmFsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZSBuZWVkZWQgdG8gZGVjb2RlIHRoZSBhdWRpbyBkYXRhLlxuICAgKlxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgbXlTb3VuZDtcbiAgICogIGZ1bmN0aW9uIHByZWxvYWQoKSB7XG4gICAqICAgIHNvdW5kRm9ybWF0cygnbXAzJywgJ29nZycpO1xuICAgKiAgICBteVNvdW5kID0gbG9hZFNvdW5kKCdhc3NldHMvZG9vcmJlbGwnKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChjYW52YXNQcmVzc2VkKTtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0KCd0YXAgaGVyZSB0byBwbGF5JywgMTAsIDIwKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGNhbnZhc1ByZXNzZWQoKSB7XG4gICAqICAgIC8vIHBsYXlpbmcgYSBzb3VuZCBmaWxlIG9uIGEgdXNlciBnZXN0dXJlXG4gICAqICAgIC8vIGlzIGVxdWl2YWxlbnQgdG8gYHVzZXJTdGFydEF1ZGlvKClgXG4gICAqICAgIG15U291bmQucGxheSgpO1xuICAgKiAgfVxuICAgKiA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlID0gZnVuY3Rpb24gKHBhdGhzLCBvbmxvYWQsIG9uZXJyb3IsIHdoaWxlTG9hZGluZykge1xuICAgIGlmICh0eXBlb2YgcGF0aHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGhzID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcGF0aHNbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBwYXRoID0gcDUucHJvdG90eXBlLl9jaGVja0ZpbGVGb3JtYXRzKHBhdGhzKTtcblxuICAgICAgICB0aGlzLnVybCA9IHBhdGg7XG4gICAgICB9IGVsc2UgaWYgKF90eXBlb2YocGF0aHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoISh3aW5kb3cuRmlsZSAmJiB3aW5kb3cuRmlsZVJlYWRlciAmJiB3aW5kb3cuRmlsZUxpc3QgJiYgd2luZG93LkJsb2IpKSB7XG4gICAgICAgICAgdGhyb3cgJ1VuYWJsZSB0byBsb2FkIGZpbGUgYmVjYXVzZSB0aGUgRmlsZSBBUEkgaXMgbm90IHN1cHBvcnRlZCc7XG4gICAgICAgIH1cbiAgICAgIH0gXG5cblxuICAgICAgaWYgKHBhdGhzLmZpbGUpIHtcbiAgICAgICAgcGF0aHMgPSBwYXRocy5maWxlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpbGUgPSBwYXRocztcbiAgICB9IFxuXG5cbiAgICB0aGlzLl9vbmVuZGVkID0gZnVuY3Rpb24gKCkge307XG5cbiAgICB0aGlzLl9sb29waW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhdXNlVGltZSA9IDA7IFxuXG4gICAgdGhpcy5fY3VlcyA9IFtdO1xuICAgIHRoaXMuX2N1ZUlEQ291bnRlciA9IDA7IFxuXG4gICAgdGhpcy5fbGFzdFBvcyA9IDA7XG4gICAgdGhpcy5fY291bnRlck5vZGUgPSBudWxsO1xuICAgIHRoaXMuX3dvcmtsZXROb2RlID0gbnVsbDsgXG5cbiAgICB0aGlzLmJ1ZmZlclNvdXJjZU5vZGVzID0gW107IFxuXG4gICAgdGhpcy5idWZmZXJTb3VyY2VOb2RlID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5wbGF5YmFja1JhdGUgPSAxO1xuICAgIHRoaXMuaW5wdXQgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgdGhpcy5vdXRwdXQgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgdGhpcy5yZXZlcnNlZCA9IGZhbHNlOyBcblxuICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmVuZFRpbWUgPSBudWxsO1xuICAgIHRoaXMucGF1c2VUaW1lID0gMDsgXG5cbiAgICB0aGlzLm1vZGUgPSAnc3VzdGFpbic7IFxuXG4gICAgdGhpcy5zdGFydE1pbGxpcyA9IG51bGw7IFxuXG4gICAgdGhpcy5wYW5Qb3NpdGlvbiA9IDAuMDtcbiAgICB0aGlzLnBhbm5lciA9IG5ldyBwNS5QYW5uZXIodGhpcy5vdXRwdXQsIHA1c291bmQuaW5wdXQsIDIpOyBcblxuICAgIGlmICh0aGlzLnVybCB8fCB0aGlzLmZpbGUpIHtcbiAgICAgIHRoaXMubG9hZChvbmxvYWQsIG9uZXJyb3IpO1xuICAgIH0gXG5cblxuICAgIHA1c291bmQuc291bmRBcnJheS5wdXNoKHRoaXMpO1xuXG4gICAgaWYgKHR5cGVvZiB3aGlsZUxvYWRpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX3doaWxlTG9hZGluZyA9IHdoaWxlTG9hZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fd2hpbGVMb2FkaW5nID0gZnVuY3Rpb24gKCkge307XG4gICAgfVxuXG4gICAgdGhpcy5fY2xlYXJPbkVuZCA9IF9jbGVhck9uRW5kLmJpbmQodGhpcyk7XG4gIH07IFxuXG5cbiAgcDUucHJvdG90eXBlLnJlZ2lzdGVyUHJlbG9hZE1ldGhvZCgnbG9hZFNvdW5kJywgcDUucHJvdG90eXBlKTtcbiAgLyoqXG4gICAqICBsb2FkU291bmQoKSByZXR1cm5zIGEgbmV3IHA1LlNvdW5kRmlsZSBmcm9tIGEgc3BlY2lmaWVkXG4gICAqICBwYXRoLiBJZiBjYWxsZWQgZHVyaW5nIHByZWxvYWQoKSwgdGhlIHA1LlNvdW5kRmlsZSB3aWxsIGJlIHJlYWR5XG4gICAqICB0byBwbGF5IGluIHRpbWUgZm9yIHNldHVwKCkgYW5kIGRyYXcoKS4gSWYgY2FsbGVkIG91dHNpZGUgb2ZcbiAgICogIHByZWxvYWQsIHRoZSBwNS5Tb3VuZEZpbGUgd2lsbCBub3QgYmUgcmVhZHkgaW1tZWRpYXRlbHksIHNvXG4gICAqICBsb2FkU291bmQgYWNjZXB0cyBhIGNhbGxiYWNrIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLiBVc2luZyBhXG4gICAqICA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL3Byb2Nlc3NpbmcvcDUuanMvd2lraS9Mb2NhbC1zZXJ2ZXJcIj5cbiAgICogIGxvY2FsIHNlcnZlcjwvYT4gaXMgcmVjb21tZW5kZWQgd2hlbiBsb2FkaW5nIGV4dGVybmFsIGZpbGVzLlxuICAgKlxuICAgKiAgQG1ldGhvZCBsb2FkU291bmRcbiAgICogIEBmb3IgcDVcbiAgICogIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gICBwYXRoICAgICBQYXRoIHRvIHRoZSBzb3VuZCBmaWxlLCBvciBhbiBhcnJheSB3aXRoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHMgdG8gc291bmRmaWxlcyBpbiBtdWx0aXBsZSBmb3JtYXRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaS5lLiBbJ3NvdW5kLm9nZycsICdzb3VuZC5tcDMnXS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbHRlcm5hdGVseSwgYWNjZXB0cyBhbiBvYmplY3Q6IGVpdGhlclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gdGhlIEhUTUw1IEZpbGUgQVBJLCBvciBhIHA1LkZpbGUuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc0NhbGxiYWNrXSAgIE5hbWUgb2YgYSBmdW5jdGlvbiB0byBjYWxsIG9uY2UgZmlsZSBsb2Fkc1xuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yQ2FsbGJhY2tdICAgTmFtZSBvZiBhIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhlcmUgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGVycm9yIGxvYWRpbmcgdGhlIGZpbGUuXG4gICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBbd2hpbGVMb2FkaW5nXSBOYW1lIG9mIGEgZnVuY3Rpb24gdG8gY2FsbCB3aGlsZSBmaWxlIGlzIGxvYWRpbmcuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdGhlIHBlcmNlbnRhZ2UgbG9hZGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc28gZmFyLCBmcm9tIDAuMCB0byAxLjAuXG4gICAqICBAcmV0dXJuIHtTb3VuZEZpbGV9ICAgICAgICAgICAgUmV0dXJucyBhIHA1LlNvdW5kRmlsZVxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgbXlTb3VuZDtcbiAgICogIGZ1bmN0aW9uIHByZWxvYWQoKSB7XG4gICAqICAgIHNvdW5kRm9ybWF0cygnbXAzJywgJ29nZycpO1xuICAgKiAgICBteVNvdW5kID0gbG9hZFNvdW5kKCdhc3NldHMvZG9vcmJlbGwnKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChjYW52YXNQcmVzc2VkKTtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0KCd0YXAgaGVyZSB0byBwbGF5JywgMTAsIDIwKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGNhbnZhc1ByZXNzZWQoKSB7XG4gICAqICAgIC8vIHBsYXlpbmcgYSBzb3VuZCBmaWxlIG9uIGEgdXNlciBnZXN0dXJlXG4gICAqICAgIC8vIGlzIGVxdWl2YWxlbnQgdG8gYHVzZXJTdGFydEF1ZGlvKClgXG4gICAqICAgIG15U291bmQucGxheSgpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuICBwNS5wcm90b3R5cGUubG9hZFNvdW5kID0gZnVuY3Rpb24gKHBhdGgsIGNhbGxiYWNrLCBvbmVycm9yLCB3aGlsZUxvYWRpbmcpIHtcbiAgICBpZiAod2luZG93LmxvY2F0aW9uLm9yaWdpbi5pbmRleE9mKCdmaWxlOi8vJykgPiAtMSAmJiB3aW5kb3cuY29yZG92YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvdy5hbGVydCgnVGhpcyBza2V0Y2ggbWF5IHJlcXVpcmUgYSBzZXJ2ZXIgdG8gbG9hZCBleHRlcm5hbCBmaWxlcy4gUGxlYXNlIHNlZSBodHRwOi8vYml0Lmx5LzFxY0lud1MnKTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHMgPSBuZXcgcDUuU291bmRGaWxlKHBhdGgsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzZWxmLl9kZWNyZW1lbnRQcmVsb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHNlbGYuX2RlY3JlbWVudFByZWxvYWQoKTtcbiAgICAgIH1cbiAgICB9LCBvbmVycm9yLCB3aGlsZUxvYWRpbmcpO1xuICAgIHJldHVybiBzO1xuICB9O1xuICAvKipcbiAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiB0aGF0IHRoZSBwNS5Tb3VuZEZpbGUgY2FsbHMgdG8gbG9hZFxuICAgKiBpdHNlbGYuIEFjY2VwdHMgYSBjYWxsYmFjayAodGhlIG5hbWUgb2YgYW5vdGhlciBmdW5jdGlvbilcbiAgICogYXMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZm9yIHA1LlNvdW5kRmlsZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc0NhbGxiYWNrXSAgIE5hbWUgb2YgYSBmdW5jdGlvbiB0byBjYWxsIG9uY2UgZmlsZSBsb2Fkc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JDYWxsYmFja10gICBOYW1lIG9mIGEgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGVyZSBpcyBhbiBlcnJvclxuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZXJyb3JUcmFjZSA9IG5ldyBFcnJvcigpLnN0YWNrO1xuXG4gICAgaWYgKHRoaXMudXJsICE9PSB1bmRlZmluZWQgJiYgdGhpcy51cmwgIT09ICcnKSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgc2VsZi5fdXBkYXRlUHJvZ3Jlc3MoZXZ0KTtcbiAgICAgIH0sIGZhbHNlKTtcbiAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgdGhpcy51cmwsIHRydWUpO1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXG4gICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICBpZiAoIXNlbGYucGFubmVyKSByZXR1cm47XG4gICAgICAgICAgYWMuZGVjb2RlQXVkaW9EYXRhKHJlcXVlc3QucmVzcG9uc2UsIFxuICAgICAgICAgIGZ1bmN0aW9uIChidWZmKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYucGFubmVyKSByZXR1cm47XG4gICAgICAgICAgICBzZWxmLmJ1ZmZlciA9IGJ1ZmY7XG4gICAgICAgICAgICBzZWxmLnBhbm5lci5pbnB1dENoYW5uZWxzKGJ1ZmYubnVtYmVyT2ZDaGFubmVscyk7XG5cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYucGFubmVyKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZXJyID0gbmV3IEN1c3RvbUVycm9yKCdkZWNvZGVBdWRpb0RhdGEnLCBlcnJvclRyYWNlLCBzZWxmLnVybCk7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ0F1ZGlvQ29udGV4dCBlcnJvciBhdCBkZWNvZGVBdWRpb0RhdGEgZm9yICcgKyBzZWxmLnVybDtcblxuICAgICAgICAgICAgaWYgKGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgZXJyLm1zZyA9IG1zZztcbiAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtc2cgKyAnXFxuIFRoZSBlcnJvciBzdGFjayB0cmFjZSBpbmNsdWRlczogXFxuJyArIGVyci5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzZWxmLnBhbm5lcikgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBDdXN0b21FcnJvcignbG9hZFNvdW5kJywgZXJyb3JUcmFjZSwgc2VsZi51cmwpO1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdVbmFibGUgdG8gbG9hZCAnICsgc2VsZi51cmwgKyAnLiBUaGUgcmVxdWVzdCBzdGF0dXMgd2FzOiAnICsgcmVxdWVzdC5zdGF0dXMgKyAnICgnICsgcmVxdWVzdC5zdGF0dXNUZXh0ICsgJyknO1xuXG4gICAgICAgICAgICBpZiAoZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IG1zZztcbiAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtc2cgKyAnXFxuIFRoZSBlcnJvciBzdGFjayB0cmFjZSBpbmNsdWRlczogXFxuJyArIGVyci5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfTsgXG5cblxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXJyID0gbmV3IEN1c3RvbUVycm9yKCdsb2FkU291bmQnLCBlcnJvclRyYWNlLCBzZWxmLnVybCk7XG4gICAgICAgIHZhciBtc2cgPSAnVGhlcmUgd2FzIG5vIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciBhdCAnICsgc2VsZi51cmwgKyAnLiBDaGVjayB0aGUgdXJsIGFuZCBpbnRlcm5ldCBjb25uZWN0aXZpdHkuJztcblxuICAgICAgICBpZiAoZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgIGVyci5tZXNzYWdlID0gbXNnO1xuICAgICAgICAgIGVycm9yQ2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG1zZyArICdcXG4gVGhlIGVycm9yIHN0YWNrIHRyYWNlIGluY2x1ZGVzOiBcXG4nICsgZXJyLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZpbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc2VsZi5wYW5uZXIpIHJldHVybjtcbiAgICAgICAgYWMuZGVjb2RlQXVkaW9EYXRhKHJlYWRlci5yZXN1bHQsIGZ1bmN0aW9uIChidWZmKSB7XG4gICAgICAgICAgaWYgKCFzZWxmLnBhbm5lcikgcmV0dXJuO1xuICAgICAgICAgIHNlbGYuYnVmZmVyID0gYnVmZjtcbiAgICAgICAgICBzZWxmLnBhbm5lci5pbnB1dENoYW5uZWxzKGJ1ZmYubnVtYmVyT2ZDaGFubmVscyk7XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHNlbGYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghc2VsZi5wYW5uZXIpIHJldHVybjtcblxuICAgICAgICBpZiAob25lcnJvcikge1xuICAgICAgICAgIG9uZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcih0aGlzLmZpbGUpO1xuICAgIH1cbiAgfTsgXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLl91cGRhdGVQcm9ncmVzcyA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICBpZiAoZXZ0Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgIHZhciBwZXJjZW50Q29tcGxldGUgPSBldnQubG9hZGVkIC8gZXZ0LnRvdGFsICogMC45OTtcblxuICAgICAgdGhpcy5fd2hpbGVMb2FkaW5nKHBlcmNlbnRDb21wbGV0ZSwgZXZ0KTsgXG5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fd2hpbGVMb2FkaW5nKCdzaXplIHVua25vd24nKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSBzb3VuZCBmaWxlIGZpbmlzaGVkIGxvYWRpbmcgc3VjY2Vzc2Z1bGx5LlxuICAgKlxuICAgKiAgQG1ldGhvZCAgaXNMb2FkZWRcbiAgICogIEBmb3IgcDUuU291bmRGaWxlXG4gICAqICBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuaXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYnVmZmVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFBsYXkgdGhlIHA1LlNvdW5kRmlsZVxuICAgKlxuICAgKiBAbWV0aG9kIHBsYXlcbiAgICogQGZvciBwNS5Tb3VuZEZpbGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydFRpbWVdICAgICAgICAgICAgKG9wdGlvbmFsKSBzY2hlZHVsZSBwbGF5YmFjayB0byBzdGFydCAoaW4gc2Vjb25kcyBmcm9tIG5vdykuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcmF0ZV0gICAgICAgICAgICAgKG9wdGlvbmFsKSBwbGF5YmFjayByYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbYW1wXSAgICAgICAgICAgICAgKG9wdGlvbmFsKSBhbXBsaXR1ZGUgKHZvbHVtZSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgcGxheWJhY2tcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjdWVTdGFydF0gICAgICAgIChvcHRpb25hbCkgY3VlIHN0YXJ0IHRpbWUgaW4gc2Vjb25kc1xuICAgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uXSAgICAgICAgICAob3B0aW9uYWwpIGR1cmF0aW9uIG9mIHBsYXliYWNrIGluIHNlY29uZHNcbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoc3RhcnRUaW1lLCByYXRlLCBhbXAsIF9jdWVTdGFydCwgZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMub3V0cHV0KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1NvdW5kRmlsZS5wbGF5KCkgY2FsbGVkIGFmdGVyIGRpc3Bvc2UnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgdmFyIGN1ZVN0YXJ0LCBjdWVFbmQ7XG4gICAgdmFyIHRpbWUgPSBzdGFydFRpbWUgfHwgMDtcblxuICAgIGlmICh0aW1lIDwgMCkge1xuICAgICAgdGltZSA9IDA7XG4gICAgfVxuXG4gICAgdGltZSA9IHRpbWUgKyBub3c7XG5cbiAgICBpZiAodHlwZW9mIHJhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnJhdGUocmF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhbXAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnNldFZvbHVtZShhbXApO1xuICAgIH0gXG5cblxuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xuICAgICAgdGhpcy5fcGF1c2VUaW1lID0gMDsgXG5cbiAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdyZXN0YXJ0JyAmJiB0aGlzLmJ1ZmZlciAmJiB0aGlzLmJ1ZmZlclNvdXJjZU5vZGUpIHtcbiAgICAgICAgdGhpcy5idWZmZXJTb3VyY2VOb2RlLnN0b3AodGltZSk7XG5cbiAgICAgICAgdGhpcy5fY291bnRlck5vZGUuc3RvcCh0aW1lKTtcbiAgICAgIH0gXG5cblxuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ3VudGlsZG9uZScgJiYgdGhpcy5pc1BsYXlpbmcoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IFxuXG5cbiAgICAgIHRoaXMuYnVmZmVyU291cmNlTm9kZSA9IHRoaXMuX2luaXRTb3VyY2VOb2RlKCk7IFxuXG4gICAgICBkZWxldGUgdGhpcy5fY291bnRlck5vZGU7XG4gICAgICB0aGlzLl9jb3VudGVyTm9kZSA9IHRoaXMuX2luaXRDb3VudGVyTm9kZSgpO1xuXG4gICAgICBpZiAoX2N1ZVN0YXJ0KSB7XG4gICAgICAgIGlmIChfY3VlU3RhcnQgPj0gMCAmJiBfY3VlU3RhcnQgPCB0aGlzLmJ1ZmZlci5kdXJhdGlvbikge1xuICAgICAgICAgIGN1ZVN0YXJ0ID0gX2N1ZVN0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93ICdzdGFydCB0aW1lIG91dCBvZiByYW5nZSc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1ZVN0YXJ0ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24gPD0gdGhpcy5idWZmZXIuZHVyYXRpb24gLSBjdWVTdGFydCA/IGR1cmF0aW9uIDogdGhpcy5idWZmZXIuZHVyYXRpb247XG4gICAgICB9IFxuXG5cbiAgICAgIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgdGhpcy5idWZmZXJTb3VyY2VOb2RlLnN0YXJ0KHRpbWUsIHRoaXMucGF1c2VUaW1lLCBkdXJhdGlvbik7XG5cbiAgICAgICAgdGhpcy5fY291bnRlck5vZGUuc3RhcnQodGltZSwgdGhpcy5wYXVzZVRpbWUsIGR1cmF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYnVmZmVyU291cmNlTm9kZS5zdGFydCh0aW1lLCBjdWVTdGFydCwgZHVyYXRpb24pO1xuXG4gICAgICAgIHRoaXMuX2NvdW50ZXJOb2RlLnN0YXJ0KHRpbWUsIGN1ZVN0YXJ0LCBkdXJhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3BsYXlpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7IFxuXG4gICAgICB0aGlzLmJ1ZmZlclNvdXJjZU5vZGVzLnB1c2godGhpcy5idWZmZXJTb3VyY2VOb2RlKTtcbiAgICAgIHRoaXMuYnVmZmVyU291cmNlTm9kZS5fYXJyYXlJbmRleCA9IHRoaXMuYnVmZmVyU291cmNlTm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgIHRoaXMuYnVmZmVyU291cmNlTm9kZS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuX2NsZWFyT25FbmQpO1xuICAgIH0gXG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93ICdub3QgcmVhZHkgdG8gcGxheSBmaWxlLCBidWZmZXIgaGFzIHlldCB0byBsb2FkLiBUcnkgcHJlbG9hZCgpJztcbiAgICAgIH0gXG5cblxuICAgIHRoaXMuYnVmZmVyU291cmNlTm9kZS5sb29wID0gdGhpcy5fbG9vcGluZztcbiAgICB0aGlzLl9jb3VudGVyTm9kZS5sb29wID0gdGhpcy5fbG9vcGluZztcblxuICAgIGlmICh0aGlzLl9sb29waW5nID09PSB0cnVlKSB7XG4gICAgICBjdWVFbmQgPSBkdXJhdGlvbiA/IGR1cmF0aW9uIDogY3VlU3RhcnQgLSAwLjAwMDAwMDAwMDAwMDAwMTtcbiAgICAgIHRoaXMuYnVmZmVyU291cmNlTm9kZS5sb29wU3RhcnQgPSBjdWVTdGFydDtcbiAgICAgIHRoaXMuYnVmZmVyU291cmNlTm9kZS5sb29wRW5kID0gY3VlRW5kO1xuICAgICAgdGhpcy5fY291bnRlck5vZGUubG9vcFN0YXJ0ID0gY3VlU3RhcnQ7XG4gICAgICB0aGlzLl9jb3VudGVyTm9kZS5sb29wRW5kID0gY3VlRW5kO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBwNS5Tb3VuZEZpbGUgaGFzIHR3byBwbGF5IG1vZGVzOiA8Y29kZT5yZXN0YXJ0PC9jb2RlPiBhbmRcbiAgICogIDxjb2RlPnN1c3RhaW48L2NvZGU+LiBQbGF5IE1vZGUgZGV0ZXJtaW5lcyB3aGF0IGhhcHBlbnMgdG8gYVxuICAgKiAgcDUuU291bmRGaWxlIGlmIGl0IGlzIHRyaWdnZXJlZCB3aGlsZSBpbiB0aGUgbWlkZGxlIG9mIHBsYXliYWNrLlxuICAgKiAgSW4gc3VzdGFpbiBtb2RlLCBwbGF5YmFjayB3aWxsIGNvbnRpbnVlIHNpbXVsdGFuZW91cyB0byB0aGVcbiAgICogIG5ldyBwbGF5YmFjay4gSW4gcmVzdGFydCBtb2RlLCBwbGF5KCkgd2lsbCBzdG9wIHBsYXliYWNrXG4gICAqICBhbmQgc3RhcnQgb3Zlci4gV2l0aCB1bnRpbERvbmUsIGEgc291bmQgd2lsbCBwbGF5IG9ubHkgaWYgaXQnc1xuICAgKiAgbm90IGFscmVhZHkgcGxheWluZy4gU3VzdGFpbiBpcyB0aGUgZGVmYXVsdCBtb2RlLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgcGxheU1vZGVcbiAgICogIEBmb3IgcDUuU291bmRGaWxlXG4gICAqICBAcGFyYW0gIHtTdHJpbmd9IHN0ciAncmVzdGFydCcgb3IgJ3N1c3RhaW4nIG9yICd1bnRpbERvbmUnXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBteVNvdW5kO1xuICAgKiAgZnVuY3Rpb24gcHJlbG9hZCgpe1xuICAgKiAgICBteVNvdW5kID0gbG9hZFNvdW5kKCdhc3NldHMvRGFtc2NyYXlfRGFuY2luZ1RpZ2VyLm1wMycpO1xuICAgKiAgfVxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKGNhbnZhc1ByZXNzZWQpO1xuICAgKiAgICBub0ZpbGwoKTtcbiAgICogICAgcmVjdCgwLCBoZWlnaHQvMiwgd2lkdGggLSAxLCBoZWlnaHQvMiAtIDEpO1xuICAgKiAgICByZWN0KDAsIDAsIHdpZHRoIC0gMSwgaGVpZ2h0LzIpO1xuICAgKiAgICB0ZXh0QWxpZ24oQ0VOVEVSLCBDRU5URVIpO1xuICAgKiAgICBmaWxsKDIwKTtcbiAgICogICAgdGV4dCgncmVzdGFydCcsIHdpZHRoLzIsIDEgKiBoZWlnaHQvNCk7XG4gICAqICAgIHRleHQoJ3N1c3RhaW4nLCB3aWR0aC8yLCAzICogaGVpZ2h0LzQpO1xuICAgKiAgfVxuICAgKiAgZnVuY3Rpb24gY2FudmFzUHJlc3NlZCgpIHtcbiAgICogICAgaWYgKG1vdXNlWCA8IGhlaWdodC8yKSB7XG4gICAqICAgICAgbXlTb3VuZC5wbGF5TW9kZSgncmVzdGFydCcpO1xuICAgKiAgICB9IGVsc2Uge1xuICAgKiAgICAgIG15U291bmQucGxheU1vZGUoJ3N1c3RhaW4nKTtcbiAgICogICAgfVxuICAgKiAgICBteVNvdW5kLnBsYXkoKTtcbiAgICogIH1cbiAgICpcbiAgICogPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUucGxheU1vZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIHMgPSBzdHIudG9Mb3dlckNhc2UoKTsgXG5cbiAgICBpZiAocyA9PT0gJ3Jlc3RhcnQnICYmIHRoaXMuYnVmZmVyICYmIHRoaXMuYnVmZmVyU291cmNlTm9kZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlclNvdXJjZU5vZGVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICAgIHRoaXMuYnVmZmVyU291cmNlTm9kZXNbaV0uc3RvcChub3cpO1xuICAgICAgfVxuICAgIH0gXG5cblxuICAgIGlmIChzID09PSAncmVzdGFydCcgfHwgcyA9PT0gJ3N1c3RhaW4nIHx8IHMgPT09ICd1bnRpbGRvbmUnKSB7XG4gICAgICB0aGlzLm1vZGUgPSBzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyAnSW52YWxpZCBwbGF5IG1vZGUuIE11c3QgYmUgZWl0aGVyIFwicmVzdGFydFwiIG9yIFwic3VzdGFpblwiJztcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgUGF1c2VzIGEgZmlsZSB0aGF0IGlzIGN1cnJlbnRseSBwbGF5aW5nLiBJZiB0aGUgZmlsZSBpcyBub3RcbiAgICogIHBsYXlpbmcsIHRoZW4gbm90aGluZyB3aWxsIGhhcHBlbi5cbiAgICpcbiAgICogIEFmdGVyIHBhdXNpbmcsIC5wbGF5KCkgd2lsbCByZXN1bWUgZnJvbSB0aGUgcGF1c2VkXG4gICAqICBwb3NpdGlvbi5cbiAgICogIElmIHA1LlNvdW5kRmlsZSBoYWQgYmVlbiBzZXQgdG8gbG9vcCBiZWZvcmUgaXQgd2FzIHBhdXNlZCxcbiAgICogIGl0IHdpbGwgY29udGludWUgdG8gbG9vcCBhZnRlciBpdCBpcyB1bnBhdXNlZCB3aXRoIC5wbGF5KCkuXG4gICAqXG4gICAqICBAbWV0aG9kIHBhdXNlXG4gICAqICBAZm9yIHA1LlNvdW5kRmlsZVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtzdGFydFRpbWVdIChvcHRpb25hbCkgc2NoZWR1bGUgZXZlbnQgdG8gb2NjdXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyBmcm9tIG5vd1xuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgc291bmRGaWxlO1xuICAgKiAgZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICogICAgc291bmRGb3JtYXRzKCdvZ2cnLCAnbXAzJyk7XG4gICAqICAgIHNvdW5kRmlsZSA9IGxvYWRTb3VuZCgnYXNzZXRzL0RhbXNjcmF5Xy1fRGFuY2luZ19UaWdlcl8wMi5tcDMnKTtcbiAgICogIH1cbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChjYW52YXNQcmVzc2VkKTtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0KCd0YXAgdG8gcGxheSwgcmVsZWFzZSB0byBwYXVzZScsIDEwLCAyMCwgd2lkdGggLSAyMCk7XG4gICAqICB9XG4gICAqICBmdW5jdGlvbiBjYW52YXNQcmVzc2VkKCkge1xuICAgKiAgICBzb3VuZEZpbGUubG9vcCgpO1xuICAgKiAgICBiYWNrZ3JvdW5kKDAsIDIwMCwgNTApO1xuICAgKiAgfVxuICAgKiAgZnVuY3Rpb24gbW91c2VSZWxlYXNlZCgpIHtcbiAgICogICAgc291bmRGaWxlLnBhdXNlKCk7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogIH1cbiAgICogIDwvY29kZT5cbiAgICogIDwvZGl2PlxuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoc3RhcnRUaW1lKSB7XG4gICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgIHZhciB0aW1lID0gc3RhcnRUaW1lIHx8IDA7XG4gICAgdmFyIHBUaW1lID0gdGltZSArIG5vdztcblxuICAgIGlmICh0aGlzLmlzUGxheWluZygpICYmIHRoaXMuYnVmZmVyICYmIHRoaXMuYnVmZmVyU291cmNlTm9kZSkge1xuICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3BsYXlpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMucGF1c2VUaW1lID0gdGhpcy5jdXJyZW50VGltZSgpO1xuICAgICAgdGhpcy5idWZmZXJTb3VyY2VOb2RlLnN0b3AocFRpbWUpO1xuXG4gICAgICB0aGlzLl9jb3VudGVyTm9kZS5zdG9wKHBUaW1lKTtcblxuICAgICAgdGhpcy5fcGF1c2VUaW1lID0gdGhpcy5jdXJyZW50VGltZSgpOyBcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcGF1c2VUaW1lID0gMDtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBMb29wIHRoZSBwNS5Tb3VuZEZpbGUuIEFjY2VwdHMgb3B0aW9uYWwgcGFyYW1ldGVycyB0byBzZXQgdGhlXG4gICAqIHBsYXliYWNrIHJhdGUsIHBsYXliYWNrIHZvbHVtZSwgbG9vcFN0YXJ0LCBsb29wRW5kLlxuICAgKlxuICAgKiBAbWV0aG9kIGxvb3BcbiAgICogQGZvciBwNS5Tb3VuZEZpbGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydFRpbWVdIChvcHRpb25hbCkgc2NoZWR1bGUgZXZlbnQgdG8gb2NjdXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZHMgZnJvbSBub3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYXRlXSAgICAgICAgKG9wdGlvbmFsKSBwbGF5YmFjayByYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbYW1wXSAgICAgICAgIChvcHRpb25hbCkgcGxheWJhY2sgdm9sdW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY3VlTG9vcFN0YXJ0XSAob3B0aW9uYWwpIHN0YXJ0VGltZSBpbiBzZWNvbmRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZHVyYXRpb25dICAob3B0aW9uYWwpIGxvb3AgZHVyYXRpb24gaW4gc2Vjb25kc1xuICAgKiBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBzb3VuZEZpbGU7XG4gICAqICBsZXQgbG9vcFN0YXJ0ID0gMC41O1xuICAgKiAgbGV0IGxvb3BEdXJhdGlvbiA9IDAuMjtcbiAgICogIGZ1bmN0aW9uIHByZWxvYWQoKSB7XG4gICAqICAgIHNvdW5kRm9ybWF0cygnb2dnJywgJ21wMycpO1xuICAgKiAgICBzb3VuZEZpbGUgPSBsb2FkU291bmQoJ2Fzc2V0cy9EYW1zY3JheV8tX0RhbmNpbmdfVGlnZXJfMDIubXAzJyk7XG4gICAqICB9XG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQoY2FudmFzUHJlc3NlZCk7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXksIHJlbGVhc2UgdG8gcGF1c2UnLCAxMCwgMjAsIHdpZHRoIC0gMjApO1xuICAgKiAgfVxuICAgKiAgZnVuY3Rpb24gY2FudmFzUHJlc3NlZCgpIHtcbiAgICogICAgc291bmRGaWxlLmxvb3AoKTtcbiAgICogICAgYmFja2dyb3VuZCgwLCAyMDAsIDUwKTtcbiAgICogIH1cbiAgICogIGZ1bmN0aW9uIG1vdXNlUmVsZWFzZWQoKSB7XG4gICAqICAgIHNvdW5kRmlsZS5wYXVzZSgpO1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICB9XG4gICAqICA8L2NvZGU+XG4gICAqICA8L2Rpdj5cbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLmxvb3AgPSBmdW5jdGlvbiAoc3RhcnRUaW1lLCByYXRlLCBhbXAsIGxvb3BTdGFydCwgZHVyYXRpb24pIHtcbiAgICB0aGlzLl9sb29waW5nID0gdHJ1ZTtcbiAgICB0aGlzLnBsYXkoc3RhcnRUaW1lLCByYXRlLCBhbXAsIGxvb3BTdGFydCwgZHVyYXRpb24pO1xuICB9O1xuICAvKipcbiAgICogU2V0IGEgcDUuU291bmRGaWxlJ3MgbG9vcGluZyBmbGFnIHRvIHRydWUgb3IgZmFsc2UuIElmIHRoZSBzb3VuZFxuICAgKiBpcyBjdXJyZW50bHkgcGxheWluZywgdGhpcyBjaGFuZ2Ugd2lsbCB0YWtlIGVmZmVjdCB3aGVuIGl0XG4gICAqIHJlYWNoZXMgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBwbGF5YmFjay5cbiAgICpcbiAgICogQG1ldGhvZCBzZXRMb29wXG4gICAqIEBmb3IgcDUuU291bmRGaWxlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gQm9vbGVhbiAgIHNldCBsb29waW5nIHRvIHRydWUgb3IgZmFsc2VcbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAoYm9vbCkge1xuICAgIGlmIChib29sID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9sb29waW5nID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGJvb2wgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl9sb29waW5nID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93ICdFcnJvcjogc2V0TG9vcCBhY2NlcHRzIGVpdGhlciB0cnVlIG9yIGZhbHNlJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5idWZmZXJTb3VyY2VOb2RlKSB7XG4gICAgICB0aGlzLmJ1ZmZlclNvdXJjZU5vZGUubG9vcCA9IHRoaXMuX2xvb3Bpbmc7XG4gICAgICB0aGlzLl9jb3VudGVyTm9kZS5sb29wID0gdGhpcy5fbG9vcGluZztcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zICd0cnVlJyBpZiBhIHA1LlNvdW5kRmlsZSBpcyBjdXJyZW50bHkgbG9vcGluZyBhbmQgcGxheWluZywgJ2ZhbHNlJyBpZiBub3QuXG4gICAqXG4gICAqIEBtZXRob2QgaXNMb29waW5nXG4gICAqIEBmb3IgcDUuU291bmRGaWxlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5pc0xvb3BpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmJ1ZmZlclNvdXJjZU5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbG9vcGluZyA9PT0gdHJ1ZSAmJiB0aGlzLmlzUGxheWluZygpID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIC8qKlxuICAgKiAgUmV0dXJucyB0cnVlIGlmIGEgcDUuU291bmRGaWxlIGlzIHBsYXlpbmcsIGZhbHNlIGlmIG5vdCAoaS5lLlxuICAgKiAgcGF1c2VkIG9yIHN0b3BwZWQpLlxuICAgKlxuICAgKiAgQG1ldGhvZCBpc1BsYXlpbmdcbiAgICogIEBmb3IgcDUuU291bmRGaWxlXG4gICAqICBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuaXNQbGF5aW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wbGF5aW5nO1xuICB9O1xuICAvKipcbiAgICogIFJldHVybnMgdHJ1ZSBpZiBhIHA1LlNvdW5kRmlsZSBpcyBwYXVzZWQsIGZhbHNlIGlmIG5vdCAoaS5lLlxuICAgKiAgcGxheWluZyBvciBzdG9wcGVkKS5cbiAgICpcbiAgICogIEBtZXRob2QgIGlzUGF1c2VkXG4gICAqICBAZm9yIHA1LlNvdW5kRmlsZVxuICAgKiAgQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXVzZWQ7XG4gIH07XG4gIC8qKlxuICAgKiBTdG9wIHNvdW5kZmlsZSBwbGF5YmFjay5cbiAgICpcbiAgICogQG1ldGhvZCBzdG9wXG4gICAqIEBmb3IgcDUuU291bmRGaWxlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRUaW1lXSAob3B0aW9uYWwpIHNjaGVkdWxlIGV2ZW50IHRvIG9jY3VyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBzZWNvbmRzIGZyb20gbm93XG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHRpbWVGcm9tTm93KSB7XG4gICAgdmFyIHRpbWUgPSB0aW1lRnJvbU5vdyB8fCAwO1xuXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ3N1c3RhaW4nIHx8IHRoaXMubW9kZSA9PT0gJ3VudGlsZG9uZScpIHtcbiAgICAgIHRoaXMuc3RvcEFsbCh0aW1lKTtcbiAgICAgIHRoaXMuX3BsYXlpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMucGF1c2VUaW1lID0gMDtcbiAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5idWZmZXIgJiYgdGhpcy5idWZmZXJTb3VyY2VOb2RlKSB7XG4gICAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICB2YXIgdCA9IHRpbWUgfHwgMDtcbiAgICAgIHRoaXMucGF1c2VUaW1lID0gMDtcbiAgICAgIHRoaXMuYnVmZmVyU291cmNlTm9kZS5zdG9wKG5vdyArIHQpO1xuXG4gICAgICB0aGlzLl9jb3VudGVyTm9kZS5zdG9wKG5vdyArIHQpO1xuXG4gICAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgU3RvcCBwbGF5YmFjayBvbiBhbGwgb2YgdGhpcyBzb3VuZGZpbGUncyBzb3VyY2VzLlxuICAgKiAgQHByaXZhdGVcbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLnN0b3BBbGwgPSBmdW5jdGlvbiAoX3RpbWUpIHtcbiAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgdmFyIHRpbWUgPSBfdGltZSB8fCAwO1xuXG4gICAgaWYgKHRoaXMuYnVmZmVyICYmIHRoaXMuYnVmZmVyU291cmNlTm9kZSkge1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmJ1ZmZlclNvdXJjZU5vZGVzKSB7XG4gICAgICAgIHZhciBidWZmZXJTb3VyY2VOb2RlID0gdGhpcy5idWZmZXJTb3VyY2VOb2Rlc1tpXTtcblxuICAgICAgICBpZiAoISFidWZmZXJTb3VyY2VOb2RlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJ1ZmZlclNvdXJjZU5vZGUuc3RvcChub3cgKyB0aW1lKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvdW50ZXJOb2RlLnN0b3Aobm93ICsgdGltZSk7XG5cbiAgICAgIHRoaXMuX29uZW5kZWQodGhpcyk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIE11bHRpcGx5IHRoZSBvdXRwdXQgdm9sdW1lIChhbXBsaXR1ZGUpIG9mIGEgc291bmQgZmlsZVxuICAgKiAgYmV0d2VlbiAwLjAgKHNpbGVuY2UpIGFuZCAxLjAgKGZ1bGwgdm9sdW1lKS5cbiAgICogIDEuMCBpcyB0aGUgbWF4aW11bSBhbXBsaXR1ZGUgb2YgYSBkaWdpdGFsIHNvdW5kLCBzbyBtdWx0aXBseWluZ1xuICAgKiAgYnkgZ3JlYXRlciB0aGFuIDEuMCBtYXkgY2F1c2UgZGlnaXRhbCBkaXN0b3J0aW9uLiBUb1xuICAgKiAgZmFkZSwgcHJvdmlkZSBhIDxjb2RlPnJhbXBUaW1lPC9jb2RlPiBwYXJhbWV0ZXIuIEZvciBtb3JlXG4gICAqICBjb21wbGV4IGZhZGVzLCBzZWUgdGhlIEVudmVsb3BlIGNsYXNzLlxuICAgKlxuICAgKiAgQWx0ZXJuYXRlbHksIHlvdSBjYW4gcGFzcyBpbiBhIHNpZ25hbCBzb3VyY2Ugc3VjaCBhcyBhblxuICAgKiAgb3NjaWxsYXRvciB0byBtb2R1bGF0ZSB0aGUgYW1wbGl0dWRlIHdpdGggYW4gYXVkaW8gc2lnbmFsLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgc2V0Vm9sdW1lXG4gICAqICBAZm9yIHA1LlNvdW5kRmlsZVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSB2b2x1bWUgIFZvbHVtZSAoYW1wbGl0dWRlKSBiZXR3ZWVuIDAuMFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgMS4wIG9yIG1vZHVsYXRpbmcgc2lnbmFsL29zY2lsbGF0b3JcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbcmFtcFRpbWVdICBGYWRlIGZvciB0IHNlY29uZHNcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbdGltZUZyb21Ob3ddICBTY2hlZHVsZSB0aGlzIGV2ZW50IHRvIGhhcHBlbiBhdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgc2Vjb25kcyBpbiB0aGUgZnV0dXJlXG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiAodm9sLCBfcmFtcFRpbWUsIF90RnJvbU5vdykge1xuICAgIGlmICh0eXBlb2Ygdm9sID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHJhbXBUaW1lID0gX3JhbXBUaW1lIHx8IDA7XG4gICAgICB2YXIgdEZyb21Ob3cgPSBfdEZyb21Ob3cgfHwgMDtcbiAgICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICAgIHZhciBjdXJyZW50Vm9sID0gdGhpcy5vdXRwdXQuZ2Fpbi52YWx1ZTtcbiAgICAgIHRoaXMub3V0cHV0LmdhaW4uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKG5vdyArIHRGcm9tTm93KTtcbiAgICAgIHRoaXMub3V0cHV0LmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoY3VycmVudFZvbCwgbm93ICsgdEZyb21Ob3cpO1xuICAgICAgdGhpcy5vdXRwdXQuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh2b2wsIG5vdyArIHRGcm9tTm93ICsgcmFtcFRpbWUpO1xuICAgIH0gZWxzZSBpZiAodm9sKSB7XG4gICAgICB2b2wuY29ubmVjdCh0aGlzLm91dHB1dC5nYWluKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMub3V0cHV0LmdhaW47XG4gICAgfVxuICB9OyBcblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuYW1wID0gcDUuU291bmRGaWxlLnByb3RvdHlwZS5zZXRWb2x1bWU7IFxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuZmFkZSA9IHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuc2V0Vm9sdW1lO1xuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuZ2V0Vm9sdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dC5nYWluLnZhbHVlO1xuICB9O1xuICAvKipcbiAgICogU2V0IHRoZSBzdGVyZW8gcGFubmluZyBvZiBhIHA1LnNvdW5kIG9iamVjdCB0b1xuICAgKiBhIGZsb2F0aW5nIHBvaW50IG51bWJlciBiZXR3ZWVuIC0xLjAgKGxlZnQpIGFuZCAxLjAgKHJpZ2h0KS5cbiAgICogRGVmYXVsdCBpcyAwLjAgKGNlbnRlcikuXG4gICAqXG4gICAqIEBtZXRob2QgcGFuXG4gICAqIEBmb3IgcDUuU291bmRGaWxlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFuVmFsdWVdICAgICBTZXQgdGhlIHN0ZXJlbyBwYW5uZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lRnJvbU5vd10gIHNjaGVkdWxlIHRoaXMgZXZlbnQgdG8gaGFwcGVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyBmcm9tIG5vd1xuICAgKiBAZXhhbXBsZVxuICAgKiA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IGJhbGxYID0gMDtcbiAgICogIGxldCBzb3VuZEZpbGU7XG4gICAqXG4gICAqICBmdW5jdGlvbiBwcmVsb2FkKCkge1xuICAgKiAgICBzb3VuZEZvcm1hdHMoJ29nZycsICdtcDMnKTtcbiAgICogICAgc291bmRGaWxlID0gbG9hZFNvdW5kKCdhc3NldHMvYmVhdGJveC5tcDMnKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKGNhbnZhc1ByZXNzZWQpO1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIGJhbGxYID0gY29uc3RyYWluKG1vdXNlWCwgMCwgd2lkdGgpO1xuICAgKiAgICBlbGxpcHNlKGJhbGxYLCBoZWlnaHQvMiwgMjAsIDIwKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGNhbnZhc1ByZXNzZWQoKXtcbiAgICogICAgLy8gbWFwIHRoZSBiYWxsJ3MgeCBsb2NhdGlvbiB0byBhIHBhbm5pbmcgZGVncmVlXG4gICAqICAgIC8vIGJldHdlZW4gLTEuMCAobGVmdCkgYW5kIDEuMCAocmlnaHQpXG4gICAqICAgIGxldCBwYW5uaW5nID0gbWFwKGJhbGxYLCAwLiwgd2lkdGgsLTEuMCwgMS4wKTtcbiAgICogICAgc291bmRGaWxlLnBhbihwYW5uaW5nKTtcbiAgICogICAgc291bmRGaWxlLnBsYXkoKTtcbiAgICogIH1cbiAgICogIDwvZGl2PjwvY29kZT5cbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLnBhbiA9IGZ1bmN0aW9uIChwdmFsLCB0RnJvbU5vdykge1xuICAgIHRoaXMucGFuUG9zaXRpb24gPSBwdmFsO1xuICAgIHRoaXMucGFubmVyLnBhbihwdmFsLCB0RnJvbU5vdyk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0ZXJlbyBwYW4gcG9zaXRpb24gKC0xLjAgdG8gMS4wKVxuICAgKlxuICAgKiBAbWV0aG9kIGdldFBhblxuICAgKiBAZm9yIHA1LlNvdW5kRmlsZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIHN0ZXJlbyBwYW4gc2V0dGluZyBvZiB0aGUgT3NjaWxsYXRvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYXMgYSBudW1iZXIgYmV0d2VlbiAtMS4wIChsZWZ0KSBhbmQgMS4wIChyaWdodCkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAwLjAgaXMgY2VudGVyIGFuZCBkZWZhdWx0LlxuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuZ2V0UGFuID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhblBvc2l0aW9uO1xuICB9O1xuICAvKipcbiAgICogIFNldCB0aGUgcGxheWJhY2sgcmF0ZSBvZiBhIHNvdW5kIGZpbGUuIFdpbGwgY2hhbmdlIHRoZSBzcGVlZCBhbmQgdGhlIHBpdGNoLlxuICAgKiAgVmFsdWVzIGxlc3MgdGhhbiB6ZXJvIHdpbGwgcmV2ZXJzZSB0aGUgYXVkaW8gYnVmZmVyLlxuICAgKlxuICAgKiAgQG1ldGhvZCByYXRlXG4gICAqICBAZm9yIHA1LlNvdW5kRmlsZVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtwbGF5YmFja1JhdGVdICAgICBTZXQgdGhlIHBsYXliYWNrIHJhdGUuIDEuMCBpcyBub3JtYWwsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC41IGlzIGhhbGYtc3BlZWQsIDIuMCBpcyB0d2ljZSBhcyBmYXN0LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZXMgbGVzcyB0aGFuIHplcm8gcGxheSBiYWNrd2FyZHMuXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBteVNvdW5kO1xuICAgKlxuICAgKiAgZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICogICAgbXlTb3VuZCA9IGxvYWRTb3VuZCgnYXNzZXRzL0RhbXNjcmF5X0RhbmNpbmdUaWdlci5tcDMnKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChjYW52YXNQcmVzc2VkKTtcbiAgICogIH1cbiAgICogIGZ1bmN0aW9uIGNhbnZhc1ByZXNzZWQoKSB7XG4gICAqICAgIG15U291bmQubG9vcCgpO1xuICAgKiAgfVxuICAgKiAgZnVuY3Rpb24gbW91c2VSZWxlYXNlZCgpIHtcbiAgICogICAgbXlTb3VuZC5wYXVzZSgpO1xuICAgKiAgfVxuICAgKiAgZnVuY3Rpb24gZHJhdygpIHtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKlxuICAgKiAgICAvLyBTZXQgdGhlIHJhdGUgdG8gYSByYW5nZSBiZXR3ZWVuIDAuMSBhbmQgNFxuICAgKiAgICAvLyBDaGFuZ2luZyB0aGUgcmF0ZSBhbHNvIGFsdGVycyB0aGUgcGl0Y2hcbiAgICogICAgbGV0IHBsYXliYWNrUmF0ZSA9IG1hcChtb3VzZVksIDAuMSwgaGVpZ2h0LCAyLCAwKTtcbiAgICogICAgcGxheWJhY2tSYXRlID0gY29uc3RyYWluKHBsYXliYWNrUmF0ZSwgMC4wMSwgNCk7XG4gICAqICAgIG15U291bmQucmF0ZShwbGF5YmFja1JhdGUpO1xuICAgKlxuICAgKiAgICBsaW5lKDAsIG1vdXNlWSwgd2lkdGgsIG1vdXNlWSk7XG4gICAqICAgIHRleHQoJ3JhdGU6ICcgKyByb3VuZChwbGF5YmFja1JhdGUgKiAxMDApICsgJyUnLCAxMCwgMjApO1xuICAgKiAgfVxuICAgKlxuICAgKiA8L2NvZGU+XG4gICAqIDwvZGl2PlxuICAgKlxuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUucmF0ZSA9IGZ1bmN0aW9uIChwbGF5YmFja1JhdGUpIHtcbiAgICB2YXIgcmV2ZXJzZSA9IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiBwbGF5YmFja1JhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5wbGF5YmFja1JhdGU7XG4gICAgfVxuXG4gICAgdGhpcy5wbGF5YmFja1JhdGUgPSBwbGF5YmFja1JhdGU7XG5cbiAgICBpZiAocGxheWJhY2tSYXRlID09PSAwKSB7XG4gICAgICBwbGF5YmFja1JhdGUgPSAwLjAwMDAwMDAwMDAwMDE7XG4gICAgfSBlbHNlIGlmIChwbGF5YmFja1JhdGUgPCAwICYmICF0aGlzLnJldmVyc2VkKSB7XG4gICAgICBwbGF5YmFja1JhdGUgPSBNYXRoLmFicyhwbGF5YmFja1JhdGUpO1xuICAgICAgcmV2ZXJzZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChwbGF5YmFja1JhdGUgPiAwICYmIHRoaXMucmV2ZXJzZWQpIHtcbiAgICAgIHJldmVyc2UgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJ1ZmZlclNvdXJjZU5vZGUpIHtcbiAgICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICAgIHRoaXMuYnVmZmVyU291cmNlTm9kZS5wbGF5YmFja1JhdGUuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKG5vdyk7XG4gICAgICB0aGlzLmJ1ZmZlclNvdXJjZU5vZGUucGxheWJhY2tSYXRlLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKE1hdGguYWJzKHBsYXliYWNrUmF0ZSksIG5vdyk7XG5cbiAgICAgIHRoaXMuX2NvdW50ZXJOb2RlLnBsYXliYWNrUmF0ZS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMobm93KTtcblxuICAgICAgdGhpcy5fY291bnRlck5vZGUucGxheWJhY2tSYXRlLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKE1hdGguYWJzKHBsYXliYWNrUmF0ZSksIG5vdyk7XG4gICAgfVxuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHRoaXMucmV2ZXJzZUJ1ZmZlcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBsYXliYWNrUmF0ZTtcbiAgfTsgXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLnNldFBpdGNoID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHZhciBuZXdQbGF5YmFja1JhdGUgPSBtaWRpVG9GcmVxKG51bSkgLyBtaWRpVG9GcmVxKDYwKTtcbiAgICB0aGlzLnJhdGUobmV3UGxheWJhY2tSYXRlKTtcbiAgfTtcblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLmdldFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5YmFja1JhdGU7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkdXJhdGlvbiBvZiBhIHNvdW5kIGZpbGUgaW4gc2Vjb25kcy5cbiAgICpcbiAgICogQG1ldGhvZCBkdXJhdGlvblxuICAgKiBAZm9yIHA1LlNvdW5kRmlsZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBkdXJhdGlvbiBvZiB0aGUgc291bmRGaWxlIGluIHNlY29uZHMuXG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5kdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwNS5Tb3VuZEZpbGUgcGxheWhlYWQsIGluIHNlY29uZHMuXG4gICAqIFRpbWUgaXMgcmVsYXRpdmUgdG8gdGhlIG5vcm1hbCBidWZmZXIgZGlyZWN0aW9uLCBzbyBpZiBgcmV2ZXJzZUJ1ZmZlcmBcbiAgICogaGFzIGJlZW4gY2FsbGVkLCBjdXJyZW50VGltZSB3aWxsIGNvdW50IGJhY2t3YXJkcy5cbiAgICpcbiAgICogQG1ldGhvZCBjdXJyZW50VGltZVxuICAgKiBAZm9yIHA1LlNvdW5kRmlsZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgY3VycmVudFRpbWUgb2YgdGhlIHNvdW5kRmlsZSBpbiBzZWNvbmRzLlxuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuY3VycmVudFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZWQgPyBNYXRoLmFicyh0aGlzLl9sYXN0UG9zIC0gdGhpcy5idWZmZXIubGVuZ3RoKSAvIGFjLnNhbXBsZVJhdGUgOiB0aGlzLl9sYXN0UG9zIC8gYWMuc2FtcGxlUmF0ZTtcbiAgfTtcbiAgLyoqXG4gICAqIE1vdmUgdGhlIHBsYXloZWFkIG9mIGEgc291bmRmaWxlIHRoYXQgaXMgY3VycmVudGx5IHBsYXlpbmcgdG8gYVxuICAgKiBuZXcgcG9zaXRpb24gYW5kIGEgbmV3IGR1cmF0aW9uLCBpbiBzZWNvbmRzLlxuICAgKiBJZiBub25lIGFyZSBnaXZlbiwgd2lsbCByZXNldCB0aGUgZmlsZSB0byBwbGF5IGVudGlyZSBkdXJhdGlvblxuICAgKiBmcm9tIHN0YXJ0IHRvIGZpbmlzaC4gVG8gc2V0IHRoZSBwb3NpdGlvbiBvZiBhIHNvdW5kZmlsZSB0aGF0IGlzXG4gICAqIG5vdCBjdXJyZW50bHkgcGxheWluZywgdXNlIHRoZSBgcGxheWAgb3IgYGxvb3BgIG1ldGhvZHMuXG4gICAqXG4gICAqIEBtZXRob2QganVtcFxuICAgKiBAZm9yIHA1LlNvdW5kRmlsZVxuICAgKiBAcGFyYW0ge051bWJlcn0gY3VlVGltZSAgICBjdWVUaW1lIG9mIHRoZSBzb3VuZEZpbGUgaW4gc2Vjb25kcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uICAgIGR1cmF0aW9uIGluIHNlY29uZHMuXG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5qdW1wID0gZnVuY3Rpb24gKGN1ZVRpbWUsIGR1cmF0aW9uKSB7XG4gICAgaWYgKGN1ZVRpbWUgPCAwIHx8IGN1ZVRpbWUgPiB0aGlzLmJ1ZmZlci5kdXJhdGlvbikge1xuICAgICAgdGhyb3cgJ2p1bXAgdGltZSBvdXQgb2YgcmFuZ2UnO1xuICAgIH1cblxuICAgIGlmIChkdXJhdGlvbiA+IHRoaXMuYnVmZmVyLmR1cmF0aW9uIC0gY3VlVGltZSkge1xuICAgICAgdGhyb3cgJ2VuZCB0aW1lIG91dCBvZiByYW5nZSc7XG4gICAgfVxuXG4gICAgdmFyIGNUaW1lID0gY3VlVGltZSB8fCAwO1xuICAgIHZhciBkdXIgPSBkdXJhdGlvbiB8fCB1bmRlZmluZWQ7XG5cbiAgICBpZiAodGhpcy5pc1BsYXlpbmcoKSkge1xuICAgICAgdGhpcy5zdG9wKDApO1xuICAgICAgdGhpcy5wbGF5KDAsIHRoaXMucGxheWJhY2tSYXRlLCB0aGlzLm91dHB1dC5nYWluLnZhbHVlLCBjVGltZSwgZHVyKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgY2hhbm5lbHMgaW4gYSBzb3VuZCBmaWxlLlxuICAgICogRm9yIGV4YW1wbGUsIE1vbm8gPSAxLCBTdGVyZW8gPSAyLlxuICAgICpcbiAgICAqIEBtZXRob2QgY2hhbm5lbHNcbiAgICAqIEBmb3IgcDUuU291bmRGaWxlXG4gICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFtjaGFubmVsc11cbiAgICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5jaGFubmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIubnVtYmVyT2ZDaGFubmVscztcbiAgfTtcbiAgLyoqXG4gICAgKiBSZXR1cm4gdGhlIHNhbXBsZSByYXRlIG9mIHRoZSBzb3VuZCBmaWxlLlxuICAgICpcbiAgICAqIEBtZXRob2Qgc2FtcGxlUmF0ZVxuICAgICogQGZvciBwNS5Tb3VuZEZpbGVcbiAgICAqIEByZXR1cm4ge051bWJlcn0gW3NhbXBsZVJhdGVdXG4gICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuc2FtcGxlUmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIuc2FtcGxlUmF0ZTtcbiAgfTtcbiAgLyoqXG4gICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBzYW1wbGVzIGluIGEgc291bmQgZmlsZS5cbiAgICAqIEVxdWFsIHRvIHNhbXBsZVJhdGUgKiBkdXJhdGlvbi5cbiAgICAqXG4gICAgKiBAbWV0aG9kIGZyYW1lc1xuICAgICogQGZvciBwNS5Tb3VuZEZpbGVcbiAgICAqIEByZXR1cm4ge051bWJlcn0gW3NhbXBsZUNvdW50XVxuICAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLmZyYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIubGVuZ3RoO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBhbXBsaXR1ZGUgcGVha3MgaW4gYSBwNS5Tb3VuZEZpbGUgdGhhdCBjYW4gYmVcbiAgICogdXNlZCB0byBkcmF3IGEgc3RhdGljIHdhdmVmb3JtLiBTY2FucyB0aHJvdWdoIHRoZSBwNS5Tb3VuZEZpbGUnc1xuICAgKiBhdWRpbyBidWZmZXIgdG8gZmluZCB0aGUgZ3JlYXRlc3QgYW1wbGl0dWRlcy4gQWNjZXB0cyBvbmVcbiAgICogcGFyYW1ldGVyLCAnbGVuZ3RoJywgd2hpY2ggZGV0ZXJtaW5lcyBzaXplIG9mIHRoZSBhcnJheS5cbiAgICogTGFyZ2VyIGFycmF5cyByZXN1bHQgaW4gbW9yZSBwcmVjaXNlIHdhdmVmb3JtIHZpc3VhbGl6YXRpb25zLlxuICAgKlxuICAgKiBJbnNwaXJlZCBieSBXYXZlc3VyZmVyLmpzLlxuICAgKlxuICAgKiBAbWV0aG9kICBnZXRQZWFrc1xuICAgKiBAZm9yIHA1LlNvdW5kRmlsZVxuICAgKiBAcGFyYW1zIHtOdW1iZXJ9IFtsZW5ndGhdIGxlbmd0aCBpcyB0aGUgc2l6ZSBvZiB0aGUgcmV0dXJuZWQgYXJyYXkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBMYXJnZXIgbGVuZ3RoIHJlc3VsdHMgaW4gbW9yZSBwcmVjaXNpb24uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byA1KndpZHRoIG9mIHRoZSBicm93c2VyIHdpbmRvdy5cbiAgICogQHJldHVybnMge0Zsb2F0MzJBcnJheX0gQXJyYXkgb2YgcGVha3MuXG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5nZXRQZWFrcyA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGxlbmd0aCA9IHdpbmRvdy53aWR0aCAqIDU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJ1ZmZlcikge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHZhciBzYW1wbGVTaXplID0gYnVmZmVyLmxlbmd0aCAvIGxlbmd0aDtcbiAgICAgICAgdmFyIHNhbXBsZVN0ZXAgPSB+fihzYW1wbGVTaXplIC8gMTApIHx8IDE7XG4gICAgICAgIHZhciBjaGFubmVscyA9IGJ1ZmZlci5udW1iZXJPZkNoYW5uZWxzO1xuICAgICAgICB2YXIgcGVha3MgPSBuZXcgRmxvYXQzMkFycmF5KE1hdGgucm91bmQobGVuZ3RoKSk7XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjaGFubmVsczsgYysrKSB7XG4gICAgICAgICAgdmFyIGNoYW4gPSBidWZmZXIuZ2V0Q2hhbm5lbERhdGEoYyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB+fihpICogc2FtcGxlU2l6ZSk7XG4gICAgICAgICAgICB2YXIgZW5kID0gfn4oc3RhcnQgKyBzYW1wbGVTaXplKTtcbiAgICAgICAgICAgIHZhciBtYXggPSAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnQ7IGogPCBlbmQ7IGogKz0gc2FtcGxlU3RlcCkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjaGFuW2pdO1xuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IHZhbHVlOyBcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgtdmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYyA9PT0gMCB8fCBNYXRoLmFicyhtYXgpID4gcGVha3NbaV0pIHtcbiAgICAgICAgICAgICAgcGVha3NbaV0gPSBtYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBlYWtzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyAnQ2Fubm90IGxvYWQgcGVha3MgeWV0LCBidWZmZXIgaXMgbm90IGxvYWRlZCc7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIFJldmVyc2VzIHRoZSBwNS5Tb3VuZEZpbGUncyBidWZmZXIgc291cmNlLlxuICAgKiAgUGxheWJhY2sgbXVzdCBiZSBoYW5kbGVkIHNlcGFyYXRlbHkgKHNlZSBleGFtcGxlKS5cbiAgICpcbiAgICogIEBtZXRob2QgIHJldmVyc2VCdWZmZXJcbiAgICogIEBmb3IgcDUuU291bmRGaWxlXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBkcnVtO1xuICAgKiAgZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICogICAgZHJ1bSA9IGxvYWRTb3VuZCgnYXNzZXRzL2RydW0ubXAzJyk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQoY2FudmFzUHJlc3NlZCk7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCAyMCwgMjApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gY2FudmFzUHJlc3NlZCgpIHtcbiAgICogICAgZHJ1bS5zdG9wKCk7XG4gICAqICAgIGRydW0ucmV2ZXJzZUJ1ZmZlcigpO1xuICAgKiAgICBkcnVtLnBsYXkoKTtcbiAgICogIH1cbiAgICogPC9jb2RlPlxuICAgKiA8L2Rpdj5cbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLnJldmVyc2VCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYnVmZmVyKSB7XG4gICAgICB2YXIgY3VycmVudFBvcyA9IHRoaXMuX2xhc3RQb3MgLyBhYy5zYW1wbGVSYXRlO1xuICAgICAgdmFyIGN1clZvbCA9IHRoaXMuZ2V0Vm9sdW1lKCk7XG4gICAgICB0aGlzLnNldFZvbHVtZSgwLCAwLjAwMSk7XG4gICAgICB2YXIgbnVtQ2hhbm5lbHMgPSB0aGlzLmJ1ZmZlci5udW1iZXJPZkNoYW5uZWxzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNoYW5uZWxzOyBpKyspIHtcbiAgICAgICAgdGhpcy5idWZmZXIuZ2V0Q2hhbm5lbERhdGEoaSkucmV2ZXJzZSgpO1xuICAgICAgfSBcblxuXG4gICAgICB0aGlzLnJldmVyc2VkID0gIXRoaXMucmV2ZXJzZWQ7XG5cbiAgICAgIGlmICh0aGlzLmlzUGxheWluZygpICYmIGN1cnJlbnRQb3MpIHtcbiAgICAgICAgdGhpcy5qdW1wKHRoaXMuZHVyYXRpb24oKSAtIGN1cnJlbnRQb3MpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFZvbHVtZShjdXJWb2wsIDAuMDAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgJ1NvdW5kRmlsZSBpcyBub3QgZG9uZSBsb2FkaW5nJztcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgU2NoZWR1bGUgYW4gZXZlbnQgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIHNvdW5kZmlsZVxuICAgKiAgcmVhY2hlcyB0aGUgZW5kIG9mIGEgYnVmZmVyLiBJZiB0aGUgc291bmRmaWxlIGlzXG4gICAqICBwbGF5aW5nIHRocm91Z2ggb25jZSwgdGhpcyB3aWxsIGJlIGNhbGxlZCB3aGVuIGl0XG4gICAqICBlbmRzLiBJZiBpdCBpcyBsb29waW5nLCBpdCB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gICAqICBzdG9wIGlzIGNhbGxlZC5cbiAgICpcbiAgICogIEBtZXRob2QgIG9uZW5kZWRcbiAgICogIEBmb3IgcDUuU291bmRGaWxlXG4gICAqICBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdW5kZmlsZSBoYXMgZW5kZWQuXG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5vbmVuZGVkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fb25lbmRlZCA9IGNhbGxiYWNrO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCkge1xuICB9O1xuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7IFxuXG4gICAgdmFyIGluZGV4ID0gcDVzb3VuZC5zb3VuZEFycmF5LmluZGV4T2YodGhpcyk7XG4gICAgcDVzb3VuZC5zb3VuZEFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5zdG9wKG5vdyk7XG5cbiAgICBpZiAodGhpcy5idWZmZXIgJiYgdGhpcy5idWZmZXJTb3VyY2VOb2RlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYnVmZmVyU291cmNlTm9kZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlclNvdXJjZU5vZGVzW2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5idWZmZXJTb3VyY2VOb2Rlc1tpXS5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJTb3VyY2VOb2Rlc1tpXS5zdG9wKG5vdyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdubyBidWZmZXIgc291cmNlIG5vZGUgdG8gZGlzcG9zZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYnVmZmVyU291cmNlTm9kZXNbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzUGxheWluZygpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5fY291bnRlck5vZGUuc3RvcChub3cpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb3VudGVyTm9kZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3V0cHV0KSB7XG4gICAgICB0aGlzLm91dHB1dC5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLm91dHB1dCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFubmVyKSB7XG4gICAgICB0aGlzLnBhbm5lci5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLnBhbm5lciA9IG51bGw7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQ29ubmVjdHMgdGhlIG91dHB1dCBvZiBhIHA1c291bmQgb2JqZWN0IHRvIGlucHV0IG9mIGFub3RoZXJcbiAgICogcDUuc291bmQgb2JqZWN0LiBGb3IgZXhhbXBsZSwgeW91IG1heSBjb25uZWN0IGEgcDUuU291bmRGaWxlIHRvIGFuXG4gICAqIEZGVCBvciBhbiBFZmZlY3QuIElmIG5vIHBhcmFtZXRlciBpcyBnaXZlbiwgaXQgd2lsbCBjb25uZWN0IHRvXG4gICAqIHRoZSBtYXN0ZXIgb3V0cHV0LiBNb3N0IHA1c291bmQgb2JqZWN0cyBjb25uZWN0IHRvIHRoZSBtYXN0ZXJcbiAgICogb3V0cHV0IHdoZW4gdGhleSBhcmUgY3JlYXRlZC5cbiAgICpcbiAgICogQG1ldGhvZCBjb25uZWN0XG4gICAqIEBmb3IgcDUuU291bmRGaWxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBBdWRpbyBvYmplY3QgdGhhdCBhY2NlcHRzIGFuIGlucHV0XG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICBpZiAoIXVuaXQpIHtcbiAgICAgIHRoaXMucGFubmVyLmNvbm5lY3QocDVzb3VuZC5pbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh1bml0Lmhhc093blByb3BlcnR5KCdpbnB1dCcpKSB7XG4gICAgICAgIHRoaXMucGFubmVyLmNvbm5lY3QodW5pdC5pbnB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhbm5lci5jb25uZWN0KHVuaXQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIHRoZSBvdXRwdXQgb2YgdGhpcyBwNXNvdW5kIG9iamVjdC5cbiAgICpcbiAgICogQG1ldGhvZCBkaXNjb25uZWN0XG4gICAqIEBmb3IgcDUuU291bmRGaWxlXG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBhbm5lcikge1xuICAgICAgdGhpcy5wYW5uZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zb2xlLndhcm4oJ3A1LlNvdW5kRmlsZS5nZXRMZXZlbCBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIGxpYnJhcnkuIFVzZSBwNS5BbXBsaXR1ZGUgaW5zdGVhZCcpO1xuICB9O1xuICAvKipcbiAgICogIFJlc2V0IHRoZSBzb3VyY2UgZm9yIHRoaXMgU291bmRGaWxlIHRvIGFcbiAgICogIG5ldyBwYXRoIChVUkwpLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgc2V0UGF0aFxuICAgKiAgQGZvciBwNS5Tb3VuZEZpbGVcbiAgICogIEBwYXJhbSB7U3RyaW5nfSAgIHBhdGggICAgIHBhdGggdG8gYXVkaW8gZmlsZVxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLnNldFBhdGggPSBmdW5jdGlvbiAocCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcGF0aCA9IHA1LnByb3RvdHlwZS5fY2hlY2tGaWxlRm9ybWF0cyhwKTtcblxuICAgIHRoaXMudXJsID0gcGF0aDtcbiAgICB0aGlzLmxvYWQoY2FsbGJhY2spO1xuICB9O1xuICAvKipcbiAgICogIFJlcGxhY2UgdGhlIGN1cnJlbnQgQXVkaW8gQnVmZmVyIHdpdGggYSBuZXcgQnVmZmVyLlxuICAgKlxuICAgKiAgQG1ldGhvZCBzZXRCdWZmZXJcbiAgICogIEBmb3IgcDUuU291bmRGaWxlXG4gICAqICBAcGFyYW0ge0FycmF5fSBidWYgQXJyYXkgb2YgRmxvYXQzMiBBcnJheShzKS4gMiBGbG9hdDMyIEFycmF5c1xuICAgKiAgICAgICAgICAgICAgICAgICAgIHdpbGwgY3JlYXRlIGEgc3RlcmVvIHNvdXJjZS4gMSB3aWxsIGNyZWF0ZVxuICAgKiAgICAgICAgICAgICAgICAgICAgIGEgbW9ubyBzb3VyY2UuXG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5zZXRCdWZmZXIgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgdmFyIG51bUNoYW5uZWxzID0gYnVmLmxlbmd0aDtcbiAgICB2YXIgc2l6ZSA9IGJ1ZlswXS5sZW5ndGg7XG4gICAgdmFyIG5ld0J1ZmZlciA9IGFjLmNyZWF0ZUJ1ZmZlcihudW1DaGFubmVscywgc2l6ZSwgYWMuc2FtcGxlUmF0ZSk7XG5cbiAgICBpZiAoIShidWZbMF0gaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSB7XG4gICAgICBidWZbMF0gPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZlswXSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgY2hhbm5lbE51bSA9IDA7IGNoYW5uZWxOdW0gPCBudW1DaGFubmVsczsgY2hhbm5lbE51bSsrKSB7XG4gICAgICB2YXIgY2hhbm5lbCA9IG5ld0J1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsTnVtKTtcbiAgICAgIGNoYW5uZWwuc2V0KGJ1ZltjaGFubmVsTnVtXSk7XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7IFxuXG4gICAgdGhpcy5wYW5uZXIuaW5wdXRDaGFubmVscyhudW1DaGFubmVscyk7XG4gIH07IFxuXG5cbiAgdmFyIF9jcmVhdGVDb3VudGVyQnVmZmVyID0gZnVuY3Rpb24gX2NyZWF0ZUNvdW50ZXJCdWZmZXIoYnVmZmVyKSB7XG4gICAgdmFyIGxlbiA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgdmFyIGF1ZGlvQnVmID0gYWMuY3JlYXRlQnVmZmVyKDEsIGJ1ZmZlci5sZW5ndGgsIGFjLnNhbXBsZVJhdGUpO1xuICAgIHZhciBhcnJheUJ1ZmZlciA9IGF1ZGlvQnVmLmdldENoYW5uZWxEYXRhKDApO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbjsgaW5kZXgrKykge1xuICAgICAgYXJyYXlCdWZmZXJbaW5kZXhdID0gaW5kZXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF1ZGlvQnVmO1xuICB9OyBcblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuX2luaXRDb3VudGVyTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBub3cgPSBhYy5jdXJyZW50VGltZTtcbiAgICB2YXIgY05vZGUgPSBhYy5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICB2YXIgd29ya2xldEJ1ZmZlclNpemUgPSBzYWZlQnVmZmVyU2l6ZSgyNTYpOyBcblxuICAgIGlmIChzZWxmLl93b3JrbGV0Tm9kZSkge1xuICAgICAgc2VsZi5fd29ya2xldE5vZGUuZGlzY29ubmVjdCgpO1xuXG4gICAgICBkZWxldGUgc2VsZi5fd29ya2xldE5vZGU7XG4gICAgfVxuXG4gICAgc2VsZi5fd29ya2xldE5vZGUgPSBuZXcgQXVkaW9Xb3JrbGV0Tm9kZShhYywgcHJvY2Vzc29yTmFtZXMuc291bmRGaWxlUHJvY2Vzc29yLCB7XG4gICAgICBwcm9jZXNzb3JPcHRpb25zOiB7XG4gICAgICAgIGJ1ZmZlclNpemU6IHdvcmtsZXRCdWZmZXJTaXplXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzZWxmLl93b3JrbGV0Tm9kZS5wb3J0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmRhdGEubmFtZSA9PT0gJ3Bvc2l0aW9uJykge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YS5wb3NpdGlvbiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLl9sYXN0UG9zID0gZXZlbnQuZGF0YS5wb3NpdGlvbjsgXG5cbiAgICAgICAgX3RoaXMuX29uVGltZVVwZGF0ZShzZWxmLl9sYXN0UG9zKTtcbiAgICAgIH1cbiAgICB9OyBcblxuXG4gICAgY05vZGUuYnVmZmVyID0gX2NyZWF0ZUNvdW50ZXJCdWZmZXIoc2VsZi5idWZmZXIpO1xuICAgIGNOb2RlLnBsYXliYWNrUmF0ZS5zZXRWYWx1ZUF0VGltZShzZWxmLnBsYXliYWNrUmF0ZSwgbm93KTtcbiAgICBjTm9kZS5jb25uZWN0KHNlbGYuX3dvcmtsZXROb2RlKTtcblxuICAgIHNlbGYuX3dvcmtsZXROb2RlLmNvbm5lY3QocDUuc291bmRPdXQuX3NpbGVudE5vZGUpO1xuXG4gICAgcmV0dXJuIGNOb2RlO1xuICB9OyBcblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuX2luaXRTb3VyY2VOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBidWZmZXJTb3VyY2VOb2RlID0gYWMuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgYnVmZmVyU291cmNlTm9kZS5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICBidWZmZXJTb3VyY2VOb2RlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHRoaXMucGxheWJhY2tSYXRlO1xuICAgIGJ1ZmZlclNvdXJjZU5vZGUuY29ubmVjdCh0aGlzLm91dHB1dCk7XG4gICAgcmV0dXJuIGJ1ZmZlclNvdXJjZU5vZGU7XG4gIH07XG4gIC8qKlxuICAgKiAgcHJvY2Vzc1BlYWtzIHJldHVybnMgYW4gYXJyYXkgb2YgdGltZXN0YW1wcyB3aGVyZSBpdCB0aGlua3MgdGhlcmUgaXMgYSBiZWF0LlxuICAgKlxuICAgKiAgVGhpcyBpcyBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBwcm9jZXNzZXMgdGhlIHNvdW5kZmlsZSBpbiBhbiBvZmZsaW5lIGF1ZGlvIGNvbnRleHQsXG4gICAqICBhbmQgc2VuZHMgdGhlIHJlc3VsdHMgdG8geW91ciBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICpcbiAgICogIFRoZSBwcm9jZXNzIGludm9sdmVzIHJ1bm5pbmcgdGhlIHNvdW5kZmlsZSB0aHJvdWdoIGEgbG93cGFzcyBmaWx0ZXIsIGFuZCBmaW5kaW5nIGFsbCBvZiB0aGVcbiAgICogIHBlYWtzIGFib3ZlIHRoZSBpbml0aWFsIHRocmVzaG9sZC4gSWYgdGhlIHRvdGFsIG51bWJlciBvZiBwZWFrcyBhcmUgYmVsb3cgdGhlIG1pbmltdW0gbnVtYmVyIG9mIHBlYWtzLFxuICAgKiAgaXQgZGVjcmVhc2VzIHRoZSB0aHJlc2hvbGQgYW5kIHJlLXJ1bnMgdGhlIGFuYWx5c2lzIHVudGlsIGVpdGhlciBtaW5QZWFrcyBvciBtaW5UaHJlc2hvbGQgYXJlIHJlYWNoZWQuXG4gICAqXG4gICAqICBAbWV0aG9kICBwcm9jZXNzUGVha3NcbiAgICogIEBmb3IgcDUuU291bmRGaWxlXG4gICAqICBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgICAgICAgYSBmdW5jdGlvbiB0byBjYWxsIG9uY2UgdGhpcyBkYXRhIGlzIHJldHVybmVkXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9ICAgW2luaXRUaHJlc2hvbGRdIGluaXRpYWwgdGhyZXNob2xkIGRlZmF1bHRzIHRvIDAuOVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSAgIFttaW5UaHJlc2hvbGRdICAgbWluaW11bSB0aHJlc2hvbGQgZGVmYXVsdHMgdG8gMC4yMlxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSAgIFttaW5QZWFrc10gICAgICAgbWluaW11bSBudW1iZXIgb2YgcGVha3MgZGVmYXVsdHMgdG8gMjAwXG4gICAqICBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgICAgICBBcnJheSBvZiB0aW1lc3RhbXBlZCBwZWFrc1xuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUucHJvY2Vzc1BlYWtzID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBfaW5pdFRocmVzaG9sZCwgX21pblRocmVzaG9sZCwgX21pblBlYWtzKSB7XG4gICAgdmFyIGJ1ZkxlbiA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICB2YXIgc2FtcGxlUmF0ZSA9IHRoaXMuYnVmZmVyLnNhbXBsZVJhdGU7XG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgIHZhciBhbGxQZWFrcyA9IFtdO1xuICAgIHZhciBpbml0aWFsVGhyZXNob2xkID0gX2luaXRUaHJlc2hvbGQgfHwgMC45LFxuICAgICAgICB0aHJlc2hvbGQgPSBpbml0aWFsVGhyZXNob2xkLFxuICAgICAgICBtaW5UaHJlc2hvbGQgPSBfbWluVGhyZXNob2xkIHx8IDAuMjIsXG4gICAgICAgIG1pblBlYWtzID0gX21pblBlYWtzIHx8IDIwMDsgXG5cbiAgICB2YXIgb2ZmbGluZUNvbnRleHQgPSBuZXcgd2luZG93Lk9mZmxpbmVBdWRpb0NvbnRleHQoMSwgYnVmTGVuLCBzYW1wbGVSYXRlKTsgXG5cbiAgICB2YXIgc291cmNlID0gb2ZmbGluZUNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjsgXG5cbiAgICB2YXIgZmlsdGVyID0gb2ZmbGluZUNvbnRleHQuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG4gICAgZmlsdGVyLnR5cGUgPSAnbG93cGFzcyc7XG4gICAgc291cmNlLmNvbm5lY3QoZmlsdGVyKTtcbiAgICBmaWx0ZXIuY29ubmVjdChvZmZsaW5lQ29udGV4dC5kZXN0aW5hdGlvbik7IFxuXG4gICAgc291cmNlLnN0YXJ0KDApO1xuICAgIG9mZmxpbmVDb250ZXh0LnN0YXJ0UmVuZGVyaW5nKCk7IFxuXG4gICAgb2ZmbGluZUNvbnRleHQub25jb21wbGV0ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIXNlbGYucGFubmVyKSByZXR1cm47XG4gICAgICB2YXIgZmlsdGVyZWRCdWZmZXIgPSBlLnJlbmRlcmVkQnVmZmVyO1xuICAgICAgdmFyIGJ1ZmZlckRhdGEgPSBmaWx0ZXJlZEJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTsgXG5cbiAgICAgIGRvIHtcbiAgICAgICAgYWxsUGVha3MgPSBnZXRQZWFrc0F0VGhyZXNob2xkKGJ1ZmZlckRhdGEsIHRocmVzaG9sZCk7XG4gICAgICAgIHRocmVzaG9sZCAtPSAwLjAwNTtcbiAgICAgIH0gd2hpbGUgKE9iamVjdC5rZXlzKGFsbFBlYWtzKS5sZW5ndGggPCBtaW5QZWFrcyAmJiB0aHJlc2hvbGQgPj0gbWluVGhyZXNob2xkKTsgXG5cblxuICAgICAgdmFyIGludGVydmFsQ291bnRzID0gY291bnRJbnRlcnZhbHNCZXR3ZWVuTmVhcmJ5UGVha3MoYWxsUGVha3MpOyBcblxuICAgICAgdmFyIGdyb3VwcyA9IGdyb3VwTmVpZ2hib3JzQnlUZW1wbyhpbnRlcnZhbENvdW50cywgZmlsdGVyZWRCdWZmZXIuc2FtcGxlUmF0ZSk7IFxuXG4gICAgICB2YXIgdG9wVGVtcG9zID0gZ3JvdXBzLnNvcnQoZnVuY3Rpb24gKGludEEsIGludEIpIHtcbiAgICAgICAgcmV0dXJuIGludEIuY291bnQgLSBpbnRBLmNvdW50O1xuICAgICAgfSkuc3BsaWNlKDAsIDUpOyBcblxuICAgICAgdGhpcy50ZW1wbyA9IHRvcFRlbXBvc1swXS50ZW1wbzsgXG5cbiAgICAgIHZhciBicG1WYXJpYW5jZSA9IDU7XG4gICAgICB2YXIgdGVtcG9QZWFrcyA9IGdldFBlYWtzQXRUb3BUZW1wbyhhbGxQZWFrcywgdG9wVGVtcG9zWzBdLnRlbXBvLCBmaWx0ZXJlZEJ1ZmZlci5zYW1wbGVSYXRlLCBicG1WYXJpYW5jZSk7XG4gICAgICBjYWxsYmFjayh0ZW1wb1BlYWtzKTtcbiAgICB9O1xuICB9OyBcblxuXG4gIHZhciBQZWFrID0gZnVuY3Rpb24gUGVhayhhbXAsIGkpIHtcbiAgICB0aGlzLnNhbXBsZUluZGV4ID0gaTtcbiAgICB0aGlzLmFtcGxpdHVkZSA9IGFtcDtcbiAgICB0aGlzLnRlbXBvcyA9IFtdO1xuICAgIHRoaXMuaW50ZXJ2YWxzID0gW107XG4gIH07IFxuXG5cbiAgZnVuY3Rpb24gZ2V0UGVha3NBdFRocmVzaG9sZChkYXRhLCB0aHJlc2hvbGQpIHtcbiAgICB2YXIgcGVha3NPYmogPSB7fTtcbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZGF0YVtpXSA+IHRocmVzaG9sZCkge1xuICAgICAgICB2YXIgYW1wID0gZGF0YVtpXTtcbiAgICAgICAgdmFyIHBlYWsgPSBuZXcgUGVhayhhbXAsIGkpO1xuICAgICAgICBwZWFrc09ialtpXSA9IHBlYWs7IFxuXG4gICAgICAgIGkgKz0gNjAwMDtcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiBwZWFrc09iajtcbiAgfSBcblxuXG4gIGZ1bmN0aW9uIGNvdW50SW50ZXJ2YWxzQmV0d2Vlbk5lYXJieVBlYWtzKHBlYWtzT2JqKSB7XG4gICAgdmFyIGludGVydmFsQ291bnRzID0gW107XG4gICAgdmFyIHBlYWtzQXJyYXkgPSBPYmplY3Qua2V5cyhwZWFrc09iaikuc29ydCgpO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHBlYWtzQXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgdmFyIHN0YXJ0UGVhayA9IHBlYWtzT2JqW3BlYWtzQXJyYXlbaW5kZXhdXTtcbiAgICAgICAgdmFyIGVuZFBlYWsgPSBwZWFrc09ialtwZWFrc0FycmF5W2luZGV4ICsgaV1dO1xuXG4gICAgICAgIGlmIChzdGFydFBlYWsgJiYgZW5kUGVhaykge1xuICAgICAgICAgIHZhciBzdGFydFBvcyA9IHN0YXJ0UGVhay5zYW1wbGVJbmRleDtcbiAgICAgICAgICB2YXIgZW5kUG9zID0gZW5kUGVhay5zYW1wbGVJbmRleDtcbiAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBlbmRQb3MgLSBzdGFydFBvczsgXG5cbiAgICAgICAgICBpZiAoaW50ZXJ2YWwgPiAwKSB7XG4gICAgICAgICAgICBzdGFydFBlYWsuaW50ZXJ2YWxzLnB1c2goaW50ZXJ2YWwpO1xuICAgICAgICAgIH0gXG5cblxuICAgICAgICAgIHZhciBmb3VuZEludGVydmFsID0gaW50ZXJ2YWxDb3VudHMuc29tZShmdW5jdGlvbiAoaW50ZXJ2YWxDb3VudCkge1xuICAgICAgICAgICAgaWYgKGludGVydmFsQ291bnQuaW50ZXJ2YWwgPT09IGludGVydmFsKSB7XG4gICAgICAgICAgICAgIGludGVydmFsQ291bnQuY291bnQrKztcbiAgICAgICAgICAgICAgcmV0dXJuIGludGVydmFsQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7IFxuXG4gICAgICAgICAgaWYgKCFmb3VuZEludGVydmFsKSB7XG4gICAgICAgICAgICBpbnRlcnZhbENvdW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgaW50ZXJ2YWw6IGludGVydmFsLFxuICAgICAgICAgICAgICBjb3VudDogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVydmFsQ291bnRzO1xuICB9IFxuXG5cbiAgZnVuY3Rpb24gZ3JvdXBOZWlnaGJvcnNCeVRlbXBvKGludGVydmFsQ291bnRzLCBzYW1wbGVSYXRlKSB7XG4gICAgdmFyIHRlbXBvQ291bnRzID0gW107XG4gICAgaW50ZXJ2YWxDb3VudHMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJ2YWxDb3VudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHRoZW9yZXRpY2FsVGVtcG8gPSBNYXRoLmFicyg2MCAvIChpbnRlcnZhbENvdW50LmludGVydmFsIC8gc2FtcGxlUmF0ZSkpO1xuICAgICAgICB0aGVvcmV0aWNhbFRlbXBvID0gbWFwVGVtcG8odGhlb3JldGljYWxUZW1wbyk7XG4gICAgICAgIHZhciBmb3VuZFRlbXBvID0gdGVtcG9Db3VudHMuc29tZShmdW5jdGlvbiAodGVtcG9Db3VudCkge1xuICAgICAgICAgIGlmICh0ZW1wb0NvdW50LnRlbXBvID09PSB0aGVvcmV0aWNhbFRlbXBvKSByZXR1cm4gdGVtcG9Db3VudC5jb3VudCArPSBpbnRlcnZhbENvdW50LmNvdW50O1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWZvdW5kVGVtcG8pIHtcbiAgICAgICAgICBpZiAoaXNOYU4odGhlb3JldGljYWxUZW1wbykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0ZW1wb0NvdW50cy5wdXNoKHtcbiAgICAgICAgICAgIHRlbXBvOiBNYXRoLnJvdW5kKHRoZW9yZXRpY2FsVGVtcG8pLFxuICAgICAgICAgICAgY291bnQ6IGludGVydmFsQ291bnQuY291bnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0ZW1wb0NvdW50cztcbiAgfSBcblxuXG4gIGZ1bmN0aW9uIGdldFBlYWtzQXRUb3BUZW1wbyhwZWFrc09iaiwgdGVtcG8sIHNhbXBsZVJhdGUsIGJwbVZhcmlhbmNlKSB7XG4gICAgdmFyIHBlYWtzQXRUb3BUZW1wbyA9IFtdO1xuICAgIHZhciBwZWFrc0FycmF5ID0gT2JqZWN0LmtleXMocGVha3NPYmopLnNvcnQoKTsgXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBlYWtzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwZWFrc0FycmF5W2ldO1xuICAgICAgdmFyIHBlYWsgPSBwZWFrc09ialtrZXldO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBlYWsuaW50ZXJ2YWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBpbnRlcnZhbEJQTSA9IE1hdGgucm91bmQoTWF0aC5hYnMoNjAgLyAocGVhay5pbnRlcnZhbHNbal0gLyBzYW1wbGVSYXRlKSkpO1xuICAgICAgICBpbnRlcnZhbEJQTSA9IG1hcFRlbXBvKGludGVydmFsQlBNKTtcblxuICAgICAgICBpZiAoTWF0aC5hYnMoaW50ZXJ2YWxCUE0gLSB0ZW1wbykgPCBicG1WYXJpYW5jZSkge1xuICAgICAgICAgIHBlYWtzQXRUb3BUZW1wby5wdXNoKHBlYWsuc2FtcGxlSW5kZXggLyBzYW1wbGVSYXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gXG5cblxuICAgIHBlYWtzQXRUb3BUZW1wbyA9IHBlYWtzQXRUb3BUZW1wby5maWx0ZXIoZnVuY3Rpb24gKHBlYWtUaW1lLCBpbmRleCwgYXJyKSB7XG4gICAgICB2YXIgZGlmID0gYXJyW2luZGV4ICsgMV0gLSBwZWFrVGltZTtcblxuICAgICAgaWYgKGRpZiA+IDAuMDEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBlYWtzQXRUb3BUZW1wbztcbiAgfSBcblxuXG4gIGZ1bmN0aW9uIG1hcFRlbXBvKHRoZW9yZXRpY2FsVGVtcG8pIHtcbiAgICBpZiAoIWlzRmluaXRlKHRoZW9yZXRpY2FsVGVtcG8pIHx8IHRoZW9yZXRpY2FsVGVtcG8gPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IFxuXG5cbiAgICB3aGlsZSAodGhlb3JldGljYWxUZW1wbyA8IDkwKSB7XG4gICAgICB0aGVvcmV0aWNhbFRlbXBvICo9IDI7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRoZW9yZXRpY2FsVGVtcG8gPiAxODAgJiYgdGhlb3JldGljYWxUZW1wbyA+IDkwKSB7XG4gICAgICB0aGVvcmV0aWNhbFRlbXBvIC89IDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoZW9yZXRpY2FsVGVtcG87XG4gIH1cblxuXG4gIHZhciBDdWUgPSBmdW5jdGlvbiBDdWUoY2FsbGJhY2ssIHRpbWUsIGlkLCB2YWwpIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy50aW1lID0gdGltZTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy52YWwgPSB2YWw7XG4gIH07XG4gIC8qKlxuICAgKiAgU2NoZWR1bGUgZXZlbnRzIHRvIHRyaWdnZXIgZXZlcnkgdGltZSBhIE1lZGlhRWxlbWVudFxuICAgKiAgKGF1ZGlvL3ZpZGVvKSByZWFjaGVzIGEgcGxheWJhY2sgY3VlIHBvaW50LlxuICAgKlxuICAgKiAgQWNjZXB0cyBhIGNhbGxiYWNrIGZ1bmN0aW9uLCBhIHRpbWUgKGluIHNlY29uZHMpIGF0IHdoaWNoIHRvIHRyaWdnZXJcbiAgICogIHRoZSBjYWxsYmFjaywgYW5kIGFuIG9wdGlvbmFsIHBhcmFtZXRlciBmb3IgdGhlIGNhbGxiYWNrLlxuICAgKlxuICAgKiAgVGltZSB3aWxsIGJlIHBhc3NlZCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbixcbiAgICogIGFuZCBwYXJhbSB3aWxsIGJlIHRoZSBzZWNvbmQgcGFyYW1ldGVyLlxuICAgKlxuICAgKlxuICAgKiAgQG1ldGhvZCAgYWRkQ3VlXG4gICAqICBAZm9yIHA1LlNvdW5kRmlsZVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9ICAgdGltZSAgICAgVGltZSBpbiBzZWNvbmRzLCByZWxhdGl2ZSB0byB0aGlzIG1lZGlhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50J3MgcGxheWJhY2suIEZvciBleGFtcGxlLCB0byB0cmlnZ2VyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbiBldmVudCBldmVyeSB0aW1lIHBsYXliYWNrIHJlYWNoZXMgdHdvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRzLCBwYXNzIGluIHRoZSBudW1iZXIgMi4gVGhpcyB3aWxsIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzZWQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgTmFtZSBvZiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVkIGF0IHRoZSBnaXZlbiB0aW1lLiBUaGUgY2FsbGJhY2sgd2lsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZSB0aW1lIGFuZCAob3B0aW9uYWxseSkgcGFyYW0gYXMgaXRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0d28gcGFyYW1ldGVycy5cbiAgICogIEBwYXJhbSB7T2JqZWN0fSBbdmFsdWVdICAgIEFuIG9iamVjdCB0byBiZSBwYXNzZWQgYXMgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmQgcGFyYW1ldGVyIHRvIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqICBAcmV0dXJuIHtOdW1iZXJ9IGlkIElEIG9mIHRoaXMgY3VlLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICB1c2VmdWwgZm9yIHJlbW92ZUN1ZShpZClcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IG15U291bmQ7XG4gICAqICBmdW5jdGlvbiBwcmVsb2FkKCkge1xuICAgKiAgICBteVNvdW5kID0gbG9hZFNvdW5kKCdhc3NldHMvRGFtc2NyYXlfRGFuY2luZ1RpZ2VyLm1wMycpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKGNhbnZhc1ByZXNzZWQpO1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ3RhcCB0byBwbGF5JywgMTAsIDIwKTtcbiAgICpcbiAgICogICAgLy8gc2NoZWR1bGUgY2FsbHMgdG8gY2hhbmdlVGV4dFxuICAgKiAgICBteVNvdW5kLmFkZEN1ZSgwLCBjaGFuZ2VUZXh0LCBcImhlbGxvXCIgKTtcbiAgICogICAgbXlTb3VuZC5hZGRDdWUoMC41LCBjaGFuZ2VUZXh0LCBcImhlbGxvLFwiICk7XG4gICAqICAgIG15U291bmQuYWRkQ3VlKDEsIGNoYW5nZVRleHQsIFwiaGVsbG8sIHA1IVwiKTtcbiAgICogICAgbXlTb3VuZC5hZGRDdWUoMS41LCBjaGFuZ2VUZXh0LCBcImhlbGxvLCBwNSEhXCIpO1xuICAgKiAgICBteVNvdW5kLmFkZEN1ZSgyLCBjaGFuZ2VUZXh0LCBcImhlbGxvLCBwNSEhISEhXCIpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gY2hhbmdlVGV4dCh2YWwpIHtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0KHZhbCwgMTAsIDIwKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGNhbnZhc1ByZXNzZWQoKSB7XG4gICAqICAgIG15U291bmQucGxheSgpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuYWRkQ3VlID0gZnVuY3Rpb24gKHRpbWUsIGNhbGxiYWNrLCB2YWwpIHtcbiAgICB2YXIgaWQgPSB0aGlzLl9jdWVJRENvdW50ZXIrKztcbiAgICB2YXIgY3VlID0gbmV3IEN1ZShjYWxsYmFjaywgdGltZSwgaWQsIHZhbCk7XG5cbiAgICB0aGlzLl9jdWVzLnB1c2goY3VlKTsgXG5cblxuICAgIHJldHVybiBpZDtcbiAgfTtcbiAgLyoqXG4gICAqICBSZW1vdmUgYSBjYWxsYmFjayBiYXNlZCBvbiBpdHMgSUQuIFRoZSBJRCBpcyByZXR1cm5lZCBieSB0aGVcbiAgICogIGFkZEN1ZSBtZXRob2QuXG4gICAqXG4gICAqICBAbWV0aG9kIHJlbW92ZUN1ZVxuICAgKiAgQGZvciBwNS5Tb3VuZEZpbGVcbiAgICogIEBwYXJhbSAge051bWJlcn0gaWQgSUQgb2YgdGhlIGN1ZSwgYXMgcmV0dXJuZWQgYnkgYWRkQ3VlXG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5yZW1vdmVDdWUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgY3VlTGVuZ3RoID0gdGhpcy5fY3Vlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1ZUxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3VlID0gdGhpcy5fY3Vlc1tpXTtcblxuICAgICAgaWYgKGN1ZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgdGhpcy5fY3Vlcy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2N1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIFJlbW92ZSBhbGwgb2YgdGhlIGNhbGxiYWNrcyB0aGF0IGhhZCBvcmlnaW5hbGx5IGJlZW4gc2NoZWR1bGVkXG4gICAqICB2aWEgdGhlIGFkZEN1ZSBtZXRob2QuXG4gICAqXG4gICAqICBAbWV0aG9kICBjbGVhckN1ZXNcbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLmNsZWFyQ3VlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jdWVzID0gW107IFxuICB9OyBcblxuXG4gIHA1LlNvdW5kRmlsZS5wcm90b3R5cGUuX29uVGltZVVwZGF0ZSA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgIHZhciBwbGF5YmFja1RpbWUgPSBwb3NpdGlvbiAvIHRoaXMuYnVmZmVyLnNhbXBsZVJhdGU7XG4gICAgdmFyIGN1ZUxlbmd0aCA9IHRoaXMuX2N1ZXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdWVMZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1ZSA9IHRoaXMuX2N1ZXNbaV07XG4gICAgICB2YXIgY2FsbGJhY2tUaW1lID0gY3VlLnRpbWU7XG4gICAgICB2YXIgdmFsID0gY3VlLnZhbDtcblxuICAgICAgaWYgKH5+dGhpcy5fcHJldlVwZGF0ZVRpbWUgPD0gY2FsbGJhY2tUaW1lICYmIGNhbGxiYWNrVGltZSA8PSBwbGF5YmFja1RpbWUpIHtcbiAgICAgICAgY3VlLmNhbGxiYWNrKHZhbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fcHJldlVwZGF0ZVRpbWUgPSBwbGF5YmFja1RpbWU7XG4gIH07XG4gIC8qKlxuICAgKiBTYXZlIGEgcDUuU291bmRGaWxlIGFzIGEgLndhdiBmaWxlLiBUaGUgYnJvd3NlciB3aWxsIHByb21wdCB0aGUgdXNlclxuICAgKiB0byBkb3dubG9hZCB0aGUgZmlsZSB0byB0aGVpciBkZXZpY2UuIFRvIHVwbG9hZCBhIGZpbGUgdG8gYSBzZXJ2ZXIsIHNlZVxuICAgKiA8YSBocmVmPVwiL2RvY3MvcmVmZXJlbmNlLyMvcDUuU291bmRGaWxlL2dldEJsb2JcIj5nZXRCbG9iPC9hPlxuICAgKlxuICAgKiBAbWV0aG9kIHNhdmVcbiAgICogQGZvciBwNS5Tb3VuZEZpbGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbZmlsZU5hbWVdICAgICAgbmFtZSBvZiB0aGUgcmVzdWx0aW5nIC53YXYgZmlsZS5cbiAgICogQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgbXlTb3VuZDtcbiAgICogIGZ1bmN0aW9uIHByZWxvYWQoKSB7XG4gICAqICAgIG15U291bmQgPSBsb2FkU291bmQoJ2Fzc2V0cy9kb29yYmVsbC5tcDMnKTtcbiAgICogIH1cbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChjYW52YXNQcmVzc2VkKTtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0KCd0YXAgdG8gZG93bmxvYWQnLCAxMCwgMjApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gY2FudmFzUHJlc3NlZCgpIHtcbiAgICogICAgbXlTb3VuZC5zYXZlKCdteSBjb29sIGZpbGVuYW1lJyk7XG4gICAqICB9XG4gICAqIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5Tb3VuZEZpbGUucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoZmlsZU5hbWUpIHtcbiAgICBwNS5wcm90b3R5cGUuc2F2ZVNvdW5kKHRoaXMsIGZpbGVOYW1lLCAnd2F2Jyk7XG4gIH07XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIHNlbmRpbmcgYSBTb3VuZEZpbGUgdG8gYSBzZXJ2ZXIuIEl0IHJldHVybnMgdGhlXG4gICAqIC53YXYtZW5jb2RlZCBhdWRpbyBkYXRhIGFzIGEgXCI8YSB0YXJnZXQ9XCJfYmxhbmtcIiB0aXRsZT1cIkJsb2IgcmVmZXJlbmNlIGF0XG4gICAqIE1ETlwiIGhyZWY9XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYlwiPkJsb2I8L2E+XCIuXG4gICAqIEEgQmxvYiBpcyBhIGZpbGUtbGlrZSBkYXRhIG9iamVjdCB0aGF0IGNhbiBiZSB1cGxvYWRlZCB0byBhIHNlcnZlclxuICAgKiB3aXRoIGFuIDxhIGhyZWY9XCIvZG9jcy9yZWZlcmVuY2UvIy9wNS9odHRwRG9cIj5odHRwPC9hPiByZXF1ZXN0LiBXZSdsbFxuICAgKiB1c2UgdGhlIGBodHRwRG9gIG9wdGlvbnMgb2JqZWN0IHRvIHNlbmQgYSBQT1NUIHJlcXVlc3Qgd2l0aCBzb21lXG4gICAqIHNwZWNpZmljIG9wdGlvbnM6IHdlIGVuY29kZSB0aGUgcmVxdWVzdCBhcyBgbXVsdGlwYXJ0L2Zvcm0tZGF0YWAsXG4gICAqIGFuZCBhdHRhY2ggdGhlIGJsb2IgYXMgb25lIG9mIHRoZSBmb3JtIHZhbHVlcyB1c2luZyBgRm9ybURhdGFgLlxuICAgKlxuICAgKlxuICAgKiBAbWV0aG9kIGdldEJsb2JcbiAgICogQGZvciBwNS5Tb3VuZEZpbGVcbiAgICogQHJldHVybnMge0Jsb2J9IEEgZmlsZS1saWtlIGRhdGEgb2JqZWN0XG4gICAqIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICogICAgbXlTb3VuZCA9IGxvYWRTb3VuZCgnYXNzZXRzL2Rvb3JiZWxsLm1wMycpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIG5vQ2FudmFzKCk7XG4gICAqICAgIGxldCBzb3VuZEJsb2IgPSBteVNvdW5kLmdldEJsb2IoKTtcbiAgICpcbiAgICogICAgLy8gTm93IHdlIGNhbiBzZW5kIHRoZSBibG9iIHRvIGEgc2VydmVyLi4uXG4gICAqICAgIGxldCBzZXJ2ZXJVcmwgPSAnaHR0cHM6Ly9qc29ucGxhY2Vob2xkZXIudHlwaWNvZGUuY29tL3Bvc3RzJztcbiAgICogICAgbGV0IGh0dHBSZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICogICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICogICAgICBib2R5OiBuZXcgRm9ybURhdGEoKS5hcHBlbmQoJ3NvdW5kQmxvYicsIHNvdW5kQmxvYiksXG4gICAqICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoe1xuICAgKiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJ1xuICAgKiAgICAgIH0pXG4gICAqICAgIH07XG4gICAqICAgIGh0dHBEbyhzZXJ2ZXJVcmwsIGh0dHBSZXF1ZXN0T3B0aW9ucyk7XG4gICAqXG4gICAqICAgIC8vIFdlIGNhbiBhbHNvIGNyZWF0ZSBhbiBgT2JqZWN0VVJMYCBwb2ludGluZyB0byB0aGUgQmxvYlxuICAgKiAgICBsZXQgYmxvYlVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoc291bmRCbG9iKTtcbiAgICpcbiAgICogICAgLy8gVGhlIGA8QXVkaW8+YCBFbGVtZW50IGFjY2VwdHMgT2JqZWN0IFVSTCdzXG4gICAqICAgIGNyZWF0ZUF1ZGlvKGJsb2JVcmwpLnNob3dDb250cm9scygpO1xuICAgKlxuICAgKiAgICBjcmVhdGVEaXYoKTtcbiAgICpcbiAgICogICAgLy8gVGhlIE9iamVjdFVSTCBleGlzdHMgYXMgbG9uZyBhcyB0aGlzIHRhYiBpcyBvcGVuXG4gICAqICAgIGxldCBpbnB1dCA9IGNyZWF0ZUlucHV0KGJsb2JVcmwpO1xuICAgKiAgICBpbnB1dC5hdHRyaWJ1dGUoJ3JlYWRvbmx5JywgdHJ1ZSk7XG4gICAqICAgIGlucHV0Lm1vdXNlQ2xpY2tlZChmdW5jdGlvbigpIHsgaW5wdXQuZWx0LnNlbGVjdCgpIH0pO1xuICAgKiAgfVxuICAgKlxuICAgKiA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuU291bmRGaWxlLnByb3RvdHlwZS5nZXRCbG9iID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhVmlldyA9IGNvbnZlcnRUb1dhdih0aGlzLmJ1ZmZlcik7XG4gICAgcmV0dXJuIG5ldyBCbG9iKFtkYXRhVmlld10sIHtcbiAgICAgIHR5cGU6ICdhdWRpby93YXYnXG4gICAgfSk7XG4gIH07IFxuXG5cbiAgZnVuY3Rpb24gX2NsZWFyT25FbmQoZSkge1xuICAgIHZhciB0aGlzQnVmZmVyU291cmNlTm9kZSA9IGUudGFyZ2V0O1xuICAgIHZhciBzb3VuZEZpbGUgPSB0aGlzOyBcblxuICAgIHRoaXNCdWZmZXJTb3VyY2VOb2RlLl9wbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpc0J1ZmZlclNvdXJjZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBzb3VuZEZpbGUuX2NsZWFyT25FbmQpOyBcblxuICAgIHNvdW5kRmlsZS5fb25lbmRlZChzb3VuZEZpbGUpOyBcblxuXG4gICAgc291bmRGaWxlLmJ1ZmZlclNvdXJjZU5vZGVzLm1hcChmdW5jdGlvbiAoXywgaSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfSkucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgIHZhciBuID0gc291bmRGaWxlLmJ1ZmZlclNvdXJjZU5vZGVzW2ldO1xuXG4gICAgICBpZiAobi5fcGxheWluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgc291bmRGaWxlLmJ1ZmZlclNvdXJjZU5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChzb3VuZEZpbGUuYnVmZmVyU291cmNlTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBzb3VuZEZpbGUuX3BsYXlpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICB2YXIgcDVzb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KSxcbiAgICAgIHNhZmVCdWZmZXJTaXplID0gX3JlcXVpcmUuc2FmZUJ1ZmZlclNpemU7XG5cbiAgdmFyIHByb2Nlc3Nvck5hbWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG4gIC8qKlxuICAgKiAgQW1wbGl0dWRlIG1lYXN1cmVzIHZvbHVtZSBiZXR3ZWVuIDAuMCBhbmQgMS4wLlxuICAgKiAgTGlzdGVucyB0byBhbGwgcDVzb3VuZCBieSBkZWZhdWx0LCBvciB1c2Ugc2V0SW5wdXQoKVxuICAgKiAgdG8gbGlzdGVuIHRvIGEgc3BlY2lmaWMgc291bmQgc291cmNlLiBBY2NlcHRzIGFuIG9wdGlvbmFsXG4gICAqICBzbW9vdGhpbmcgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIDAuXG4gICAqXG4gICAqICBAY2xhc3MgcDUuQW1wbGl0dWRlXG4gICAqICBAY29uc3RydWN0b3JcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbc21vb3RoaW5nXSBiZXR3ZWVuIDAuMCBhbmQgLjk5OSB0byBzbW9vdGhcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtcGxpdHVkZSByZWFkaW5ncyAoZGVmYXVsdHMgdG8gMClcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IHNvdW5kLCBhbXBsaXR1ZGU7XG4gICAqXG4gICAqICBmdW5jdGlvbiBwcmVsb2FkKCl7XG4gICAqICAgIHNvdW5kID0gbG9hZFNvdW5kKCdhc3NldHMvYmVhdC5tcDMnKTtcbiAgICogIH1cbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwxMDApO1xuICAgKiAgICBjbnYubW91c2VDbGlja2VkKHRvZ2dsZVNvdW5kKTtcbiAgICogICAgYW1wbGl0dWRlID0gbmV3IHA1LkFtcGxpdHVkZSgpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gZHJhdygpIHtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0KCd0YXAgdG8gcGxheScsIDIwLCAyMCk7XG4gICAqXG4gICAqICAgIGxldCBsZXZlbCA9IGFtcGxpdHVkZS5nZXRMZXZlbCgpO1xuICAgKiAgICBsZXQgc2l6ZSA9IG1hcChsZXZlbCwgMCwgMSwgMCwgMjAwKTtcbiAgICogICAgZWxsaXBzZSh3aWR0aC8yLCBoZWlnaHQvMiwgc2l6ZSwgc2l6ZSk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiB0b2dnbGVTb3VuZCgpIHtcbiAgICogICAgaWYgKHNvdW5kLmlzUGxheWluZygpICl7XG4gICAqICAgICAgc291bmQuc3RvcCgpO1xuICAgKiAgICB9IGVsc2Uge1xuICAgKiAgICAgIHNvdW5kLnBsYXkoKTtcbiAgICogICAgfVxuICAgKiAgfVxuICAgKlxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LkFtcGxpdHVkZSA9IGZ1bmN0aW9uIChzbW9vdGhpbmcpIHtcbiAgICB0aGlzLmJ1ZmZlclNpemUgPSBzYWZlQnVmZmVyU2l6ZSgyMDQ4KTsgXG5cbiAgICB0aGlzLmF1ZGlvY29udGV4dCA9IHA1c291bmQuYXVkaW9jb250ZXh0O1xuICAgIHRoaXMuX3dvcmtsZXROb2RlID0gbmV3IEF1ZGlvV29ya2xldE5vZGUodGhpcy5hdWRpb2NvbnRleHQsIHByb2Nlc3Nvck5hbWVzLmFtcGxpdHVkZVByb2Nlc3Nvciwge1xuICAgICAgb3V0cHV0Q2hhbm5lbENvdW50OiBbMV0sXG4gICAgICBwYXJhbWV0ZXJEYXRhOiB7XG4gICAgICAgIHNtb290aGluZzogc21vb3RoaW5nIHx8IDBcbiAgICAgIH0sXG4gICAgICBwcm9jZXNzb3JPcHRpb25zOiB7XG4gICAgICAgIG5vcm1hbGl6ZTogZmFsc2UsXG4gICAgICAgIHNtb290aGluZzogc21vb3RoaW5nIHx8IDAsXG4gICAgICAgIG51bUlucHV0Q2hhbm5lbHM6IDIsXG4gICAgICAgIGJ1ZmZlclNpemU6IHRoaXMuYnVmZmVyU2l6ZVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fd29ya2xldE5vZGUucG9ydC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kYXRhLm5hbWUgPT09ICdhbXBsaXR1ZGUnKSB7XG4gICAgICAgIHRoaXMudm9sdW1lID0gZXZlbnQuZGF0YS52b2x1bWU7XG4gICAgICAgIHRoaXMudm9sTm9ybSA9IGV2ZW50LmRhdGEudm9sTm9ybTtcbiAgICAgICAgdGhpcy5zdGVyZW9Wb2wgPSBldmVudC5kYXRhLnN0ZXJlb1ZvbDtcbiAgICAgICAgdGhpcy5zdGVyZW9Wb2xOb3JtID0gZXZlbnQuZGF0YS5zdGVyZW9Wb2xOb3JtO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTsgXG5cblxuICAgIHRoaXMuaW5wdXQgPSB0aGlzLl93b3JrbGV0Tm9kZTtcbiAgICB0aGlzLm91dHB1dCA9IHRoaXMuYXVkaW9jb250ZXh0LmNyZWF0ZUdhaW4oKTsgXG5cbiAgICB0aGlzLnZvbHVtZSA9IDA7XG4gICAgdGhpcy52b2xOb3JtID0gMDtcbiAgICB0aGlzLnN0ZXJlb1ZvbCA9IFswLCAwXTtcbiAgICB0aGlzLnN0ZXJlb1ZvbE5vcm0gPSBbMCwgMF07XG4gICAgdGhpcy5ub3JtYWxpemUgPSBmYWxzZTtcblxuICAgIHRoaXMuX3dvcmtsZXROb2RlLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXG4gICAgdGhpcy5vdXRwdXQuZ2Fpbi52YWx1ZSA9IDA7IFxuXG4gICAgdGhpcy5vdXRwdXQuY29ubmVjdCh0aGlzLmF1ZGlvY29udGV4dC5kZXN0aW5hdGlvbik7IFxuXG4gICAgcDVzb3VuZC5tZXRlci5jb25uZWN0KHRoaXMuX3dvcmtsZXROb2RlKTsgXG5cbiAgICBwNXNvdW5kLnNvdW5kQXJyYXkucHVzaCh0aGlzKTtcbiAgfTtcbiAgLyoqXG4gICAqICBDb25uZWN0cyB0byB0aGUgcDVzb3VuZCBpbnN0YW5jZSAobWFzdGVyIG91dHB1dCkgYnkgZGVmYXVsdC5cbiAgICogIE9wdGlvbmFsbHksIHlvdSBjYW4gcGFzcyBpbiBhIHNwZWNpZmljIHNvdXJjZSAoaS5lLiBhIHNvdW5kZmlsZSkuXG4gICAqXG4gICAqICBAbWV0aG9kIHNldElucHV0XG4gICAqICBAZm9yIHA1LkFtcGxpdHVkZVxuICAgKiAgQHBhcmFtIHtzb3VuZE9iamVjdHx1bmRlZmluZWR9IFtzbmRdIHNldCB0aGUgc291bmQgc291cmNlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wdGlvbmFsLCBkZWZhdWx0cyB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc3RlciBvdXRwdXQpXG4gICAqICBAcGFyYW0ge051bWJlcnx1bmRlZmluZWR9IFtzbW9vdGhpbmddIGEgcmFuZ2UgYmV0d2VlbiAwLjAgYW5kIDEuMFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBzbW9vdGggYW1wbGl0dWRlIHJlYWRpbmdzXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGZ1bmN0aW9uIHByZWxvYWQoKXtcbiAgICogICAgc291bmQxID0gbG9hZFNvdW5kKCdhc3NldHMvYmVhdC5tcDMnKTtcbiAgICogICAgc291bmQyID0gbG9hZFNvdW5kKCdhc3NldHMvZHJ1bS5tcDMnKTtcbiAgICogIH1cbiAgICogIGZ1bmN0aW9uIHNldHVwKCl7XG4gICAqICAgIGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZUNsaWNrZWQodG9nZ2xlU291bmQpO1xuICAgKlxuICAgKiAgICBhbXBsaXR1ZGUgPSBuZXcgcDUuQW1wbGl0dWRlKCk7XG4gICAqICAgIGFtcGxpdHVkZS5zZXRJbnB1dChzb3VuZDIpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gZHJhdygpIHtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0KCd0YXAgdG8gcGxheScsIDIwLCAyMCk7XG4gICAqXG4gICAqICAgIGxldCBsZXZlbCA9IGFtcGxpdHVkZS5nZXRMZXZlbCgpO1xuICAgKiAgICBsZXQgc2l6ZSA9IG1hcChsZXZlbCwgMCwgMSwgMCwgMjAwKTtcbiAgICogICAgZWxsaXBzZSh3aWR0aC8yLCBoZWlnaHQvMiwgc2l6ZSwgc2l6ZSk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiB0b2dnbGVTb3VuZCgpe1xuICAgKiAgICBpZiAoc291bmQxLmlzUGxheWluZygpICYmIHNvdW5kMi5pc1BsYXlpbmcoKSkge1xuICAgKiAgICAgIHNvdW5kMS5zdG9wKCk7XG4gICAqICAgICAgc291bmQyLnN0b3AoKTtcbiAgICogICAgfSBlbHNlIHtcbiAgICogICAgICBzb3VuZDEucGxheSgpO1xuICAgKiAgICAgIHNvdW5kMi5wbGF5KCk7XG4gICAqICAgIH1cbiAgICogIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5BbXBsaXR1ZGUucHJvdG90eXBlLnNldElucHV0ID0gZnVuY3Rpb24gKHNvdXJjZSwgc21vb3RoaW5nKSB7XG4gICAgcDVzb3VuZC5tZXRlci5kaXNjb25uZWN0KCk7XG5cbiAgICBpZiAoc21vb3RoaW5nKSB7XG4gICAgICB0aGlzLl93b3JrbGV0Tm9kZS5wYXJhbWV0ZXJzLmdldCgnc21vb3RoaW5nJykudmFsdWUgPSBzbW9vdGhpbmc7XG4gICAgfSBcblxuXG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmxvZygnQW1wbGl0dWRlIGlucHV0IHNvdXJjZSBpcyBub3QgcmVhZHkhIENvbm5lY3RpbmcgdG8gbWFzdGVyIG91dHB1dCBpbnN0ZWFkJyk7XG4gICAgICBwNXNvdW5kLm1ldGVyLmNvbm5lY3QodGhpcy5fd29ya2xldE5vZGUpO1xuICAgIH0gXG4gICAgZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgcDUuU2lnbmFsKSB7XG4gICAgICAgIHNvdXJjZS5vdXRwdXQuY29ubmVjdCh0aGlzLl93b3JrbGV0Tm9kZSk7XG4gICAgICB9IFxuICAgICAgZWxzZSBpZiAoc291cmNlKSB7XG4gICAgICAgICAgc291cmNlLmNvbm5lY3QodGhpcy5fd29ya2xldE5vZGUpO1xuXG4gICAgICAgICAgdGhpcy5fd29ya2xldE5vZGUuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgICAgdGhpcy5fd29ya2xldE5vZGUuY29ubmVjdCh0aGlzLm91dHB1dCk7XG4gICAgICAgIH0gXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcDVzb3VuZC5tZXRlci5jb25uZWN0KHRoaXMuX3dvcmtsZXROb2RlKTtcbiAgICAgICAgICB9XG4gIH07XG5cbiAgcDUuQW1wbGl0dWRlLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICBpZiAodW5pdCkge1xuICAgICAgaWYgKHVuaXQuaGFzT3duUHJvcGVydHkoJ2lucHV0JykpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQuY29ubmVjdCh1bml0LmlucHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3V0cHV0LmNvbm5lY3QodW5pdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3V0cHV0LmNvbm5lY3QodGhpcy5wYW5uZXIuY29ubmVjdChwNXNvdW5kLmlucHV0KSk7XG4gICAgfVxuICB9O1xuXG4gIHA1LkFtcGxpdHVkZS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vdXRwdXQpIHtcbiAgICAgIHRoaXMub3V0cHV0LmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgUmV0dXJucyBhIHNpbmdsZSBBbXBsaXR1ZGUgcmVhZGluZyBhdCB0aGUgbW9tZW50IGl0IGlzIGNhbGxlZC5cbiAgICogIEZvciBjb250aW51b3VzIHJlYWRpbmdzLCBydW4gaW4gdGhlIGRyYXcgbG9vcC5cbiAgICpcbiAgICogIEBtZXRob2QgZ2V0TGV2ZWxcbiAgICogIEBmb3IgcDUuQW1wbGl0dWRlXG4gICAqICBAcGFyYW0ge051bWJlcn0gW2NoYW5uZWxdIE9wdGlvbmFsbHkgcmV0dXJuIG9ubHkgY2hhbm5lbCAwIChsZWZ0KSBvciAxIChyaWdodClcbiAgICogIEByZXR1cm4ge051bWJlcn0gICAgICAgQW1wbGl0dWRlIGFzIGEgbnVtYmVyIGJldHdlZW4gMC4wIGFuZCAxLjBcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgZnVuY3Rpb24gcHJlbG9hZCgpe1xuICAgKiAgICBzb3VuZCA9IGxvYWRTb3VuZCgnYXNzZXRzL2JlYXQubXAzJyk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZUNsaWNrZWQodG9nZ2xlU291bmQpO1xuICAgKiAgICBhbXBsaXR1ZGUgPSBuZXcgcDUuQW1wbGl0dWRlKCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBkcmF3KCkge1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCwgMTUwKTtcbiAgICogICAgdGV4dEFsaWduKENFTlRFUik7XG4gICAqICAgIHRleHQoJ3RhcCB0byBwbGF5Jywgd2lkdGgvMiwgMjApO1xuICAgKlxuICAgKiAgICBsZXQgbGV2ZWwgPSBhbXBsaXR1ZGUuZ2V0TGV2ZWwoKTtcbiAgICogICAgbGV0IHNpemUgPSBtYXAobGV2ZWwsIDAsIDEsIDAsIDIwMCk7XG4gICAqICAgIGVsbGlwc2Uod2lkdGgvMiwgaGVpZ2h0LzIsIHNpemUsIHNpemUpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gdG9nZ2xlU291bmQoKXtcbiAgICogICAgaWYgKHNvdW5kLmlzUGxheWluZygpKSB7XG4gICAqICAgICAgc291bmQuc3RvcCgpO1xuICAgKiAgICB9IGVsc2Uge1xuICAgKiAgICAgIHNvdW5kLnBsYXkoKTtcbiAgICogICAgfVxuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LkFtcGxpdHVkZS5wcm90b3R5cGUuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgIGlmICh0eXBlb2YgY2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmICh0aGlzLm5vcm1hbGl6ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVyZW9Wb2xOb3JtW2NoYW5uZWxdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcmVvVm9sW2NoYW5uZWxdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5ub3JtYWxpemUpIHtcbiAgICAgIHJldHVybiB0aGlzLnZvbE5vcm07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnZvbHVtZTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHJlc3VsdHMgb2YgQW1wbGl0dWRlLnByb2Nlc3MoKSB3aWxsIGJlXG4gICAqIE5vcm1hbGl6ZWQuIFRvIG5vcm1hbGl6ZSwgQW1wbGl0dWRlIGZpbmRzIHRoZSBkaWZmZXJlbmNlIHRoZVxuICAgKiBsb3VkZXN0IHJlYWRpbmcgaXQgaGFzIHByb2Nlc3NlZCBhbmQgdGhlIG1heGltdW0gYW1wbGl0dWRlIG9mXG4gICAqIDEuMC4gQW1wbGl0dWRlIGFkZHMgdGhpcyBkaWZmZXJlbmNlIHRvIGFsbCB2YWx1ZXMgdG8gcHJvZHVjZVxuICAgKiByZXN1bHRzIHRoYXQgd2lsbCByZWxpYWJseSBtYXAgYmV0d2VlbiAwLjAgYW5kIDEuMC4gSG93ZXZlcixcbiAgICogaWYgYSBsb3VkZXIgbW9tZW50IG9jY3VycywgdGhlIGFtb3VudCB0aGF0IE5vcm1hbGl6ZSBhZGRzIHRvXG4gICAqIGFsbCB0aGUgdmFsdWVzIHdpbGwgY2hhbmdlLiBBY2NlcHRzIGFuIG9wdGlvbmFsIGJvb2xlYW4gcGFyYW1ldGVyXG4gICAqICh0cnVlIG9yIGZhbHNlKS4gTm9ybWFsaXppbmcgaXMgb2ZmIGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqIEBtZXRob2QgdG9nZ2xlTm9ybWFsaXplXG4gICAqIEBmb3IgcDUuQW1wbGl0dWRlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Jvb2xlYW5dIHNldCBub3JtYWxpemUgdG8gdHJ1ZSAoMSkgb3IgZmFsc2UgKDApXG4gICAqL1xuXG5cbiAgcDUuQW1wbGl0dWRlLnByb3RvdHlwZS50b2dnbGVOb3JtYWxpemUgPSBmdW5jdGlvbiAoYm9vbCkge1xuICAgIGlmICh0eXBlb2YgYm9vbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzLm5vcm1hbGl6ZSA9IGJvb2w7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm9ybWFsaXplID0gIXRoaXMubm9ybWFsaXplO1xuICAgIH1cblxuICAgIHRoaXMuX3dvcmtsZXROb2RlLnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgbmFtZTogJ3RvZ2dsZU5vcm1hbGl6ZScsXG4gICAgICBub3JtYWxpemU6IHRoaXMubm9ybWFsaXplXG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiAgU21vb3RoIEFtcGxpdHVkZSBhbmFseXNpcyBieSBhdmVyYWdpbmcgd2l0aCB0aGUgbGFzdCBhbmFseXNpc1xuICAgKiAgZnJhbWUuIE9mZiBieSBkZWZhdWx0LlxuICAgKlxuICAgKiAgQG1ldGhvZCBzbW9vdGhcbiAgICogIEBmb3IgcDUuQW1wbGl0dWRlXG4gICAqICBAcGFyYW0ge051bWJlcn0gc2V0IHNtb290aGluZyBmcm9tIDAuMCA8PSAxXG4gICAqL1xuXG5cbiAgcDUuQW1wbGl0dWRlLnByb3RvdHlwZS5zbW9vdGggPSBmdW5jdGlvbiAocykge1xuICAgIGlmIChzID49IDAgJiYgcyA8IDEpIHtcbiAgICAgIHRoaXMuX3dvcmtsZXROb2RlLnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBuYW1lOiAnc21vb3RoaW5nJyxcbiAgICAgICAgc21vb3RoaW5nOiBzXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ0Vycm9yOiBzbW9vdGhpbmcgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEnKTtcbiAgICB9XG4gIH07XG5cbiAgcDUuQW1wbGl0dWRlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmRleCA9IHA1c291bmQuc291bmRBcnJheS5pbmRleE9mKHRoaXMpO1xuICAgIHA1c291bmQuc291bmRBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgaWYgKHRoaXMuaW5wdXQpIHtcbiAgICAgIHRoaXMuaW5wdXQuZGlzY29ubmVjdCgpO1xuICAgICAgZGVsZXRlIHRoaXMuaW5wdXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3V0cHV0KSB7XG4gICAgICB0aGlzLm91dHB1dC5kaXNjb25uZWN0KCk7XG4gICAgICBkZWxldGUgdGhpcy5vdXRwdXQ7XG4gICAgfVxuXG4gICAgdGhpcy5fd29ya2xldE5vZGUuZGlzY29ubmVjdCgpO1xuXG4gICAgZGVsZXRlIHRoaXMuX3dvcmtsZXROb2RlO1xuICB9O1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gIHZhciBwNXNvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgLyoqXG4gICAqICA8cD5GRlQgKEZhc3QgRm91cmllciBUcmFuc2Zvcm0pIGlzIGFuIGFuYWx5c2lzIGFsZ29yaXRobSB0aGF0XG4gICAqICBpc29sYXRlcyBpbmRpdmlkdWFsXG4gICAqICA8YSBocmVmPVwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXVkaW9fZnJlcXVlbmN5XCI+XG4gICAqICBhdWRpbyBmcmVxdWVuY2llczwvYT4gd2l0aGluIGEgd2F2ZWZvcm0uPC9wPlxuICAgKlxuICAgKiAgPHA+T25jZSBpbnN0YW50aWF0ZWQsIGEgcDUuRkZUIG9iamVjdCBjYW4gcmV0dXJuIGFuIGFycmF5IGJhc2VkIG9uXG4gICAqICB0d28gdHlwZXMgb2YgYW5hbHlzZXM6IDxicj4g4oCiIDxjb2RlPkZGVC53YXZlZm9ybSgpPC9jb2RlPiBjb21wdXRlc1xuICAgKiAgYW1wbGl0dWRlIHZhbHVlcyBhbG9uZyB0aGUgdGltZSBkb21haW4uIFRoZSBhcnJheSBpbmRpY2VzIGNvcnJlc3BvbmRcbiAgICogIHRvIHNhbXBsZXMgYWNyb3NzIGEgYnJpZWYgbW9tZW50IGluIHRpbWUuIEVhY2ggdmFsdWUgcmVwcmVzZW50c1xuICAgKiAgYW1wbGl0dWRlIG9mIHRoZSB3YXZlZm9ybSBhdCB0aGF0IHNhbXBsZSBvZiB0aW1lLjxicj5cbiAgICogIOKAoiA8Y29kZT5GRlQuYW5hbHl6ZSgpIDwvY29kZT4gY29tcHV0ZXMgYW1wbGl0dWRlIHZhbHVlcyBhbG9uZyB0aGVcbiAgICogIGZyZXF1ZW5jeSBkb21haW4uIFRoZSBhcnJheSBpbmRpY2VzIGNvcnJlc3BvbmQgdG8gZnJlcXVlbmNpZXMgKGkuZS5cbiAgICogIHBpdGNoZXMpLCBmcm9tIHRoZSBsb3dlc3QgdG8gdGhlIGhpZ2hlc3QgdGhhdCBodW1hbnMgY2FuIGhlYXIuIEVhY2hcbiAgICogIHZhbHVlIHJlcHJlc2VudHMgYW1wbGl0dWRlIGF0IHRoYXQgc2xpY2Ugb2YgdGhlIGZyZXF1ZW5jeSBzcGVjdHJ1bS5cbiAgICogIFVzZSB3aXRoIDxjb2RlPmdldEVuZXJneSgpPC9jb2RlPiB0byBtZWFzdXJlIGFtcGxpdHVkZSBhdCBzcGVjaWZpY1xuICAgKiAgZnJlcXVlbmNpZXMsIG9yIHdpdGhpbiBhIHJhbmdlIG9mIGZyZXF1ZW5jaWVzLiA8L3A+XG4gICAqXG4gICAqICA8cD5GRlQgYW5hbHl6ZXMgYSB2ZXJ5IHNob3J0IHNuYXBzaG90IG9mIHNvdW5kIGNhbGxlZCBhIHNhbXBsZVxuICAgKiAgYnVmZmVyLiBJdCByZXR1cm5zIGFuIGFycmF5IG9mIGFtcGxpdHVkZSBtZWFzdXJlbWVudHMsIHJlZmVycmVkXG4gICAqICB0byBhcyA8Y29kZT5iaW5zPC9jb2RlPi4gVGhlIGFycmF5IGlzIDEwMjQgYmlucyBsb25nIGJ5IGRlZmF1bHQuXG4gICAqICBZb3UgY2FuIGNoYW5nZSB0aGUgYmluIGFycmF5IGxlbmd0aCwgYnV0IGl0IG11c3QgYmUgYSBwb3dlciBvZiAyXG4gICAqICBiZXR3ZWVuIDE2IGFuZCAxMDI0IGluIG9yZGVyIGZvciB0aGUgRkZUIGFsZ29yaXRobSB0byBmdW5jdGlvblxuICAgKiAgY29ycmVjdGx5LiBUaGUgYWN0dWFsIHNpemUgb2YgdGhlIEZGVCBidWZmZXIgaXMgdHdpY2UgdGhlXG4gICAqICBudW1iZXIgb2YgYmlucywgc28gZ2l2ZW4gYSBzdGFuZGFyZCBzYW1wbGUgcmF0ZSwgdGhlIGJ1ZmZlciBpc1xuICAgKiAgMjA0OC80NDEwMCBzZWNvbmRzIGxvbmcuPC9wPlxuICAgKlxuICAgKlxuICAgKiAgQGNsYXNzIHA1LkZGVFxuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3Ntb290aGluZ10gICBTbW9vdGggcmVzdWx0cyBvZiBGcmVxIFNwZWN0cnVtLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMC4wIDwgc21vb3RoaW5nIDwgMS4wLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gMC44LlxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtiaW5zXSAgICBMZW5ndGggb2YgcmVzdWx0aW5nIGFycmF5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNdXN0IGJlIGEgcG93ZXIgb2YgdHdvIGJldHdlZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgMTYgYW5kIDEwMjQuIERlZmF1bHRzIHRvIDEwMjQuXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGZ1bmN0aW9uIHByZWxvYWQoKXtcbiAgICogICAgc291bmQgPSBsb2FkU291bmQoJ2Fzc2V0cy9EYW1zY3JheV9EYW5jaW5nVGlnZXIubXAzJyk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpe1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwxMDApO1xuICAgKiAgICBjbnYubW91c2VDbGlja2VkKHRvZ2dsZVBsYXkpO1xuICAgKiAgICBmZnQgPSBuZXcgcDUuRkZUKCk7XG4gICAqICAgIHNvdW5kLmFtcCgwLjIpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gZHJhdygpe1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqXG4gICAqICAgIGxldCBzcGVjdHJ1bSA9IGZmdC5hbmFseXplKCk7XG4gICAqICAgIG5vU3Ryb2tlKCk7XG4gICAqICAgIGZpbGwoMjU1LCAwLCAyNTUpO1xuICAgKiAgICBmb3IgKGxldCBpID0gMDsgaTwgc3BlY3RydW0ubGVuZ3RoOyBpKyspe1xuICAgKiAgICAgIGxldCB4ID0gbWFwKGksIDAsIHNwZWN0cnVtLmxlbmd0aCwgMCwgd2lkdGgpO1xuICAgKiAgICAgIGxldCBoID0gLWhlaWdodCArIG1hcChzcGVjdHJ1bVtpXSwgMCwgMjU1LCBoZWlnaHQsIDApO1xuICAgKiAgICAgIHJlY3QoeCwgaGVpZ2h0LCB3aWR0aCAvIHNwZWN0cnVtLmxlbmd0aCwgaCApXG4gICAqICAgIH1cbiAgICpcbiAgICogICAgbGV0IHdhdmVmb3JtID0gZmZ0LndhdmVmb3JtKCk7XG4gICAqICAgIG5vRmlsbCgpO1xuICAgKiAgICBiZWdpblNoYXBlKCk7XG4gICAqICAgIHN0cm9rZSgyMCk7XG4gICAqICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2F2ZWZvcm0ubGVuZ3RoOyBpKyspe1xuICAgKiAgICAgIGxldCB4ID0gbWFwKGksIDAsIHdhdmVmb3JtLmxlbmd0aCwgMCwgd2lkdGgpO1xuICAgKiAgICAgIGxldCB5ID0gbWFwKCB3YXZlZm9ybVtpXSwgLTEsIDEsIDAsIGhlaWdodCk7XG4gICAqICAgICAgdmVydGV4KHgseSk7XG4gICAqICAgIH1cbiAgICogICAgZW5kU2hhcGUoKTtcbiAgICpcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCAyMCwgMjApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gdG9nZ2xlUGxheSgpIHtcbiAgICogICAgaWYgKHNvdW5kLmlzUGxheWluZygpKSB7XG4gICAqICAgICAgc291bmQucGF1c2UoKTtcbiAgICogICAgfSBlbHNlIHtcbiAgICogICAgICBzb3VuZC5sb29wKCk7XG4gICAqICAgIH1cbiAgICogIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5GRlQgPSBmdW5jdGlvbiAoc21vb3RoaW5nLCBiaW5zKSB7XG4gICAgdGhpcy5pbnB1dCA9IHRoaXMuYW5hbHlzZXIgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIGJpbnM6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYW5hbHlzZXIuZmZ0U2l6ZSAvIDI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGIpIHtcbiAgICAgICAgICB0aGlzLmFuYWx5c2VyLmZmdFNpemUgPSBiICogMjtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgc21vb3RoaW5nOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFuYWx5c2VyLnNtb290aGluZ1RpbWVDb25zdGFudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQocykge1xuICAgICAgICAgIHRoaXMuYW5hbHlzZXIuc21vb3RoaW5nVGltZUNvbnN0YW50ID0gcztcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7IFxuXG4gICAgdGhpcy5zbW9vdGgoc21vb3RoaW5nKTtcbiAgICB0aGlzLmJpbnMgPSBiaW5zIHx8IDEwMjQ7IFxuXG4gICAgcDVzb3VuZC5mZnRNZXRlci5jb25uZWN0KHRoaXMuYW5hbHlzZXIpO1xuICAgIHRoaXMuZnJlcURvbWFpbiA9IG5ldyBVaW50OEFycmF5KHRoaXMuYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuICAgIHRoaXMudGltZURvbWFpbiA9IG5ldyBVaW50OEFycmF5KHRoaXMuYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpOyBcblxuICAgIHRoaXMuYmFzcyA9IFsyMCwgMTQwXTtcbiAgICB0aGlzLmxvd01pZCA9IFsxNDAsIDQwMF07XG4gICAgdGhpcy5taWQgPSBbNDAwLCAyNjAwXTtcbiAgICB0aGlzLmhpZ2hNaWQgPSBbMjYwMCwgNTIwMF07XG4gICAgdGhpcy50cmVibGUgPSBbNTIwMCwgMTQwMDBdOyBcblxuICAgIHA1c291bmQuc291bmRBcnJheS5wdXNoKHRoaXMpO1xuICB9O1xuICAvKipcbiAgICogIFNldCB0aGUgaW5wdXQgc291cmNlIGZvciB0aGUgRkZUIGFuYWx5c2lzLiBJZiBubyBzb3VyY2UgaXNcbiAgICogIHByb3ZpZGVkLCBGRlQgd2lsbCBhbmFseXplIGFsbCBzb3VuZCBpbiB0aGUgc2tldGNoLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgc2V0SW5wdXRcbiAgICogIEBmb3IgcDUuRkZUXG4gICAqICBAcGFyYW0ge09iamVjdH0gW3NvdXJjZV0gcDUuc291bmQgb2JqZWN0IChvciB3ZWIgYXVkaW8gQVBJIHNvdXJjZSBub2RlKVxuICAgKi9cblxuXG4gIHA1LkZGVC5wcm90b3R5cGUuc2V0SW5wdXQgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgIHA1c291bmQuZmZ0TWV0ZXIuY29ubmVjdCh0aGlzLmFuYWx5c2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNvdXJjZS5vdXRwdXQpIHtcbiAgICAgICAgc291cmNlLm91dHB1dC5jb25uZWN0KHRoaXMuYW5hbHlzZXIpO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2UuY29ubmVjdCkge1xuICAgICAgICBzb3VyY2UuY29ubmVjdCh0aGlzLmFuYWx5c2VyKTtcbiAgICAgIH1cblxuICAgICAgcDVzb3VuZC5mZnRNZXRlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIFJldHVybnMgYW4gYXJyYXkgb2YgYW1wbGl0dWRlIHZhbHVlcyAoYmV0d2VlbiAtMS4wIGFuZCArMS4wKSB0aGF0IHJlcHJlc2VudFxuICAgKiAgYSBzbmFwc2hvdCBvZiBhbXBsaXR1ZGUgcmVhZGluZ3MgaW4gYSBzaW5nbGUgYnVmZmVyLiBMZW5ndGggd2lsbCBiZVxuICAgKiAgZXF1YWwgdG8gYmlucyAoZGVmYXVsdHMgdG8gMTAyNCkuIENhbiBiZSB1c2VkIHRvIGRyYXcgdGhlIHdhdmVmb3JtXG4gICAqICBvZiBhIHNvdW5kLlxuICAgKlxuICAgKiAgQG1ldGhvZCB3YXZlZm9ybVxuICAgKiAgQGZvciBwNS5GRlRcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbYmluc10gICAgTXVzdCBiZSBhIHBvd2VyIG9mIHR3byBiZXR3ZWVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE2IGFuZCAxMDI0LiBEZWZhdWx0cyB0byAxMDI0LlxuICAgKiAgQHBhcmFtIHtTdHJpbmd9IFtwcmVjaXNpb25dIElmIGFueSB2YWx1ZSBpcyBwcm92aWRlZCwgd2lsbCByZXR1cm4gcmVzdWx0c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIGEgRmxvYXQzMiBBcnJheSB3aGljaCBpcyBtb3JlIHByZWNpc2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGFuIGEgcmVndWxhciBhcnJheS5cbiAgICogIEByZXR1cm4ge0FycmF5fSAgQXJyYXkgICAgQXJyYXkgb2YgYW1wbGl0dWRlIHZhbHVlcyAoLTEgdG8gMSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlciB0aW1lLiBBcnJheSBsZW5ndGggPSBiaW5zLlxuICAgKlxuICAgKi9cblxuXG4gIHA1LkZGVC5wcm90b3R5cGUud2F2ZWZvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJpbnMsIG1vZGUsIG5vcm1hbEFycmF5O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICBiaW5zID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB0aGlzLmFuYWx5c2VyLmZmdFNpemUgPSBiaW5zICogMjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1vZGUgPSBhcmd1bWVudHNbaV07XG4gICAgICB9XG4gICAgfSBcblxuXG4gICAgaWYgKG1vZGUgJiYgIXA1LnByb3RvdHlwZS5faXNTYWZhcmkoKSkge1xuICAgICAgdGltZVRvRmxvYXQodGhpcywgdGhpcy50aW1lRG9tYWluKTtcbiAgICAgIHRoaXMuYW5hbHlzZXIuZ2V0RmxvYXRUaW1lRG9tYWluRGF0YSh0aGlzLnRpbWVEb21haW4pO1xuICAgICAgcmV0dXJuIHRoaXMudGltZURvbWFpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZVRvSW50KHRoaXMsIHRoaXMudGltZURvbWFpbik7XG4gICAgICB0aGlzLmFuYWx5c2VyLmdldEJ5dGVUaW1lRG9tYWluRGF0YSh0aGlzLnRpbWVEb21haW4pO1xuICAgICAgdmFyIG5vcm1hbEFycmF5ID0gbmV3IEFycmF5KCk7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy50aW1lRG9tYWluLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBzY2FsZWQgPSBwNS5wcm90b3R5cGUubWFwKHRoaXMudGltZURvbWFpbltqXSwgMCwgMjU1LCAtMSwgMSk7XG4gICAgICAgIG5vcm1hbEFycmF5LnB1c2goc2NhbGVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vcm1hbEFycmF5O1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBSZXR1cm5zIGFuIGFycmF5IG9mIGFtcGxpdHVkZSB2YWx1ZXMgKGJldHdlZW4gMCBhbmQgMjU1KVxuICAgKiAgYWNyb3NzIHRoZSBmcmVxdWVuY3kgc3BlY3RydW0uIExlbmd0aCBpcyBlcXVhbCB0byBGRlQgYmluc1xuICAgKiAgKDEwMjQgYnkgZGVmYXVsdCkuIFRoZSBhcnJheSBpbmRpY2VzIGNvcnJlc3BvbmQgdG8gZnJlcXVlbmNpZXNcbiAgICogIChpLmUuIHBpdGNoZXMpLCBmcm9tIHRoZSBsb3dlc3QgdG8gdGhlIGhpZ2hlc3QgdGhhdCBodW1hbnMgY2FuXG4gICAqICBoZWFyLiBFYWNoIHZhbHVlIHJlcHJlc2VudHMgYW1wbGl0dWRlIGF0IHRoYXQgc2xpY2Ugb2YgdGhlXG4gICAqICBmcmVxdWVuY3kgc3BlY3RydW0uIE11c3QgYmUgY2FsbGVkIHByaW9yIHRvIHVzaW5nXG4gICAqICA8Y29kZT5nZXRFbmVyZ3koKTwvY29kZT4uXG4gICAqXG4gICAqICBAbWV0aG9kIGFuYWx5emVcbiAgICogIEBmb3IgcDUuRkZUXG4gICAqICBAcGFyYW0ge051bWJlcn0gW2JpbnNdICAgIE11c3QgYmUgYSBwb3dlciBvZiB0d28gYmV0d2VlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTYgYW5kIDEwMjQuIERlZmF1bHRzIHRvIDEwMjQuXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSAgICBJZiBcImRCLFwiIHJldHVybnMgZGVjaWJlbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbWVhc3VyZW1lbnRzIGJldHdlZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xNDAgYW5kIDAgKG1heCkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPdGhlcndpc2UgcmV0dXJucyBpbnRlZ2VycyBmcm9tIDAtMjU1LlxuICAgKiAgQHJldHVybiB7QXJyYXl9IHNwZWN0cnVtICAgIEFycmF5IG9mIGVuZXJneSAoYW1wbGl0dWRlL3ZvbHVtZSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgYWNyb3NzIHRoZSBmcmVxdWVuY3kgc3BlY3RydW0uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTG93ZXN0IGVuZXJneSAoc2lsZW5jZSkgPSAwLCBoaWdoZXN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGUgaXMgMjU1LlxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgb3NjLCBmZnQ7XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpe1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHN0YXJ0U291bmQpO1xuICAgKiAgICBvc2MgPSBuZXcgcDUuT3NjaWxsYXRvcigpO1xuICAgKiAgICBvc2MuYW1wKDApO1xuICAgKiAgICBmZnQgPSBuZXcgcDUuRkZUKCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBkcmF3KCl7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICpcbiAgICogICAgbGV0IGZyZXEgPSBtYXAobW91c2VYLCAwLCB3aW5kb3dXaWR0aCwgMjAsIDEwMDAwKTtcbiAgICogICAgZnJlcSA9IGNvbnN0cmFpbihmcmVxLCAxLCAyMDAwMCk7XG4gICAqICAgIG9zYy5mcmVxKGZyZXEpO1xuICAgKlxuICAgKiAgICBsZXQgc3BlY3RydW0gPSBmZnQuYW5hbHl6ZSgpO1xuICAgKiAgICBub1N0cm9rZSgpO1xuICAgKiAgICBmaWxsKDI1NSwgMCwgMjU1KTtcbiAgICogICAgZm9yIChsZXQgaSA9IDA7IGk8IHNwZWN0cnVtLmxlbmd0aDsgaSsrKXtcbiAgICogICAgICBsZXQgeCA9IG1hcChpLCAwLCBzcGVjdHJ1bS5sZW5ndGgsIDAsIHdpZHRoKTtcbiAgICogICAgICBsZXQgaCA9IC1oZWlnaHQgKyBtYXAoc3BlY3RydW1baV0sIDAsIDI1NSwgaGVpZ2h0LCAwKTtcbiAgICogICAgICByZWN0KHgsIGhlaWdodCwgd2lkdGggLyBzcGVjdHJ1bS5sZW5ndGgsIGggKTtcbiAgICogICAgfVxuICAgKlxuICAgKiAgICBzdHJva2UoMjU1KTtcbiAgICogICAgaWYgKCFvc2Muc3RhcnRlZCkge1xuICAgKiAgICAgIHRleHQoJ3RhcCBoZXJlIGFuZCBkcmFnIHRvIGNoYW5nZSBmcmVxdWVuY3knLCAxMCwgMjAsIHdpZHRoIC0gMjApO1xuICAgKiAgICB9IGVsc2Uge1xuICAgKiAgICAgIHRleHQocm91bmQoZnJlcSkrJ0h6JywgMTAsIDIwKTtcbiAgICogICAgfVxuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gc3RhcnRTb3VuZCgpIHtcbiAgICogICAgb3NjLnN0YXJ0KCk7XG4gICAqICAgIG9zYy5hbXAoMC41LCAwLjIpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gbW91c2VSZWxlYXNlZCgpIHtcbiAgICogICAgb3NjLmFtcCgwLCAwLjIpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKlxuICAgKlxuICAgKi9cblxuXG4gIHA1LkZGVC5wcm90b3R5cGUuYW5hbHl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5iaW5zID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB0aGlzLmFuYWx5c2VyLmZmdFNpemUgPSB0aGlzLmJpbnMgKiAyO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbW9kZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kZSAmJiBtb2RlLnRvTG93ZXJDYXNlKCkgPT09ICdkYicpIHtcbiAgICAgIGZyZXFUb0Zsb2F0KHRoaXMpO1xuICAgICAgdGhpcy5hbmFseXNlci5nZXRGbG9hdEZyZXF1ZW5jeURhdGEodGhpcy5mcmVxRG9tYWluKTtcbiAgICAgIHJldHVybiB0aGlzLmZyZXFEb21haW47XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyZXFUb0ludCh0aGlzLCB0aGlzLmZyZXFEb21haW4pO1xuICAgICAgdGhpcy5hbmFseXNlci5nZXRCeXRlRnJlcXVlbmN5RGF0YSh0aGlzLmZyZXFEb21haW4pO1xuICAgICAgdmFyIG5vcm1hbEFycmF5ID0gQXJyYXkuYXBwbHkoW10sIHRoaXMuZnJlcURvbWFpbik7XG4gICAgICByZXR1cm4gbm9ybWFsQXJyYXk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIFJldHVybnMgdGhlIGFtb3VudCBvZiBlbmVyZ3kgKHZvbHVtZSkgYXQgYSBzcGVjaWZpY1xuICAgKiAgPGEgaHJlZj1cImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0F1ZGlvX2ZyZXF1ZW5jeVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgKiAgZnJlcXVlbmN5PC9hPiwgb3IgdGhlIGF2ZXJhZ2UgYW1vdW50IG9mIGVuZXJneSBiZXR3ZWVuIHR3b1xuICAgKiAgZnJlcXVlbmNpZXMuIEFjY2VwdHMgTnVtYmVyKHMpIGNvcnJlc3BvbmRpbmdcbiAgICogIHRvIGZyZXF1ZW5jeSAoaW4gSHopLCBvciBhIFN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHByZWRlZmluZWRcbiAgICogIGZyZXF1ZW5jeSByYW5nZXMgKFwiYmFzc1wiLCBcImxvd01pZFwiLCBcIm1pZFwiLCBcImhpZ2hNaWRcIiwgXCJ0cmVibGVcIikuXG4gICAqICBSZXR1cm5zIGEgcmFuZ2UgYmV0d2VlbiAwIChubyBlbmVyZ3kvdm9sdW1lIGF0IHRoYXQgZnJlcXVlbmN5KSBhbmRcbiAgICogIDI1NSAobWF4aW11bSBlbmVyZ3kpLlxuICAgKiAgPGVtPk5PVEU6IGFuYWx5emUoKSBtdXN0IGJlIGNhbGxlZCBwcmlvciB0byBnZXRFbmVyZ3koKS4gQW5hbHl6ZSgpXG4gICAqICB0ZWxscyB0aGUgRkZUIHRvIGFuYWx5emUgZnJlcXVlbmN5IGRhdGEsIGFuZCBnZXRFbmVyZ3koKSB1c2VzXG4gICAqICB0aGUgcmVzdWx0cyBkZXRlcm1pbmUgdGhlIHZhbHVlIGF0IGEgc3BlY2lmaWMgZnJlcXVlbmN5IG9yXG4gICAqICByYW5nZSBvZiBmcmVxdWVuY2llcy48L2VtPjwvcD5cbiAgICpcbiAgICogIEBtZXRob2QgIGdldEVuZXJneVxuICAgKiAgQGZvciBwNS5GRlRcbiAgICogIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IGZyZXF1ZW5jeTEgICBXaWxsIHJldHVybiBhIHZhbHVlIHJlcHJlc2VudGluZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5lcmd5IGF0IHRoaXMgZnJlcXVlbmN5LiBBbHRlcm5hdGVseSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBzdHJpbmdzIFwiYmFzc1wiLCBcImxvd01pZFwiIFwibWlkXCIsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImhpZ2hNaWRcIiwgYW5kIFwidHJlYmxlXCIgd2lsbCByZXR1cm5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWRlZmluZWQgZnJlcXVlbmN5IHJhbmdlcy5cbiAgICogIEBwYXJhbSAge051bWJlcn0gW2ZyZXF1ZW5jeTJdIElmIGEgc2Vjb25kIGZyZXF1ZW5jeSBpcyBnaXZlbixcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgcmV0dXJuIGF2ZXJhZ2UgYW1vdW50IG9mXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmVyZ3kgdGhhdCBleGlzdHMgYmV0d2VlbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3byBmcmVxdWVuY2llcy5cbiAgICogIEByZXR1cm4ge051bWJlcn0gICBFbmVyZ3kgICBFbmVyZ3kgKHZvbHVtZS9hbXBsaXR1ZGUpIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwIGFuZCAyNTUuXG4gICAqXG4gICAqL1xuXG5cbiAgcDUuRkZULnByb3RvdHlwZS5nZXRFbmVyZ3kgPSBmdW5jdGlvbiAoZnJlcXVlbmN5MSwgZnJlcXVlbmN5Mikge1xuICAgIHZhciBueXF1aXN0ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuc2FtcGxlUmF0ZSAvIDI7XG5cbiAgICBpZiAoZnJlcXVlbmN5MSA9PT0gJ2Jhc3MnKSB7XG4gICAgICBmcmVxdWVuY3kxID0gdGhpcy5iYXNzWzBdO1xuICAgICAgZnJlcXVlbmN5MiA9IHRoaXMuYmFzc1sxXTtcbiAgICB9IGVsc2UgaWYgKGZyZXF1ZW5jeTEgPT09ICdsb3dNaWQnKSB7XG4gICAgICBmcmVxdWVuY3kxID0gdGhpcy5sb3dNaWRbMF07XG4gICAgICBmcmVxdWVuY3kyID0gdGhpcy5sb3dNaWRbMV07XG4gICAgfSBlbHNlIGlmIChmcmVxdWVuY3kxID09PSAnbWlkJykge1xuICAgICAgZnJlcXVlbmN5MSA9IHRoaXMubWlkWzBdO1xuICAgICAgZnJlcXVlbmN5MiA9IHRoaXMubWlkWzFdO1xuICAgIH0gZWxzZSBpZiAoZnJlcXVlbmN5MSA9PT0gJ2hpZ2hNaWQnKSB7XG4gICAgICBmcmVxdWVuY3kxID0gdGhpcy5oaWdoTWlkWzBdO1xuICAgICAgZnJlcXVlbmN5MiA9IHRoaXMuaGlnaE1pZFsxXTtcbiAgICB9IGVsc2UgaWYgKGZyZXF1ZW5jeTEgPT09ICd0cmVibGUnKSB7XG4gICAgICBmcmVxdWVuY3kxID0gdGhpcy50cmVibGVbMF07XG4gICAgICBmcmVxdWVuY3kyID0gdGhpcy50cmVibGVbMV07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmcmVxdWVuY3kxICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgJ2ludmFsaWQgaW5wdXQgZm9yIGdldEVuZXJneSgpJztcbiAgICB9IGVsc2UgaWYgKCFmcmVxdWVuY3kyKSB7XG4gICAgICB2YXIgaW5kZXggPSBNYXRoLnJvdW5kKGZyZXF1ZW5jeTEgLyBueXF1aXN0ICogdGhpcy5mcmVxRG9tYWluLmxlbmd0aCk7XG4gICAgICByZXR1cm4gdGhpcy5mcmVxRG9tYWluW2luZGV4XTtcbiAgICB9IGVsc2UgaWYgKGZyZXF1ZW5jeTEgJiYgZnJlcXVlbmN5Mikge1xuICAgICAgaWYgKGZyZXF1ZW5jeTEgPiBmcmVxdWVuY3kyKSB7XG4gICAgICAgIHZhciBzd2FwID0gZnJlcXVlbmN5MjtcbiAgICAgICAgZnJlcXVlbmN5MiA9IGZyZXF1ZW5jeTE7XG4gICAgICAgIGZyZXF1ZW5jeTEgPSBzd2FwO1xuICAgICAgfVxuXG4gICAgICB2YXIgbG93SW5kZXggPSBNYXRoLnJvdW5kKGZyZXF1ZW5jeTEgLyBueXF1aXN0ICogdGhpcy5mcmVxRG9tYWluLmxlbmd0aCk7XG4gICAgICB2YXIgaGlnaEluZGV4ID0gTWF0aC5yb3VuZChmcmVxdWVuY3kyIC8gbnlxdWlzdCAqIHRoaXMuZnJlcURvbWFpbi5sZW5ndGgpO1xuICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgIHZhciBudW1GcmVxdWVuY2llcyA9IDA7IFxuXG4gICAgICBmb3IgKHZhciBpID0gbG93SW5kZXg7IGkgPD0gaGlnaEluZGV4OyBpKyspIHtcbiAgICAgICAgdG90YWwgKz0gdGhpcy5mcmVxRG9tYWluW2ldO1xuICAgICAgICBudW1GcmVxdWVuY2llcyArPSAxO1xuICAgICAgfSBcblxuXG4gICAgICB2YXIgdG9SZXR1cm4gPSB0b3RhbCAvIG51bUZyZXF1ZW5jaWVzO1xuICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyAnaW52YWxpZCBpbnB1dCBmb3IgZ2V0RW5lcmd5KCknO1xuICAgIH1cbiAgfTsgXG5cblxuICBwNS5GRlQucHJvdG90eXBlLmdldEZyZXEgPSBmdW5jdGlvbiAoZnJlcTEsIGZyZXEyKSB7XG4gICAgY29uc29sZS5sb2coJ2dldEZyZXEoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGdldEVuZXJneSgpIGluc3RlYWQuJyk7XG4gICAgdmFyIHggPSB0aGlzLmdldEVuZXJneShmcmVxMSwgZnJlcTIpO1xuICAgIHJldHVybiB4O1xuICB9O1xuICAvKipcbiAgICogIFJldHVybnMgdGhlXG4gICAqICA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGVjdHJhbF9jZW50cm9pZFwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgKiAgc3BlY3RyYWwgY2VudHJvaWQ8L2E+IG9mIHRoZSBpbnB1dCBzaWduYWwuXG4gICAqICA8ZW0+Tk9URTogYW5hbHl6ZSgpIG11c3QgYmUgY2FsbGVkIHByaW9yIHRvIGdldENlbnRyb2lkKCkuIEFuYWx5emUoKVxuICAgKiAgdGVsbHMgdGhlIEZGVCB0byBhbmFseXplIGZyZXF1ZW5jeSBkYXRhLCBhbmQgZ2V0Q2VudHJvaWQoKSB1c2VzXG4gICAqICB0aGUgcmVzdWx0cyBkZXRlcm1pbmUgdGhlIHNwZWN0cmFsIGNlbnRyb2lkLjwvZW0+PC9wPlxuICAgKlxuICAgKiAgQG1ldGhvZCAgZ2V0Q2VudHJvaWRcbiAgICogIEBmb3IgcDUuRkZUXG4gICAqICBAcmV0dXJuIHtOdW1iZXJ9ICAgU3BlY3RyYWwgQ2VudHJvaWQgRnJlcXVlbmN5ICAgRnJlcXVlbmN5IG9mIHRoZSBzcGVjdHJhbCBjZW50cm9pZCBpbiBIei5cbiAgICpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqIGZ1bmN0aW9uIHNldHVwKCl7XG4gICAqICBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLDEwMCk7XG4gICAqICBjbnYubW91c2VQcmVzc2VkKHVzZXJTdGFydEF1ZGlvKTtcbiAgICogIHNvdW5kID0gbmV3IHA1LkF1ZGlvSW4oKTtcbiAgICogIHNvdW5kLnN0YXJ0KCk7XG4gICAqICBmZnQgPSBuZXcgcDUuRkZUKCk7XG4gICAqICBzb3VuZC5jb25uZWN0KGZmdCk7XG4gICAqfVxuICAgKlxuICAgKmZ1bmN0aW9uIGRyYXcoKSB7XG4gICAqICBpZiAoZ2V0QXVkaW9Db250ZXh0KCkuc3RhdGUgIT09ICdydW5uaW5nJykge1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ3RhcCBoZXJlIGFuZCBlbmFibGUgbWljIHRvIGJlZ2luJywgMTAsIDIwLCB3aWR0aCAtIDIwKTtcbiAgICogICAgcmV0dXJuO1xuICAgKiAgfVxuICAgKiAgbGV0IGNlbnRyb2lkcGxvdCA9IDAuMDtcbiAgICogIGxldCBzcGVjdHJhbENlbnRyb2lkID0gMDtcbiAgICpcbiAgICogIGJhY2tncm91bmQoMCk7XG4gICAqICBzdHJva2UoMCwyNTUsMCk7XG4gICAqICBsZXQgc3BlY3RydW0gPSBmZnQuYW5hbHl6ZSgpO1xuICAgKiAgZmlsbCgwLDI1NSwwKTsgLy8gc3BlY3RydW0gaXMgZ3JlZW5cbiAgICpcbiAgICogIC8vZHJhdyB0aGUgc3BlY3RydW1cbiAgICogIGZvciAobGV0IGkgPSAwOyBpIDwgc3BlY3RydW0ubGVuZ3RoOyBpKyspe1xuICAgKiAgICBsZXQgeCA9IG1hcChsb2coaSksIDAsIGxvZyhzcGVjdHJ1bS5sZW5ndGgpLCAwLCB3aWR0aCk7XG4gICAqICAgIGxldCBoID0gbWFwKHNwZWN0cnVtW2ldLCAwLCAyNTUsIDAsIGhlaWdodCk7XG4gICAqICAgIGxldCByZWN0YW5nbGVfd2lkdGggPSAobG9nKGkrMSktbG9nKGkpKSood2lkdGgvbG9nKHNwZWN0cnVtLmxlbmd0aCkpO1xuICAgKiAgICByZWN0KHgsIGhlaWdodCwgcmVjdGFuZ2xlX3dpZHRoLCAtaCApXG4gICAqICB9XG4gICAqICBsZXQgbnlxdWlzdCA9IDIyMDUwO1xuICAgKlxuICAgKiAgLy8gZ2V0IHRoZSBjZW50cm9pZFxuICAgKiAgc3BlY3RyYWxDZW50cm9pZCA9IGZmdC5nZXRDZW50cm9pZCgpO1xuICAgKlxuICAgKiAgLy8gdGhlIG1lYW5fZnJlcV9pbmRleCBjYWxjdWxhdGlvbiBpcyBmb3IgdGhlIGRpc3BsYXkuXG4gICAqICBsZXQgbWVhbl9mcmVxX2luZGV4ID0gc3BlY3RyYWxDZW50cm9pZC8obnlxdWlzdC9zcGVjdHJ1bS5sZW5ndGgpO1xuICAgKlxuICAgKiAgY2VudHJvaWRwbG90ID0gbWFwKGxvZyhtZWFuX2ZyZXFfaW5kZXgpLCAwLCBsb2coc3BlY3RydW0ubGVuZ3RoKSwgMCwgd2lkdGgpO1xuICAgKlxuICAgKiAgc3Ryb2tlKDI1NSwwLDApOyAvLyB0aGUgbGluZSBzaG93aW5nIHdoZXJlIHRoZSBjZW50cm9pZCBpcyB3aWxsIGJlIHJlZFxuICAgKlxuICAgKiAgcmVjdChjZW50cm9pZHBsb3QsIDAsIHdpZHRoIC8gc3BlY3RydW0ubGVuZ3RoLCBoZWlnaHQpXG4gICAqICBub1N0cm9rZSgpO1xuICAgKiAgZmlsbCgyNTUsMjU1LDI1NSk7ICAvLyB0ZXh0IGlzIHdoaXRlXG4gICAqICB0ZXh0KCdjZW50cm9pZDogJywgMTAsIDIwKTtcbiAgICogIHRleHQocm91bmQoc3BlY3RyYWxDZW50cm9pZCkrJyBIeicsIDEwLCA0MCk7XG4gICAqfVxuICAgKiA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuRkZULnByb3RvdHlwZS5nZXRDZW50cm9pZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbnlxdWlzdCA9IHA1c291bmQuYXVkaW9jb250ZXh0LnNhbXBsZVJhdGUgLyAyO1xuICAgIHZhciBjdW11bGF0aXZlX3N1bSA9IDA7XG4gICAgdmFyIGNlbnRyb2lkX25vcm1hbGl6YXRpb24gPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZyZXFEb21haW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1bXVsYXRpdmVfc3VtICs9IGkgKiB0aGlzLmZyZXFEb21haW5baV07XG4gICAgICBjZW50cm9pZF9ub3JtYWxpemF0aW9uICs9IHRoaXMuZnJlcURvbWFpbltpXTtcbiAgICB9XG5cbiAgICB2YXIgbWVhbl9mcmVxX2luZGV4ID0gMDtcblxuICAgIGlmIChjZW50cm9pZF9ub3JtYWxpemF0aW9uICE9PSAwKSB7XG4gICAgICBtZWFuX2ZyZXFfaW5kZXggPSBjdW11bGF0aXZlX3N1bSAvIGNlbnRyb2lkX25vcm1hbGl6YXRpb247XG4gICAgfVxuXG4gICAgdmFyIHNwZWNfY2VudHJvaWRfZnJlcSA9IG1lYW5fZnJlcV9pbmRleCAqIChueXF1aXN0IC8gdGhpcy5mcmVxRG9tYWluLmxlbmd0aCk7XG4gICAgcmV0dXJuIHNwZWNfY2VudHJvaWRfZnJlcTtcbiAgfTtcbiAgLyoqXG4gICAqICBTbW9vdGggRkZUIGFuYWx5c2lzIGJ5IGF2ZXJhZ2luZyB3aXRoIHRoZSBsYXN0IGFuYWx5c2lzIGZyYW1lLlxuICAgKlxuICAgKiAgQG1ldGhvZCBzbW9vdGhcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBzbW9vdGhpbmcgICAgMC4wIDwgc21vb3RoaW5nIDwgMS4wLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byAwLjguXG4gICAqL1xuXG5cbiAgcDUuRkZULnByb3RvdHlwZS5zbW9vdGggPSBmdW5jdGlvbiAocykge1xuICAgIGlmICh0eXBlb2YgcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuc21vb3RoaW5nID0gcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zbW9vdGhpbmc7XG4gIH07XG5cbiAgcDUuRkZULnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmRleCA9IHA1c291bmQuc291bmRBcnJheS5pbmRleE9mKHRoaXMpO1xuICAgIHA1c291bmQuc291bmRBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgaWYgKHRoaXMuYW5hbHlzZXIpIHtcbiAgICAgIHRoaXMuYW5hbHlzZXIuZGlzY29ubmVjdCgpO1xuICAgICAgZGVsZXRlIHRoaXMuYW5hbHlzZXI7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIFJldHVybnMgYW4gYXJyYXkgb2YgYXZlcmFnZSBhbXBsaXR1ZGUgdmFsdWVzIGZvciBhIGdpdmVuIG51bWJlclxuICAgKiAgb2YgZnJlcXVlbmN5IGJhbmRzIHNwbGl0IGVxdWFsbHkuIE4gZGVmYXVsdHMgdG8gMTYuXG4gICAqICA8ZW0+Tk9URTogYW5hbHl6ZSgpIG11c3QgYmUgY2FsbGVkIHByaW9yIHRvIGxpbkF2ZXJhZ2VzKCkuIEFuYWx5emUoKVxuICAgKiAgdGVsbHMgdGhlIEZGVCB0byBhbmFseXplIGZyZXF1ZW5jeSBkYXRhLCBhbmQgbGluQXZlcmFnZXMoKSB1c2VzXG4gICAqICB0aGUgcmVzdWx0cyB0byBncm91cCB0aGVtIGludG8gYSBzbWFsbGVyIHNldCBvZiBhdmVyYWdlcy48L2VtPjwvcD5cbiAgICpcbiAgICogIEBtZXRob2QgIGxpbkF2ZXJhZ2VzXG4gICAqICBAZm9yIHA1LkZGVFxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSAgTiAgICAgICAgICAgICAgICBOdW1iZXIgb2YgcmV0dXJuZWQgZnJlcXVlbmN5IGdyb3Vwc1xuICAgKiAgQHJldHVybiB7QXJyYXl9ICAgbGluZWFyQXZlcmFnZXMgICBBcnJheSBvZiBhdmVyYWdlIGFtcGxpdHVkZSB2YWx1ZXMgZm9yIGVhY2ggZ3JvdXBcbiAgICovXG5cblxuICBwNS5GRlQucHJvdG90eXBlLmxpbkF2ZXJhZ2VzID0gZnVuY3Rpb24gKE4pIHtcbiAgICB2YXIgTiA9IE4gfHwgMTY7IFxuXG4gICAgdmFyIHNwZWN0cnVtID0gdGhpcy5mcmVxRG9tYWluO1xuICAgIHZhciBzcGVjdHJ1bUxlbmd0aCA9IHNwZWN0cnVtLmxlbmd0aDtcbiAgICB2YXIgc3BlY3RydW1TdGVwID0gTWF0aC5mbG9vcihzcGVjdHJ1bUxlbmd0aCAvIE4pO1xuICAgIHZhciBsaW5lYXJBdmVyYWdlcyA9IG5ldyBBcnJheShOKTsgXG5cbiAgICB2YXIgZ3JvdXBJbmRleCA9IDA7XG5cbiAgICBmb3IgKHZhciBzcGVjSW5kZXggPSAwOyBzcGVjSW5kZXggPCBzcGVjdHJ1bUxlbmd0aDsgc3BlY0luZGV4KyspIHtcbiAgICAgIGxpbmVhckF2ZXJhZ2VzW2dyb3VwSW5kZXhdID0gbGluZWFyQXZlcmFnZXNbZ3JvdXBJbmRleF0gIT09IHVuZGVmaW5lZCA/IChsaW5lYXJBdmVyYWdlc1tncm91cEluZGV4XSArIHNwZWN0cnVtW3NwZWNJbmRleF0pIC8gMiA6IHNwZWN0cnVtW3NwZWNJbmRleF07IFxuXG4gICAgICBpZiAoc3BlY0luZGV4ICUgc3BlY3RydW1TdGVwID09PSBzcGVjdHJ1bVN0ZXAgLSAxKSB7XG4gICAgICAgIGdyb3VwSW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGluZWFyQXZlcmFnZXM7XG4gIH07XG4gIC8qKlxuICAgKiAgUmV0dXJucyBhbiBhcnJheSBvZiBhdmVyYWdlIGFtcGxpdHVkZSB2YWx1ZXMgb2YgdGhlIHNwZWN0cnVtLCBmb3IgYSBnaXZlblxuICAgKiAgc2V0IG9mIDxhIGhyZWY9XCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PY3RhdmVfYmFuZFwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgKiAgT2N0YXZlIEJhbmRzPC9hPlxuICAgKiAgPGVtPk5PVEU6IGFuYWx5emUoKSBtdXN0IGJlIGNhbGxlZCBwcmlvciB0byBsb2dBdmVyYWdlcygpLiBBbmFseXplKClcbiAgICogIHRlbGxzIHRoZSBGRlQgdG8gYW5hbHl6ZSBmcmVxdWVuY3kgZGF0YSwgYW5kIGxvZ0F2ZXJhZ2VzKCkgdXNlc1xuICAgKiAgdGhlIHJlc3VsdHMgdG8gZ3JvdXAgdGhlbSBpbnRvIGEgc21hbGxlciBzZXQgb2YgYXZlcmFnZXMuPC9lbT48L3A+XG4gICAqXG4gICAqICBAbWV0aG9kICBsb2dBdmVyYWdlc1xuICAgKiAgQGZvciBwNS5GRlRcbiAgICogIEBwYXJhbSAge0FycmF5fSAgIG9jdGF2ZUJhbmRzICAgIEFycmF5IG9mIE9jdGF2ZSBCYW5kcyBvYmplY3RzIGZvciBncm91cGluZ1xuICAgKiAgQHJldHVybiB7QXJyYXl9ICAgbG9nQXZlcmFnZXMgICAgQXJyYXkgb2YgYXZlcmFnZSBhbXBsaXR1ZGUgdmFsdWVzIGZvciBlYWNoIGdyb3VwXG4gICAqL1xuXG5cbiAgcDUuRkZULnByb3RvdHlwZS5sb2dBdmVyYWdlcyA9IGZ1bmN0aW9uIChvY3RhdmVCYW5kcykge1xuICAgIHZhciBueXF1aXN0ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuc2FtcGxlUmF0ZSAvIDI7XG4gICAgdmFyIHNwZWN0cnVtID0gdGhpcy5mcmVxRG9tYWluO1xuICAgIHZhciBzcGVjdHJ1bUxlbmd0aCA9IHNwZWN0cnVtLmxlbmd0aDtcbiAgICB2YXIgbG9nQXZlcmFnZXMgPSBuZXcgQXJyYXkob2N0YXZlQmFuZHMubGVuZ3RoKTsgXG5cbiAgICB2YXIgb2N0YXZlSW5kZXggPSAwO1xuXG4gICAgZm9yICh2YXIgc3BlY0luZGV4ID0gMDsgc3BlY0luZGV4IDwgc3BlY3RydW1MZW5ndGg7IHNwZWNJbmRleCsrKSB7XG4gICAgICB2YXIgc3BlY0luZGV4RnJlcXVlbmN5ID0gTWF0aC5yb3VuZChzcGVjSW5kZXggKiBueXF1aXN0IC8gdGhpcy5mcmVxRG9tYWluLmxlbmd0aCk7IFxuXG4gICAgICBpZiAoc3BlY0luZGV4RnJlcXVlbmN5ID4gb2N0YXZlQmFuZHNbb2N0YXZlSW5kZXhdLmhpKSB7XG4gICAgICAgIG9jdGF2ZUluZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIGxvZ0F2ZXJhZ2VzW29jdGF2ZUluZGV4XSA9IGxvZ0F2ZXJhZ2VzW29jdGF2ZUluZGV4XSAhPT0gdW5kZWZpbmVkID8gKGxvZ0F2ZXJhZ2VzW29jdGF2ZUluZGV4XSArIHNwZWN0cnVtW3NwZWNJbmRleF0pIC8gMiA6IHNwZWN0cnVtW3NwZWNJbmRleF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvZ0F2ZXJhZ2VzO1xuICB9O1xuICAvKipcbiAgICogIENhbGN1bGF0ZXMgYW5kIFJldHVybnMgdGhlIDEvTlxuICAgKiAgPGEgaHJlZj1cImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09jdGF2ZV9iYW5kXCIgdGFyZ2V0PVwiX2JsYW5rXCI+T2N0YXZlIEJhbmRzPC9hPlxuICAgKiAgTiBkZWZhdWx0cyB0byAzIGFuZCBtaW5pbXVtIGNlbnRyYWwgZnJlcXVlbmN5IHRvIDE1LjYyNUh6LlxuICAgKiAgKDEvMyBPY3RhdmUgQmFuZHMgfj0gMzEgRnJlcXVlbmN5IEJhbmRzKVxuICAgKiAgU2V0dGluZyBmQ3RyMCB0byBhIGNlbnRyYWwgdmFsdWUgb2YgYSBoaWdoZXIgb2N0YXZlIHdpbGwgaWdub3JlIHRoZSBsb3dlciBiYW5kc1xuICAgKiAgYW5kIHByb2R1Y2UgbGVzcyBmcmVxdWVuY3kgZ3JvdXBzLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgIGdldE9jdGF2ZUJhbmRzXG4gICAqICBAZm9yIHA1LkZGVFxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSAgTiAgICAgICAgICAgICBTcGVjaWZpZXMgdGhlIDEvTiB0eXBlIG9mIGdlbmVyYXRlZCBvY3RhdmUgYmFuZHNcbiAgICogIEBwYXJhbSAge051bWJlcn0gIGZDdHIwICAgICAgICAgTWluaW11bSBjZW50cmFsIGZyZXF1ZW5jeSBmb3IgdGhlIGxvd2VzdCBiYW5kXG4gICAqICBAcmV0dXJuIHtBcnJheX0gICBvY3RhdmVCYW5kcyAgIEFycmF5IG9mIG9jdGF2ZSBiYW5kIG9iamVjdHMgd2l0aCB0aGVpciBib3VuZHNcbiAgICovXG5cblxuICBwNS5GRlQucHJvdG90eXBlLmdldE9jdGF2ZUJhbmRzID0gZnVuY3Rpb24gKE4sIGZDdHIwKSB7XG4gICAgdmFyIE4gPSBOIHx8IDM7IFxuXG4gICAgdmFyIGZDdHIwID0gZkN0cjAgfHwgMTUuNjI1OyBcblxuICAgIHZhciBvY3RhdmVCYW5kcyA9IFtdO1xuICAgIHZhciBsYXN0RnJlcXVlbmN5QmFuZCA9IHtcbiAgICAgIGxvOiBmQ3RyMCAvIE1hdGgucG93KDIsIDEgLyAoMiAqIE4pKSxcbiAgICAgIGN0cjogZkN0cjAsXG4gICAgICBoaTogZkN0cjAgKiBNYXRoLnBvdygyLCAxIC8gKDIgKiBOKSlcbiAgICB9O1xuICAgIG9jdGF2ZUJhbmRzLnB1c2gobGFzdEZyZXF1ZW5jeUJhbmQpO1xuICAgIHZhciBueXF1aXN0ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuc2FtcGxlUmF0ZSAvIDI7XG5cbiAgICB3aGlsZSAobGFzdEZyZXF1ZW5jeUJhbmQuaGkgPCBueXF1aXN0KSB7XG4gICAgICB2YXIgbmV3RnJlcXVlbmN5QmFuZCA9IHt9O1xuICAgICAgbmV3RnJlcXVlbmN5QmFuZC5sbyA9IGxhc3RGcmVxdWVuY3lCYW5kLmhpO1xuICAgICAgbmV3RnJlcXVlbmN5QmFuZC5jdHIgPSBsYXN0RnJlcXVlbmN5QmFuZC5jdHIgKiBNYXRoLnBvdygyLCAxIC8gTik7XG4gICAgICBuZXdGcmVxdWVuY3lCYW5kLmhpID0gbmV3RnJlcXVlbmN5QmFuZC5jdHIgKiBNYXRoLnBvdygyLCAxIC8gKDIgKiBOKSk7XG4gICAgICBvY3RhdmVCYW5kcy5wdXNoKG5ld0ZyZXF1ZW5jeUJhbmQpO1xuICAgICAgbGFzdEZyZXF1ZW5jeUJhbmQgPSBuZXdGcmVxdWVuY3lCYW5kO1xuICAgIH1cblxuICAgIHJldHVybiBvY3RhdmVCYW5kcztcbiAgfTsgXG5cblxuICB2YXIgZnJlcVRvRmxvYXQgPSBmdW5jdGlvbiBmcmVxVG9GbG9hdChmZnQpIHtcbiAgICBpZiAoZmZ0LmZyZXFEb21haW4gaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgPT09IGZhbHNlKSB7XG4gICAgICBmZnQuZnJlcURvbWFpbiA9IG5ldyBGbG9hdDMyQXJyYXkoZmZ0LmFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGZyZXFUb0ludCA9IGZ1bmN0aW9uIGZyZXFUb0ludChmZnQpIHtcbiAgICBpZiAoZmZ0LmZyZXFEb21haW4gaW5zdGFuY2VvZiBVaW50OEFycmF5ID09PSBmYWxzZSkge1xuICAgICAgZmZ0LmZyZXFEb21haW4gPSBuZXcgVWludDhBcnJheShmZnQuYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdGltZVRvRmxvYXQgPSBmdW5jdGlvbiB0aW1lVG9GbG9hdChmZnQpIHtcbiAgICBpZiAoZmZ0LnRpbWVEb21haW4gaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgPT09IGZhbHNlKSB7XG4gICAgICBmZnQudGltZURvbWFpbiA9IG5ldyBGbG9hdDMyQXJyYXkoZmZ0LmFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHRpbWVUb0ludCA9IGZ1bmN0aW9uIHRpbWVUb0ludChmZnQpIHtcbiAgICBpZiAoZmZ0LnRpbWVEb21haW4gaW5zdGFuY2VvZiBVaW50OEFycmF5ID09PSBmYWxzZSkge1xuICAgICAgZmZ0LnRpbWVEb21haW4gPSBuZXcgVWludDhBcnJheShmZnQuYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuICAgIH1cbiAgfTtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICB2YXIgU2lnbmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuICB2YXIgQWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxuICB2YXIgTXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbiAgdmFyIFNjYWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG4gIC8qKlxuICAgKiAgPHA+cDUuU2lnbmFsIGlzIGEgY29uc3RhbnQgYXVkaW8tcmF0ZSBzaWduYWwgdXNlZCBieSBwNS5Pc2NpbGxhdG9yXG4gICAqICBhbmQgcDUuRW52ZWxvcGUgZm9yIG1vZHVsYXRpb24gbWF0aC48L3A+XG4gICAqXG4gICAqICA8cD5UaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIFdlYiBBdWRpbyBpcyBwcm9jZXNzZWQgb24gYSBzZXByYXRlIGNsb2NrLlxuICAgKiAgRm9yIGV4YW1wbGUsIHRoZSBwNSBkcmF3IGxvb3AgcnVucyBhYm91dCA2MCB0aW1lcyBwZXIgc2Vjb25kLiBCdXRcbiAgICogIHRoZSBhdWRpbyBjbG9jayBtdXN0IHByb2Nlc3Mgc2FtcGxlcyA0NDEwMCB0aW1lcyBwZXIgc2Vjb25kLiBJZiB3ZVxuICAgKiAgd2FudCB0byBhZGQgYSB2YWx1ZSB0byBlYWNoIG9mIHRob3NlIHNhbXBsZXMsIHdlIGNhbid0IGRvIGl0IGluIHRoZVxuICAgKiAgZHJhdyBsb29wLCBidXQgd2UgY2FuIGRvIGl0IGJ5IGFkZGluZyBhIGNvbnN0YW50LXJhdGUgYXVkaW8gc2lnbmFsLjwvcC5cbiAgICpcbiAgICogIDxwPlRoaXMgY2xhc3MgbW9zdGx5IGZ1bmN0aW9ucyBiZWhpbmQgdGhlIHNjZW5lcyBpbiBwNS5zb3VuZCwgYW5kIHJldHVybnNcbiAgICogIGEgVG9uZS5TaWduYWwgZnJvbSB0aGUgVG9uZS5qcyBsaWJyYXJ5IGJ5IFlvdGFtIE1hbm4uXG4gICAqICBJZiB5b3Ugd2FudCB0byB3b3JrIGRpcmVjdGx5IHdpdGggYXVkaW8gc2lnbmFscyBmb3IgbW9kdWxhclxuICAgKiAgc3ludGhlc2lzLCBjaGVjayBvdXRcbiAgICogIDxhIGhyZWY9J2h0dHA6Ly9iaXQubHkvMW9Jb0VuZycgdGFyZ2V0PV8nYmxhbmsnPnRvbmUuanMuPC9hPjwvcD5cbiAgICpcbiAgICogIEBjbGFzcyAgcDUuU2lnbmFsXG4gICAqICBAY29uc3RydWN0b3JcbiAgICogIEByZXR1cm4ge1RvbmUuU2lnbmFsfSBBIFNpZ25hbCBvYmplY3QgZnJvbSB0aGUgVG9uZS5qcyBsaWJyYXJ5XG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBjYXJyaWVyLCBtb2R1bGF0b3I7XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQoY2FudmFzUHJlc3NlZCk7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCAyMCwgMjApO1xuICAgKlxuICAgKiAgICBjYXJyaWVyID0gbmV3IHA1Lk9zY2lsbGF0b3IoJ3NpbmUnKTtcbiAgICogICAgY2Fycmllci5zdGFydCgpO1xuICAgKiAgICBjYXJyaWVyLmFtcCgxKTsgLy8gc2V0IGFtcGxpdHVkZVxuICAgKiAgICBjYXJyaWVyLmZyZXEoMjIwKTsgLy8gc2V0IGZyZXF1ZW5jeVxuICAgKlxuICAgKiAgICBtb2R1bGF0b3IgPSBuZXcgcDUuT3NjaWxsYXRvcignc2F3dG9vdGgnKTtcbiAgICogICAgbW9kdWxhdG9yLmRpc2Nvbm5lY3QoKTtcbiAgICogICAgbW9kdWxhdG9yLnN0YXJ0KCk7XG4gICAqICAgIG1vZHVsYXRvci5hbXAoMSk7XG4gICAqICAgIG1vZHVsYXRvci5mcmVxKDQpO1xuICAgKlxuICAgKiAgICAvLyBNb2R1bGF0b3IncyBkZWZhdWx0IGFtcGxpdHVkZSByYW5nZSBpcyAtMSB0byAxLlxuICAgKiAgICAvLyBNdWx0aXBseSBpdCBieSAtMjAwLCBzbyB0aGUgcmFuZ2UgaXMgLTIwMCB0byAyMDBcbiAgICogICAgLy8gdGhlbiBhZGQgMjIwIHNvIHRoZSByYW5nZSBpcyAyMCB0byA0MjBcbiAgICogICAgY2Fycmllci5mcmVxKCBtb2R1bGF0b3IubXVsdCgtNDAwKS5hZGQoMjIwKSApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gY2FudmFzUHJlc3NlZCgpIHtcbiAgICogICAgdXNlclN0YXJ0QXVkaW8oKTtcbiAgICogICAgY2Fycmllci5hbXAoMS4wKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIG1vdXNlUmVsZWFzZWQoKSB7XG4gICAqICAgIGNhcnJpZXIuYW1wKDApO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LlNpZ25hbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBzID0gbmV3IFNpZ25hbCh2YWx1ZSk7IFxuXG4gICAgcmV0dXJuIHM7IFxuICB9O1xuICAvKipcbiAgICogIEZhZGUgdG8gdmFsdWUsIGZvciBzbW9vdGggdHJhbnNpdGlvbnNcbiAgICpcbiAgICogIEBtZXRob2QgIGZhZGVcbiAgICogIEBmb3IgcDUuU2lnbmFsXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IHZhbHVlICAgICAgICAgIFZhbHVlIHRvIHNldCB0aGlzIHNpZ25hbFxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbc2Vjb25kc0Zyb21Ob3ddIExlbmd0aCBvZiBmYWRlLCBpbiBzZWNvbmRzIGZyb20gbm93XG4gICAqL1xuXG5cbiAgU2lnbmFsLnByb3RvdHlwZS5mYWRlID0gU2lnbmFsLnByb3RvdHlwZS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZTtcbiAgTXVsdC5wcm90b3R5cGUuZmFkZSA9IFNpZ25hbC5wcm90b3R5cGUuZmFkZTtcbiAgQWRkLnByb3RvdHlwZS5mYWRlID0gU2lnbmFsLnByb3RvdHlwZS5mYWRlO1xuICBTY2FsZS5wcm90b3R5cGUuZmFkZSA9IFNpZ25hbC5wcm90b3R5cGUuZmFkZTtcbiAgLyoqXG4gICAqICBDb25uZWN0IGEgcDUuc291bmQgb2JqZWN0IG9yIFdlYiBBdWRpbyBub2RlIHRvIHRoaXNcbiAgICogIHA1LlNpZ25hbCBzbyB0aGF0IGl0cyBhbXBsaXR1ZGUgdmFsdWVzIGNhbiBiZSBzY2FsZWQuXG4gICAqXG4gICAqICBAbWV0aG9kIHNldElucHV0XG4gICAqICBAZm9yIHA1LlNpZ25hbFxuICAgKiAgQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuXG4gIFNpZ25hbC5wcm90b3R5cGUuc2V0SW5wdXQgPSBmdW5jdGlvbiAoX2lucHV0KSB7XG4gICAgX2lucHV0LmNvbm5lY3QodGhpcyk7XG4gIH07XG5cbiAgTXVsdC5wcm90b3R5cGUuc2V0SW5wdXQgPSBTaWduYWwucHJvdG90eXBlLnNldElucHV0O1xuICBBZGQucHJvdG90eXBlLnNldElucHV0ID0gU2lnbmFsLnByb3RvdHlwZS5zZXRJbnB1dDtcbiAgU2NhbGUucHJvdG90eXBlLnNldElucHV0ID0gU2lnbmFsLnByb3RvdHlwZS5zZXRJbnB1dDsgXG5cbiAgLyoqXG4gICAqICBBZGQgYSBjb25zdGFudCB2YWx1ZSB0byB0aGlzIGF1ZGlvIHNpZ25hbCxcbiAgICogIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBhdWRpbyBzaWduYWwuIERvZXNcbiAgICogIG5vdCBjaGFuZ2UgdGhlIHZhbHVlIG9mIHRoZSBvcmlnaW5hbCBzaWduYWwsXG4gICAqICBpbnN0ZWFkIGl0IHJldHVybnMgYSBuZXcgcDUuU2lnbmFsQWRkLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgYWRkXG4gICAqICBAZm9yIHA1LlNpZ25hbFxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IG51bWJlclxuICAgKiAgQHJldHVybiB7cDUuU2lnbmFsfSBvYmplY3RcbiAgICovXG5cbiAgU2lnbmFsLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgdmFyIGFkZCA9IG5ldyBBZGQobnVtKTsgXG5cbiAgICB0aGlzLmNvbm5lY3QoYWRkKTtcbiAgICByZXR1cm4gYWRkO1xuICB9O1xuXG4gIE11bHQucHJvdG90eXBlLmFkZCA9IFNpZ25hbC5wcm90b3R5cGUuYWRkO1xuICBBZGQucHJvdG90eXBlLmFkZCA9IFNpZ25hbC5wcm90b3R5cGUuYWRkO1xuICBTY2FsZS5wcm90b3R5cGUuYWRkID0gU2lnbmFsLnByb3RvdHlwZS5hZGQ7XG4gIC8qKlxuICAgKiAgTXVsdGlwbHkgdGhpcyBzaWduYWwgYnkgYSBjb25zdGFudCB2YWx1ZSxcbiAgICogIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBhdWRpbyBzaWduYWwuIERvZXNcbiAgICogIG5vdCBjaGFuZ2UgdGhlIHZhbHVlIG9mIHRoZSBvcmlnaW5hbCBzaWduYWwsXG4gICAqICBpbnN0ZWFkIGl0IHJldHVybnMgYSBuZXcgcDUuU2lnbmFsTXVsdC5cbiAgICpcbiAgICogIEBtZXRob2QgIG11bHRcbiAgICogIEBmb3IgcDUuU2lnbmFsXG4gICAqICBAcGFyYW0ge051bWJlcn0gbnVtYmVyIHRvIG11bHRpcGx5XG4gICAqICBAcmV0dXJuIHtwNS5TaWduYWx9IG9iamVjdFxuICAgKi9cblxuICBTaWduYWwucHJvdG90eXBlLm11bHQgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgdmFyIG11bHQgPSBuZXcgTXVsdChudW0pOyBcblxuICAgIHRoaXMuY29ubmVjdChtdWx0KTtcbiAgICByZXR1cm4gbXVsdDtcbiAgfTtcblxuICBNdWx0LnByb3RvdHlwZS5tdWx0ID0gU2lnbmFsLnByb3RvdHlwZS5tdWx0O1xuICBBZGQucHJvdG90eXBlLm11bHQgPSBTaWduYWwucHJvdG90eXBlLm11bHQ7XG4gIFNjYWxlLnByb3RvdHlwZS5tdWx0ID0gU2lnbmFsLnByb3RvdHlwZS5tdWx0O1xuICAvKipcbiAgICogIFNjYWxlIHRoaXMgc2lnbmFsIHZhbHVlIHRvIGEgZ2l2ZW4gcmFuZ2UsXG4gICAqICBhbmQgcmV0dXJuIHRoZSByZXN1bHQgYXMgYW4gYXVkaW8gc2lnbmFsLiBEb2VzXG4gICAqICBub3QgY2hhbmdlIHRoZSB2YWx1ZSBvZiB0aGUgb3JpZ2luYWwgc2lnbmFsLFxuICAgKiAgaW5zdGVhZCBpdCByZXR1cm5zIGEgbmV3IHA1LlNpZ25hbFNjYWxlLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgc2NhbGVcbiAgICogIEBmb3IgcDUuU2lnbmFsXG4gICAqICBAcGFyYW0ge051bWJlcn0gbnVtYmVyIHRvIG11bHRpcGx5XG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IGluTWluICBpbnB1dCByYW5nZSBtaW51bXVtXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IGluTWF4ICBpbnB1dCByYW5nZSBtYXhpbXVtXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IG91dE1pbiBpbnB1dCByYW5nZSBtaW51bXVtXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IG91dE1heCBpbnB1dCByYW5nZSBtYXhpbXVtXG4gICAqICBAcmV0dXJuIHtwNS5TaWduYWx9IG9iamVjdFxuICAgKi9cblxuICBTaWduYWwucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gKGluTWluLCBpbk1heCwgb3V0TWluLCBvdXRNYXgpIHtcbiAgICB2YXIgbWFwT3V0TWluLCBtYXBPdXRNYXg7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgbWFwT3V0TWluID0gcDUucHJvdG90eXBlLm1hcChvdXRNaW4sIGluTWluLCBpbk1heCwgMCwgMSkgLSAwLjU7XG4gICAgICBtYXBPdXRNYXggPSBwNS5wcm90b3R5cGUubWFwKG91dE1heCwgaW5NaW4sIGluTWF4LCAwLCAxKSAtIDAuNTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFwT3V0TWluID0gYXJndW1lbnRzWzBdO1xuICAgICAgbWFwT3V0TWF4ID0gYXJndW1lbnRzWzFdO1xuICAgIH1cblxuICAgIHZhciBzY2FsZSA9IG5ldyBTY2FsZShtYXBPdXRNaW4sIG1hcE91dE1heCk7XG4gICAgdGhpcy5jb25uZWN0KHNjYWxlKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG5cbiAgTXVsdC5wcm90b3R5cGUuc2NhbGUgPSBTaWduYWwucHJvdG90eXBlLnNjYWxlO1xuICBBZGQucHJvdG90eXBlLnNjYWxlID0gU2lnbmFsLnByb3RvdHlwZS5zY2FsZTtcbiAgU2NhbGUucHJvdG90eXBlLnNjYWxlID0gU2lnbmFsLnByb3RvdHlwZS5zY2FsZTtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXygyMSldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihvKXtvLkZyZXF1ZW5jeT1mdW5jdGlvbihlLHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIG8uRnJlcXVlbmN5KSlyZXR1cm4gbmV3IG8uRnJlcXVlbmN5KGUsdCk7by5UaW1lQmFzZS5jYWxsKHRoaXMsZSx0KX0sby5leHRlbmQoby5GcmVxdWVuY3ksby5UaW1lQmFzZSksby5GcmVxdWVuY3kucHJvdG90eXBlLl9wcmltYXJ5RXhwcmVzc2lvbnM9T2JqZWN0LmNyZWF0ZShvLlRpbWVCYXNlLnByb3RvdHlwZS5fcHJpbWFyeUV4cHJlc3Npb25zKSxvLkZyZXF1ZW5jeS5wcm90b3R5cGUuX3ByaW1hcnlFeHByZXNzaW9ucy5taWRpPXtyZWdleHA6L14oXFxkKyg/OlxcLlxcZCspP21pZGkpLyxtZXRob2Q6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubWlkaVRvRnJlcXVlbmN5KGUpfX0sby5GcmVxdWVuY3kucHJvdG90eXBlLl9wcmltYXJ5RXhwcmVzc2lvbnMubm90ZT17cmVnZXhwOi9eKFthLWddezF9KD86YnwjfHh8YmIpPykoLT9bMC05XSspL2ksbWV0aG9kOmZ1bmN0aW9uKGUsdCl7dmFyIHI9bltlLnRvTG93ZXJDYXNlKCldKzEyKihwYXJzZUludCh0KSsxKTtyZXR1cm4gdGhpcy5taWRpVG9GcmVxdWVuY3kocil9fSxvLkZyZXF1ZW5jeS5wcm90b3R5cGUuX3ByaW1hcnlFeHByZXNzaW9ucy50cj17cmVnZXhwOi9eKFxcZCsoPzpcXC5cXGQrKT8pOihcXGQrKD86XFwuXFxkKyk/KTo/KFxcZCsoPzpcXC5cXGQrKT8pPy8sbWV0aG9kOmZ1bmN0aW9uKGUsdCxyKXt2YXIgbj0xO3JldHVybiBlJiZcIjBcIiE9PWUmJihuKj10aGlzLl9iZWF0c1RvVW5pdHModGhpcy5fdGltZVNpZ25hdHVyZSgpKnBhcnNlRmxvYXQoZSkpKSx0JiZcIjBcIiE9PXQmJihuKj10aGlzLl9iZWF0c1RvVW5pdHMocGFyc2VGbG9hdCh0KSkpLHImJlwiMFwiIT09ciYmKG4qPXRoaXMuX2JlYXRzVG9Vbml0cyhwYXJzZUZsb2F0KHIpLzQpKSxufX0sby5GcmVxdWVuY3kucHJvdG90eXBlLnRyYW5zcG9zZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fZXhwcj1mdW5jdGlvbihlLHQpe3JldHVybiBlKCkqdGhpcy5pbnRlcnZhbFRvRnJlcXVlbmN5UmF0aW8odCl9LmJpbmQodGhpcyx0aGlzLl9leHByLGUpLHRoaXN9LG8uRnJlcXVlbmN5LnByb3RvdHlwZS5oYXJtb25pemU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX2V4cHI9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHI9ZSgpLG49W10sbz0wO288dC5sZW5ndGg7bysrKW5bb109cip0aGlzLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbyh0W29dKTtyZXR1cm4gbn0uYmluZCh0aGlzLHRoaXMuX2V4cHIsZSksdGhpc30sby5GcmVxdWVuY3kucHJvdG90eXBlLnRvTWlkaT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZyZXF1ZW5jeVRvTWlkaSh0aGlzLnZhbHVlT2YoKSl9LG8uRnJlcXVlbmN5LnByb3RvdHlwZS50b05vdGU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnZhbHVlT2YoKSx0PU1hdGgubG9nKGUvby5GcmVxdWVuY3kuQTQpL01hdGguTE4yLHI9TWF0aC5yb3VuZCgxMip0KSs1NyxuPU1hdGguZmxvb3Ioci8xMik7cmV0dXJuIG48MCYmKHIrPS0xMipuKSxpW3IlMTJdK24udG9TdHJpbmcoKX0sby5GcmVxdWVuY3kucHJvdG90eXBlLnRvU2Vjb25kcz1mdW5jdGlvbigpe3JldHVybiAxL3RoaXMudmFsdWVPZigpfSxvLkZyZXF1ZW5jeS5wcm90b3R5cGUudG9GcmVxdWVuY3k9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZU9mKCl9LG8uRnJlcXVlbmN5LnByb3RvdHlwZS50b1RpY2tzPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5fYmVhdHNUb1VuaXRzKDEpLHQ9dGhpcy52YWx1ZU9mKCkvZTtyZXR1cm4gTWF0aC5mbG9vcih0Km8uVHJhbnNwb3J0LlBQUSl9LG8uRnJlcXVlbmN5LnByb3RvdHlwZS5fZnJlcXVlbmN5VG9Vbml0cz1mdW5jdGlvbihlKXtyZXR1cm4gZX0sby5GcmVxdWVuY3kucHJvdG90eXBlLl90aWNrc1RvVW5pdHM9ZnVuY3Rpb24oZSl7cmV0dXJuIDEvKDYwKmUvKG8uVHJhbnNwb3J0LmJwbS52YWx1ZSpvLlRyYW5zcG9ydC5QUFEpKX0sby5GcmVxdWVuY3kucHJvdG90eXBlLl9iZWF0c1RvVW5pdHM9ZnVuY3Rpb24oZSl7cmV0dXJuIDEvby5UaW1lQmFzZS5wcm90b3R5cGUuX2JlYXRzVG9Vbml0cy5jYWxsKHRoaXMsZSl9LG8uRnJlcXVlbmN5LnByb3RvdHlwZS5fc2Vjb25kc1RvVW5pdHM9ZnVuY3Rpb24oZSl7cmV0dXJuIDEvZX0sby5GcmVxdWVuY3kucHJvdG90eXBlLl9kZWZhdWx0VW5pdHM9XCJoelwiO3ZhciBuPXtjYmI6LTIsY2I6LTEsYzowLFwiYyNcIjoxLGN4OjIsZGJiOjAsZGI6MSxkOjIsXCJkI1wiOjMsZHg6NCxlYmI6MixlYjozLGU6NCxcImUjXCI6NSxleDo2LGZiYjozLGZiOjQsZjo1LFwiZiNcIjo2LGZ4OjcsZ2JiOjUsZ2I6NixnOjcsXCJnI1wiOjgsZ3g6OSxhYmI6NyxhYjo4LGE6OSxcImEjXCI6MTAsYXg6MTEsYmJiOjksYmI6MTAsYjoxMSxcImIjXCI6MTIsYng6MTN9LGk9W1wiQ1wiLFwiQyNcIixcIkRcIixcIkQjXCIsXCJFXCIsXCJGXCIsXCJGI1wiLFwiR1wiLFwiRyNcIixcIkFcIixcIkEjXCIsXCJCXCJdO3JldHVybiBvLkZyZXF1ZW5jeS5BND00NDAsby5GcmVxdWVuY3kucHJvdG90eXBlLm1pZGlUb0ZyZXF1ZW5jeT1mdW5jdGlvbihlKXtyZXR1cm4gby5GcmVxdWVuY3kuQTQqTWF0aC5wb3coMiwoZS02OSkvMTIpfSxvLkZyZXF1ZW5jeS5wcm90b3R5cGUuZnJlcXVlbmN5VG9NaWRpPWZ1bmN0aW9uKGUpe3JldHVybiA2OSsxMipNYXRoLmxvZyhlL28uRnJlcXVlbmN5LkE0KS9NYXRoLkxOMn0sby5GcmVxdWVuY3l9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXygyMCldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihvKXtyZXR1cm4gby5UcmFuc3BvcnRUaW1lPWZ1bmN0aW9uKHQscil7aWYoISh0aGlzIGluc3RhbmNlb2Ygby5UcmFuc3BvcnRUaW1lKSlyZXR1cm4gbmV3IG8uVHJhbnNwb3J0VGltZSh0LHIpO28uVGltZS5jYWxsKHRoaXMsdCxyKX0sby5leHRlbmQoby5UcmFuc3BvcnRUaW1lLG8uVGltZSksby5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS5fdW5hcnlFeHByZXNzaW9ucz1PYmplY3QuY3JlYXRlKG8uVGltZS5wcm90b3R5cGUuX3VuYXJ5RXhwcmVzc2lvbnMpLG8uVHJhbnNwb3J0VGltZS5wcm90b3R5cGUuX3VuYXJ5RXhwcmVzc2lvbnMucXVhbnRpemU9e3JlZ2V4cDovXkAvLG1ldGhvZDpmdW5jdGlvbih0KXt2YXIgcj10aGlzLl9zZWNvbmRzVG9UaWNrcyh0KCkpLGU9TWF0aC5jZWlsKG8uVHJhbnNwb3J0LnRpY2tzL3IpO3JldHVybiB0aGlzLl90aWNrc1RvVW5pdHMoZSpyKX19LG8uVHJhbnNwb3J0VGltZS5wcm90b3R5cGUuX3NlY29uZHNUb1RpY2tzPWZ1bmN0aW9uKHQpe3ZhciByPXQvdGhpcy5fYmVhdHNUb1VuaXRzKDEpO3JldHVybiBNYXRoLnJvdW5kKHIqby5UcmFuc3BvcnQuUFBRKX0sby5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS52YWx1ZU9mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NlY29uZHNUb1RpY2tzKHRoaXMuX2V4cHIoKSkrKHRoaXMuX3BsdXNOb3c/by5UcmFuc3BvcnQudGlja3M6MCl9LG8uVHJhbnNwb3J0VGltZS5wcm90b3R5cGUudG9UaWNrcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlT2YoKX0sby5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS50b1NlY29uZHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZXhwcigpKyh0aGlzLl9wbHVzTm93P28uVHJhbnNwb3J0LnNlY29uZHM6MCl9LG8uVHJhbnNwb3J0VGltZS5wcm90b3R5cGUudG9GcmVxdWVuY3k9ZnVuY3Rpb24oKXtyZXR1cm4gMS90aGlzLnRvU2Vjb25kcygpfSxvLlRyYW5zcG9ydFRpbWV9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICB2YXIgcDVzb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIEFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbiAgdmFyIE11bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG4gIHZhciBTY2FsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG4gIHZhciBUaW1lbGluZVNpZ25hbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuICAvKipcbiAgICogIDxwPkVudmVsb3BlcyBhcmUgcHJlLWRlZmluZWQgYW1wbGl0dWRlIGRpc3RyaWJ1dGlvbiBvdmVyIHRpbWUuXG4gICAqICBUeXBpY2FsbHksIGVudmVsb3BlcyBhcmUgdXNlZCB0byBjb250cm9sIHRoZSBvdXRwdXQgdm9sdW1lXG4gICAqICBvZiBhbiBvYmplY3QsIGEgc2VyaWVzIG9mIGZhZGVzIHJlZmVycmVkIHRvIGFzIEF0dGFjaywgRGVjYXksXG4gICAqICBTdXN0YWluIGFuZCBSZWxlYXNlIChcbiAgICogIDxhIGhyZWY9XCJodHRwczovL3VwbG9hZC53aWtpbWVkaWEub3JnL3dpa2lwZWRpYS9jb21tb25zL2UvZWEvQURTUl9wYXJhbWV0ZXIuc3ZnXCI+QURTUjwvYT5cbiAgICogICkuIEVudmVsb3BlcyBjYW4gYWxzbyBjb250cm9sIG90aGVyIFdlYiBBdWRpbyBQYXJhbWV0ZXJz4oCUZm9yIGV4YW1wbGUsIGEgcDUuRW52ZWxvcGUgY2FuXG4gICAqICBjb250cm9sIGFuIE9zY2lsbGF0b3IncyBmcmVxdWVuY3kgbGlrZSB0aGlzOiA8Y29kZT5vc2MuZnJlcShlbnYpPC9jb2RlPi48L3A+XG4gICAqICA8cD5Vc2UgPGNvZGU+PGEgaHJlZj1cIiMvcDUuRW52ZWxvcGUvc2V0UmFuZ2VcIj5zZXRSYW5nZTwvYT48L2NvZGU+IHRvIGNoYW5nZSB0aGUgYXR0YWNrL3JlbGVhc2UgbGV2ZWwuXG4gICAqICBVc2UgPGNvZGU+PGEgaHJlZj1cIiMvcDUuRW52ZWxvcGUvc2V0QURTUlwiPnNldEFEU1I8L2E+PC9jb2RlPiB0byBjaGFuZ2UgYXR0YWNrVGltZSwgZGVjYXlUaW1lLCBzdXN0YWluUGVyY2VudCBhbmQgcmVsZWFzZVRpbWUuPC9wPlxuICAgKiAgPHA+VXNlIHRoZSA8Y29kZT48YSBocmVmPVwiIy9wNS5FbnZlbG9wZS9wbGF5XCI+cGxheTwvYT48L2NvZGU+IG1ldGhvZCB0byBwbGF5IHRoZSBlbnRpcmUgZW52ZWxvcGUsXG4gICAqICB0aGUgPGNvZGU+PGEgaHJlZj1cIiMvcDUuRW52ZWxvcGUvcmFtcFwiPnJhbXA8L2E+PC9jb2RlPiBtZXRob2QgZm9yIGEgcGluZ2FibGUgdHJpZ2dlcixcbiAgICogIG9yIDxjb2RlPjxhIGhyZWY9XCIjL3A1LkVudmVsb3BlL3RyaWdnZXJBdHRhY2tcIj50cmlnZ2VyQXR0YWNrPC9hPjwvY29kZT4vXG4gICAqICA8Y29kZT48YSBocmVmPVwiIy9wNS5FbnZlbG9wZS90cmlnZ2VyUmVsZWFzZVwiPnRyaWdnZXJSZWxlYXNlPC9hPjwvY29kZT4gdG8gdHJpZ2dlciBub3RlT24vbm90ZU9mZi48L3A+XG4gICAqXG4gICAqICBAY2xhc3MgcDUuRW52ZWxvcGVcbiAgICogIEBjb25zdHJ1Y3RvclxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgdDEgPSAwLjE7IC8vIGF0dGFjayB0aW1lIGluIHNlY29uZHNcbiAgICogIGxldCBsMSA9IDAuNzsgLy8gYXR0YWNrIGxldmVsIDAuMCB0byAxLjBcbiAgICogIGxldCB0MiA9IDAuMzsgLy8gZGVjYXkgdGltZSBpbiBzZWNvbmRzXG4gICAqICBsZXQgbDIgPSAwLjE7IC8vIGRlY2F5IGxldmVsICAwLjAgdG8gMS4wXG4gICAqXG4gICAqICBsZXQgZW52O1xuICAgKiAgbGV0IHRyaU9zYztcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0KCd0YXAgdG8gcGxheScsIDIwLCAyMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQocGxheVNvdW5kKTtcbiAgICpcbiAgICogICAgZW52ID0gbmV3IHA1LkVudmVsb3BlKHQxLCBsMSwgdDIsIGwyKTtcbiAgICogICAgdHJpT3NjID0gbmV3IHA1Lk9zY2lsbGF0b3IoJ3RyaWFuZ2xlJyk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBwbGF5U291bmQoKSB7XG4gICAqICAgIC8vIHN0YXJ0aW5nIHRoZSBvc2NpbGxhdG9yIGVuc3VyZXMgdGhhdCBhdWRpbyBpcyBlbmFibGVkLlxuICAgKiAgICB0cmlPc2Muc3RhcnQoKTtcbiAgICogICAgZW52LnBsYXkodHJpT3NjKTtcbiAgICogIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5FbnZlbG9wZSA9IGZ1bmN0aW9uICh0MSwgbDEsIHQyLCBsMiwgdDMsIGwzKSB7XG4gICAgLyoqXG4gICAgICogVGltZSB1bnRpbCBlbnZlbG9wZSByZWFjaGVzIGF0dGFja0xldmVsXG4gICAgICogQHByb3BlcnR5IGF0dGFja1RpbWVcbiAgICAgKi9cbiAgICB0aGlzLmFUaW1lID0gdDEgfHwgMC4xO1xuICAgIC8qKlxuICAgICAqIExldmVsIG9uY2UgYXR0YWNrIGlzIGNvbXBsZXRlLlxuICAgICAqIEBwcm9wZXJ0eSBhdHRhY2tMZXZlbFxuICAgICAqL1xuXG4gICAgdGhpcy5hTGV2ZWwgPSBsMSB8fCAxO1xuICAgIC8qKlxuICAgICAqIFRpbWUgdW50aWwgZW52ZWxvcGUgcmVhY2hlcyBkZWNheUxldmVsLlxuICAgICAqIEBwcm9wZXJ0eSBkZWNheVRpbWVcbiAgICAgKi9cblxuICAgIHRoaXMuZFRpbWUgPSB0MiB8fCAwLjU7XG4gICAgLyoqXG4gICAgICogTGV2ZWwgYWZ0ZXIgZGVjYXkuIFRoZSBlbnZlbG9wZSB3aWxsIHN1c3RhaW4gaGVyZSB1bnRpbCBpdCBpcyByZWxlYXNlZC5cbiAgICAgKiBAcHJvcGVydHkgZGVjYXlMZXZlbFxuICAgICAqL1xuXG4gICAgdGhpcy5kTGV2ZWwgPSBsMiB8fCAwO1xuICAgIC8qKlxuICAgICAqIER1cmF0aW9uIG9mIHRoZSByZWxlYXNlIHBvcnRpb24gb2YgdGhlIGVudmVsb3BlLlxuICAgICAqIEBwcm9wZXJ0eSByZWxlYXNlVGltZVxuICAgICAqL1xuXG4gICAgdGhpcy5yVGltZSA9IHQzIHx8IDA7XG4gICAgLyoqXG4gICAgICogTGV2ZWwgYXQgdGhlIGVuZCBvZiB0aGUgcmVsZWFzZS5cbiAgICAgKiBAcHJvcGVydHkgcmVsZWFzZUxldmVsXG4gICAgICovXG5cbiAgICB0aGlzLnJMZXZlbCA9IGwzIHx8IDA7XG4gICAgdGhpcy5fcmFtcEhpZ2hQZXJjZW50YWdlID0gMC45ODtcbiAgICB0aGlzLl9yYW1wTG93UGVyY2VudGFnZSA9IDAuMDI7XG4gICAgdGhpcy5vdXRwdXQgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgdGhpcy5jb250cm9sID0gbmV3IFRpbWVsaW5lU2lnbmFsKCk7XG5cbiAgICB0aGlzLl9pbml0KCk7IFxuXG5cbiAgICB0aGlzLmNvbnRyb2wuY29ubmVjdCh0aGlzLm91dHB1dCk7IFxuXG4gICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDsgXG5cbiAgICB0aGlzLm1hdGhPcHMgPSBbdGhpcy5jb250cm9sXTsgXG5cbiAgICB0aGlzLmlzRXhwb25lbnRpYWwgPSBmYWxzZTsgXG5cbiAgICB0aGlzLnNvdXJjZVRvQ2xlYXIgPSBudWxsOyBcblxuICAgIHRoaXMud2FzVHJpZ2dlcmVkID0gZmFsc2U7IFxuXG4gICAgcDVzb3VuZC5zb3VuZEFycmF5LnB1c2godGhpcyk7XG4gIH07IFxuXG5cbiAgcDUuRW52ZWxvcGUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICB2YXIgdCA9IG5vdztcbiAgICB0aGlzLmNvbnRyb2wuc2V0VGFyZ2V0QXRUaW1lKDAuMDAwMDEsIHQsIC4wMDEpOyBcblxuICAgIHRoaXMuX3NldFJhbXBBRCh0aGlzLmFUaW1lLCB0aGlzLmRUaW1lKTtcbiAgfTtcbiAgLyoqXG4gICAqICBSZXNldCB0aGUgZW52ZWxvcGUgd2l0aCBhIHNlcmllcyBvZiB0aW1lL3ZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgc2V0XG4gICAqICBAZm9yIHA1LkVudmVsb3BlXG4gICAqICBAcGFyYW0ge051bWJlcn0gYXR0YWNrVGltZSAgICAgVGltZSAoaW4gc2Vjb25kcykgYmVmb3JlIGxldmVsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhY2hlcyBhdHRhY2tMZXZlbFxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IGF0dGFja0xldmVsICAgIFR5cGljYWxseSBhbiBhbXBsaXR1ZGUgYmV0d2VlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuMCBhbmQgMS4wXG4gICAqICBAcGFyYW0ge051bWJlcn0gZGVjYXlUaW1lICAgICAgVGltZVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IGRlY2F5TGV2ZWwgICBBbXBsaXR1ZGUgKEluIGEgc3RhbmRhcmQgQURTUiBlbnZlbG9wZSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNheUxldmVsID0gc3VzdGFpbkxldmVsKVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IHJlbGVhc2VUaW1lICAgUmVsZWFzZSBUaW1lIChpbiBzZWNvbmRzKVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IHJlbGVhc2VMZXZlbCAgQW1wbGl0dWRlXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBhdHRhY2tUaW1lO1xuICAgKiAgbGV0IGwxID0gMC43OyAvLyBhdHRhY2sgbGV2ZWwgMC4wIHRvIDEuMFxuICAgKiAgbGV0IHQyID0gMC4zOyAvLyBkZWNheSB0aW1lIGluIHNlY29uZHNcbiAgICogIGxldCBsMiA9IDAuMTsgLy8gZGVjYXkgbGV2ZWwgIDAuMCB0byAxLjBcbiAgICogIGxldCBsMyA9IDAuMjsgLy8gcmVsZWFzZSB0aW1lIGluIHNlY29uZHNcbiAgICpcbiAgICogIGxldCBlbnYsIHRyaU9zYztcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChwbGF5U291bmQpO1xuICAgKlxuICAgKiAgICBlbnYgPSBuZXcgcDUuRW52ZWxvcGUoKTtcbiAgICogICAgdHJpT3NjID0gbmV3IHA1Lk9zY2lsbGF0b3IoJ3RyaWFuZ2xlJyk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBkcmF3KCkge1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ3RhcCBoZXJlIHRvIHBsYXknLCA1LCAyMCk7XG4gICAqXG4gICAqICAgIGF0dGFja1RpbWUgPSBtYXAobW91c2VYLCAwLCB3aWR0aCwgMC4wLCAxLjApO1xuICAgKiAgICB0ZXh0KCdhdHRhY2sgdGltZTogJyArIGF0dGFja1RpbWUsIDUsIGhlaWdodCAtIDIwKTtcbiAgICogIH1cbiAgICpcbiAgICogIC8vIG1vdXNlQ2xpY2sgdHJpZ2dlcnMgZW52ZWxvcGUgaWYgb3ZlciBjYW52YXNcbiAgICogIGZ1bmN0aW9uIHBsYXlTb3VuZCgpIHtcbiAgICogICAgZW52LnNldChhdHRhY2tUaW1lLCBsMSwgdDIsIGwyLCBsMyk7XG4gICAqXG4gICAqICAgIHRyaU9zYy5zdGFydCgpO1xuICAgKiAgICBlbnYucGxheSh0cmlPc2MpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKlxuICAgKi9cblxuXG4gIHA1LkVudmVsb3BlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodDEsIGwxLCB0MiwgbDIsIHQzLCBsMykge1xuICAgIHRoaXMuYVRpbWUgPSB0MTtcbiAgICB0aGlzLmFMZXZlbCA9IGwxO1xuICAgIHRoaXMuZFRpbWUgPSB0MiB8fCAwO1xuICAgIHRoaXMuZExldmVsID0gbDIgfHwgMDtcbiAgICB0aGlzLnJUaW1lID0gdDMgfHwgMDtcbiAgICB0aGlzLnJMZXZlbCA9IGwzIHx8IDA7IFxuXG4gICAgdGhpcy5fc2V0UmFtcEFEKHQxLCB0Mik7XG4gIH07XG4gIC8qKlxuICAgKiAgU2V0IHZhbHVlcyBsaWtlIGEgdHJhZGl0aW9uYWxcbiAgICogIDxhIGhyZWY9XCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW50aGVzaXplciMvbWVkaWEvRmlsZTpBRFNSX3BhcmFtZXRlci5zdmdcIj5cbiAgICogIEFEU1IgZW52ZWxvcGVcbiAgICogIDwvYT4uXG4gICAqXG4gICAqICBAbWV0aG9kICBzZXRBRFNSXG4gICAqICBAZm9yIHA1LkVudmVsb3BlXG4gICAqICBAcGFyYW0ge051bWJlcn0gYXR0YWNrVGltZSAgICBUaW1lIChpbiBzZWNvbmRzIGJlZm9yZSBlbnZlbG9wZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhY2hlcyBBdHRhY2sgTGV2ZWxcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbZGVjYXlUaW1lXSAgICBUaW1lIChpbiBzZWNvbmRzKSBiZWZvcmUgZW52ZWxvcGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWNoZXMgRGVjYXkvU3VzdGFpbiBMZXZlbFxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtzdXNSYXRpb10gICAgUmF0aW8gYmV0d2VlbiBhdHRhY2tMZXZlbCBhbmQgcmVsZWFzZUxldmVsLCBvbiBhIHNjYWxlIGZyb20gMCB0byAxLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmUgMS4wID0gYXR0YWNrTGV2ZWwsIDAuMCA9IHJlbGVhc2VMZXZlbC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBzdXNSYXRpbyBkZXRlcm1pbmVzIHRoZSBkZWNheUxldmVsIGFuZCB0aGUgbGV2ZWwgYXQgd2hpY2ggdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXN0YWluIHBvcnRpb24gb2YgdGhlIGVudmVsb3BlIHdpbGwgc3VzdGFpbi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZvciBleGFtcGxlLCBpZiBhdHRhY2tMZXZlbCBpcyAwLjQsIHJlbGVhc2VMZXZlbCBpcyAwLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHN1c0FtdCBpcyAwLjUsIHRoZSBkZWNheUxldmVsIHdvdWxkIGJlIDAuMi4gSWYgYXR0YWNrTGV2ZWwgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlYXNlZCB0byAxLjAgKHVzaW5nIDxjb2RlPnNldFJhbmdlPC9jb2RlPiksXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIGRlY2F5TGV2ZWwgd291bGQgaW5jcmVhc2UgcHJvcG9ydGlvbmFsbHksIHRvIGJlY29tZSAwLjUuXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3JlbGVhc2VUaW1lXSAgIFRpbWUgaW4gc2Vjb25kcyBmcm9tIG5vdyAoZGVmYXVsdHMgdG8gMClcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IGF0dGFja0xldmVsID0gMS4wO1xuICAgKiAgbGV0IHJlbGVhc2VMZXZlbCA9IDA7XG4gICAqXG4gICAqICBsZXQgYXR0YWNrVGltZSA9IDAuMDAxO1xuICAgKiAgbGV0IGRlY2F5VGltZSA9IDAuMjtcbiAgICogIGxldCBzdXNQZXJjZW50ID0gMC4yO1xuICAgKiAgbGV0IHJlbGVhc2VUaW1lID0gMC41O1xuICAgKlxuICAgKiAgbGV0IGVudiwgdHJpT3NjO1xuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHBsYXlFbnYpO1xuICAgKlxuICAgKiAgICBlbnYgPSBuZXcgcDUuRW52ZWxvcGUoKTtcbiAgICogICAgdHJpT3NjID0gbmV3IHA1Lk9zY2lsbGF0b3IoJ3RyaWFuZ2xlJyk7XG4gICAqICAgIHRyaU9zYy5hbXAoZW52KTtcbiAgICogICAgdHJpT3NjLmZyZXEoMjIwKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIGhlcmUgdG8gcGxheScsIDUsIDIwKTtcbiAgICogICAgYXR0YWNrVGltZSA9IG1hcChtb3VzZVgsIDAsIHdpZHRoLCAwLCAxLjApO1xuICAgKiAgICB0ZXh0KCdhdHRhY2sgdGltZTogJyArIGF0dGFja1RpbWUsIDUsIGhlaWdodCAtIDQwKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHBsYXlFbnYoKSB7XG4gICAqICAgIHRyaU9zYy5zdGFydCgpO1xuICAgKiAgICBlbnYuc2V0QURTUihhdHRhY2tUaW1lLCBkZWNheVRpbWUsIHN1c1BlcmNlbnQsIHJlbGVhc2VUaW1lKTtcbiAgICogICAgZW52LnBsYXkoKTtcbiAgICogIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5FbnZlbG9wZS5wcm90b3R5cGUuc2V0QURTUiA9IGZ1bmN0aW9uIChhVGltZSwgZFRpbWUsIHNQZXJjZW50LCByVGltZSkge1xuICAgIHRoaXMuYVRpbWUgPSBhVGltZTtcbiAgICB0aGlzLmRUaW1lID0gZFRpbWUgfHwgMDsgXG5cbiAgICB0aGlzLnNQZXJjZW50ID0gc1BlcmNlbnQgfHwgMDtcbiAgICB0aGlzLmRMZXZlbCA9IHR5cGVvZiBzUGVyY2VudCAhPT0gJ3VuZGVmaW5lZCcgPyBzUGVyY2VudCAqICh0aGlzLmFMZXZlbCAtIHRoaXMuckxldmVsKSArIHRoaXMuckxldmVsIDogMDtcbiAgICB0aGlzLnJUaW1lID0gclRpbWUgfHwgMDsgXG5cbiAgICB0aGlzLl9zZXRSYW1wQUQoYVRpbWUsIGRUaW1lKTtcbiAgfTtcbiAgLyoqXG4gICAqICBTZXQgbWF4IChhdHRhY2tMZXZlbCkgYW5kIG1pbiAocmVsZWFzZUxldmVsKSBvZiBlbnZlbG9wZS5cbiAgICpcbiAgICogIEBtZXRob2QgIHNldFJhbmdlXG4gICAqICBAZm9yIHA1LkVudmVsb3BlXG4gICAqICBAcGFyYW0ge051bWJlcn0gYUxldmVsIGF0dGFjayBsZXZlbCAoZGVmYXVsdHMgdG8gMSlcbiAgICogIEBwYXJhbSB7TnVtYmVyfSByTGV2ZWwgcmVsZWFzZSBsZXZlbCAoZGVmYXVsdHMgdG8gMClcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IGF0dGFja0xldmVsID0gMS4wO1xuICAgKiAgbGV0IHJlbGVhc2VMZXZlbCA9IDA7XG4gICAqXG4gICAqICBsZXQgYXR0YWNrVGltZSA9IDAuMDAxO1xuICAgKiAgbGV0IGRlY2F5VGltZSA9IDAuMjtcbiAgICogIGxldCBzdXNQZXJjZW50ID0gMC4yO1xuICAgKiAgbGV0IHJlbGVhc2VUaW1lID0gMC41O1xuICAgKlxuICAgKiAgbGV0IGVudiwgdHJpT3NjO1xuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHBsYXlFbnYpO1xuICAgKlxuICAgKiAgICBlbnYgPSBuZXcgcDUuRW52ZWxvcGUoKTtcbiAgICogICAgdHJpT3NjID0gbmV3IHA1Lk9zY2lsbGF0b3IoJ3RyaWFuZ2xlJyk7XG4gICAqICAgIHRyaU9zYy5hbXAoZW52KTtcbiAgICogICAgdHJpT3NjLmZyZXEoMjIwKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIGhlcmUgdG8gcGxheScsIDUsIDIwKTtcbiAgICogICAgYXR0YWNrTGV2ZWwgPSBtYXAobW91c2VZLCBoZWlnaHQsIDAsIDAsIDEuMCk7XG4gICAqICAgIHRleHQoJ2F0dGFjayBsZXZlbDogJyArIGF0dGFja0xldmVsLCA1LCBoZWlnaHQgLSAyMCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBwbGF5RW52KCkge1xuICAgKiAgICB0cmlPc2Muc3RhcnQoKTtcbiAgICogICAgZW52LnNldFJhbmdlKGF0dGFja0xldmVsLCByZWxlYXNlTGV2ZWwpO1xuICAgKiAgICBlbnYucGxheSgpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LkVudmVsb3BlLnByb3RvdHlwZS5zZXRSYW5nZSA9IGZ1bmN0aW9uIChhTGV2ZWwsIHJMZXZlbCkge1xuICAgIHRoaXMuYUxldmVsID0gYUxldmVsIHx8IDE7XG4gICAgdGhpcy5yTGV2ZWwgPSByTGV2ZWwgfHwgMDsgXG4gIH07IFxuXG5cbiAgcDUuRW52ZWxvcGUucHJvdG90eXBlLl9zZXRSYW1wQUQgPSBmdW5jdGlvbiAodDEsIHQyKSB7XG4gICAgdGhpcy5fcmFtcEF0dGFja1RpbWUgPSB0aGlzLmNoZWNrRXhwSW5wdXQodDEpO1xuICAgIHRoaXMuX3JhbXBEZWNheVRpbWUgPSB0aGlzLmNoZWNrRXhwSW5wdXQodDIpO1xuICAgIHZhciBUQ0Rlbm9taW5hdG9yID0gMS4wOyBcblxuICAgIFRDRGVub21pbmF0b3IgPSBNYXRoLmxvZygxLjAgLyB0aGlzLmNoZWNrRXhwSW5wdXQoMS4wIC0gdGhpcy5fcmFtcEhpZ2hQZXJjZW50YWdlKSk7XG4gICAgdGhpcy5fcmFtcEF0dGFja1RDID0gdDEgLyB0aGlzLmNoZWNrRXhwSW5wdXQoVENEZW5vbWluYXRvcik7XG4gICAgVENEZW5vbWluYXRvciA9IE1hdGgubG9nKDEuMCAvIHRoaXMuX3JhbXBMb3dQZXJjZW50YWdlKTtcbiAgICB0aGlzLl9yYW1wRGVjYXlUQyA9IHQyIC8gdGhpcy5jaGVja0V4cElucHV0KFRDRGVub21pbmF0b3IpO1xuICB9OyBcblxuXG4gIHA1LkVudmVsb3BlLnByb3RvdHlwZS5zZXRSYW1wUGVyY2VudGFnZXMgPSBmdW5jdGlvbiAocDEsIHAyKSB7XG4gICAgdGhpcy5fcmFtcEhpZ2hQZXJjZW50YWdlID0gdGhpcy5jaGVja0V4cElucHV0KHAxKTtcbiAgICB0aGlzLl9yYW1wTG93UGVyY2VudGFnZSA9IHRoaXMuY2hlY2tFeHBJbnB1dChwMik7XG4gICAgdmFyIFRDRGVub21pbmF0b3IgPSAxLjA7IFxuXG4gICAgVENEZW5vbWluYXRvciA9IE1hdGgubG9nKDEuMCAvIHRoaXMuY2hlY2tFeHBJbnB1dCgxLjAgLSB0aGlzLl9yYW1wSGlnaFBlcmNlbnRhZ2UpKTtcbiAgICB0aGlzLl9yYW1wQXR0YWNrVEMgPSB0aGlzLl9yYW1wQXR0YWNrVGltZSAvIHRoaXMuY2hlY2tFeHBJbnB1dChUQ0Rlbm9taW5hdG9yKTtcbiAgICBUQ0Rlbm9taW5hdG9yID0gTWF0aC5sb2coMS4wIC8gdGhpcy5fcmFtcExvd1BlcmNlbnRhZ2UpO1xuICAgIHRoaXMuX3JhbXBEZWNheVRDID0gdGhpcy5fcmFtcERlY2F5VGltZSAvIHRoaXMuY2hlY2tFeHBJbnB1dChUQ0Rlbm9taW5hdG9yKTtcbiAgfTtcbiAgLyoqXG4gICAqICBBc3NpZ24gYSBwYXJhbWV0ZXIgdG8gYmUgY29udHJvbGxlZCBieSB0aGlzIGVudmVsb3BlLlxuICAgKiAgSWYgYSBwNS5Tb3VuZCBvYmplY3QgaXMgZ2l2ZW4sIHRoZW4gdGhlIHA1LkVudmVsb3BlIHdpbGwgY29udHJvbCBpdHNcbiAgICogIG91dHB1dCBnYWluLiBJZiBtdWx0aXBsZSBpbnB1dHMgYXJlIHByb3ZpZGVkLCB0aGUgZW52IHdpbGxcbiAgICogIGNvbnRyb2wgYWxsIG9mIHRoZW0uXG4gICAqXG4gICAqICBAbWV0aG9kICBzZXRJbnB1dFxuICAgKiAgQGZvciBwNS5FbnZlbG9wZVxuICAgKiAgQHBhcmFtICB7T2JqZWN0fSBbLi4uaW5wdXRzXSAgICAgICAgIEEgcDUuc291bmQgb2JqZWN0IG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXZWIgQXVkaW8gUGFyYW0uXG4gICAqL1xuXG5cbiAgcDUuRW52ZWxvcGUucHJvdG90eXBlLnNldElucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmNvbm5lY3QoYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgU2V0IHdoZXRoZXIgdGhlIGVudmVsb3BlIHJhbXAgaXMgbGluZWFyIChkZWZhdWx0KSBvciBleHBvbmVudGlhbC5cbiAgICogIEV4cG9uZW50aWFsIHJhbXBzIGNhbiBiZSB1c2VmdWwgYmVjYXVzZSB3ZSBwZXJjZWl2ZSBhbXBsaXR1ZGVcbiAgICogIGFuZCBmcmVxdWVuY3kgbG9nYXJpdGhtaWNhbGx5LlxuICAgKlxuICAgKiAgQG1ldGhvZCAgc2V0RXhwXG4gICAqICBAZm9yIHA1LkVudmVsb3BlXG4gICAqICBAcGFyYW0ge0Jvb2xlYW59IGlzRXhwIHRydWUgaXMgZXhwb25lbnRpYWwsIGZhbHNlIGlzIGxpbmVhclxuICAgKi9cblxuXG4gIHA1LkVudmVsb3BlLnByb3RvdHlwZS5zZXRFeHAgPSBmdW5jdGlvbiAoaXNFeHApIHtcbiAgICB0aGlzLmlzRXhwb25lbnRpYWwgPSBpc0V4cDtcbiAgfTsgXG5cblxuICBwNS5FbnZlbG9wZS5wcm90b3R5cGUuY2hlY2tFeHBJbnB1dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA8PSAwKSB7XG4gICAgICB2YWx1ZSA9IDAuMDAwMDAwMDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICAvKipcbiAgICogIDxwPlBsYXkgdGVsbHMgdGhlIGVudmVsb3BlIHRvIHN0YXJ0IGFjdGluZyBvbiBhIGdpdmVuIGlucHV0LlxuICAgKiAgSWYgdGhlIGlucHV0IGlzIGEgcDUuc291bmQgb2JqZWN0IChpLmUuIEF1ZGlvSW4sIE9zY2lsbGF0b3IsXG4gICAqICBTb3VuZEZpbGUpLCB0aGVuIEVudmVsb3BlIHdpbGwgY29udHJvbCBpdHMgb3V0cHV0IHZvbHVtZS5cbiAgICogIEVudmVsb3BlcyBjYW4gYWxzbyBiZSB1c2VkIHRvIGNvbnRyb2wgYW55IDxhIGhyZWY9XCJcbiAgICogIGh0dHA6Ly9kb2NzLndlYnBsYXRmb3JtLm9yZy93aWtpL2FwaXMvd2ViYXVkaW8vQXVkaW9QYXJhbVwiPlxuICAgKiAgV2ViIEF1ZGlvIEF1ZGlvIFBhcmFtLjwvYT48L3A+XG4gICAqXG4gICAqICBAbWV0aG9kICBwbGF5XG4gICAqICBAZm9yIHA1LkVudmVsb3BlXG4gICAqICBAcGFyYW0gIHtPYmplY3R9IHVuaXQgICAgICAgICBBIHA1LnNvdW5kIG9iamVjdCBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2ViIEF1ZGlvIFBhcmFtLlxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbc3RhcnRUaW1lXSAgdGltZSBmcm9tIG5vdyAoaW4gc2Vjb25kcykgYXQgd2hpY2ggdG8gcGxheVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbc3VzdGFpblRpbWVdIHRpbWUgdG8gc3VzdGFpbiBiZWZvcmUgcmVsZWFzaW5nIHRoZSBlbnZlbG9wZVxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgYXR0YWNrTGV2ZWwgPSAxLjA7XG4gICAqICBsZXQgcmVsZWFzZUxldmVsID0gMDtcbiAgICpcbiAgICogIGxldCBhdHRhY2tUaW1lID0gMC4wMDE7XG4gICAqICBsZXQgZGVjYXlUaW1lID0gMC4yO1xuICAgKiAgbGV0IHN1c1BlcmNlbnQgPSAwLjI7XG4gICAqICBsZXQgcmVsZWFzZVRpbWUgPSAwLjU7XG4gICAqXG4gICAqICBsZXQgZW52LCB0cmlPc2M7XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQocGxheUVudik7XG4gICAqXG4gICAqICAgIGVudiA9IG5ldyBwNS5FbnZlbG9wZSgpO1xuICAgKiAgICB0cmlPc2MgPSBuZXcgcDUuT3NjaWxsYXRvcigndHJpYW5nbGUnKTtcbiAgICogICAgdHJpT3NjLmFtcChlbnYpO1xuICAgKiAgICB0cmlPc2MuZnJlcSgyMjApO1xuICAgKiAgICB0cmlPc2Muc3RhcnQoKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIGhlcmUgdG8gcGxheScsIDUsIDIwKTtcbiAgICogICAgYXR0YWNrVGltZSA9IG1hcChtb3VzZVgsIDAsIHdpZHRoLCAwLCAxLjApO1xuICAgKiAgICBhdHRhY2tMZXZlbCA9IG1hcChtb3VzZVksIGhlaWdodCwgMCwgMCwgMS4wKTtcbiAgICogICAgdGV4dCgnYXR0YWNrIHRpbWU6ICcgKyBhdHRhY2tUaW1lLCA1LCBoZWlnaHQgLSA0MCk7XG4gICAqICAgIHRleHQoJ2F0dGFjayBsZXZlbDogJyArIGF0dGFja0xldmVsLCA1LCBoZWlnaHQgLSAyMCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBwbGF5RW52KCkge1xuICAgKiAgICAvLyBlbnN1cmUgdGhhdCBhdWRpbyBpcyBlbmFibGVkXG4gICAqICAgIHVzZXJTdGFydEF1ZGlvKCk7XG4gICAqXG4gICAqICAgIGVudi5zZXRBRFNSKGF0dGFja1RpbWUsIGRlY2F5VGltZSwgc3VzUGVyY2VudCwgcmVsZWFzZVRpbWUpO1xuICAgKiAgICBlbnYuc2V0UmFuZ2UoYXR0YWNrTGV2ZWwsIHJlbGVhc2VMZXZlbCk7XG4gICAqICAgIGVudi5wbGF5KCk7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuRW52ZWxvcGUucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAodW5pdCwgc2Vjb25kc0Zyb21Ob3csIHN1c1RpbWUpIHtcbiAgICB2YXIgdEZyb21Ob3cgPSBzZWNvbmRzRnJvbU5vdyB8fCAwO1xuICAgIHZhciBzdXNUaW1lID0gc3VzVGltZSB8fCAwO1xuXG4gICAgaWYgKHVuaXQpIHtcbiAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24gIT09IHVuaXQpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0KHVuaXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudHJpZ2dlckF0dGFjayh1bml0LCB0RnJvbU5vdyk7XG4gICAgdGhpcy50cmlnZ2VyUmVsZWFzZSh1bml0LCB0RnJvbU5vdyArIHRoaXMuYVRpbWUgKyB0aGlzLmRUaW1lICsgc3VzVGltZSk7XG4gIH07XG4gIC8qKlxuICAgKiAgVHJpZ2dlciB0aGUgQXR0YWNrLCBhbmQgRGVjYXkgcG9ydGlvbiBvZiB0aGUgRW52ZWxvcGUuXG4gICAqICBTaW1pbGFyIHRvIGhvbGRpbmcgZG93biBhIGtleSBvbiBhIHBpYW5vLCBidXQgaXQgd2lsbFxuICAgKiAgaG9sZCB0aGUgc3VzdGFpbiBsZXZlbCB1bnRpbCB5b3UgbGV0IGdvLiBJbnB1dCBjYW4gYmVcbiAgICogIGFueSBwNS5zb3VuZCBvYmplY3QsIG9yIGEgPGEgaHJlZj1cIlxuICAgKiAgaHR0cDovL2RvY3Mud2VicGxhdGZvcm0ub3JnL3dpa2kvYXBpcy93ZWJhdWRpby9BdWRpb1BhcmFtXCI+XG4gICAqICBXZWIgQXVkaW8gUGFyYW08L2E+LlxuICAgKlxuICAgKiAgQG1ldGhvZCAgdHJpZ2dlckF0dGFja1xuICAgKiAgQGZvciBwNS5FbnZlbG9wZVxuICAgKiAgQHBhcmFtICB7T2JqZWN0fSB1bml0IHA1LnNvdW5kIE9iamVjdCBvciBXZWIgQXVkaW8gUGFyYW1cbiAgICogIEBwYXJhbSAge051bWJlcn0gc2Vjb25kc0Zyb21Ob3cgdGltZSBmcm9tIG5vdyAoaW4gc2Vjb25kcylcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IGF0dGFja1RpbWUgPSAwLjAwMTtcbiAgICogIGxldCBkZWNheVRpbWUgPSAwLjI7XG4gICAqICBsZXQgc3VzUGVyY2VudCA9IDAuMztcbiAgICogIGxldCByZWxlYXNlVGltZSA9IDAuNDtcbiAgICogIGxldCBlbnYsIHRyaU9zYztcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0QWxpZ24oQ0VOVEVSKTtcbiAgICogICAgdGV4dFNpemUoMTApO1xuICAgKiAgICB0ZXh0KCd0YXAgdG8gdHJpZ2dlckF0dGFjaycsIHdpZHRoLzIsIGhlaWdodC8yKTtcbiAgICpcbiAgICogICAgZW52ID0gbmV3IHA1LkVudmVsb3BlKCk7XG4gICAqICAgIGVudi5zZXRBRFNSKGF0dGFja1RpbWUsIGRlY2F5VGltZSwgc3VzUGVyY2VudCwgcmVsZWFzZVRpbWUpO1xuICAgKiAgICBlbnYuc2V0UmFuZ2UoMS4wLCAwLjApO1xuICAgKiAgICB0cmlPc2MgPSBuZXcgcDUuT3NjaWxsYXRvcigndHJpYW5nbGUnKTtcbiAgICogICAgdHJpT3NjLmZyZXEoMjIwKTtcbiAgICpcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChlbnZBdHRhY2spO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gZW52QXR0YWNrKCkgIHtcbiAgICogICAgYmFja2dyb3VuZCgwLCAyNTUsIDI1NSk7XG4gICAqICAgIHRleHQoJ3JlbGVhc2UgdG8gcmVsZWFzZScsIHdpZHRoLzIsIGhlaWdodC8yKTtcbiAgICpcbiAgICogICAgLy8gZW5zdXJlcyBhdWRpbyBpcyBlbmFibGVkLiBTZWUgYWxzbzogYHVzZXJTdGFydEF1ZGlvYFxuICAgKiAgICB0cmlPc2Muc3RhcnQoKTtcbiAgICpcbiAgICogICAgZW52LnRyaWdnZXJBdHRhY2sodHJpT3NjKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIG1vdXNlUmVsZWFzZWQoKSB7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHRyaWdnZXJBdHRhY2snLCB3aWR0aC8yLCBoZWlnaHQvMik7XG4gICAqXG4gICAqICAgIGVudi50cmlnZ2VyUmVsZWFzZSh0cmlPc2MpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LkVudmVsb3BlLnByb3RvdHlwZS50cmlnZ2VyQXR0YWNrID0gZnVuY3Rpb24gKHVuaXQsIHNlY29uZHNGcm9tTm93KSB7XG4gICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgIHZhciB0RnJvbU5vdyA9IHNlY29uZHNGcm9tTm93IHx8IDA7XG4gICAgdmFyIHQgPSBub3cgKyB0RnJvbU5vdztcbiAgICB0aGlzLmxhc3RBdHRhY2sgPSB0O1xuICAgIHRoaXMud2FzVHJpZ2dlcmVkID0gdHJ1ZTtcblxuICAgIGlmICh1bml0KSB7XG4gICAgICBpZiAodGhpcy5jb25uZWN0aW9uICE9PSB1bml0KSB7XG4gICAgICAgIHRoaXMuY29ubmVjdCh1bml0KTtcbiAgICAgIH1cbiAgICB9IFxuXG5cbiAgICB2YXIgdmFsVG9TZXQgPSB0aGlzLmNvbnRyb2wuZ2V0VmFsdWVBdFRpbWUodCk7XG5cbiAgICBpZiAodGhpcy5pc0V4cG9uZW50aWFsID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmNvbnRyb2wuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLmNoZWNrRXhwSW5wdXQodmFsVG9TZXQpLCB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250cm9sLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZhbFRvU2V0LCB0KTtcbiAgICB9IFxuXG5cbiAgICB0ICs9IHRoaXMuYVRpbWU7XG5cbiAgICBpZiAodGhpcy5pc0V4cG9uZW50aWFsID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmNvbnRyb2wuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLmNoZWNrRXhwSW5wdXQodGhpcy5hTGV2ZWwpLCB0KTtcbiAgICAgIHZhbFRvU2V0ID0gdGhpcy5jaGVja0V4cElucHV0KHRoaXMuY29udHJvbC5nZXRWYWx1ZUF0VGltZSh0KSk7XG4gICAgICB0aGlzLmNvbnRyb2wuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHQpO1xuICAgICAgdGhpcy5jb250cm9sLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodmFsVG9TZXQsIHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbnRyb2wubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5hTGV2ZWwsIHQpO1xuICAgICAgdmFsVG9TZXQgPSB0aGlzLmNvbnRyb2wuZ2V0VmFsdWVBdFRpbWUodCk7XG4gICAgICB0aGlzLmNvbnRyb2wuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHQpO1xuICAgICAgdGhpcy5jb250cm9sLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZhbFRvU2V0LCB0KTtcbiAgICB9IFxuXG5cbiAgICB0ICs9IHRoaXMuZFRpbWU7XG5cbiAgICBpZiAodGhpcy5pc0V4cG9uZW50aWFsID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmNvbnRyb2wuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLmNoZWNrRXhwSW5wdXQodGhpcy5kTGV2ZWwpLCB0KTtcbiAgICAgIHZhbFRvU2V0ID0gdGhpcy5jaGVja0V4cElucHV0KHRoaXMuY29udHJvbC5nZXRWYWx1ZUF0VGltZSh0KSk7XG4gICAgICB0aGlzLmNvbnRyb2wuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHQpO1xuICAgICAgdGhpcy5jb250cm9sLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodmFsVG9TZXQsIHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbnRyb2wubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5kTGV2ZWwsIHQpO1xuICAgICAgdmFsVG9TZXQgPSB0aGlzLmNvbnRyb2wuZ2V0VmFsdWVBdFRpbWUodCk7XG4gICAgICB0aGlzLmNvbnRyb2wuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHQpO1xuICAgICAgdGhpcy5jb250cm9sLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZhbFRvU2V0LCB0KTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgVHJpZ2dlciB0aGUgUmVsZWFzZSBvZiB0aGUgRW52ZWxvcGUuIFRoaXMgaXMgc2ltaWxhciB0byByZWxlYXNpbmdcbiAgICogIHRoZSBrZXkgb24gYSBwaWFubyBhbmQgbGV0dGluZyB0aGUgc291bmQgZmFkZSBhY2NvcmRpbmcgdG8gdGhlXG4gICAqICByZWxlYXNlIGxldmVsIGFuZCByZWxlYXNlIHRpbWUuXG4gICAqXG4gICAqICBAbWV0aG9kICB0cmlnZ2VyUmVsZWFzZVxuICAgKiAgQGZvciBwNS5FbnZlbG9wZVxuICAgKiAgQHBhcmFtICB7T2JqZWN0fSB1bml0IHA1LnNvdW5kIE9iamVjdCBvciBXZWIgQXVkaW8gUGFyYW1cbiAgICogIEBwYXJhbSAge051bWJlcn0gc2Vjb25kc0Zyb21Ob3cgdGltZSB0byB0cmlnZ2VyIHRoZSByZWxlYXNlXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBhdHRhY2tUaW1lID0gMC4wMDE7XG4gICAqICBsZXQgZGVjYXlUaW1lID0gMC4yO1xuICAgKiAgbGV0IHN1c1BlcmNlbnQgPSAwLjM7XG4gICAqICBsZXQgcmVsZWFzZVRpbWUgPSAwLjQ7XG4gICAqICBsZXQgZW52LCB0cmlPc2M7XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dEFsaWduKENFTlRFUik7XG4gICAqICAgIHRleHRTaXplKDEwKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHRyaWdnZXJBdHRhY2snLCB3aWR0aC8yLCBoZWlnaHQvMik7XG4gICAqXG4gICAqICAgIGVudiA9IG5ldyBwNS5FbnZlbG9wZSgpO1xuICAgKiAgICBlbnYuc2V0QURTUihhdHRhY2tUaW1lLCBkZWNheVRpbWUsIHN1c1BlcmNlbnQsIHJlbGVhc2VUaW1lKTtcbiAgICogICAgZW52LnNldFJhbmdlKDEuMCwgMC4wKTtcbiAgICogICAgdHJpT3NjID0gbmV3IHA1Lk9zY2lsbGF0b3IoJ3RyaWFuZ2xlJyk7XG4gICAqICAgIHRyaU9zYy5mcmVxKDIyMCk7XG4gICAqXG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQoZW52QXR0YWNrKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGVudkF0dGFjaygpICB7XG4gICAqICAgIGJhY2tncm91bmQoMCwgMjU1LCAyNTUpO1xuICAgKiAgICB0ZXh0KCdyZWxlYXNlIHRvIHJlbGVhc2UnLCB3aWR0aC8yLCBoZWlnaHQvMik7XG4gICAqXG4gICAqICAgIC8vIGVuc3VyZXMgYXVkaW8gaXMgZW5hYmxlZC4gU2VlIGFsc286IGB1c2VyU3RhcnRBdWRpb2BcbiAgICogICAgdHJpT3NjLnN0YXJ0KCk7XG4gICAqXG4gICAqICAgIGVudi50cmlnZ2VyQXR0YWNrKHRyaU9zYyk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBtb3VzZVJlbGVhc2VkKCkge1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ3RhcCB0byB0cmlnZ2VyQXR0YWNrJywgd2lkdGgvMiwgaGVpZ2h0LzIpO1xuICAgKlxuICAgKiAgICBlbnYudHJpZ2dlclJlbGVhc2UodHJpT3NjKTtcbiAgICogIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5FbnZlbG9wZS5wcm90b3R5cGUudHJpZ2dlclJlbGVhc2UgPSBmdW5jdGlvbiAodW5pdCwgc2Vjb25kc0Zyb21Ob3cpIHtcbiAgICBpZiAoIXRoaXMud2FzVHJpZ2dlcmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgIHZhciB0RnJvbU5vdyA9IHNlY29uZHNGcm9tTm93IHx8IDA7XG4gICAgdmFyIHQgPSBub3cgKyB0RnJvbU5vdztcblxuICAgIGlmICh1bml0KSB7XG4gICAgICBpZiAodGhpcy5jb25uZWN0aW9uICE9PSB1bml0KSB7XG4gICAgICAgIHRoaXMuY29ubmVjdCh1bml0KTtcbiAgICAgIH1cbiAgICB9IFxuXG5cbiAgICB2YXIgdmFsVG9TZXQgPSB0aGlzLmNvbnRyb2wuZ2V0VmFsdWVBdFRpbWUodCk7XG5cbiAgICBpZiAodGhpcy5pc0V4cG9uZW50aWFsID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmNvbnRyb2wuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLmNoZWNrRXhwSW5wdXQodmFsVG9TZXQpLCB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250cm9sLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZhbFRvU2V0LCB0KTtcbiAgICB9IFxuXG5cbiAgICB0ICs9IHRoaXMuclRpbWU7XG5cbiAgICBpZiAodGhpcy5pc0V4cG9uZW50aWFsID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmNvbnRyb2wuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLmNoZWNrRXhwSW5wdXQodGhpcy5yTGV2ZWwpLCB0KTtcbiAgICAgIHZhbFRvU2V0ID0gdGhpcy5jaGVja0V4cElucHV0KHRoaXMuY29udHJvbC5nZXRWYWx1ZUF0VGltZSh0KSk7XG4gICAgICB0aGlzLmNvbnRyb2wuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHQpO1xuICAgICAgdGhpcy5jb250cm9sLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodmFsVG9TZXQsIHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbnRyb2wubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5yTGV2ZWwsIHQpO1xuICAgICAgdmFsVG9TZXQgPSB0aGlzLmNvbnRyb2wuZ2V0VmFsdWVBdFRpbWUodCk7XG4gICAgICB0aGlzLmNvbnRyb2wuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHQpO1xuICAgICAgdGhpcy5jb250cm9sLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZhbFRvU2V0LCB0KTtcbiAgICB9XG5cbiAgICB0aGlzLndhc1RyaWdnZXJlZCA9IGZhbHNlO1xuICB9O1xuICAvKipcbiAgICogIEV4cG9uZW50aWFsbHkgcmFtcCB0byBhIHZhbHVlIHVzaW5nIHRoZSBmaXJzdCB0d29cbiAgICogIHZhbHVlcyBmcm9tIDxjb2RlPjxhIGhyZWY9XCIjL3A1LkVudmVsb3BlL3NldEFEU1JcIj5zZXRBRFNSKGF0dGFja1RpbWUsIGRlY2F5VGltZSk8L2E+PC9jb2RlPlxuICAgKiAgYXMgPGEgaHJlZj1cImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JDX3RpbWVfY29uc3RhbnRcIj5cbiAgICogIHRpbWUgY29uc3RhbnRzPC9hPiBmb3Igc2ltcGxlIGV4cG9uZW50aWFsIHJhbXBzLlxuICAgKiAgSWYgdGhlIHZhbHVlIGlzIGhpZ2hlciB0aGFuIGN1cnJlbnQgdmFsdWUsIGl0IHVzZXMgYXR0YWNrVGltZSxcbiAgICogIHdoaWxlIGEgZGVjcmVhc2UgdXNlcyBkZWNheVRpbWUuXG4gICAqXG4gICAqICBAbWV0aG9kICByYW1wXG4gICAqICBAZm9yIHA1LkVudmVsb3BlXG4gICAqICBAcGFyYW0gIHtPYmplY3R9IHVuaXQgICAgICAgICAgIHA1LnNvdW5kIE9iamVjdCBvciBXZWIgQXVkaW8gUGFyYW1cbiAgICogIEBwYXJhbSAge051bWJlcn0gc2Vjb25kc0Zyb21Ob3cgV2hlbiB0byB0cmlnZ2VyIHRoZSByYW1wXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IHYgICAgICAgICAgICAgIFRhcmdldCB2YWx1ZVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbdjJdICAgICAgICAgICBTZWNvbmQgdGFyZ2V0IHZhbHVlIChvcHRpb25hbClcbiAgICogIEBleGFtcGxlXG4gICAqICA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IGVudiwgb3NjLCBhbXA7XG4gICAqXG4gICAqICBsZXQgYXR0YWNrVGltZSA9IDAuMDAxO1xuICAgKiAgbGV0IGRlY2F5VGltZSA9IDAuMjtcbiAgICogIGxldCBhdHRhY2tMZXZlbCA9IDE7XG4gICAqICBsZXQgZGVjYXlMZXZlbCA9IDA7XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGZpbGwoMCwyNTUsMCk7XG4gICAqICAgIG5vU3Ryb2tlKCk7XG4gICAqXG4gICAqICAgIGVudiA9IG5ldyBwNS5FbnZlbG9wZSgpO1xuICAgKiAgICBlbnYuc2V0QURTUihhdHRhY2tUaW1lLCBkZWNheVRpbWUpO1xuICAgKiAgICBvc2MgPSBuZXcgcDUuT3NjaWxsYXRvcigpO1xuICAgKiAgICBvc2MuYW1wKGVudik7XG4gICAqICAgIGFtcCA9IG5ldyBwNS5BbXBsaXR1ZGUoKTtcbiAgICpcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZCh0cmlnZ2VyUmFtcCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiB0cmlnZ2VyUmFtcCgpIHtcbiAgICogICAgLy8gZW5zdXJlcyBhdWRpbyBpcyBlbmFibGVkLiBTZWUgYWxzbzogYHVzZXJTdGFydEF1ZGlvYFxuICAgKiAgICBvc2Muc3RhcnQoKTtcbiAgICpcbiAgICogICAgZW52LnJhbXAob3NjLCAwLCBhdHRhY2tMZXZlbCwgZGVjYXlMZXZlbCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBkcmF3KCkge1xuICAgKiAgICBiYWNrZ3JvdW5kKDIwKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCAxMCwgMjApO1xuICAgKiAgICBsZXQgaCA9IG1hcChhbXAuZ2V0TGV2ZWwoKSwgMCwgMC40LCAwLCBoZWlnaHQpOztcbiAgICogICAgcmVjdCgwLCBoZWlnaHQsIHdpZHRoLCAtaCk7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuRW52ZWxvcGUucHJvdG90eXBlLnJhbXAgPSBmdW5jdGlvbiAodW5pdCwgc2Vjb25kc0Zyb21Ob3csIHYxLCB2Mikge1xuICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICB2YXIgdEZyb21Ob3cgPSBzZWNvbmRzRnJvbU5vdyB8fCAwO1xuICAgIHZhciB0ID0gbm93ICsgdEZyb21Ob3c7XG4gICAgdmFyIGRlc3RpbmF0aW9uMSA9IHRoaXMuY2hlY2tFeHBJbnB1dCh2MSk7XG4gICAgdmFyIGRlc3RpbmF0aW9uMiA9IHR5cGVvZiB2MiAhPT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmNoZWNrRXhwSW5wdXQodjIpIDogdW5kZWZpbmVkOyBcblxuICAgIGlmICh1bml0KSB7XG4gICAgICBpZiAodGhpcy5jb25uZWN0aW9uICE9PSB1bml0KSB7XG4gICAgICAgIHRoaXMuY29ubmVjdCh1bml0KTtcbiAgICAgIH1cbiAgICB9IFxuXG5cbiAgICB2YXIgY3VycmVudFZhbCA9IHRoaXMuY2hlY2tFeHBJbnB1dCh0aGlzLmNvbnRyb2wuZ2V0VmFsdWVBdFRpbWUodCkpOyBcblxuICAgIGlmIChkZXN0aW5hdGlvbjEgPiBjdXJyZW50VmFsKSB7XG4gICAgICB0aGlzLmNvbnRyb2wuc2V0VGFyZ2V0QXRUaW1lKGRlc3RpbmF0aW9uMSwgdCwgdGhpcy5fcmFtcEF0dGFja1RDKTtcbiAgICAgIHQgKz0gdGhpcy5fcmFtcEF0dGFja1RpbWU7XG4gICAgfSBcbiAgICBlbHNlIGlmIChkZXN0aW5hdGlvbjEgPCBjdXJyZW50VmFsKSB7XG4gICAgICAgIHRoaXMuY29udHJvbC5zZXRUYXJnZXRBdFRpbWUoZGVzdGluYXRpb24xLCB0LCB0aGlzLl9yYW1wRGVjYXlUQyk7XG4gICAgICAgIHQgKz0gdGhpcy5fcmFtcERlY2F5VGltZTtcbiAgICAgIH0gXG5cblxuICAgIGlmIChkZXN0aW5hdGlvbjIgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyBcblxuICAgIGlmIChkZXN0aW5hdGlvbjIgPiBkZXN0aW5hdGlvbjEpIHtcbiAgICAgIHRoaXMuY29udHJvbC5zZXRUYXJnZXRBdFRpbWUoZGVzdGluYXRpb24yLCB0LCB0aGlzLl9yYW1wQXR0YWNrVEMpO1xuICAgIH0gXG4gICAgZWxzZSBpZiAoZGVzdGluYXRpb24yIDwgZGVzdGluYXRpb24xKSB7XG4gICAgICAgIHRoaXMuY29udHJvbC5zZXRUYXJnZXRBdFRpbWUoZGVzdGluYXRpb24yLCB0LCB0aGlzLl9yYW1wRGVjYXlUQyk7XG4gICAgICB9XG4gIH07XG5cbiAgcDUuRW52ZWxvcGUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAodW5pdCkge1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IHVuaXQ7IFxuXG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBwNS5Pc2NpbGxhdG9yIHx8IHVuaXQgaW5zdGFuY2VvZiBwNS5Tb3VuZEZpbGUgfHwgdW5pdCBpbnN0YW5jZW9mIHA1LkF1ZGlvSW4gfHwgdW5pdCBpbnN0YW5jZW9mIHA1LlJldmVyYiB8fCB1bml0IGluc3RhbmNlb2YgcDUuTm9pc2UgfHwgdW5pdCBpbnN0YW5jZW9mIHA1LkZpbHRlciB8fCB1bml0IGluc3RhbmNlb2YgcDUuRGVsYXkpIHtcbiAgICAgIHVuaXQgPSB1bml0Lm91dHB1dC5nYWluO1xuICAgIH1cblxuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQXVkaW9QYXJhbSkge1xuICAgICAgdW5pdC5zZXRWYWx1ZUF0VGltZSgwLCBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgfVxuXG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBwNS5TaWduYWwpIHtcbiAgICAgIHVuaXQuc2V0VmFsdWUoMCk7XG4gICAgfVxuXG4gICAgdGhpcy5vdXRwdXQuY29ubmVjdCh1bml0KTtcbiAgfTtcblxuICBwNS5FbnZlbG9wZS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vdXRwdXQpIHtcbiAgICAgIHRoaXMub3V0cHV0LmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH07IFxuXG4gIC8qKlxuICAgKiAgQWRkIGEgdmFsdWUgdG8gdGhlIHA1Lk9zY2lsbGF0b3IncyBvdXRwdXQgYW1wbGl0dWRlLFxuICAgKiAgYW5kIHJldHVybiB0aGUgb3NjaWxsYXRvci4gQ2FsbGluZyB0aGlzIG1ldGhvZFxuICAgKiAgYWdhaW4gd2lsbCBvdmVycmlkZSB0aGUgaW5pdGlhbCBhZGQoKSB3aXRoIG5ldyB2YWx1ZXMuXG4gICAqXG4gICAqICBAbWV0aG9kICBhZGRcbiAgICogIEBmb3IgcDUuRW52ZWxvcGVcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgQ29uc3RhbnQgbnVtYmVyIHRvIGFkZFxuICAgKiAgQHJldHVybiB7cDUuRW52ZWxvcGV9IEVudmVsb3BlIFJldHVybnMgdGhpcyBlbnZlbG9wZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHNjYWxlZCBvdXRwdXRcbiAgICovXG5cblxuICBwNS5FbnZlbG9wZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHZhciBhZGQgPSBuZXcgQWRkKG51bSk7XG4gICAgdmFyIHRoaXNDaGFpbiA9IHRoaXMubWF0aE9wcy5sZW5ndGg7XG4gICAgdmFyIG5leHRDaGFpbiA9IHRoaXMub3V0cHV0O1xuICAgIHJldHVybiBwNS5wcm90b3R5cGUuX21hdGhDaGFpbih0aGlzLCBhZGQsIHRoaXNDaGFpbiwgbmV4dENoYWluLCBBZGQpO1xuICB9O1xuICAvKipcbiAgICogIE11bHRpcGx5IHRoZSBwNS5FbnZlbG9wZSdzIG91dHB1dCBhbXBsaXR1ZGVcbiAgICogIGJ5IGEgZml4ZWQgdmFsdWUuIENhbGxpbmcgdGhpcyBtZXRob2RcbiAgICogIGFnYWluIHdpbGwgb3ZlcnJpZGUgdGhlIGluaXRpYWwgbXVsdCgpIHdpdGggbmV3IHZhbHVlcy5cbiAgICpcbiAgICogIEBtZXRob2QgIG11bHRcbiAgICogIEBmb3IgcDUuRW52ZWxvcGVcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgQ29uc3RhbnQgbnVtYmVyIHRvIG11bHRpcGx5XG4gICAqICBAcmV0dXJuIHtwNS5FbnZlbG9wZX0gRW52ZWxvcGUgUmV0dXJucyB0aGlzIGVudmVsb3BlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggc2NhbGVkIG91dHB1dFxuICAgKi9cblxuXG4gIHA1LkVudmVsb3BlLnByb3RvdHlwZS5tdWx0ID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHZhciBtdWx0ID0gbmV3IE11bHQobnVtKTtcbiAgICB2YXIgdGhpc0NoYWluID0gdGhpcy5tYXRoT3BzLmxlbmd0aDtcbiAgICB2YXIgbmV4dENoYWluID0gdGhpcy5vdXRwdXQ7XG4gICAgcmV0dXJuIHA1LnByb3RvdHlwZS5fbWF0aENoYWluKHRoaXMsIG11bHQsIHRoaXNDaGFpbiwgbmV4dENoYWluLCBNdWx0KTtcbiAgfTtcbiAgLyoqXG4gICAqICBTY2FsZSB0aGlzIGVudmVsb3BlJ3MgYW1wbGl0dWRlIHZhbHVlcyB0byBhIGdpdmVuXG4gICAqICByYW5nZSwgYW5kIHJldHVybiB0aGUgZW52ZWxvcGUuIENhbGxpbmcgdGhpcyBtZXRob2RcbiAgICogIGFnYWluIHdpbGwgb3ZlcnJpZGUgdGhlIGluaXRpYWwgc2NhbGUoKSB3aXRoIG5ldyB2YWx1ZXMuXG4gICAqXG4gICAqICBAbWV0aG9kICBzY2FsZVxuICAgKiAgQGZvciBwNS5FbnZlbG9wZVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBpbk1pbiAgaW5wdXQgcmFuZ2UgbWludW11bVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBpbk1heCAgaW5wdXQgcmFuZ2UgbWF4aW11bVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBvdXRNaW4gaW5wdXQgcmFuZ2UgbWludW11bVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBvdXRNYXggaW5wdXQgcmFuZ2UgbWF4aW11bVxuICAgKiAgQHJldHVybiB7cDUuRW52ZWxvcGV9IEVudmVsb3BlIFJldHVybnMgdGhpcyBlbnZlbG9wZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHNjYWxlZCBvdXRwdXRcbiAgICovXG5cblxuICBwNS5FbnZlbG9wZS5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbiAoaW5NaW4sIGluTWF4LCBvdXRNaW4sIG91dE1heCkge1xuICAgIHZhciBzY2FsZSA9IG5ldyBTY2FsZShpbk1pbiwgaW5NYXgsIG91dE1pbiwgb3V0TWF4KTtcbiAgICB2YXIgdGhpc0NoYWluID0gdGhpcy5tYXRoT3BzLmxlbmd0aDtcbiAgICB2YXIgbmV4dENoYWluID0gdGhpcy5vdXRwdXQ7XG4gICAgcmV0dXJuIHA1LnByb3RvdHlwZS5fbWF0aENoYWluKHRoaXMsIHNjYWxlLCB0aGlzQ2hhaW4sIG5leHRDaGFpbiwgU2NhbGUpO1xuICB9OyBcblxuXG4gIHA1LkVudmVsb3BlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmRleCA9IHA1c291bmQuc291bmRBcnJheS5pbmRleE9mKHRoaXMpO1xuICAgIHA1c291bmQuc291bmRBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuXG4gICAgaWYgKHRoaXMuY29udHJvbCkge1xuICAgICAgdGhpcy5jb250cm9sLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuY29udHJvbCA9IG51bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLm1hdGhPcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMubWF0aE9wc1tpXS5kaXNwb3NlKCk7XG4gICAgfVxuICB9OyBcblxuXG4gIHA1LkVudiA9IGZ1bmN0aW9uICh0MSwgbDEsIHQyLCBsMiwgdDMsIGwzKSB7XG4gICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBwNS5FbnYgaXMgbm93IGRlcHJlY2F0ZWQgYW5kIG1heSBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucy4gJyArICdQbGVhc2UgdXNlIHRoZSBuZXcgcDUuRW52ZWxvcGUgaW5zdGVhZC4nKTtcbiAgICBwNS5FbnZlbG9wZS5jYWxsKHRoaXMsIHQxLCBsMSwgdDIsIGwyLCB0MywgbDMpO1xuICB9O1xuXG4gIHA1LkVudi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHA1LkVudmVsb3BlLnByb3RvdHlwZSk7XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgdmFyIHA1c291bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuICAvKipcbiAgICogIENyZWF0ZXMgYSBQdWxzZSBvYmplY3QsIGFuIG9zY2lsbGF0b3IgdGhhdCBpbXBsZW1lbnRzXG4gICAqICBQdWxzZSBXaWR0aCBNb2R1bGF0aW9uLlxuICAgKiAgVGhlIHB1bHNlIGlzIGNyZWF0ZWQgd2l0aCB0d28gb3NjaWxsYXRvcnMuXG4gICAqICBBY2NlcHRzIGEgcGFyYW1ldGVyIGZvciBmcmVxdWVuY3ksIGFuZCB0byBzZXQgdGhlXG4gICAqICB3aWR0aCBiZXR3ZWVuIHRoZSBwdWxzZXMuIFNlZSA8YSBocmVmPVwiXG4gICAqICBodHRwOi8vcDVqcy5vcmcvcmVmZXJlbmNlLyMvcDUuT3NjaWxsYXRvclwiPlxuICAgKiAgPGNvZGU+cDUuT3NjaWxsYXRvcjwvY29kZT4gZm9yIGEgZnVsbCBsaXN0IG9mIG1ldGhvZHMuXG4gICAqXG4gICAqICBAY2xhc3MgcDUuUHVsc2VcbiAgICogIEBleHRlbmRzIHA1Lk9zY2lsbGF0b3JcbiAgICogIEBjb25zdHJ1Y3RvclxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtmcmVxXSBGcmVxdWVuY3kgaW4gb3NjaWxsYXRpb25zIHBlciBzZWNvbmQgKEh6KVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFt3XSAgICBXaWR0aCBiZXR3ZWVuIHRoZSBwdWxzZXMgKDAgdG8gMS4wLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0cyB0byAwKVxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgcHVsc2U7XG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQoc3RhcnRQdWxzZSk7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICpcbiAgICogICAgcHVsc2UgPSBuZXcgcDUuUHVsc2UoKTtcbiAgICogICAgcHVsc2UuYW1wKDAuNSk7XG4gICAqICAgIHB1bHNlLmZyZXEoMjIwKTtcbiAgICogIH1cbiAgICogIGZ1bmN0aW9uIHN0YXJ0UHVsc2UoKSB7XG4gICAqICAgIHB1bHNlLnN0YXJ0KCk7XG4gICAqICAgIHB1bHNlLmFtcCgwLjUsIDAuMDIpO1xuICAgKiAgfVxuICAgKiAgZnVuY3Rpb24gbW91c2VSZWxlYXNlZCgpIHtcbiAgICogICAgcHVsc2UuYW1wKDAsIDAuMik7XG4gICAqICB9XG4gICAqICBmdW5jdGlvbiBkcmF3KCkge1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ3RhcCB0byBwbGF5JywgNSwgMjAsIHdpZHRoIC0gMjApO1xuICAgKiAgICBsZXQgdyA9IG1hcChtb3VzZVgsIDAsIHdpZHRoLCAwLCAxKTtcbiAgICogICAgdyA9IGNvbnN0cmFpbih3LCAwLCAxKTtcbiAgICogICAgcHVsc2Uud2lkdGgodyk7XG4gICAqICAgIHRleHQoJ3B1bHNlIHdpZHRoOiAnICsgdywgNSwgaGVpZ2h0IC0gMjApO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LlB1bHNlID0gZnVuY3Rpb24gKGZyZXEsIHcpIHtcbiAgICBwNS5Pc2NpbGxhdG9yLmNhbGwodGhpcywgZnJlcSwgJ3Nhd3Rvb3RoJyk7IFxuXG4gICAgdGhpcy53ID0gdyB8fCAwOyBcblxuICAgIHRoaXMub3NjMiA9IG5ldyBwNS5TYXdPc2MoZnJlcSk7IFxuXG4gICAgdGhpcy5kTm9kZSA9IHA1c291bmQuYXVkaW9jb250ZXh0LmNyZWF0ZURlbGF5KCk7IFxuXG4gICAgdGhpcy5kY09mZnNldCA9IGNyZWF0ZURDT2Zmc2V0KCk7XG4gICAgdGhpcy5kY0dhaW4gPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgdGhpcy5kY09mZnNldC5jb25uZWN0KHRoaXMuZGNHYWluKTtcbiAgICB0aGlzLmRjR2Fpbi5jb25uZWN0KHRoaXMub3V0cHV0KTsgXG5cbiAgICB0aGlzLmYgPSBmcmVxIHx8IDQ0MDtcbiAgICB2YXIgbVcgPSB0aGlzLncgLyB0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5LnZhbHVlO1xuICAgIHRoaXMuZE5vZGUuZGVsYXlUaW1lLnZhbHVlID0gbVc7XG4gICAgdGhpcy5kY0dhaW4uZ2Fpbi52YWx1ZSA9IDEuNyAqICgwLjUgLSB0aGlzLncpOyBcblxuICAgIHRoaXMub3NjMi5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5vc2MyLnBhbm5lci5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5vc2MyLmFtcCgtMSk7IFxuXG4gICAgdGhpcy5vc2MyLm91dHB1dC5jb25uZWN0KHRoaXMuZE5vZGUpO1xuICAgIHRoaXMuZE5vZGUuY29ubmVjdCh0aGlzLm91dHB1dCk7XG4gICAgdGhpcy5vdXRwdXQuZ2Fpbi52YWx1ZSA9IDE7XG4gICAgdGhpcy5vdXRwdXQuY29ubmVjdCh0aGlzLnBhbm5lcik7XG4gIH07XG5cbiAgcDUuUHVsc2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwNS5Pc2NpbGxhdG9yLnByb3RvdHlwZSk7XG4gIC8qKlxuICAgKiAgU2V0IHRoZSB3aWR0aCBvZiBhIFB1bHNlIG9iamVjdCAoYW4gb3NjaWxsYXRvciB0aGF0IGltcGxlbWVudHNcbiAgICogIFB1bHNlIFdpZHRoIE1vZHVsYXRpb24pLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgd2lkdGhcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGhdICAgIFdpZHRoIGJldHdlZW4gdGhlIHB1bHNlcyAoMCB0byAxLjAsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzIHRvIDApXG4gICAqL1xuXG4gIHA1LlB1bHNlLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uICh3KSB7XG4gICAgaWYgKHR5cGVvZiB3ID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKHcgPD0gMS4wICYmIHcgPj0gMC4wKSB7XG4gICAgICAgIHRoaXMudyA9IHc7IFxuXG4gICAgICAgIHZhciBtVyA9IHRoaXMudyAvIHRoaXMub3NjaWxsYXRvci5mcmVxdWVuY3kudmFsdWU7XG4gICAgICAgIHRoaXMuZE5vZGUuZGVsYXlUaW1lLnZhbHVlID0gbVc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGNHYWluLmdhaW4udmFsdWUgPSAxLjcgKiAoMC41IC0gdGhpcy53KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdy5jb25uZWN0KHRoaXMuZE5vZGUuZGVsYXlUaW1lKTtcbiAgICAgIHZhciBzaWcgPSBuZXcgcDUuU2lnbmFsQWRkKC0wLjUpO1xuICAgICAgc2lnLnNldElucHV0KHcpO1xuICAgICAgc2lnID0gc2lnLm11bHQoLTEpO1xuICAgICAgc2lnID0gc2lnLm11bHQoMS43KTtcbiAgICAgIHNpZy5jb25uZWN0KHRoaXMuZGNHYWluLmdhaW4pO1xuICAgIH1cbiAgfTtcblxuICBwNS5QdWxzZS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoZiwgdGltZSkge1xuICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICB2YXIgdCA9IHRpbWUgfHwgMDtcblxuICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICB2YXIgZnJlcSA9IGYgfHwgdGhpcy5mO1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLm9zY2lsbGF0b3IudHlwZTtcbiAgICAgIHRoaXMub3NjaWxsYXRvciA9IHA1c291bmQuYXVkaW9jb250ZXh0LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICAgIHRoaXMub3NjaWxsYXRvci5mcmVxdWVuY3kuc2V0VmFsdWVBdFRpbWUoZnJlcSwgbm93KTtcbiAgICAgIHRoaXMub3NjaWxsYXRvci50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMub3NjaWxsYXRvci5jb25uZWN0KHRoaXMub3V0cHV0KTtcbiAgICAgIHRoaXMub3NjaWxsYXRvci5zdGFydCh0ICsgbm93KTsgXG5cbiAgICAgIHRoaXMub3NjMi5vc2NpbGxhdG9yID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgICAgdGhpcy5vc2MyLm9zY2lsbGF0b3IuZnJlcXVlbmN5LnNldFZhbHVlQXRUaW1lKGZyZXEsIHQgKyBub3cpO1xuICAgICAgdGhpcy5vc2MyLm9zY2lsbGF0b3IudHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLm9zYzIub3NjaWxsYXRvci5jb25uZWN0KHRoaXMub3NjMi5vdXRwdXQpO1xuICAgICAgdGhpcy5vc2MyLnN0YXJ0KHQgKyBub3cpO1xuICAgICAgdGhpcy5mcmVxTm9kZSA9IFt0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5LCB0aGlzLm9zYzIub3NjaWxsYXRvci5mcmVxdWVuY3ldOyBcblxuICAgICAgdGhpcy5kY09mZnNldCA9IGNyZWF0ZURDT2Zmc2V0KCk7XG4gICAgICB0aGlzLmRjT2Zmc2V0LmNvbm5lY3QodGhpcy5kY0dhaW4pO1xuICAgICAgdGhpcy5kY09mZnNldC5zdGFydCh0ICsgbm93KTsgXG5cbiAgICAgIGlmICh0aGlzLm1vZHMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm1vZHMuZnJlcXVlbmN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5tb2RzLmZyZXF1ZW5jeS5jb25uZWN0KHRoaXMuZnJlcU5vZGVbMF0pO1xuICAgICAgICB0aGlzLm1vZHMuZnJlcXVlbmN5LmNvbm5lY3QodGhpcy5mcmVxTm9kZVsxXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICB0aGlzLm9zYzIuc3RhcnRlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIHA1LlB1bHNlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICB2YXIgdCA9IHRpbWUgfHwgMDtcbiAgICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICAgIHRoaXMub3NjaWxsYXRvci5zdG9wKHQgKyBub3cpO1xuXG4gICAgICBpZiAodGhpcy5vc2MyLm9zY2lsbGF0b3IpIHtcbiAgICAgICAgdGhpcy5vc2MyLm9zY2lsbGF0b3Iuc3RvcCh0ICsgbm93KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kY09mZnNldC5zdG9wKHQgKyBub3cpO1xuICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICB0aGlzLm9zYzIuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBwNS5QdWxzZS5wcm90b3R5cGUuZnJlcSA9IGZ1bmN0aW9uICh2YWwsIHJhbXBUaW1lLCB0RnJvbU5vdykge1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5mID0gdmFsO1xuICAgICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgdmFyIHJhbXBUaW1lID0gcmFtcFRpbWUgfHwgMDtcbiAgICAgIHZhciB0RnJvbU5vdyA9IHRGcm9tTm93IHx8IDA7XG4gICAgICB2YXIgY3VycmVudEZyZXEgPSB0aGlzLm9zY2lsbGF0b3IuZnJlcXVlbmN5LnZhbHVlO1xuICAgICAgdGhpcy5vc2NpbGxhdG9yLmZyZXF1ZW5jeS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMobm93KTtcbiAgICAgIHRoaXMub3NjaWxsYXRvci5mcmVxdWVuY3kuc2V0VmFsdWVBdFRpbWUoY3VycmVudEZyZXEsIG5vdyArIHRGcm9tTm93KTtcbiAgICAgIHRoaXMub3NjaWxsYXRvci5mcmVxdWVuY3kuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh2YWwsIHRGcm9tTm93ICsgcmFtcFRpbWUgKyBub3cpO1xuICAgICAgdGhpcy5vc2MyLm9zY2lsbGF0b3IuZnJlcXVlbmN5LmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhub3cpO1xuICAgICAgdGhpcy5vc2MyLm9zY2lsbGF0b3IuZnJlcXVlbmN5LnNldFZhbHVlQXRUaW1lKGN1cnJlbnRGcmVxLCBub3cgKyB0RnJvbU5vdyk7XG4gICAgICB0aGlzLm9zYzIub3NjaWxsYXRvci5mcmVxdWVuY3kuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh2YWwsIHRGcm9tTm93ICsgcmFtcFRpbWUgKyBub3cpO1xuXG4gICAgICBpZiAodGhpcy5mcmVxTW9kKSB7XG4gICAgICAgIHRoaXMuZnJlcU1vZC5vdXRwdXQuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmZyZXFNb2QgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsLm91dHB1dCkge1xuICAgICAgdmFsLm91dHB1dC5kaXNjb25uZWN0KCk7XG4gICAgICB2YWwub3V0cHV0LmNvbm5lY3QodGhpcy5vc2NpbGxhdG9yLmZyZXF1ZW5jeSk7XG4gICAgICB2YWwub3V0cHV0LmNvbm5lY3QodGhpcy5vc2MyLm9zY2lsbGF0b3IuZnJlcXVlbmN5KTtcbiAgICAgIHRoaXMuZnJlcU1vZCA9IHZhbDtcbiAgICB9XG4gIH07IFxuXG5cbiAgZnVuY3Rpb24gY3JlYXRlRENPZmZzZXQoKSB7XG4gICAgdmFyIGFjID0gcDVzb3VuZC5hdWRpb2NvbnRleHQ7XG4gICAgdmFyIGJ1ZmZlciA9IGFjLmNyZWF0ZUJ1ZmZlcigxLCAyMDQ4LCBhYy5zYW1wbGVSYXRlKTtcbiAgICB2YXIgZGF0YSA9IGJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjA0ODsgaSsrKSB7XG4gICAgICBkYXRhW2ldID0gMS4wO1xuICAgIH1cblxuICAgIHZhciBidWZmZXJTb3VyY2UgPSBhYy5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICBidWZmZXJTb3VyY2UuYnVmZmVyID0gYnVmZmVyO1xuICAgIGJ1ZmZlclNvdXJjZS5sb29wID0gdHJ1ZTtcbiAgICByZXR1cm4gYnVmZmVyU291cmNlO1xuICB9XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgdmFyIHA1c291bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuICAvKipcbiAgICogIE5vaXNlIGlzIGEgdHlwZSBvZiBvc2NpbGxhdG9yIHRoYXQgZ2VuZXJhdGVzIGEgYnVmZmVyIHdpdGggcmFuZG9tIHZhbHVlcy5cbiAgICpcbiAgICogIEBjbGFzcyBwNS5Ob2lzZVxuICAgKiAgQGV4dGVuZHMgcDUuT3NjaWxsYXRvclxuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIG5vaXNlIGNhbiBiZSAnd2hpdGUnIChkZWZhdWx0KSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICdicm93bicgb3IgJ3BpbmsnLlxuICAgKi9cblxuXG4gIHA1Lk5vaXNlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgYXNzaWduVHlwZTtcbiAgICBwNS5Pc2NpbGxhdG9yLmNhbGwodGhpcyk7XG4gICAgZGVsZXRlIHRoaXMuZjtcbiAgICBkZWxldGUgdGhpcy5mcmVxO1xuICAgIGRlbGV0ZSB0aGlzLm9zY2lsbGF0b3I7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2Jyb3duJykge1xuICAgICAgYXNzaWduVHlwZSA9IF9icm93bk5vaXNlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3BpbmsnKSB7XG4gICAgICBhc3NpZ25UeXBlID0gX3BpbmtOb2lzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVHlwZSA9IF93aGl0ZU5vaXNlO1xuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyID0gYXNzaWduVHlwZTtcbiAgfTtcblxuICBwNS5Ob2lzZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHA1Lk9zY2lsbGF0b3IucHJvdG90eXBlKTsgXG5cbiAgdmFyIF93aGl0ZU5vaXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBidWZmZXJTaXplID0gMiAqIHA1c291bmQuYXVkaW9jb250ZXh0LnNhbXBsZVJhdGU7XG4gICAgdmFyIHdoaXRlQnVmZmVyID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3JlYXRlQnVmZmVyKDEsIGJ1ZmZlclNpemUsIHA1c291bmQuYXVkaW9jb250ZXh0LnNhbXBsZVJhdGUpO1xuICAgIHZhciBub2lzZURhdGEgPSB3aGl0ZUJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyU2l6ZTsgaSsrKSB7XG4gICAgICBub2lzZURhdGFbaV0gPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XG4gICAgfVxuXG4gICAgd2hpdGVCdWZmZXIudHlwZSA9ICd3aGl0ZSc7XG4gICAgcmV0dXJuIHdoaXRlQnVmZmVyO1xuICB9KCk7XG5cbiAgdmFyIF9waW5rTm9pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJ1ZmZlclNpemUgPSAyICogcDVzb3VuZC5hdWRpb2NvbnRleHQuc2FtcGxlUmF0ZTtcbiAgICB2YXIgcGlua0J1ZmZlciA9IHA1c291bmQuYXVkaW9jb250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCBidWZmZXJTaXplLCBwNXNvdW5kLmF1ZGlvY29udGV4dC5zYW1wbGVSYXRlKTtcbiAgICB2YXIgbm9pc2VEYXRhID0gcGlua0J1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcbiAgICB2YXIgYjAsIGIxLCBiMiwgYjMsIGI0LCBiNSwgYjY7XG4gICAgYjAgPSBiMSA9IGIyID0gYjMgPSBiNCA9IGI1ID0gYjYgPSAwLjA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlclNpemU7IGkrKykge1xuICAgICAgdmFyIHdoaXRlID0gTWF0aC5yYW5kb20oKSAqIDIgLSAxO1xuICAgICAgYjAgPSAwLjk5ODg2ICogYjAgKyB3aGl0ZSAqIDAuMDU1NTE3OTtcbiAgICAgIGIxID0gMC45OTMzMiAqIGIxICsgd2hpdGUgKiAwLjA3NTA3NTk7XG4gICAgICBiMiA9IDAuOTY5MDAgKiBiMiArIHdoaXRlICogMC4xNTM4NTIwO1xuICAgICAgYjMgPSAwLjg2NjUwICogYjMgKyB3aGl0ZSAqIDAuMzEwNDg1NjtcbiAgICAgIGI0ID0gMC41NTAwMCAqIGI0ICsgd2hpdGUgKiAwLjUzMjk1MjI7XG4gICAgICBiNSA9IC0wLjc2MTYgKiBiNSAtIHdoaXRlICogMC4wMTY4OTgwO1xuICAgICAgbm9pc2VEYXRhW2ldID0gYjAgKyBiMSArIGIyICsgYjMgKyBiNCArIGI1ICsgYjYgKyB3aGl0ZSAqIDAuNTM2MjtcbiAgICAgIG5vaXNlRGF0YVtpXSAqPSAwLjExOyBcblxuICAgICAgYjYgPSB3aGl0ZSAqIDAuMTE1OTI2O1xuICAgIH1cblxuICAgIHBpbmtCdWZmZXIudHlwZSA9ICdwaW5rJztcbiAgICByZXR1cm4gcGlua0J1ZmZlcjtcbiAgfSgpO1xuXG4gIHZhciBfYnJvd25Ob2lzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYnVmZmVyU2l6ZSA9IDIgKiBwNXNvdW5kLmF1ZGlvY29udGV4dC5zYW1wbGVSYXRlO1xuICAgIHZhciBicm93bkJ1ZmZlciA9IHA1c291bmQuYXVkaW9jb250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCBidWZmZXJTaXplLCBwNXNvdW5kLmF1ZGlvY29udGV4dC5zYW1wbGVSYXRlKTtcbiAgICB2YXIgbm9pc2VEYXRhID0gYnJvd25CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgdmFyIGxhc3RPdXQgPSAwLjA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlclNpemU7IGkrKykge1xuICAgICAgdmFyIHdoaXRlID0gTWF0aC5yYW5kb20oKSAqIDIgLSAxO1xuICAgICAgbm9pc2VEYXRhW2ldID0gKGxhc3RPdXQgKyAwLjAyICogd2hpdGUpIC8gMS4wMjtcbiAgICAgIGxhc3RPdXQgPSBub2lzZURhdGFbaV07XG4gICAgICBub2lzZURhdGFbaV0gKj0gMy41O1xuICAgIH1cblxuICAgIGJyb3duQnVmZmVyLnR5cGUgPSAnYnJvd24nO1xuICAgIHJldHVybiBicm93bkJ1ZmZlcjtcbiAgfSgpO1xuICAvKipcbiAgICogIFNldCB0eXBlIG9mIG5vaXNlIHRvICd3aGl0ZScsICdwaW5rJyBvciAnYnJvd24nLlxuICAgKiAgV2hpdGUgaXMgdGhlIGRlZmF1bHQuXG4gICAqXG4gICAqICBAbWV0aG9kIHNldFR5cGVcbiAgICogIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gJ3doaXRlJywgJ3BpbmsnIG9yICdicm93bidcbiAgICovXG5cblxuICBwNS5Ob2lzZS5wcm90b3R5cGUuc2V0VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICd3aGl0ZSc6XG4gICAgICAgIHRoaXMuYnVmZmVyID0gX3doaXRlTm9pc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdwaW5rJzpcbiAgICAgICAgdGhpcy5idWZmZXIgPSBfcGlua05vaXNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYnJvd24nOlxuICAgICAgICB0aGlzLmJ1ZmZlciA9IF9icm93bk5vaXNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5idWZmZXIgPSBfd2hpdGVOb2lzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICB0aGlzLnN0b3Aobm93KTtcbiAgICAgIHRoaXMuc3RhcnQobm93ICsgLjAxKTtcbiAgICB9XG4gIH07XG5cbiAgcDUuTm9pc2UucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLnR5cGU7XG4gIH07XG5cbiAgcDUuTm9pc2UucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cblxuICAgIHRoaXMubm9pc2UgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICB0aGlzLm5vaXNlLmJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgIHRoaXMubm9pc2UubG9vcCA9IHRydWU7XG4gICAgdGhpcy5ub2lzZS5jb25uZWN0KHRoaXMub3V0cHV0KTtcbiAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgdGhpcy5ub2lzZS5zdGFydChub3cpO1xuICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gIH07XG5cbiAgcDUuTm9pc2UucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuXG4gICAgaWYgKHRoaXMubm9pc2UpIHtcbiAgICAgIHRoaXMubm9pc2Uuc3RvcChub3cpO1xuICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHA1Lk5vaXNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTsgXG5cbiAgICB2YXIgaW5kZXggPSBwNXNvdW5kLnNvdW5kQXJyYXkuaW5kZXhPZih0aGlzKTtcbiAgICBwNXNvdW5kLnNvdW5kQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIGlmICh0aGlzLm5vaXNlKSB7XG4gICAgICB0aGlzLm5vaXNlLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuc3RvcChub3cpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm91dHB1dCkge1xuICAgICAgdGhpcy5vdXRwdXQuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhbm5lcikge1xuICAgICAgdGhpcy5wYW5uZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIHRoaXMub3V0cHV0ID0gbnVsbDtcbiAgICB0aGlzLnBhbm5lciA9IG51bGw7XG4gICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgIHRoaXMubm9pc2UgPSBudWxsO1xuICB9O1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gIHZhciBwNXNvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTsgXG5cblxuICBwNXNvdW5kLmlucHV0U291cmNlcyA9IFtdO1xuICAvKipcbiAgICogIDxwPkdldCBhdWRpbyBmcm9tIGFuIGlucHV0LCBpLmUuIHlvdXIgY29tcHV0ZXIncyBtaWNyb3Bob25lLjwvcD5cbiAgICpcbiAgICogIDxwPlR1cm4gdGhlIG1pYyBvbi9vZmYgd2l0aCB0aGUgc3RhcnQoKSBhbmQgc3RvcCgpIG1ldGhvZHMuIFdoZW4gdGhlIG1pY1xuICAgKiAgaXMgb24sIGl0cyB2b2x1bWUgY2FuIGJlIG1lYXN1cmVkIHdpdGggZ2V0TGV2ZWwgb3IgYnkgY29ubmVjdGluZyBhblxuICAgKiAgRkZUIG9iamVjdC48L3A+XG4gICAqXG4gICAqICA8cD5JZiB5b3Ugd2FudCB0byBoZWFyIHRoZSBBdWRpb0luLCB1c2UgdGhlIC5jb25uZWN0KCkgbWV0aG9kLlxuICAgKiAgQXVkaW9JbiBkb2VzIG5vdCBjb25uZWN0IHRvIHA1LnNvdW5kIG91dHB1dCBieSBkZWZhdWx0IHRvIHByZXZlbnRcbiAgICogIGZlZWRiYWNrLjwvcD5cbiAgICpcbiAgICogIDxwPjxlbT5Ob3RlOiBUaGlzIHVzZXMgdGhlIDxhIGhyZWY9XCJodHRwOi8vY2FuaXVzZS5jb20vc3RyZWFtXCI+Z2V0VXNlck1lZGlhL1xuICAgKiAgU3RyZWFtPC9hPiBBUEksIHdoaWNoIGlzIG5vdCBzdXBwb3J0ZWQgYnkgY2VydGFpbiBicm93c2Vycy4gQWNjZXNzIGluIENocm9tZSBicm93c2VyXG4gICAqICBpcyBsaW1pdGVkIHRvIGxvY2FsaG9zdCBhbmQgaHR0cHMsIGJ1dCBhY2Nlc3Mgb3ZlciBodHRwIG1heSBiZSBsaW1pdGVkLjwvZW0+PC9wPlxuICAgKlxuICAgKiAgQGNsYXNzIHA1LkF1ZGlvSW5cbiAgICogIEBjb25zdHJ1Y3RvclxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yQ2FsbGJhY2tdIEEgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGVyZSBpcyBhbiBlcnJvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2Vzc2luZyB0aGUgQXVkaW9Jbi4gRm9yIGV4YW1wbGUsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2FmYXJpIGFuZCBpT1MgZGV2aWNlcyBkbyBub3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHkgYWxsb3cgbWljcm9waG9uZSBhY2Nlc3MuXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBtaWM7XG4gICAqXG4gICAqICAgZnVuY3Rpb24gc2V0dXAoKXtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQodXNlclN0YXJ0QXVkaW8pO1xuICAgKiAgICB0ZXh0QWxpZ24oQ0VOVEVSKTtcbiAgICogICAgbWljID0gbmV3IHA1LkF1ZGlvSW4oKTtcbiAgICogICAgbWljLnN0YXJ0KCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBkcmF3KCl7XG4gICAqICAgIGJhY2tncm91bmQoMCk7XG4gICAqICAgIGZpbGwoMjU1KTtcbiAgICogICAgdGV4dCgndGFwIHRvIHN0YXJ0Jywgd2lkdGgvMiwgMjApO1xuICAgKlxuICAgKiAgICBtaWNMZXZlbCA9IG1pYy5nZXRMZXZlbCgpO1xuICAgKiAgICBsZXQgeSA9IGhlaWdodCAtIG1pY0xldmVsICogaGVpZ2h0O1xuICAgKiAgICBlbGxpcHNlKHdpZHRoLzIsIHksIDEwLCAxMCk7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG4gIHA1LkF1ZGlvSW4gPSBmdW5jdGlvbiAoZXJyb3JDYWxsYmFjaykge1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtHYWluTm9kZX0gaW5wdXRcbiAgICAgKi9cbiAgICB0aGlzLmlucHV0ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7R2Fpbk5vZGV9IG91dHB1dFxuICAgICAqL1xuXG4gICAgdGhpcy5vdXRwdXQgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtNZWRpYVN0cmVhbXxudWxsfSBzdHJlYW1cbiAgICAgKi9cblxuICAgIHRoaXMuc3RyZWFtID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge01lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlfG51bGx9IG1lZGlhU3RyZWFtXG4gICAgICovXG5cbiAgICB0aGlzLm1lZGlhU3RyZWFtID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxudWxsfSBjdXJyZW50U291cmNlXG4gICAgICovXG5cbiAgICB0aGlzLmN1cnJlbnRTb3VyY2UgPSBudWxsO1xuICAgIC8qKlxuICAgICAqICBDbGllbnQgbXVzdCBhbGxvdyBicm93c2VyIHRvIGFjY2VzcyB0aGVpciBtaWNyb3Bob25lIC8gYXVkaW9pbiBzb3VyY2UuXG4gICAgICogIERlZmF1bHQ6IGZhbHNlLiBXaWxsIGJlY29tZSB0cnVlIHdoZW4gdGhlIGNsaWVudCBlbmFibGVzIGFjY2Vzcy5cbiAgICAgKlxuICAgICAqICBAcHJvcGVydHkge0Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKi9cblxuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIElucHV0IGFtcGxpdHVkZSwgY29ubmVjdCB0byBpdCBieSBkZWZhdWx0IGJ1dCBub3QgdG8gbWFzdGVyIG91dFxuICAgICAqXG4gICAgICogIEBwcm9wZXJ0eSB7cDUuQW1wbGl0dWRlfSBhbXBsaXR1ZGVcbiAgICAgKi9cblxuICAgIHRoaXMuYW1wbGl0dWRlID0gbmV3IHA1LkFtcGxpdHVkZSgpO1xuICAgIHRoaXMub3V0cHV0LmNvbm5lY3QodGhpcy5hbXBsaXR1ZGUuaW5wdXQpO1xuXG4gICAgaWYgKCF3aW5kb3cuTWVkaWFTdHJlYW1UcmFjayB8fCAhd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMgfHwgIXdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xuICAgICAgZXJyb3JDYWxsYmFjayA/IGVycm9yQ2FsbGJhY2soKSA6IHdpbmRvdy5hbGVydCgnVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTWVkaWFTdHJlYW1UcmFjayBhbmQgbWVkaWFEZXZpY2VzJyk7XG4gICAgfSBcblxuXG4gICAgcDVzb3VuZC5zb3VuZEFycmF5LnB1c2godGhpcyk7XG4gIH07XG4gIC8qKlxuICAgKiAgU3RhcnQgcHJvY2Vzc2luZyBhdWRpbyBpbnB1dC4gVGhpcyBlbmFibGVzIHRoZSB1c2Ugb2Ygb3RoZXJcbiAgICogIEF1ZGlvSW4gbWV0aG9kcyBsaWtlIGdldExldmVsKCkuIE5vdGUgdGhhdCBieSBkZWZhdWx0LCBBdWRpb0luXG4gICAqICBpcyBub3QgY29ubmVjdGVkIHRvIHA1LnNvdW5kJ3Mgb3V0cHV0LiBTbyB5b3Ugd29uJ3QgaGVhclxuICAgKiAgYW55dGhpbmcgdW5sZXNzIHlvdSB1c2UgdGhlIGNvbm5lY3QoKSBtZXRob2QuPGJyLz5cbiAgICpcbiAgICogIENlcnRhaW4gYnJvd3NlcnMgbGltaXQgYWNjZXNzIHRvIHRoZSB1c2VyJ3MgbWljcm9waG9uZS4gRm9yIGV4YW1wbGUsXG4gICAqICBDaHJvbWUgb25seSBhbGxvd3MgYWNjZXNzIGZyb20gbG9jYWxob3N0IGFuZCBvdmVyIGh0dHBzLiBGb3IgdGhpcyByZWFzb24sXG4gICAqICB5b3UgbWF5IHdhbnQgdG8gaW5jbHVkZSBhbiBlcnJvckNhbGxiYWNr4oCUYSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBpbiBjYXNlXG4gICAqICB0aGUgYnJvd3NlciB3b24ndCBwcm92aWRlIG1pYyBhY2Nlc3MuXG4gICAqXG4gICAqICBAbWV0aG9kIHN0YXJ0XG4gICAqICBAZm9yIHA1LkF1ZGlvSW5cbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzQ2FsbGJhY2tdIE5hbWUgb2YgYSBmdW5jdGlvbiB0byBjYWxsIG9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcy5cbiAgICogIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvckNhbGxiYWNrXSBOYW1lIG9mIGEgZnVuY3Rpb24gdG8gY2FsbCBpZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZXJlIHdhcyBhbiBlcnJvci4gRm9yIGV4YW1wbGUsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFVzZXJNZWRpYS5cbiAgICovXG5cblxuICBwNS5BdWRpb0luLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5zdHJlYW0pIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH0gXG5cblxuICAgIHZhciBhdWRpb1NvdXJjZSA9IHA1c291bmQuaW5wdXRTb3VyY2VzW3NlbGYuY3VycmVudFNvdXJjZV07XG4gICAgdmFyIGNvbnN0cmFpbnRzID0ge1xuICAgICAgYXVkaW86IHtcbiAgICAgICAgc2FtcGxlUmF0ZTogcDVzb3VuZC5hdWRpb2NvbnRleHQuc2FtcGxlUmF0ZSxcbiAgICAgICAgZWNob0NhbmNlbGxhdGlvbjogZmFsc2VcbiAgICAgIH1cbiAgICB9OyBcblxuICAgIGlmIChwNXNvdW5kLmlucHV0U291cmNlc1t0aGlzLmN1cnJlbnRTb3VyY2VdKSB7XG4gICAgICBjb25zdHJhaW50cy5hdWRpby5kZXZpY2VJZCA9IGF1ZGlvU291cmNlLmRldmljZUlkO1xuICAgIH1cblxuICAgIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cykudGhlbihmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICBzZWxmLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgIHNlbGYuZW5hYmxlZCA9IHRydWU7IFxuXG4gICAgICBzZWxmLm1lZGlhU3RyZWFtID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3RyZWFtKTtcbiAgICAgIHNlbGYubWVkaWFTdHJlYW0uY29ubmVjdChzZWxmLm91dHB1dCk7IFxuXG4gICAgICBzZWxmLmFtcGxpdHVkZS5zZXRJbnB1dChzZWxmLm91dHB1dCk7XG4gICAgICBpZiAoc3VjY2Vzc0NhbGxiYWNrKSBzdWNjZXNzQ2FsbGJhY2soKTtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnJvckNhbGxiYWNrKSBlcnJvckNhbGxiYWNrKGVycik7ZWxzZSBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiAgVHVybiB0aGUgQXVkaW9JbiBvZmYuIElmIHRoZSBBdWRpb0luIGlzIHN0b3BwZWQsIGl0IGNhbm5vdCBnZXRMZXZlbCgpLlxuICAgKiAgSWYgcmUtc3RhcnRpbmcsIHRoZSB1c2VyIG1heSBiZSBwcm9tcHRlZCBmb3IgcGVybWlzc2lvbiBhY2Nlc3MuXG4gICAqXG4gICAqICBAbWV0aG9kIHN0b3BcbiAgICogIEBmb3IgcDUuQXVkaW9JblxuICAgKi9cblxuXG4gIHA1LkF1ZGlvSW4ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc3RyZWFtKSB7XG4gICAgICB0aGlzLnN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWVkaWFTdHJlYW0uZGlzY29ubmVjdCgpO1xuICAgICAgZGVsZXRlIHRoaXMubWVkaWFTdHJlYW07XG4gICAgICBkZWxldGUgdGhpcy5zdHJlYW07XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIENvbm5lY3QgdG8gYW4gYXVkaW8gdW5pdC4gSWYgbm8gcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB3aWxsXG4gICAqICBjb25uZWN0IHRvIHRoZSBtYXN0ZXIgb3V0cHV0IChpLmUuIHlvdXIgc3BlYWtlcnMpLjxici8+XG4gICAqXG4gICAqICBAbWV0aG9kICBjb25uZWN0XG4gICAqICBAZm9yIHA1LkF1ZGlvSW5cbiAgICogIEBwYXJhbSAge09iamVjdH0gW3VuaXRdIEFuIG9iamVjdCB0aGF0IGFjY2VwdHMgYXVkaW8gaW5wdXQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNoIGFzIGFuIEZGVFxuICAgKi9cblxuXG4gIHA1LkF1ZGlvSW4ucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAodW5pdCkge1xuICAgIGlmICh1bml0KSB7XG4gICAgICBpZiAodW5pdC5oYXNPd25Qcm9wZXJ0eSgnaW5wdXQnKSkge1xuICAgICAgICB0aGlzLm91dHB1dC5jb25uZWN0KHVuaXQuaW5wdXQpO1xuICAgICAgfSBlbHNlIGlmICh1bml0Lmhhc093blByb3BlcnR5KCdhbmFseXNlcicpKSB7XG4gICAgICAgIHRoaXMub3V0cHV0LmNvbm5lY3QodW5pdC5hbmFseXNlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm91dHB1dC5jb25uZWN0KHVuaXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm91dHB1dC5jb25uZWN0KHA1c291bmQuaW5wdXQpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBEaXNjb25uZWN0IHRoZSBBdWRpb0luIGZyb20gYWxsIGF1ZGlvIHVuaXRzLiBGb3IgZXhhbXBsZSwgaWZcbiAgICogIGNvbm5lY3QoKSBoYWQgYmVlbiBjYWxsZWQsIGRpc2Nvbm5lY3QoKSB3aWxsIHN0b3Agc2VuZGluZ1xuICAgKiAgc2lnbmFsIHRvIHlvdXIgc3BlYWtlcnMuPGJyLz5cbiAgICpcbiAgICogIEBtZXRob2QgIGRpc2Nvbm5lY3RcbiAgICogIEBmb3IgcDUuQXVkaW9JblxuICAgKi9cblxuXG4gIHA1LkF1ZGlvSW4ucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3V0cHV0KSB7XG4gICAgICB0aGlzLm91dHB1dC5kaXNjb25uZWN0KCk7IFxuXG4gICAgICB0aGlzLm91dHB1dC5jb25uZWN0KHRoaXMuYW1wbGl0dWRlLmlucHV0KTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgUmVhZCB0aGUgQW1wbGl0dWRlICh2b2x1bWUgbGV2ZWwpIG9mIGFuIEF1ZGlvSW4uIFRoZSBBdWRpb0luXG4gICAqICBjbGFzcyBjb250YWlucyBpdHMgb3duIGluc3RhbmNlIG9mIHRoZSBBbXBsaXR1ZGUgY2xhc3MgdG8gaGVscFxuICAgKiAgbWFrZSBpdCBlYXN5IHRvIGdldCBhIG1pY3JvcGhvbmUncyB2b2x1bWUgbGV2ZWwuIEFjY2VwdHMgYW5cbiAgICogIG9wdGlvbmFsIHNtb290aGluZyB2YWx1ZSAoMC4wIDwgMS4wKS4gPGVtPk5PVEU6IEF1ZGlvSW4gbXVzdFxuICAgKiAgLnN0YXJ0KCkgYmVmb3JlIHVzaW5nIC5nZXRMZXZlbCgpLjwvZW0+PGJyLz5cbiAgICpcbiAgICogIEBtZXRob2QgIGdldExldmVsXG4gICAqICBAZm9yIHA1LkF1ZGlvSW5cbiAgICogIEBwYXJhbSAge051bWJlcn0gW3Ntb290aGluZ10gU21vb3RoaW5nIGlzIDAuMCBieSBkZWZhdWx0LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTbW9vdGhzIHZhbHVlcyBiYXNlZCBvbiBwcmV2aW91cyB2YWx1ZXMuXG4gICAqICBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICBWb2x1bWUgbGV2ZWwgKGJldHdlZW4gMC4wIGFuZCAxLjApXG4gICAqL1xuXG5cbiAgcDUuQXVkaW9Jbi5wcm90b3R5cGUuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoc21vb3RoaW5nKSB7XG4gICAgaWYgKHNtb290aGluZykge1xuICAgICAgdGhpcy5hbXBsaXR1ZGUuc21vb3RoaW5nID0gc21vb3RoaW5nO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFtcGxpdHVkZS5nZXRMZXZlbCgpO1xuICB9O1xuICAvKipcbiAgICogIFNldCBhbXBsaXR1ZGUgKHZvbHVtZSkgb2YgYSBtaWMgaW5wdXQgYmV0d2VlbiAwIGFuZCAxLjAuIDxici8+XG4gICAqXG4gICAqICBAbWV0aG9kICBhbXBcbiAgICogIEBmb3IgcDUuQXVkaW9JblxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSB2b2wgYmV0d2VlbiAwIGFuZCAxLjBcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbdGltZV0gcmFtcCB0aW1lIChvcHRpb25hbClcbiAgICovXG5cblxuICBwNS5BdWRpb0luLnByb3RvdHlwZS5hbXAgPSBmdW5jdGlvbiAodm9sLCB0KSB7XG4gICAgaWYgKHQpIHtcbiAgICAgIHZhciByYW1wVGltZSA9IHQgfHwgMDtcbiAgICAgIHZhciBjdXJyZW50Vm9sID0gdGhpcy5vdXRwdXQuZ2Fpbi52YWx1ZTtcbiAgICAgIHRoaXMub3V0cHV0LmdhaW4uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lKTtcbiAgICAgIHRoaXMub3V0cHV0LmdhaW4uc2V0VmFsdWVBdFRpbWUoY3VycmVudFZvbCwgcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWUpO1xuICAgICAgdGhpcy5vdXRwdXQuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh2b2wsIHJhbXBUaW1lICsgcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm91dHB1dC5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgICB0aGlzLm91dHB1dC5nYWluLnNldFZhbHVlQXRUaW1lKHZvbCwgcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIGF2YWlsYWJsZSBpbnB1dCBzb3VyY2VzLiBUaGlzIGlzIGEgd3JhcHBlclxuICAgKiBmb3IgPGEgdGl0bGU9XCJNZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpIC0gV2ViIEFQSXMgfCBNRE5cIiB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPVxuICAgKiAgXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFEZXZpY2VzL2VudW1lcmF0ZURldmljZXNcIlxuICAgKiAgPiBhbmQgaXQgcmV0dXJucyBhIFByb21pc2UuXG4gICAqXG4gICAqIEBtZXRob2QgIGdldFNvdXJjZXNcbiAgICogQGZvciBwNS5BdWRpb0luXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbc3VjY2Vzc0NhbGxiYWNrXSBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIGhhbmRsZXMgdGhlIHNvdXJjZXMgd2hlbiB0aGV5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXZlIGJlZW4gZW51bWVyYXRlZC4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlcyB0aGUgZGV2aWNlTGlzdCBhcnJheSBhcyBpdHMgb25seSBhcmd1bWVudFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW2Vycm9yQ2FsbGJhY2tdIFRoaXMgb3B0aW9uYWwgY2FsbGJhY2sgcmVjZWl2ZXMgdGhlIGVycm9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSBhcyBpdHMgYXJndW1lbnQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IGNhbiBiZSB1c2VkIGluIHBsYWNlIG9mIHRoZSBjYWxsYmFja3MsIHNpbWlsYXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gdGhlIGVudW1lcmF0ZURldmljZXMoKSBtZXRob2RcbiAgICogQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgYXVkaW9JbjtcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCl7XG4gICAqICAgIHRleHQoJ2dldHRpbmcgc291cmNlcy4uLicsIDAsIDIwKTtcbiAgICogICAgYXVkaW9JbiA9IG5ldyBwNS5BdWRpb0luKCk7XG4gICAqICAgIGF1ZGlvSW4uZ2V0U291cmNlcyhnb3RTb3VyY2VzKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGdvdFNvdXJjZXMoZGV2aWNlTGlzdCkge1xuICAgKiAgICBpZiAoZGV2aWNlTGlzdC5sZW5ndGggPiAwKSB7XG4gICAqICAgICAgLy9zZXQgdGhlIHNvdXJjZSB0byB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgZGV2aWNlTGlzdCBhcnJheVxuICAgKiAgICAgIGF1ZGlvSW4uc2V0U291cmNlKDApO1xuICAgKiAgICAgIGxldCBjdXJyZW50U291cmNlID0gZGV2aWNlTGlzdFthdWRpb0luLmN1cnJlbnRTb3VyY2VdO1xuICAgKiAgICAgIHRleHQoJ3NldCBzb3VyY2UgdG86ICcgKyBjdXJyZW50U291cmNlLmRldmljZUlkLCA1LCAyMCwgd2lkdGgpO1xuICAgKiAgICB9XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuQXVkaW9Jbi5wcm90b3R5cGUuZ2V0U291cmNlcyA9IGZ1bmN0aW9uIChvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpLnRoZW4oZnVuY3Rpb24gKGRldmljZXMpIHtcbiAgICAgICAgcDVzb3VuZC5pbnB1dFNvdXJjZXMgPSBkZXZpY2VzLmZpbHRlcihmdW5jdGlvbiAoZGV2aWNlKSB7XG4gICAgICAgICAgcmV0dXJuIGRldmljZS5raW5kID09PSAnYXVkaW9pbnB1dCc7XG4gICAgICAgIH0pO1xuICAgICAgICByZXNvbHZlKHA1c291bmQuaW5wdXRTb3VyY2VzKTtcblxuICAgICAgICBpZiAob25TdWNjZXNzKSB7XG4gICAgICAgICAgb25TdWNjZXNzKHA1c291bmQuaW5wdXRTb3VyY2VzKTtcbiAgICAgICAgfVxuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcblxuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IE1lZGlhU3RyZWFtVHJhY2suZ2V0U291cmNlcygpJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogIFNldCB0aGUgaW5wdXQgc291cmNlLiBBY2NlcHRzIGEgbnVtYmVyIHJlcHJlc2VudGluZyBhXG4gICAqICBwb3NpdGlvbiBpbiB0aGUgYXJyYXkgcmV0dXJuZWQgYnkgZ2V0U291cmNlcygpLlxuICAgKiAgVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnRcbiAgICogIDxhIHRpdGxlPVwiTWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKSAtIFdlYiBBUElzIHwgTUROXCIgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj1cbiAgICogIFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhRGV2aWNlcy9lbnVtZXJhdGVEZXZpY2VzXCJcbiAgICogID5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTwvYT4uPGJyLz5cbiAgICpcbiAgICogIEBtZXRob2Qgc2V0U291cmNlXG4gICAqICBAZm9yIHA1LkF1ZGlvSW5cbiAgICogIEBwYXJhbSB7bnVtYmVyfSBudW0gcG9zaXRpb24gb2YgaW5wdXQgc291cmNlIGluIHRoZSBhcnJheVxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgYXVkaW9JbjtcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCl7XG4gICAqICAgIHRleHQoJ2dldHRpbmcgc291cmNlcy4uLicsIDAsIDIwKTtcbiAgICogICAgYXVkaW9JbiA9IG5ldyBwNS5BdWRpb0luKCk7XG4gICAqICAgIGF1ZGlvSW4uZ2V0U291cmNlcyhnb3RTb3VyY2VzKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIGdvdFNvdXJjZXMoZGV2aWNlTGlzdCkge1xuICAgKiAgICBpZiAoZGV2aWNlTGlzdC5sZW5ndGggPiAwKSB7XG4gICAqICAgICAgLy9zZXQgdGhlIHNvdXJjZSB0byB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgZGV2aWNlTGlzdCBhcnJheVxuICAgKiAgICAgIGF1ZGlvSW4uc2V0U291cmNlKDApO1xuICAgKiAgICAgIGxldCBjdXJyZW50U291cmNlID0gZGV2aWNlTGlzdFthdWRpb0luLmN1cnJlbnRTb3VyY2VdO1xuICAgKiAgICAgIHRleHQoJ3NldCBzb3VyY2UgdG86ICcgKyBjdXJyZW50U291cmNlLmRldmljZUlkLCA1LCAyMCwgd2lkdGgpO1xuICAgKiAgICB9XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuQXVkaW9Jbi5wcm90b3R5cGUuc2V0U291cmNlID0gZnVuY3Rpb24gKG51bSkge1xuICAgIGlmIChwNXNvdW5kLmlucHV0U291cmNlcy5sZW5ndGggPiAwICYmIG51bSA8IHA1c291bmQuaW5wdXRTb3VyY2VzLmxlbmd0aCkge1xuICAgICAgdGhpcy5jdXJyZW50U291cmNlID0gbnVtO1xuICAgICAgY29uc29sZS5sb2coJ3NldCBzb3VyY2UgdG8gJywgcDVzb3VuZC5pbnB1dFNvdXJjZXNbdGhpcy5jdXJyZW50U291cmNlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCd1bmFibGUgdG8gc2V0IGlucHV0IHNvdXJjZScpO1xuICAgIH0gXG5cblxuICAgIGlmICh0aGlzLnN0cmVhbSAmJiB0aGlzLnN0cmVhbS5hY3RpdmUpIHtcbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gIH07IFxuXG5cbiAgcDUuQXVkaW9Jbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5kZXggPSBwNXNvdW5kLnNvdW5kQXJyYXkuaW5kZXhPZih0aGlzKTtcbiAgICBwNXNvdW5kLnNvdW5kQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLnN0b3AoKTtcblxuICAgIGlmICh0aGlzLm91dHB1dCkge1xuICAgICAgdGhpcy5vdXRwdXQuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFtcGxpdHVkZSkge1xuICAgICAgdGhpcy5hbXBsaXR1ZGUuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLmFtcGxpdHVkZTtcbiAgICBkZWxldGUgdGhpcy5vdXRwdXQ7XG4gIH07XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9fd2VicGFja19yZXF1aXJlX18oMiksX193ZWJwYWNrX3JlcXVpcmVfXyg1MiksX193ZWJwYWNrX3JlcXVpcmVfXyg1OCksX193ZWJwYWNrX3JlcXVpcmVfXyg5KV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKGkpe1widXNlIHN0cmljdFwiO3JldHVybiBpLkNyb3NzRmFkZT1mdW5jdGlvbihlKXt0aGlzLmNyZWF0ZUluc091dHMoMiwxKSx0aGlzLmE9dGhpcy5pbnB1dFswXT1uZXcgaS5HYWluLHRoaXMuYj10aGlzLmlucHV0WzFdPW5ldyBpLkdhaW4sdGhpcy5mYWRlPW5ldyBpLlNpZ25hbCh0aGlzLmRlZmF1bHRBcmcoZSwuNSksaS5UeXBlLk5vcm1hbFJhbmdlKSx0aGlzLl9lcXVhbFBvd2VyQT1uZXcgaS5FcXVhbFBvd2VyR2Fpbix0aGlzLl9lcXVhbFBvd2VyQj1uZXcgaS5FcXVhbFBvd2VyR2Fpbix0aGlzLl9pbnZlcnQ9bmV3IGkuRXhwcihcIjEgLSAkMFwiKSx0aGlzLmEuY29ubmVjdCh0aGlzLm91dHB1dCksdGhpcy5iLmNvbm5lY3QodGhpcy5vdXRwdXQpLHRoaXMuZmFkZS5jaGFpbih0aGlzLl9lcXVhbFBvd2VyQix0aGlzLmIuZ2FpbiksdGhpcy5mYWRlLmNoYWluKHRoaXMuX2ludmVydCx0aGlzLl9lcXVhbFBvd2VyQSx0aGlzLmEuZ2FpbiksdGhpcy5fcmVhZE9ubHkoXCJmYWRlXCIpfSxpLmV4dGVuZChpLkNyb3NzRmFkZSksaS5Dcm9zc0ZhZGUucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm4gaS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpLHRoaXMuX3dyaXRhYmxlKFwiZmFkZVwiKSx0aGlzLl9lcXVhbFBvd2VyQS5kaXNwb3NlKCksdGhpcy5fZXF1YWxQb3dlckE9bnVsbCx0aGlzLl9lcXVhbFBvd2VyQi5kaXNwb3NlKCksdGhpcy5fZXF1YWxQb3dlckI9bnVsbCx0aGlzLmZhZGUuZGlzcG9zZSgpLHRoaXMuZmFkZT1udWxsLHRoaXMuX2ludmVydC5kaXNwb3NlKCksdGhpcy5faW52ZXJ0PW51bGwsdGhpcy5hLmRpc3Bvc2UoKSx0aGlzLmE9bnVsbCx0aGlzLmIuZGlzcG9zZSgpLHRoaXMuYj1udWxsLHRoaXN9LGkuQ3Jvc3NGYWRlfSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9fd2VicGFja19yZXF1aXJlX18oNyksX193ZWJwYWNrX3JlcXVpcmVfXygxNiksX193ZWJwYWNrX3JlcXVpcmVfXygzKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KSxfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKHApe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSxuLHIpe3ZhciB0PW5ldyBlO3JldHVybiByLl9ldmFsKG5bMF0pLmNvbm5lY3QodCwwLDApLHIuX2V2YWwoblsxXSkuY29ubmVjdCh0LDAsMSksdH1mdW5jdGlvbiB0KGUsbixyKXt2YXIgdD1uZXcgZTtyZXR1cm4gci5fZXZhbChuWzBdKS5jb25uZWN0KHQsMCwwKSx0fWZ1bmN0aW9uIG8oZSl7cmV0dXJuIGU/cGFyc2VGbG9hdChlKTp2b2lkIDB9ZnVuY3Rpb24gaShlKXtyZXR1cm4gZSYmZS5hcmdzP3BhcnNlRmxvYXQoZS5hcmdzKTp2b2lkIDB9cmV0dXJuIHAuRXhwcj1mdW5jdGlvbigpe3ZhciBuPXRoaXMuX3JlcGxhY2VtZW50cyhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSxlPXRoaXMuX3BhcnNlSW5wdXRzKG4pO3RoaXMuX25vZGVzPVtdLHRoaXMuaW5wdXQ9bmV3IEFycmF5KGUpO2Zvcih2YXIgcj0wO3I8ZTtyKyspdGhpcy5pbnB1dFtyXT10aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO3ZhciB0LG89dGhpcy5fcGFyc2VUcmVlKG4pO3RyeXt0PXRoaXMuX2V2YWwobyl9Y2F0Y2goZSl7dGhyb3cgdGhpcy5fZGlzcG9zZU5vZGVzKCksbmV3IEVycm9yKFwiVG9uZS5FeHByOiBDb3VsZCBldmFsdWF0ZSBleHByZXNzaW9uOiBcIituKX10aGlzLm91dHB1dD10fSxwLmV4dGVuZChwLkV4cHIscC5TaWduYWxCYXNlKSxwLkV4cHIuX0V4cHJlc3Npb25zPXt2YWx1ZTp7c2lnbmFsOntyZWdleHA6L15cXGQrXFwuXFxkK3xeXFxkKy8sbWV0aG9kOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgcC5TaWduYWwobyhlKSl9fSxpbnB1dDp7cmVnZXhwOi9eXFwkXFxkLyxtZXRob2Q6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gbi5pbnB1dFtvKGUuc3Vic3RyKDEpKV19fX0sZ2x1ZTp7XCIoXCI6e3JlZ2V4cDovXlxcKC99LFwiKVwiOntyZWdleHA6L15cXCkvfSxcIixcIjp7cmVnZXhwOi9eLC99fSxmdW5jOnthYnM6e3JlZ2V4cDovXmFicy8sbWV0aG9kOnQuYmluZCh0aGlzLHAuQWJzKX0sbW9kOntyZWdleHA6L15tb2QvLG1ldGhvZDpmdW5jdGlvbihlLG4pe3ZhciByPWkoZVsxXSksdD1uZXcgcC5Nb2R1bG8ocik7cmV0dXJuIG4uX2V2YWwoZVswXSkuY29ubmVjdCh0KSx0fX0scG93OntyZWdleHA6L15wb3cvLG1ldGhvZDpmdW5jdGlvbihlLG4pe3ZhciByPWkoZVsxXSksdD1uZXcgcC5Qb3cocik7cmV0dXJuIG4uX2V2YWwoZVswXSkuY29ubmVjdCh0KSx0fX0sYTJnOntyZWdleHA6L15hMmcvLG1ldGhvZDpmdW5jdGlvbihlLG4pe3ZhciByPW5ldyBwLkF1ZGlvVG9HYWluO3JldHVybiBuLl9ldmFsKGVbMF0pLmNvbm5lY3Qocikscn19fSxiaW5hcnk6e1wiK1wiOntyZWdleHA6L15cXCsvLHByZWNlZGVuY2U6MSxtZXRob2Q6ci5iaW5kKHRoaXMscC5BZGQpfSxcIi1cIjp7cmVnZXhwOi9eXFwtLyxwcmVjZWRlbmNlOjEsbWV0aG9kOmZ1bmN0aW9uKGUsbil7cmV0dXJuIDE9PT1lLmxlbmd0aD90KHAuTmVnYXRlLGUsbik6cihwLlN1YnRyYWN0LGUsbil9fSxcIipcIjp7cmVnZXhwOi9eXFwqLyxwcmVjZWRlbmNlOjAsbWV0aG9kOnIuYmluZCh0aGlzLHAuTXVsdGlwbHkpfX0sdW5hcnk6e1wiLVwiOntyZWdleHA6L15cXC0vLG1ldGhvZDp0LmJpbmQodGhpcyxwLk5lZ2F0ZSl9LFwiIVwiOntyZWdleHA6L15cXCEvLG1ldGhvZDp0LmJpbmQodGhpcyxwLk5PVCl9fX0scC5FeHByLnByb3RvdHlwZS5fcGFyc2VJbnB1dHM9ZnVuY3Rpb24oZSl7dmFyIG49ZS5tYXRjaCgvXFwkXFxkL2cpLHI9MDtpZihudWxsIT09bilmb3IodmFyIHQ9MDt0PG4ubGVuZ3RoO3QrKyl7dmFyIG89cGFyc2VJbnQoblt0XS5zdWJzdHIoMSkpKzE7cj1NYXRoLm1heChyLG8pfXJldHVybiByfSxwLkV4cHIucHJvdG90eXBlLl9yZXBsYWNlbWVudHM9ZnVuY3Rpb24oZSl7Zm9yKHZhciBuPWUuc2hpZnQoKSxyPTA7cjxlLmxlbmd0aDtyKyspbj1uLnJlcGxhY2UoL1xcJS9pLGVbcl0pO3JldHVybiBufSxwLkV4cHIucHJvdG90eXBlLl90b2tlbml6ZT1mdW5jdGlvbihlKXtmb3IodmFyIG49LTEscj1bXTswPGUubGVuZ3RoOyl7dmFyIHQ9byhlPWUudHJpbSgpKTtyLnB1c2godCksZT1lLnN1YnN0cih0LnZhbHVlLmxlbmd0aCl9ZnVuY3Rpb24gbyhlKXtmb3IodmFyIG4gaW4gcC5FeHByLl9FeHByZXNzaW9ucyl7dmFyIHI9cC5FeHByLl9FeHByZXNzaW9uc1tuXTtmb3IodmFyIHQgaW4gcil7dmFyIG89clt0XSxpPW8ucmVnZXhwLGE9ZS5tYXRjaChpKTtpZihudWxsIT09YSlyZXR1cm57dHlwZTpuLHZhbHVlOmFbMF0sbWV0aG9kOm8ubWV0aG9kfX19dGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVG9uZS5FeHByOiBVbmV4cGVjdGVkIHRva2VuIFwiK2UpfXJldHVybntuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHJbKytuXX0scGVlazpmdW5jdGlvbigpe3JldHVybiByW24rMV19fX0scC5FeHByLnByb3RvdHlwZS5fcGFyc2VUcmVlPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuX3Rva2VuaXplKGUpLGE9dGhpcy5pc1VuZGVmLmJpbmQodGhpcyk7ZnVuY3Rpb24gcihlLG4pe3JldHVybiFhKGUpJiZcImdsdWVcIj09PWUudHlwZSYmZS52YWx1ZT09PW59ZnVuY3Rpb24gbyhlLG4scil7dmFyIHQ9cC5FeHByLl9FeHByZXNzaW9uc1tuXTtpZighYShlKSlmb3IodmFyIG8gaW4gdCl7dmFyIGk9dFtvXTtpZihpLnJlZ2V4cC50ZXN0KGUudmFsdWUpKXtpZihhKHIpKXJldHVybiEwO2lmKGkucHJlY2VkZW5jZT09PXIpcmV0dXJuITB9fXJldHVybiExfWZ1bmN0aW9uIGkoZSl7dmFyIG47YShlKSYmKGU9NSksbj1lPDA/ZnVuY3Rpb24gZSgpe3ZhciBuLHI7bj10LnBlZWsoKTtpZihvKG4sXCJ1bmFyeVwiKSlyZXR1cm4gbj10Lm5leHQoKSxyPWUoKSx7b3BlcmF0b3I6bi52YWx1ZSxtZXRob2Q6bi5tZXRob2QsYXJnczpbcl19O3JldHVybiBzKCl9KCk6aShlLTEpO2Zvcih2YXIgcj10LnBlZWsoKTtvKHIsXCJiaW5hcnlcIixlKTspbj17b3BlcmF0b3I6KHI9dC5uZXh0KCkpLnZhbHVlLG1ldGhvZDpyLm1ldGhvZCxhcmdzOltuLGkoZS0xKV19LHI9dC5wZWVrKCk7cmV0dXJuIG59ZnVuY3Rpb24gcygpe3ZhciBlLG47aWYoZT10LnBlZWsoKSxhKGUpKXRocm93IG5ldyBTeW50YXhFcnJvcihcIlRvbmUuRXhwcjogVW5leHBlY3RlZCB0ZXJtaW5hdGlvbiBvZiBleHByZXNzaW9uXCIpO2lmKFwiZnVuY1wiPT09ZS50eXBlKXJldHVybiBmdW5jdGlvbihlKXt2YXIgbj1bXTtpZighcih0Lm5leHQoKSxcIihcIikpdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUb25lLkV4cHI6IEV4cGVjdGVkICggaW4gYSBmdW5jdGlvbiBjYWxsIFwiJytlLnZhbHVlKydcIicpO3IodC5wZWVrKCksXCIpXCIpfHwobj1mdW5jdGlvbigpe3ZhciBlLG49W107Zm9yKDtlPWkoKSwhYShlKSYmKG4ucHVzaChlKSxyKHQucGVlaygpLFwiLFwiKSk7KXQubmV4dCgpO3JldHVybiBufSgpKTtpZihyKHQubmV4dCgpLFwiKVwiKSlyZXR1cm57bWV0aG9kOmUubWV0aG9kLGFyZ3M6bixuYW1lOm5hbWV9O3Rocm93IG5ldyBTeW50YXhFcnJvcignVG9uZS5FeHByOiBFeHBlY3RlZCApIGluIGEgZnVuY3Rpb24gY2FsbCBcIicrZS52YWx1ZSsnXCInKX0oZT10Lm5leHQoKSk7aWYoXCJ2YWx1ZVwiPT09ZS50eXBlKXJldHVybnttZXRob2Q6KGU9dC5uZXh0KCkpLm1ldGhvZCxhcmdzOmUudmFsdWV9O2lmKHIoZSxcIihcIikpe2lmKHQubmV4dCgpLG49aSgpLCFyKGU9dC5uZXh0KCksXCIpXCIpKXRocm93IG5ldyBTeW50YXhFcnJvcihcIkV4cGVjdGVkIClcIik7cmV0dXJuIG59dGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVG9uZS5FeHByOiBQYXJzZSBlcnJvciwgY2Fubm90IHByb2Nlc3MgdG9rZW4gXCIrZS52YWx1ZSl9cmV0dXJuIGkoKX0scC5FeHByLnByb3RvdHlwZS5fZXZhbD1mdW5jdGlvbihlKXtpZighdGhpcy5pc1VuZGVmKGUpKXt2YXIgbj1lLm1ldGhvZChlLmFyZ3MsdGhpcyk7cmV0dXJuIHRoaXMuX25vZGVzLnB1c2gobiksbn19LHAuRXhwci5wcm90b3R5cGUuX2Rpc3Bvc2VOb2Rlcz1mdW5jdGlvbigpe2Zvcih2YXIgZT0wO2U8dGhpcy5fbm9kZXMubGVuZ3RoO2UrKyl7dmFyIG49dGhpcy5fbm9kZXNbZV07dGhpcy5pc0Z1bmN0aW9uKG4uZGlzcG9zZSk/bi5kaXNwb3NlKCk6dGhpcy5pc0Z1bmN0aW9uKG4uZGlzY29ubmVjdCkmJm4uZGlzY29ubmVjdCgpLG49bnVsbCx0aGlzLl9ub2Rlc1tlXT1udWxsfXRoaXMuX25vZGVzPW51bGx9LHAuRXhwci5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3AucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKSx0aGlzLl9kaXNwb3NlTm9kZXMoKX0scC5FeHByfSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9fd2VicGFja19yZXF1aXJlX18oMjYpLF9fd2VicGFja19yZXF1aXJlX18oMTYpLF9fd2VicGFja19yZXF1aXJlX18oMildLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihlKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gZS5HcmVhdGVyVGhhbj1mdW5jdGlvbih0KXt0aGlzLmNyZWF0ZUluc091dHMoMiwwKSx0aGlzLl9wYXJhbT10aGlzLmlucHV0WzBdPW5ldyBlLlN1YnRyYWN0KHQpLHRoaXMuaW5wdXRbMV09dGhpcy5fcGFyYW0uaW5wdXRbMV0sdGhpcy5fZ3R6PXRoaXMub3V0cHV0PW5ldyBlLkdyZWF0ZXJUaGFuWmVybyx0aGlzLl9wYXJhbS5jb25uZWN0KHRoaXMuX2d0eil9LGUuZXh0ZW5kKGUuR3JlYXRlclRoYW4sZS5TaWduYWwpLGUuR3JlYXRlclRoYW4ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm4gZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpLHRoaXMuX3BhcmFtLmRpc3Bvc2UoKSx0aGlzLl9wYXJhbT1udWxsLHRoaXMuX2d0ei5kaXNwb3NlKCksdGhpcy5fZ3R6PW51bGwsdGhpc30sZS5HcmVhdGVyVGhhbn0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygwKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLF9fd2VicGFja19yZXF1aXJlX18oMTkpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24ocyl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIHMuQWJzPWZ1bmN0aW9uKCl7dGhpcy5fYWJzPXRoaXMuaW5wdXQ9dGhpcy5vdXRwdXQ9bmV3IHMuV2F2ZVNoYXBlcihmdW5jdGlvbihzKXtyZXR1cm4gMD09PXM/MDpNYXRoLmFicyhzKX0sMTI3KX0scy5leHRlbmQocy5BYnMscy5TaWduYWxCYXNlKSxzLkFicy5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3JldHVybiBzLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksdGhpcy5fYWJzLmRpc3Bvc2UoKSx0aGlzLl9hYnM9bnVsbCx0aGlzfSxzLkFic30pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygwKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLF9fd2VicGFja19yZXF1aXJlX18oMyksX193ZWJwYWNrX3JlcXVpcmVfXygxNildLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihpKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gaS5Nb2R1bG89ZnVuY3Rpb24odCl7dGhpcy5jcmVhdGVJbnNPdXRzKDEsMCksdGhpcy5fc2hhcGVyPW5ldyBpLldhdmVTaGFwZXIoTWF0aC5wb3coMiwxNikpLHRoaXMuX211bHRpcGx5PW5ldyBpLk11bHRpcGx5LHRoaXMuX3N1YnRyYWN0PXRoaXMub3V0cHV0PW5ldyBpLlN1YnRyYWN0LHRoaXMuX21vZFNpZ25hbD1uZXcgaS5TaWduYWwodCksdGhpcy5pbnB1dC5mYW4odGhpcy5fc2hhcGVyLHRoaXMuX3N1YnRyYWN0KSx0aGlzLl9tb2RTaWduYWwuY29ubmVjdCh0aGlzLl9tdWx0aXBseSwwLDApLHRoaXMuX3NoYXBlci5jb25uZWN0KHRoaXMuX211bHRpcGx5LDAsMSksdGhpcy5fbXVsdGlwbHkuY29ubmVjdCh0aGlzLl9zdWJ0cmFjdCwwLDEpLHRoaXMuX3NldFdhdmVTaGFwZXIodCl9LGkuZXh0ZW5kKGkuTW9kdWxvLGkuU2lnbmFsQmFzZSksaS5Nb2R1bG8ucHJvdG90eXBlLl9zZXRXYXZlU2hhcGVyPWZ1bmN0aW9uKGkpe3RoaXMuX3NoYXBlci5zZXRNYXAoZnVuY3Rpb24odCl7cmV0dXJuIE1hdGguZmxvb3IoKHQrMWUtNCkvaSl9KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGkuTW9kdWxvLnByb3RvdHlwZSxcInZhbHVlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tb2RTaWduYWwudmFsdWV9LHNldDpmdW5jdGlvbih0KXt0aGlzLl9tb2RTaWduYWwudmFsdWU9dCx0aGlzLl9zZXRXYXZlU2hhcGVyKHQpfX0pLGkuTW9kdWxvLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7cmV0dXJuIGkucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKSx0aGlzLl9zaGFwZXIuZGlzcG9zZSgpLHRoaXMuX3NoYXBlcj1udWxsLHRoaXMuX211bHRpcGx5LmRpc3Bvc2UoKSx0aGlzLl9tdWx0aXBseT1udWxsLHRoaXMuX3N1YnRyYWN0LmRpc3Bvc2UoKSx0aGlzLl9zdWJ0cmFjdD1udWxsLHRoaXMuX21vZFNpZ25hbC5kaXNwb3NlKCksdGhpcy5fbW9kU2lnbmFsPW51bGwsdGhpc30saS5Nb2R1bG99KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXyg1KV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO3JldHVybiB0LlBvdz1mdW5jdGlvbihlKXt0aGlzLl9leHA9dGhpcy5kZWZhdWx0QXJnKGUsMSksdGhpcy5fZXhwU2NhbGVyPXRoaXMuaW5wdXQ9dGhpcy5vdXRwdXQ9bmV3IHQuV2F2ZVNoYXBlcih0aGlzLl9leHBGdW5jKHRoaXMuX2V4cCksODE5Mil9LHQuZXh0ZW5kKHQuUG93LHQuU2lnbmFsQmFzZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuUG93LnByb3RvdHlwZSxcInZhbHVlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9leHB9LHNldDpmdW5jdGlvbihlKXt0aGlzLl9leHA9ZSx0aGlzLl9leHBTY2FsZXIuc2V0TWFwKHRoaXMuX2V4cEZ1bmModGhpcy5fZXhwKSl9fSksdC5Qb3cucHJvdG90eXBlLl9leHBGdW5jPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gTWF0aC5wb3coTWF0aC5hYnMoZSksdCl9fSx0LlBvdy5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3JldHVybiB0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyksdGhpcy5fZXhwU2NhbGVyLmRpc3Bvc2UoKSx0aGlzLl9leHBTY2FsZXI9bnVsbCx0aGlzfSx0LlBvd30pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygwKSxfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLF9fd2VicGFja19yZXF1aXJlX18oMildLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihuKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gbi5BdWRpb1RvR2Fpbj1mdW5jdGlvbigpe3RoaXMuX25vcm09dGhpcy5pbnB1dD10aGlzLm91dHB1dD1uZXcgbi5XYXZlU2hhcGVyKGZ1bmN0aW9uKG4pe3JldHVybihuKzEpLzJ9KX0sbi5leHRlbmQobi5BdWRpb1RvR2FpbixuLlNpZ25hbEJhc2UpLG4uQXVkaW9Ub0dhaW4ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm4gbi5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpLHRoaXMuX25vcm0uZGlzcG9zZSgpLHRoaXMuX25vcm09bnVsbCx0aGlzfSxuLkF1ZGlvVG9HYWlufSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDApLF9fd2VicGFja19yZXF1aXJlX18oNSldLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbihlKXtcInVzZSBzdHJpY3RcIjtyZXR1cm4gZS5FcXVhbFBvd2VyR2Fpbj1mdW5jdGlvbigpe3RoaXMuX2VxUG93ZXI9dGhpcy5pbnB1dD10aGlzLm91dHB1dD1uZXcgZS5XYXZlU2hhcGVyKGZ1bmN0aW9uKGUpe3JldHVybiBNYXRoLmFicyhlKTwuMDAxPzA6dGhpcy5lcXVhbFBvd2VyU2NhbGUoZSl9LmJpbmQodGhpcyksNDA5Nil9LGUuZXh0ZW5kKGUuRXF1YWxQb3dlckdhaW4sZS5TaWduYWxCYXNlKSxlLkVxdWFsUG93ZXJHYWluLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7cmV0dXJuIGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKSx0aGlzLl9lcVBvd2VyLmRpc3Bvc2UoKSx0aGlzLl9lcVBvd2VyPW51bGwsdGhpc30sZS5FcXVhbFBvd2VyR2Fpbn0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gIHZhciBFZmZlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG4gIHZhciBFUUZpbHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xuICAvKipcbiAgICogcDUuRVEgaXMgYW4gYXVkaW8gZWZmZWN0IHRoYXQgcGVyZm9ybXMgdGhlIGZ1bmN0aW9uIG9mIGEgbXVsdGliYW5kXG4gICAqIGF1ZGlvIGVxdWFsaXplci4gRXF1YWxpemF0aW9uIGlzIHVzZWQgdG8gYWRqdXN0IHRoZSBiYWxhbmNlIG9mXG4gICAqIGZyZXF1ZW5jeSBjb21wb2VuZW50cyBvZiBhbiBhdWRpbyBzaWduYWwuIFRoaXMgcHJvY2VzcyBpcyBjb21tb25seSB1c2VkXG4gICAqIGluIHNvdW5kIHByb2R1Y3Rpb24gYW5kIHJlY29yZGluZyB0byBjaGFuZ2UgdGhlIHdhdmVmb3JtIGJlZm9yZSBpdCByZWFjaGVzXG4gICAqIGEgc291bmQgb3V0cHV0IGRldmljZS4gRVEgY2FuIGFsc28gYmUgdXNlZCBhcyBhbiBhdWRpbyBlZmZlY3QgdG8gY3JlYXRlXG4gICAqIGludGVyZXN0aW5nIGRpc3RvcnRpb25zIGJ5IGZpbHRlcmluZyBvdXQgcGFydHMgb2YgdGhlIHNwZWN0cnVtLiBwNS5FUSBpc1xuICAgKiBidWlsdCB1c2luZyBhIGNoYWluIG9mIFdlYiBBdWRpbyBCaXF1YWQgRmlsdGVyIE5vZGVzIGFuZCBjYW4gYmVcbiAgICogaW5zdGFudGlhdGVkIHdpdGggMyBvciA4IGJhbmRzLiBCYW5kcyBjYW4gYmUgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tXG4gICAqIHRoZSBFUSBieSBkaXJlY3RseSBtb2RpZnlpbmcgcDUuRVEuYmFuZHMgKHRoZSBhcnJheSB0aGF0IHN0b3JlcyBmaWx0ZXJzKS5cbiAgICpcbiAgICogVGhpcyBjbGFzcyBleHRlbmRzIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3RcIj5wNS5FZmZlY3Q8L2E+LlxuICAgKiBNZXRob2RzIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvYW1wXCI+YW1wKCk8L2E+LCA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2NoYWluXCI+Y2hhaW4oKTwvYT4sXG4gICAqIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvZHJ5d2V0XCI+ZHJ5d2V0KCk8L2E+LCA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2Nvbm5lY3RcIj5jb25uZWN0KCk8L2E+LCBhbmRcbiAgICogPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9kaXNjb25uZWN0XCI+ZGlzY29ubmVjdCgpPC9hPiBhcmUgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAY2xhc3MgcDUuRVFcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHA1LkVmZmVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gW19lcXNpemVdIENvbnN0cnVjdG9yIHdpbGwgYWNjZXB0IDMgb3IgOCwgZGVmYXVsdHMgdG8gM1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IHA1LkVRIG9iamVjdFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiA8ZGl2Pjxjb2RlPlxuICAgKiBsZXQgZXEsIHNvdW5kRmlsZVxuICAgKiBsZXQgZXFCYW5kSW5kZXggPSAwO1xuICAgKiBsZXQgZXFCYW5kTmFtZXMgPSBbJ2xvd3MnLCAnbWlkcycsICdoaWdocyddO1xuICAgKlxuICAgKiBmdW5jdGlvbiBwcmVsb2FkKCkge1xuICAgKiAgIHNvdW5kRm9ybWF0cygnbXAzJywgJ29nZycpO1xuICAgKiAgIHNvdW5kRmlsZSA9IGxvYWRTb3VuZCgnYXNzZXRzL2JlYXQnKTtcbiAgICogfVxuICAgKlxuICAgKiBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICBjbnYubW91c2VQcmVzc2VkKHRvZ2dsZVNvdW5kKTtcbiAgICpcbiAgICogICBlcSA9IG5ldyBwNS5FUShlcUJhbmROYW1lcy5sZW5ndGgpO1xuICAgKiAgIHNvdW5kRmlsZS5kaXNjb25uZWN0KCk7XG4gICAqICAgZXEucHJvY2Vzcyhzb3VuZEZpbGUpO1xuICAgKiB9XG4gICAqXG4gICAqIGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAqICAgYmFja2dyb3VuZCgzMCk7XG4gICAqICAgbm9TdHJva2UoKTtcbiAgICogICBmaWxsKDI1NSk7XG4gICAqICAgdGV4dEFsaWduKENFTlRFUik7XG4gICAqICAgdGV4dCgnZmlsdGVyaW5nICcsIDUwLCAyNSk7XG4gICAqXG4gICAqICAgZmlsbCgyNTUsIDQwLCAyNTUpO1xuICAgKiAgIHRleHRTaXplKDI2KTtcbiAgICogICB0ZXh0KGVxQmFuZE5hbWVzW2VxQmFuZEluZGV4XSwgNTAsIDU1KTtcbiAgICpcbiAgICogICBmaWxsKDI1NSk7XG4gICAqICAgdGV4dFNpemUoOSk7XG4gICAqXG4gICAqICAgaWYgKCFzb3VuZEZpbGUuaXNQbGF5aW5nKCkpIHtcbiAgICogICAgIHRleHQoJ3RhcCB0byBwbGF5JywgNTAsIDgwKTtcbiAgICogICB9IGVsc2Uge1xuICAgKiAgICAgdGV4dCgndGFwIHRvIGZpbHRlciBuZXh0IGJhbmQnLCA1MCwgODApXG4gICAqICAgfVxuICAgKiB9XG4gICAqXG4gICAqIGZ1bmN0aW9uIHRvZ2dsZVNvdW5kKCkge1xuICAgKiAgIGlmICghc291bmRGaWxlLmlzUGxheWluZygpKSB7XG4gICAqICAgICBzb3VuZEZpbGUucGxheSgpO1xuICAgKiAgIH0gZWxzZSB7XG4gICAqICAgICBlcUJhbmRJbmRleCA9IChlcUJhbmRJbmRleCArIDEpICUgZXEuYmFuZHMubGVuZ3RoO1xuICAgKiAgIH1cbiAgICpcbiAgICogICBmb3IgKGxldCBpID0gMDsgaSA8IGVxLmJhbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAqICAgICBlcS5iYW5kc1tpXS5nYWluKDApO1xuICAgKiAgIH1cbiAgICogICAvLyBmaWx0ZXIgdGhlIGJhbmQgd2Ugd2FudCB0byBmaWx0ZXJcbiAgICogICBlcS5iYW5kc1tlcUJhbmRJbmRleF0uZ2FpbigtNDApO1xuICAgKiB9XG4gICAqIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5FUSA9IGZ1bmN0aW9uIChfZXFzaXplKSB7XG4gICAgRWZmZWN0LmNhbGwodGhpcyk7IFxuXG4gICAgX2Vxc2l6ZSA9IF9lcXNpemUgPT09IDMgfHwgX2Vxc2l6ZSA9PT0gOCA/IF9lcXNpemUgOiAzO1xuICAgIHZhciBmYWN0b3I7XG4gICAgX2Vxc2l6ZSA9PT0gMyA/IGZhY3RvciA9IE1hdGgucG93KDIsIDMpIDogZmFjdG9yID0gMjtcbiAgICAvKipcbiAgICAgICogIFRoZSBwNS5FUSBpcyBidWlsdCB3aXRoIGFic3RyYWN0ZWQgcDUuRmlsdGVyIG9iamVjdHMuXG4gICAgICAqICBUbyBtb2RpZnkgYW55IGJhbmRzLCB1c2UgbWV0aG9kcyBvZiB0aGUgPGFcbiAgICAgICogIGhyZWY9XCIvcmVmZXJlbmNlLyMvcDUuRmlsdGVyXCIgdGl0bGU9XCJwNS5GaWx0ZXIgcmVmZXJlbmNlXCI+XG4gICAgICAqICBwNS5GaWx0ZXI8L2E+IEFQSSwgZXNwZWNpYWxseSBgZ2FpbmAgYW5kIGBmcmVxYC5cbiAgICAgICogIEJhbmRzIGFyZSBzdG9yZWQgaW4gYW4gYXJyYXksIHdpdGggaW5kaWNlcyAwIC0gMywgb3IgMCAtIDdcbiAgICAgICogIEBwcm9wZXJ0eSB7QXJyYXl9ICBiYW5kc1xuICAgICAgKlxuICAgICovXG5cbiAgICB0aGlzLmJhbmRzID0gW107XG4gICAgdmFyIGZyZXEsIHJlcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2Vxc2l6ZTsgaSsrKSB7XG4gICAgICBpZiAoaSA9PT0gX2Vxc2l6ZSAtIDEpIHtcbiAgICAgICAgZnJlcSA9IDIxMDAwO1xuICAgICAgICByZXMgPSAuMDE7XG4gICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgZnJlcSA9IDEwMDtcbiAgICAgICAgcmVzID0gLjE7XG4gICAgICB9IGVsc2UgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgZnJlcSA9IF9lcXNpemUgPT09IDMgPyAzNjAgKiBmYWN0b3IgOiAzNjA7XG4gICAgICAgIHJlcyA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmVxID0gdGhpcy5iYW5kc1tpIC0gMV0uZnJlcSgpICogZmFjdG9yO1xuICAgICAgICByZXMgPSAxO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJhbmRzW2ldID0gdGhpcy5fbmV3QmFuZChmcmVxLCByZXMpO1xuXG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgdGhpcy5iYW5kc1tpIC0gMV0uY29ubmVjdCh0aGlzLmJhbmRzW2ldLmJpcXVhZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5iYW5kc1tpXS5iaXF1YWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYmFuZHNbX2Vxc2l6ZSAtIDFdLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuICB9O1xuXG4gIHA1LkVRLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRWZmZWN0LnByb3RvdHlwZSk7XG4gIC8qKlxuICAgKiBQcm9jZXNzIGFuIGlucHV0IGJ5IGNvbm5lY3RpbmcgaXQgdG8gdGhlIEVRXG4gICAqIEBtZXRob2QgIHByb2Nlc3NcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzcmMgQXVkaW8gc291cmNlXG4gICAqL1xuXG4gIHA1LkVRLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHNyYykge1xuICAgIHNyYy5jb25uZWN0KHRoaXMuaW5wdXQpO1xuICB9OyBcbiAgLy8gICAqIFNldCB0aGUgZnJlcXVlbmN5IGFuZCBnYWluIG9mIGVhY2ggYmFuZCBpbiB0aGUgRVEuIFRoaXMgbWV0aG9kIHNob3VsZCBiZVxuICAvLyAgICogY2FsbGVkIHdpdGggMyBvciA4IGZyZXF1ZW5jeSBhbmQgZ2FpbiBwYWlycywgZGVwZW5kaW5nIG9uIHRoZSBzaXplIG9mIHRoZSBFUS5cbiAgLy8gICAqIGV4LiBlcS5zZXQoZnJlcTAsIGdhaW4wLCBmcmVxMSwgZ2FpbjEsIGZyZXEyLCBnYWluMik7XG4gIC8vICAgKlxuICAvLyAgICogQG1ldGhvZCAgc2V0XG4gIC8vICAgKiBAZm9yIHA1LkVRXG4gIC8vICAgKiBAcGFyYW0ge051bWJlcn0gW2ZyZXEwXSBGcmVxdWVuY3kgdmFsdWUgZm9yIGJhbmQgd2l0aCBpbmRleCAwXG4gIC8vICAgKiBAcGFyYW0ge051bWJlcn0gW2dhaW4wXSBHYWluIHZhbHVlIGZvciBiYW5kIHdpdGggaW5kZXggMFxuICAvLyAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcmVxMV0gRnJlcXVlbmN5IHZhbHVlIGZvciBiYW5kIHdpdGggaW5kZXggMVxuICAvLyAgICogQHBhcmFtIHtOdW1iZXJ9IFtnYWluMV0gR2FpbiB2YWx1ZSBmb3IgYmFuZCB3aXRoIGluZGV4IDFcbiAgLy8gICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJlcTJdIEZyZXF1ZW5jeSB2YWx1ZSBmb3IgYmFuZCB3aXRoIGluZGV4IDJcbiAgLy8gICAqIEBwYXJhbSB7TnVtYmVyfSBbZ2FpbjJdIEdhaW4gdmFsdWUgZm9yIGJhbmQgd2l0aCBpbmRleCAyXG4gIC8vICAgKiBAcGFyYW0ge051bWJlcn0gW2ZyZXEzXSBGcmVxdWVuY3kgdmFsdWUgZm9yIGJhbmQgd2l0aCBpbmRleCAzXG4gIC8vICAgKiBAcGFyYW0ge051bWJlcn0gW2dhaW4zXSBHYWluIHZhbHVlIGZvciBiYW5kIHdpdGggaW5kZXggM1xuICAvLyAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcmVxNF0gRnJlcXVlbmN5IHZhbHVlIGZvciBiYW5kIHdpdGggaW5kZXggNFxuICAvLyAgICogQHBhcmFtIHtOdW1iZXJ9IFtnYWluNF0gR2FpbiB2YWx1ZSBmb3IgYmFuZCB3aXRoIGluZGV4IDRcbiAgLy8gICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJlcTVdIEZyZXF1ZW5jeSB2YWx1ZSBmb3IgYmFuZCB3aXRoIGluZGV4IDVcbiAgLy8gICAqIEBwYXJhbSB7TnVtYmVyfSBbZ2FpbjVdIEdhaW4gdmFsdWUgZm9yIGJhbmQgd2l0aCBpbmRleCA1XG4gIC8vICAgKiBAcGFyYW0ge051bWJlcn0gW2ZyZXE2XSBGcmVxdWVuY3kgdmFsdWUgZm9yIGJhbmQgd2l0aCBpbmRleCA2XG4gIC8vICAgKiBAcGFyYW0ge051bWJlcn0gW2dhaW42XSBHYWluIHZhbHVlIGZvciBiYW5kIHdpdGggaW5kZXggNlxuICAvLyAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcmVxN10gRnJlcXVlbmN5IHZhbHVlIGZvciBiYW5kIHdpdGggaW5kZXggN1xuICAvLyAgICogQHBhcmFtIHtOdW1iZXJ9IFtnYWluN10gR2FpbiB2YWx1ZSBmb3IgYmFuZCB3aXRoIGluZGV4IDdcbiAgLy8gICAqL1xuXG5cbiAgcDUuRVEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gdGhpcy5iYW5kcy5sZW5ndGggKiAyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB0aGlzLmJhbmRzW2kgLyAyXS5mcmVxKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIHRoaXMuYmFuZHNbaSAvIDJdLmdhaW4oYXJndW1lbnRzW2kgKyAxXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FyZ3VtZW50IG1pc21hdGNoLiAuc2V0KCkgc2hvdWxkIGJlIGNhbGxlZCB3aXRoICcgKyB0aGlzLmJhbmRzLmxlbmd0aCAqIDIgKyAnIGFyZ3VtZW50cy4gKG9uZSBmcmVxdWVuY3kgYW5kIGdhaW4gdmFsdWUgcGFpciBmb3IgZWFjaCBiYW5kIG9mIHRoZSBlcSknKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgYmFuZC4gQ3JlYXRlcyBhIHA1LkZpbHRlciBhbmQgc3RyaXBzIGF3YXkgZXZlcnl0aGluZyBidXRcbiAgICogdGhlIHJhdyBiaXF1YWQgZmlsdGVyLiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIGFic3RyYWN0ZWQgcDUuRmlsdGVyLFxuICAgKiB3aGljaCBjYW4gYmUgYWRkZWQgdG8gcDUuRVEuYmFuZHMsIGluIG9yZGVyIHRvIGNyZWF0ZSBuZXcgRVEgYmFuZHMuXG4gICAqIEBwcml2YXRlXG4gICAqIEBmb3IgcDUuRVFcbiAgICogQG1ldGhvZCAgX25ld0JhbmRcbiAgICogQHBhcmFtICB7TnVtYmVyfSBmcmVxXG4gICAqIEBwYXJhbSAge051bWJlcn0gcmVzXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICBBYnN0cmFjdGVkIEZpbHRlclxuICAgKi9cblxuXG4gIHA1LkVRLnByb3RvdHlwZS5fbmV3QmFuZCA9IGZ1bmN0aW9uIChmcmVxLCByZXMpIHtcbiAgICByZXR1cm4gbmV3IEVRRmlsdGVyKGZyZXEsIHJlcyk7XG4gIH07XG5cbiAgcDUuRVEucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmFwcGx5KHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuYmFuZHMpIHtcbiAgICAgIHdoaWxlICh0aGlzLmJhbmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYmFuZHMucG9wKCkuZGlzcG9zZSgpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgdGhpcy5iYW5kcztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHA1LkVRO1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gIHZhciBGaWx0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxuICB2YXIgcDVzb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gIC8qKlxuICAgKiAgRVFGaWx0ZXIgZXh0ZW5kcyBwNS5GaWx0ZXIgd2l0aCBjb25zdHJhaW50c1xuICAgKiAgbmVjZXNzYXJ5IGZvciB0aGUgcDUuRVFcbiAgICpcbiAgICogIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgdmFyIEVRRmlsdGVyID0gZnVuY3Rpb24gRVFGaWx0ZXIoZnJlcSwgcmVzKSB7XG4gICAgRmlsdGVyLmNhbGwodGhpcywgJ3BlYWtpbmcnKTtcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLnNldChmcmVxLCByZXMpO1xuICAgIHRoaXMuYmlxdWFkLmdhaW4udmFsdWUgPSAwO1xuICAgIGRlbGV0ZSB0aGlzLmlucHV0O1xuICAgIGRlbGV0ZSB0aGlzLm91dHB1dDtcbiAgICBkZWxldGUgdGhpcy5fZHJ5d2V0O1xuICAgIGRlbGV0ZSB0aGlzLndldDtcbiAgfTtcblxuICBFUUZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZpbHRlci5wcm90b3R5cGUpO1xuXG4gIEVRRmlsdGVyLnByb3RvdHlwZS5hbXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc29sZS53YXJuKCdgYW1wKClgIGlzIG5vdCBhdmFpbGFibGUgZm9yIHA1LkVRIGJhbmRzLiBVc2UgYC5nYWluKClgJyk7XG4gIH07XG5cbiAgRVFGaWx0ZXIucHJvdG90eXBlLmRyeXdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zb2xlLndhcm4oJ2Bkcnl3ZXQoKWAgaXMgbm90IGF2YWlsYWJsZSBmb3IgcDUuRVEgYmFuZHMuJyk7XG4gIH07XG5cbiAgRVFGaWx0ZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAodW5pdCkge1xuICAgIHZhciB1ID0gdW5pdCB8fCBwNS5zb3VuZE91dC5pbnB1dDtcblxuICAgIGlmICh0aGlzLmJpcXVhZCkge1xuICAgICAgdGhpcy5iaXF1YWQuY29ubmVjdCh1LmlucHV0ID8gdS5pbnB1dCA6IHUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm91dHB1dC5jb25uZWN0KHUuaW5wdXQgPyB1LmlucHV0IDogdSk7XG4gICAgfVxuICB9O1xuXG4gIEVRRmlsdGVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmJpcXVhZCkge1xuICAgICAgdGhpcy5iaXF1YWQuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfTtcblxuICBFUUZpbHRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5kZXggPSBwNXNvdW5kLnNvdW5kQXJyYXkuaW5kZXhPZih0aGlzKTtcbiAgICBwNXNvdW5kLnNvdW5kQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICBkZWxldGUgdGhpcy5iaXF1YWQ7XG4gIH07XG5cbiAgcmV0dXJuIEVRRmlsdGVyO1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gIHZhciBwNXNvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuICB2YXIgRWZmZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbiAgLyoqXG4gICAqIFBhbm5lcjNEIGlzIGJhc2VkIG9uIHRoZSA8YSB0aXRsZT1cIldlYiBBdWRpbyBQYW5uZXIgZG9jc1wiICBocmVmPVxuICAgKiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QYW5uZXJOb2RlXCI+XG4gICAqIFdlYiBBdWRpbyBTcGF0aWFsIFBhbm5lciBOb2RlPC9hPi5cbiAgICogVGhpcyBwYW5uZXIgaXMgYSBzcGF0aWFsIHByb2Nlc3Npbmcgbm9kZSB0aGF0IGFsbG93cyBhdWRpbyB0byBiZSBwb3NpdGlvbmVkXG4gICAqIGFuZCBvcmllbnRlZCBpbiAzRCBzcGFjZS5cbiAgICpcbiAgICogVGhlIHBvc2l0aW9uIGlzIHJlbGF0aXZlIHRvIGFuIDxhIHRpdGxlPVwiV2ViIEF1ZGlvIExpc3RlbmVyIGRvY3NcIiBocmVmPVxuICAgKiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb0xpc3RlbmVyXCI+XG4gICAqIEF1ZGlvIENvbnRleHQgTGlzdGVuZXI8L2E+LCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbiAgICogYnkgPGNvZGU+cDUuc291bmRPdXQuYXVkaW9jb250ZXh0Lmxpc3RlbmVyPC9jb2RlPlxuICAgKlxuICAgKlxuICAgKiBAY2xhc3MgcDUuUGFubmVyM0RcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuXG5cbiAgcDUuUGFubmVyM0QgPSBmdW5jdGlvbiAoKSB7XG4gICAgRWZmZWN0LmNhbGwodGhpcyk7XG4gICAgLyoqXG4gICAgICogIDxhIHRpdGxlPVwiV2ViIEF1ZGlvIFBhbm5lciBkb2NzXCIgIGhyZWY9XG4gICAgICogIFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Bhbm5lck5vZGVcIj5cbiAgICAgKiAgV2ViIEF1ZGlvIFNwYXRpYWwgUGFubmVyIE5vZGU8L2E+XG4gICAgICpcbiAgICAgKiAgUHJvcGVydGllcyBpbmNsdWRlXG4gICAgICogICAgLSAgPGEgdGl0bGU9XCJ3MyBzcGVjIGZvciBQYW5uaW5nIE1vZGVsXCJcbiAgICAgKiAgICBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1ZGlvLyNpZGwtZGVmLVBhbm5pbmdNb2RlbFR5cGVcIlxuICAgICAqICAgID5wYW5uaW5nTW9kZWw8L2E+OiBcImVxdWFsIHBvd2VyXCIgb3IgXCJIUlRGXCJcbiAgICAgKiAgICAtICA8YSB0aXRsZT1cInczIHNwZWMgZm9yIERpc3RhbmNlIE1vZGVsXCJcbiAgICAgKiAgICBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1ZGlvLyNpZGwtZGVmLURpc3RhbmNlTW9kZWxUeXBlXCJcbiAgICAgKiAgICA+ZGlzdGFuY2VNb2RlbDwvYT46IFwibGluZWFyXCIsIFwiaW52ZXJzZVwiLCBvciBcImV4cG9uZW50aWFsXCJcbiAgICAgKlxuICAgICAqICBAcHJvcGVydHkge0F1ZGlvTm9kZX0gcGFubmVyXG4gICAgICpcbiAgICAgKi9cblxuICAgIHRoaXMucGFubmVyID0gdGhpcy5hYy5jcmVhdGVQYW5uZXIoKTtcbiAgICB0aGlzLnBhbm5lci5wYW5uaW5nTW9kZWwgPSAnSFJURic7XG4gICAgdGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbCA9ICdsaW5lYXInO1xuICAgIHRoaXMucGFubmVyLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLnBhbm5lcik7XG4gIH07XG5cbiAgcDUuUGFubmVyM0QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFZmZlY3QucHJvdG90eXBlKTtcbiAgLyoqXG4gICAqIENvbm5lY3QgYW4gYXVkaW8gc29yY2VcbiAgICpcbiAgICogQG1ldGhvZCAgcHJvY2Vzc1xuICAgKiBAZm9yIHA1LlBhbm5lcjNEXG4gICAqIEBwYXJhbSAge09iamVjdH0gc3JjIElucHV0IHNvdXJjZVxuICAgKi9cblxuICBwNS5QYW5uZXIzRC5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICBzcmMuY29ubmVjdCh0aGlzLmlucHV0KTtcbiAgfTtcbiAgLyoqXG4gICAqIFNldCB0aGUgWCxZLFogcG9zaXRpb24gb2YgdGhlIFBhbm5lclxuICAgKiBAbWV0aG9kIHNldFxuICAgKiBAZm9yIHA1LlBhbm5lcjNEXG4gICAqIEBwYXJhbSAge051bWJlcn0geFZhbFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHlWYWxcbiAgICogQHBhcmFtICB7TnVtYmVyfSB6VmFsXG4gICAqIEBwYXJhbSAge051bWJlcn0gdGltZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICBVcGRhdGVkIHgsIHksIHogdmFsdWVzIGFzIGFuIGFycmF5XG4gICAqL1xuXG5cbiAgcDUuUGFubmVyM0QucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh4VmFsLCB5VmFsLCB6VmFsLCB0aW1lKSB7XG4gICAgdGhpcy5wb3NpdGlvblgoeFZhbCwgdGltZSk7XG4gICAgdGhpcy5wb3NpdGlvblkoeVZhbCwgdGltZSk7XG4gICAgdGhpcy5wb3NpdGlvblooelZhbCwgdGltZSk7XG4gICAgcmV0dXJuIFt0aGlzLnBhbm5lci5wb3NpdGlvblgudmFsdWUsIHRoaXMucGFubmVyLnBvc2l0aW9uWS52YWx1ZSwgdGhpcy5wYW5uZXIucG9zaXRpb25aLnZhbHVlXTtcbiAgfTtcbiAgLyoqXG4gICAqIEdldHRlciBhbmQgc2V0dGVyIG1ldGhvZHMgZm9yIHBvc2l0aW9uIGNvb3JkaW5hdGVzXG4gICAqIEBtZXRob2QgcG9zaXRpb25YXG4gICAqIEBmb3IgcDUuUGFubmVyM0RcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgIHVwZGF0ZWQgY29vcmRpbmF0ZSB2YWx1ZVxuICAgKi9cblxuICAvKipcbiAgICogR2V0dGVyIGFuZCBzZXR0ZXIgbWV0aG9kcyBmb3IgcG9zaXRpb24gY29vcmRpbmF0ZXNcbiAgICogQG1ldGhvZCBwb3NpdGlvbllcbiAgICogQGZvciBwNS5QYW5uZXIzRFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgdXBkYXRlZCBjb29yZGluYXRlIHZhbHVlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZXR0ZXIgYW5kIHNldHRlciBtZXRob2RzIGZvciBwb3NpdGlvbiBjb29yZGluYXRlc1xuICAgKiBAbWV0aG9kIHBvc2l0aW9uWlxuICAgKiBAZm9yIHA1LlBhbm5lcjNEXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICB1cGRhdGVkIGNvb3JkaW5hdGUgdmFsdWVcbiAgICovXG5cblxuICBwNS5QYW5uZXIzRC5wcm90b3R5cGUucG9zaXRpb25YID0gZnVuY3Rpb24gKHhWYWwsIHRpbWUpIHtcbiAgICB2YXIgdCA9IHRpbWUgfHwgMDtcblxuICAgIGlmICh0eXBlb2YgeFZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucGFubmVyLnBvc2l0aW9uWC52YWx1ZSA9IHhWYWw7XG4gICAgICB0aGlzLnBhbm5lci5wb3NpdGlvblguY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAxICsgdCk7XG4gICAgICB0aGlzLnBhbm5lci5wb3NpdGlvblgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoeFZhbCwgdGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDIgKyB0KTtcbiAgICB9IGVsc2UgaWYgKHhWYWwpIHtcbiAgICAgIHhWYWwuY29ubmVjdCh0aGlzLnBhbm5lci5wb3NpdGlvblgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhbm5lci5wb3NpdGlvblgudmFsdWU7XG4gIH07XG5cbiAgcDUuUGFubmVyM0QucHJvdG90eXBlLnBvc2l0aW9uWSA9IGZ1bmN0aW9uICh5VmFsLCB0aW1lKSB7XG4gICAgdmFyIHQgPSB0aW1lIHx8IDA7XG5cbiAgICBpZiAodHlwZW9mIHlWYWwgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnBhbm5lci5wb3NpdGlvblkudmFsdWUgPSB5VmFsO1xuICAgICAgdGhpcy5wYW5uZXIucG9zaXRpb25ZLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMSArIHQpO1xuICAgICAgdGhpcy5wYW5uZXIucG9zaXRpb25ZLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHlWYWwsIHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAyICsgdCk7XG4gICAgfSBlbHNlIGlmICh5VmFsKSB7XG4gICAgICB5VmFsLmNvbm5lY3QodGhpcy5wYW5uZXIucG9zaXRpb25ZKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYW5uZXIucG9zaXRpb25ZLnZhbHVlO1xuICB9O1xuXG4gIHA1LlBhbm5lcjNELnByb3RvdHlwZS5wb3NpdGlvblogPSBmdW5jdGlvbiAoelZhbCwgdGltZSkge1xuICAgIHZhciB0ID0gdGltZSB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZiB6VmFsID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5wYW5uZXIucG9zaXRpb25aLnZhbHVlID0gelZhbDtcbiAgICAgIHRoaXMucGFubmVyLnBvc2l0aW9uWi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDEgKyB0KTtcbiAgICAgIHRoaXMucGFubmVyLnBvc2l0aW9uWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh6VmFsLCB0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMiArIHQpO1xuICAgIH0gZWxzZSBpZiAoelZhbCkge1xuICAgICAgelZhbC5jb25uZWN0KHRoaXMucGFubmVyLnBvc2l0aW9uWik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFubmVyLnBvc2l0aW9uWi52YWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIFNldCB0aGUgWCxZLFogcG9zaXRpb24gb2YgdGhlIFBhbm5lclxuICAgKiBAbWV0aG9kICBvcmllbnRcbiAgICogQGZvciBwNS5QYW5uZXIzRFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHhWYWxcbiAgICogQHBhcmFtICB7TnVtYmVyfSB5VmFsXG4gICAqIEBwYXJhbSAge051bWJlcn0gelZhbFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWVcbiAgICogQHJldHVybiB7QXJyYXl9ICAgICAgVXBkYXRlZCB4LCB5LCB6IHZhbHVlcyBhcyBhbiBhcnJheVxuICAgKi9cblxuXG4gIHA1LlBhbm5lcjNELnByb3RvdHlwZS5vcmllbnQgPSBmdW5jdGlvbiAoeFZhbCwgeVZhbCwgelZhbCwgdGltZSkge1xuICAgIHRoaXMub3JpZW50WCh4VmFsLCB0aW1lKTtcbiAgICB0aGlzLm9yaWVudFkoeVZhbCwgdGltZSk7XG4gICAgdGhpcy5vcmllbnRaKHpWYWwsIHRpbWUpO1xuICAgIHJldHVybiBbdGhpcy5wYW5uZXIub3JpZW50YXRpb25YLnZhbHVlLCB0aGlzLnBhbm5lci5vcmllbnRhdGlvblkudmFsdWUsIHRoaXMucGFubmVyLm9yaWVudGF0aW9uWi52YWx1ZV07XG4gIH07XG4gIC8qKlxuICAgKiBHZXR0ZXIgYW5kIHNldHRlciBtZXRob2RzIGZvciBvcmllbnQgY29vcmRpbmF0ZXNcbiAgICogQG1ldGhvZCBvcmllbnRYXG4gICAqIEBmb3IgcDUuUGFubmVyM0RcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgIHVwZGF0ZWQgY29vcmRpbmF0ZSB2YWx1ZVxuICAgKi9cblxuICAvKipcbiAgICogR2V0dGVyIGFuZCBzZXR0ZXIgbWV0aG9kcyBmb3Igb3JpZW50IGNvb3JkaW5hdGVzXG4gICAqIEBtZXRob2Qgb3JpZW50WVxuICAgKiBAZm9yIHA1LlBhbm5lcjNEXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICB1cGRhdGVkIGNvb3JkaW5hdGUgdmFsdWVcbiAgICovXG5cbiAgLyoqXG4gICAqIEdldHRlciBhbmQgc2V0dGVyIG1ldGhvZHMgZm9yIG9yaWVudCBjb29yZGluYXRlc1xuICAgKiBAbWV0aG9kIG9yaWVudFpcbiAgICogQGZvciBwNS5QYW5uZXIzRFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgdXBkYXRlZCBjb29yZGluYXRlIHZhbHVlXG4gICAqL1xuXG5cbiAgcDUuUGFubmVyM0QucHJvdG90eXBlLm9yaWVudFggPSBmdW5jdGlvbiAoeFZhbCwgdGltZSkge1xuICAgIHZhciB0ID0gdGltZSB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZiB4VmFsID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5wYW5uZXIub3JpZW50YXRpb25YLnZhbHVlID0geFZhbDtcbiAgICAgIHRoaXMucGFubmVyLm9yaWVudGF0aW9uWC5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDEgKyB0KTtcbiAgICAgIHRoaXMucGFubmVyLm9yaWVudGF0aW9uWC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh4VmFsLCB0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMiArIHQpO1xuICAgIH0gZWxzZSBpZiAoeFZhbCkge1xuICAgICAgeFZhbC5jb25uZWN0KHRoaXMucGFubmVyLm9yaWVudGF0aW9uWCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFubmVyLm9yaWVudGF0aW9uWC52YWx1ZTtcbiAgfTtcblxuICBwNS5QYW5uZXIzRC5wcm90b3R5cGUub3JpZW50WSA9IGZ1bmN0aW9uICh5VmFsLCB0aW1lKSB7XG4gICAgdmFyIHQgPSB0aW1lIHx8IDA7XG5cbiAgICBpZiAodHlwZW9mIHlWYWwgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnBhbm5lci5vcmllbnRhdGlvblkudmFsdWUgPSB5VmFsO1xuICAgICAgdGhpcy5wYW5uZXIub3JpZW50YXRpb25ZLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMSArIHQpO1xuICAgICAgdGhpcy5wYW5uZXIub3JpZW50YXRpb25ZLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHlWYWwsIHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAyICsgdCk7XG4gICAgfSBlbHNlIGlmICh5VmFsKSB7XG4gICAgICB5VmFsLmNvbm5lY3QodGhpcy5wYW5uZXIub3JpZW50YXRpb25ZKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYW5uZXIub3JpZW50YXRpb25ZLnZhbHVlO1xuICB9O1xuXG4gIHA1LlBhbm5lcjNELnByb3RvdHlwZS5vcmllbnRaID0gZnVuY3Rpb24gKHpWYWwsIHRpbWUpIHtcbiAgICB2YXIgdCA9IHRpbWUgfHwgMDtcblxuICAgIGlmICh0eXBlb2YgelZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucGFubmVyLm9yaWVudGF0aW9uWi52YWx1ZSA9IHpWYWw7XG4gICAgICB0aGlzLnBhbm5lci5vcmllbnRhdGlvblouY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAxICsgdCk7XG4gICAgICB0aGlzLnBhbm5lci5vcmllbnRhdGlvbloubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoelZhbCwgdGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDIgKyB0KTtcbiAgICB9IGVsc2UgaWYgKHpWYWwpIHtcbiAgICAgIHpWYWwuY29ubmVjdCh0aGlzLnBhbm5lci5vcmllbnRhdGlvblopO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhbm5lci5vcmllbnRhdGlvbloudmFsdWU7XG4gIH07XG4gIC8qKlxuICAgKiBTZXQgdGhlIHJvbGxvZmYgZmFjdG9yIGFuZCBtYXggZGlzdGFuY2VcbiAgICogQG1ldGhvZCAgc2V0RmFsbG9mZlxuICAgKiBAZm9yIHA1LlBhbm5lcjNEXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4RGlzdGFuY2VdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcm9sbG9mZkZhY3Rvcl1cbiAgICovXG5cblxuICBwNS5QYW5uZXIzRC5wcm90b3R5cGUuc2V0RmFsbG9mZiA9IGZ1bmN0aW9uIChtYXhEaXN0YW5jZSwgcm9sbG9mZkZhY3Rvcikge1xuICAgIHRoaXMubWF4RGlzdChtYXhEaXN0YW5jZSk7XG4gICAgdGhpcy5yb2xsb2ZmKHJvbGxvZmZGYWN0b3IpO1xuICB9O1xuICAvKipcbiAgICogTWF4aXVtIGRpc3RhbmNlIGJldHdlZW4gdGhlIHNvdXJjZSBhbmQgdGhlIGxpc3RlbmVyXG4gICAqIEBtZXRob2QgIG1heERpc3RcbiAgICogQGZvciBwNS5QYW5uZXIzRFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG1heERpc3RhbmNlXG4gICAqIEByZXR1cm4ge051bWJlcn0gdXBkYXRlZCB2YWx1ZVxuICAgKi9cblxuXG4gIHA1LlBhbm5lcjNELnByb3RvdHlwZS5tYXhEaXN0ID0gZnVuY3Rpb24gKG1heERpc3RhbmNlKSB7XG4gICAgaWYgKHR5cGVvZiBtYXhEaXN0YW5jZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucGFubmVyLm1heERpc3RhbmNlID0gbWF4RGlzdGFuY2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFubmVyLm1heERpc3RhbmNlO1xuICB9O1xuICAvKipcbiAgICogSG93IHF1aWNrbHkgdGhlIHZvbHVtZSBpcyByZWR1Y2VkIGFzIHRoZSBzb3VyY2UgbW92ZXMgYXdheSBmcm9tIHRoZSBsaXN0ZW5lclxuICAgKiBAbWV0aG9kICByb2xsb2ZcbiAgICogQGZvciBwNS5QYW5uZXIzRFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHJvbGxvZmZGYWN0b3JcbiAgICogQHJldHVybiB7TnVtYmVyfSB1cGRhdGVkIHZhbHVlXG4gICAqL1xuXG5cbiAgcDUuUGFubmVyM0QucHJvdG90eXBlLnJvbGxvZmYgPSBmdW5jdGlvbiAocm9sbG9mZkZhY3Rvcikge1xuICAgIGlmICh0eXBlb2Ygcm9sbG9mZkZhY3RvciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3IgPSByb2xsb2ZmRmFjdG9yO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yO1xuICB9O1xuXG4gIHA1LlBhbm5lcjNELmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmFwcGx5KHRoaXMpO1xuXG4gICAgaWYgKHRoaXMucGFubmVyKSB7XG4gICAgICB0aGlzLnBhbm5lci5kaXNjb25uZWN0KCk7XG4gICAgICBkZWxldGUgdGhpcy5wYW5uZXI7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBwNS5QYW5uZXIzRDtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICB2YXIgcDVzb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIEVmZmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7IFxuICAvLyAgICogbGlzdGVuZXIgaXMgYSBjbGFzcyB0aGF0IGNhbiBjb25zdHJ1Y3QgYm90aCBhIFNwYXRpYWwgUGFubmVyXG4gIC8vICAgKiBhbmQgYSBTcGF0aWFsIExpc3RlbmVyLiBUaGUgcGFubmVyIGlzIGJhc2VkIG9uIHRoZSBcbiAgLy8gICAqIFdlYiBBdWRpbyBTcGF0aWFsIFBhbm5lciBOb2RlXG4gIC8vICAgKiBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXVkaW8vI3RoZS1saXN0ZW5lcm5vZGUtaW50ZXJmYWNlXG4gIC8vICAgKiBUaGlzIHBhbm5lciBpcyBhIHNwYXRpYWwgcHJvY2Vzc2luZyBub2RlIHRoYXQgYWxsb3dzIGF1ZGlvIHRvIGJlIHBvc2l0aW9uZWRcbiAgLy8gICAqIGFuZCBvcmllbnRlZCBpbiAzRCBzcGFjZS4gXG4gIC8vICAgKlxuICAvLyAgICogVGhlIExpc3RlbmVyIG1vZGlmaWVzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBBdWRpbyBDb250ZXh0IExpc3RlbmVyLiBcbiAgLy8gICAqIEJvdGggb2JqZWN0cyB0eXBlcyB1c2UgdGhlIHNhbWUgbWV0aG9kcy4gVGhlIGRlZmF1bHQgaXMgYSBzcGF0aWFsIHBhbm5lci5cbiAgLy8gICAqXG4gIC8vICAgKiA8Y29kZT5wNS5QYW5uZXIzRDwvY29kZT4gLSBDb25zdHJ1Y3RzIGEgU3BhdGlhbCBQYW5uZXI8YnIvPlxuICAvLyAgICogPGNvZGU+cDUuTGlzdGVuZXIzRDwvY29kZT4gLSBDb25zdHJ1Y3RzIGEgU3BhdGlhbCBMaXN0ZW5lcjxici8+XG4gIC8vICAgKlxuICAvLyAgICogQGNsYXNzIGxpc3RlbmVyXG4gIC8vICAgKiBAY29uc3RydWN0b3JcbiAgLy8gICAqIEByZXR1cm4ge09iamVjdH0gcDUuTGlzdGVuZXIzRCBPYmplY3RcbiAgLy8gICAqXG4gIC8vICAgKiBAcGFyYW0ge1dlYiBBdWRpbyBOb2RlfSBsaXN0ZW5lciBXZWIgQXVkaW8gU3BhdGlhbCBQYW5uaW5nIE5vZGVcbiAgLy8gICAqIEBwYXJhbSB7QXVkaW9QYXJhbX0gbGlzdGVuZXIucGFubmluZ01vZGVsIFwiZXF1YWwgcG93ZXJcIiBvciBcIkhSVEZcIlxuICAvLyAgICogQHBhcmFtIHtBdWRpb1BhcmFtfSBsaXN0ZW5lci5kaXN0YW5jZU1vZGVsIFwibGluZWFyXCIsIFwiaW52ZXJzZVwiLCBvciBcImV4cG9uZW50aWFsXCJcbiAgLy8gICAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gW1NwZWNpZnkgY29uc3RydWN0aW9uIG9mIGEgc3BhdGlhbCBwYW5uZXIgb3IgbGlzdGVuZXJdXG4gIC8vICAgKi9cblxuXG4gIHA1Lkxpc3RlbmVyM0QgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHRoaXMuYWMgPSBwNXNvdW5kLmF1ZGlvY29udGV4dDtcbiAgICB0aGlzLmxpc3RlbmVyID0gdGhpcy5hYy5saXN0ZW5lcjtcbiAgfTsgXG4gIC8vICAgKiBDb25uZWN0IGFuIGF1ZGlvIHNvcmNlXG4gIC8vICAgKiBAcGFyYW0gIHtPYmplY3R9IHNyYyBJbnB1dCBzb3VyY2VcbiAgLy8gICAqL1xuXG5cbiAgcDUuTGlzdGVuZXIzRC5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICBzcmMuY29ubmVjdCh0aGlzLmlucHV0KTtcbiAgfTsgXG4gIC8vICAgKiBTZXQgdGhlIFgsWSxaIHBvc2l0aW9uIG9mIHRoZSBQYW5uZXJcbiAgLy8gICAqIEBwYXJhbSAge1tOdW1iZXJdfSB4VmFsXG4gIC8vICAgKiBAcGFyYW0gIHtbTnVtYmVyXX0geVZhbFxuICAvLyAgICogQHBhcmFtICB7W051bWJlcl19IHpWYWxcbiAgLy8gICAqIEBwYXJhbSAge1tOdW1iZXJdfSB0aW1lXG4gIC8vICAgKiBAcmV0dXJuIHtbQXJyYXldfSAgICAgIFtVcGRhdGVkIHgsIHksIHogdmFsdWVzIGFzIGFuIGFycmF5XVxuICAvLyAgICovXG5cblxuICBwNS5MaXN0ZW5lcjNELnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uICh4VmFsLCB5VmFsLCB6VmFsLCB0aW1lKSB7XG4gICAgdGhpcy5wb3NpdGlvblgoeFZhbCwgdGltZSk7XG4gICAgdGhpcy5wb3NpdGlvblkoeVZhbCwgdGltZSk7XG4gICAgdGhpcy5wb3NpdGlvblooelZhbCwgdGltZSk7XG4gICAgcmV0dXJuIFt0aGlzLmxpc3RlbmVyLnBvc2l0aW9uWC52YWx1ZSwgdGhpcy5saXN0ZW5lci5wb3NpdGlvblkudmFsdWUsIHRoaXMubGlzdGVuZXIucG9zaXRpb25aLnZhbHVlXTtcbiAgfTsgXG4gIC8vICAgKiBHZXR0ZXIgYW5kIHNldHRlciBtZXRob2RzIGZvciBwb3NpdGlvbiBjb29yZGluYXRlc1xuICAvLyAgICogQHJldHVybiB7TnVtYmVyfSAgICAgIFt1cGRhdGVkIGNvb3JkaW5hdGUgdmFsdWVdXG4gIC8vICAgKi9cblxuXG4gIHA1Lkxpc3RlbmVyM0QucHJvdG90eXBlLnBvc2l0aW9uWCA9IGZ1bmN0aW9uICh4VmFsLCB0aW1lKSB7XG4gICAgdmFyIHQgPSB0aW1lIHx8IDA7XG5cbiAgICBpZiAodHlwZW9mIHhWYWwgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyLnBvc2l0aW9uWC52YWx1ZSA9IHhWYWw7XG4gICAgICB0aGlzLmxpc3RlbmVyLnBvc2l0aW9uWC5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDEgKyB0KTtcbiAgICAgIHRoaXMubGlzdGVuZXIucG9zaXRpb25YLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHhWYWwsIHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAyICsgdCk7XG4gICAgfSBlbHNlIGlmICh4VmFsKSB7XG4gICAgICB4VmFsLmNvbm5lY3QodGhpcy5saXN0ZW5lci5wb3NpdGlvblgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLnBvc2l0aW9uWC52YWx1ZTtcbiAgfTtcblxuICBwNS5MaXN0ZW5lcjNELnByb3RvdHlwZS5wb3NpdGlvblkgPSBmdW5jdGlvbiAoeVZhbCwgdGltZSkge1xuICAgIHZhciB0ID0gdGltZSB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZiB5VmFsID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5saXN0ZW5lci5wb3NpdGlvblkudmFsdWUgPSB5VmFsO1xuICAgICAgdGhpcy5saXN0ZW5lci5wb3NpdGlvblkuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAxICsgdCk7XG4gICAgICB0aGlzLmxpc3RlbmVyLnBvc2l0aW9uWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh5VmFsLCB0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMiArIHQpO1xuICAgIH0gZWxzZSBpZiAoeVZhbCkge1xuICAgICAgeVZhbC5jb25uZWN0KHRoaXMubGlzdGVuZXIucG9zaXRpb25ZKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5wb3NpdGlvblkudmFsdWU7XG4gIH07XG5cbiAgcDUuTGlzdGVuZXIzRC5wcm90b3R5cGUucG9zaXRpb25aID0gZnVuY3Rpb24gKHpWYWwsIHRpbWUpIHtcbiAgICB2YXIgdCA9IHRpbWUgfHwgMDtcblxuICAgIGlmICh0eXBlb2YgelZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMubGlzdGVuZXIucG9zaXRpb25aLnZhbHVlID0gelZhbDtcbiAgICAgIHRoaXMubGlzdGVuZXIucG9zaXRpb25aLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMSArIHQpO1xuICAgICAgdGhpcy5saXN0ZW5lci5wb3NpdGlvbloubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoelZhbCwgdGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDIgKyB0KTtcbiAgICB9IGVsc2UgaWYgKHpWYWwpIHtcbiAgICAgIHpWYWwuY29ubmVjdCh0aGlzLmxpc3RlbmVyLnBvc2l0aW9uWik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIucG9zaXRpb25aLnZhbHVlO1xuICB9OyBcbiAgLy8gICAqIE92ZXJyaWRlcyB0aGUgbGlzdGVuZXIgb3JpZW50KCkgbWV0aG9kIGJlY2F1c2UgTGlzdGVuZXIgaGFzIHNsaWdodGx5XG4gIC8vICAgKiBkaWZmZXJlbnQgcGFyYW1zLiBJbiBodW1hbiB0ZXJtcywgRm9yd2FyZCB2ZWN0b3JzIGFyZSB0aGUgZGlyZWN0aW9uIHRoZSBcbiAgLy8gICAqIG5vc2UgaXMgcG9pbnRpbmcuIFVwIHZlY3RvcnMgYXJlIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHRvcCBvZiB0aGUgaGVhZC5cbiAgLy8gICAqXG4gIC8vICAgKiBAbWV0aG9kIG9yaWVudFxuICAvLyAgICogQHBhcmFtICB7TnVtYmVyfSB4VmFsRiAgRm9yd2FyZCB2ZWN0b3IgWCBkaXJlY3Rpb25cbiAgLy8gICAqIEBwYXJhbSAge051bWJlcn0geVZhbEYgIEZvcndhcmQgdmVjdG9yIFkgZGlyZWN0aW9uXG4gIC8vICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHpWYWxGICBGb3J3YXJkIHZlY3RvciBaIGRpcmVjdGlvblxuICAvLyAgICogQHBhcmFtICB7TnVtYmVyfSB4VmFsVSAgVXAgdmVjdG9yIFggZGlyZWN0aW9uXG4gIC8vICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHlWYWxVICBVcCB2ZWN0b3IgWSBkaXJlY3Rpb25cbiAgLy8gICAqIEBwYXJhbSAge051bWJlcn0gelZhbFUgIFVwIHZlY3RvciBaIGRpcmVjdGlvblxuICAvLyAgICogQHBhcmFtICB7TnVtYmVyfSB0aW1lICBcbiAgLy8gICAqIEByZXR1cm4ge0FycmF5fSAgICAgICBBbGwgb3JpZW5hdGlvbiBwYXJhbXNcbiAgLy8gICAqL1xuXG5cbiAgcDUuTGlzdGVuZXIzRC5wcm90b3R5cGUub3JpZW50ID0gZnVuY3Rpb24gKHhWYWxGLCB5VmFsRiwgelZhbEYsIHhWYWxVLCB5VmFsVSwgelZhbFUsIHRpbWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyB8fCBhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICB0aW1lID0gYXJndW1lbnRzWzNdO1xuICAgICAgdGhpcy5vcmllbnRGb3J3YXJkKHhWYWxGLCB5VmFsRiwgelZhbEYsIHRpbWUpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNiB8fCBhcmd1bWVudHMgPT09IDcpIHtcbiAgICAgIHRoaXMub3JpZW50Rm9yd2FyZCh4VmFsRiwgeVZhbEYsIHpWYWxGKTtcbiAgICAgIHRoaXMub3JpZW50VXAoeFZhbFUsIHlWYWxVLCB6VmFsVSwgdGltZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFt0aGlzLmxpc3RlbmVyLmZvcndhcmRYLnZhbHVlLCB0aGlzLmxpc3RlbmVyLmZvcndhcmRZLnZhbHVlLCB0aGlzLmxpc3RlbmVyLmZvcndhcmRaLnZhbHVlLCB0aGlzLmxpc3RlbmVyLnVwWC52YWx1ZSwgdGhpcy5saXN0ZW5lci51cFkudmFsdWUsIHRoaXMubGlzdGVuZXIudXBaLnZhbHVlXTtcbiAgfTtcblxuICBwNS5MaXN0ZW5lcjNELnByb3RvdHlwZS5vcmllbnRGb3J3YXJkID0gZnVuY3Rpb24gKHhWYWxGLCB5VmFsRiwgelZhbEYsIHRpbWUpIHtcbiAgICB0aGlzLmZvcndhcmRYKHhWYWxGLCB0aW1lKTtcbiAgICB0aGlzLmZvcndhcmRZKHlWYWxGLCB0aW1lKTtcbiAgICB0aGlzLmZvcndhcmRaKHpWYWxGLCB0aW1lKTtcbiAgICByZXR1cm4gW3RoaXMubGlzdGVuZXIuZm9yd2FyZFgsIHRoaXMubGlzdGVuZXIuZm9yd2FyZFksIHRoaXMubGlzdGVuZXIuZm9yd2FyZFpdO1xuICB9O1xuXG4gIHA1Lkxpc3RlbmVyM0QucHJvdG90eXBlLm9yaWVudFVwID0gZnVuY3Rpb24gKHhWYWxVLCB5VmFsVSwgelZhbFUsIHRpbWUpIHtcbiAgICB0aGlzLnVwWCh4VmFsVSwgdGltZSk7XG4gICAgdGhpcy51cFkoeVZhbFUsIHRpbWUpO1xuICAgIHRoaXMudXBaKHpWYWxVLCB0aW1lKTtcbiAgICByZXR1cm4gW3RoaXMubGlzdGVuZXIudXBYLCB0aGlzLmxpc3RlbmVyLnVwWSwgdGhpcy5saXN0ZW5lci51cFpdO1xuICB9OyBcbiAgLy8gICAqIEdldHRlciBhbmQgc2V0dGVyIG1ldGhvZHMgZm9yIG9yaWVudCBjb29yZGluYXRlc1xuICAvLyAgICogQHJldHVybiB7TnVtYmVyfSAgICAgIFt1cGRhdGVkIGNvb3JkaW5hdGUgdmFsdWVdXG4gIC8vICAgKi9cblxuXG4gIHA1Lkxpc3RlbmVyM0QucHJvdG90eXBlLmZvcndhcmRYID0gZnVuY3Rpb24gKHhWYWwsIHRpbWUpIHtcbiAgICB2YXIgdCA9IHRpbWUgfHwgMDtcblxuICAgIGlmICh0eXBlb2YgeFZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMubGlzdGVuZXIuZm9yd2FyZFgudmFsdWUgPSB4VmFsO1xuICAgICAgdGhpcy5saXN0ZW5lci5mb3J3YXJkWC5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDEgKyB0KTtcbiAgICAgIHRoaXMubGlzdGVuZXIuZm9yd2FyZFgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoeFZhbCwgdGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDIgKyB0KTtcbiAgICB9IGVsc2UgaWYgKHhWYWwpIHtcbiAgICAgIHhWYWwuY29ubmVjdCh0aGlzLmxpc3RlbmVyLmZvcndhcmRYKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5mb3J3YXJkWC52YWx1ZTtcbiAgfTtcblxuICBwNS5MaXN0ZW5lcjNELnByb3RvdHlwZS5mb3J3YXJkWSA9IGZ1bmN0aW9uICh5VmFsLCB0aW1lKSB7XG4gICAgdmFyIHQgPSB0aW1lIHx8IDA7XG5cbiAgICBpZiAodHlwZW9mIHlWYWwgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyLmZvcndhcmRZLnZhbHVlID0geVZhbDtcbiAgICAgIHRoaXMubGlzdGVuZXIuZm9yd2FyZFkuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAxICsgdCk7XG4gICAgICB0aGlzLmxpc3RlbmVyLmZvcndhcmRZLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHlWYWwsIHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAyICsgdCk7XG4gICAgfSBlbHNlIGlmICh5VmFsKSB7XG4gICAgICB5VmFsLmNvbm5lY3QodGhpcy5saXN0ZW5lci5mb3J3YXJkWSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuZm9yd2FyZFkudmFsdWU7XG4gIH07XG5cbiAgcDUuTGlzdGVuZXIzRC5wcm90b3R5cGUuZm9yd2FyZFogPSBmdW5jdGlvbiAoelZhbCwgdGltZSkge1xuICAgIHZhciB0ID0gdGltZSB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZiB6VmFsID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5saXN0ZW5lci5mb3J3YXJkWi52YWx1ZSA9IHpWYWw7XG4gICAgICB0aGlzLmxpc3RlbmVyLmZvcndhcmRaLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMSArIHQpO1xuICAgICAgdGhpcy5saXN0ZW5lci5mb3J3YXJkWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh6VmFsLCB0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMiArIHQpO1xuICAgIH0gZWxzZSBpZiAoelZhbCkge1xuICAgICAgelZhbC5jb25uZWN0KHRoaXMubGlzdGVuZXIuZm9yd2FyZFopO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmZvcndhcmRaLnZhbHVlO1xuICB9O1xuXG4gIHA1Lkxpc3RlbmVyM0QucHJvdG90eXBlLnVwWCA9IGZ1bmN0aW9uICh4VmFsLCB0aW1lKSB7XG4gICAgdmFyIHQgPSB0aW1lIHx8IDA7XG5cbiAgICBpZiAodHlwZW9mIHhWYWwgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyLnVwWC52YWx1ZSA9IHhWYWw7XG4gICAgICB0aGlzLmxpc3RlbmVyLnVwWC5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDEgKyB0KTtcbiAgICAgIHRoaXMubGlzdGVuZXIudXBYLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHhWYWwsIHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAyICsgdCk7XG4gICAgfSBlbHNlIGlmICh4VmFsKSB7XG4gICAgICB4VmFsLmNvbm5lY3QodGhpcy5saXN0ZW5lci51cFgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLnVwWC52YWx1ZTtcbiAgfTtcblxuICBwNS5MaXN0ZW5lcjNELnByb3RvdHlwZS51cFkgPSBmdW5jdGlvbiAoeVZhbCwgdGltZSkge1xuICAgIHZhciB0ID0gdGltZSB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZiB5VmFsID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5saXN0ZW5lci51cFkudmFsdWUgPSB5VmFsO1xuICAgICAgdGhpcy5saXN0ZW5lci51cFkuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAxICsgdCk7XG4gICAgICB0aGlzLmxpc3RlbmVyLnVwWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh5VmFsLCB0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMiArIHQpO1xuICAgIH0gZWxzZSBpZiAoeVZhbCkge1xuICAgICAgeVZhbC5jb25uZWN0KHRoaXMubGlzdGVuZXIudXBZKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci51cFkudmFsdWU7XG4gIH07XG5cbiAgcDUuTGlzdGVuZXIzRC5wcm90b3R5cGUudXBaID0gZnVuY3Rpb24gKHpWYWwsIHRpbWUpIHtcbiAgICB2YXIgdCA9IHRpbWUgfHwgMDtcblxuICAgIGlmICh0eXBlb2YgelZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMubGlzdGVuZXIudXBaLnZhbHVlID0gelZhbDtcbiAgICAgIHRoaXMubGlzdGVuZXIudXBaLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMSArIHQpO1xuICAgICAgdGhpcy5saXN0ZW5lci51cFoubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoelZhbCwgdGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDIgKyB0KTtcbiAgICB9IGVsc2UgaWYgKHpWYWwpIHtcbiAgICAgIHpWYWwuY29ubmVjdCh0aGlzLmxpc3RlbmVyLnVwWik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIudXBaLnZhbHVlO1xuICB9O1xuXG4gIHJldHVybiBwNS5MaXN0ZW5lcjNEO1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gIHZhciBGaWx0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxuICB2YXIgRWZmZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbiAgLyoqXG4gICAqICBEZWxheSBpcyBhbiBlY2hvIGVmZmVjdC4gSXQgcHJvY2Vzc2VzIGFuIGV4aXN0aW5nIHNvdW5kIHNvdXJjZSxcbiAgICogIGFuZCBvdXRwdXRzIGEgZGVsYXllZCB2ZXJzaW9uIG9mIHRoYXQgc291bmQuIFRoZSBwNS5EZWxheSBjYW5cbiAgICogIHByb2R1Y2UgZGlmZmVyZW50IGVmZmVjdHMgZGVwZW5kaW5nIG9uIHRoZSBkZWxheVRpbWUsIGZlZWRiYWNrLFxuICAgKiAgZmlsdGVyLCBhbmQgdHlwZS4gSW4gdGhlIGV4YW1wbGUgYmVsb3csIGEgZmVlZGJhY2sgb2YgMC41ICh0aGVcbiAgICogIGRlZmF1bHQgdmFsdWUpIHdpbGwgcHJvZHVjZSBhIGxvb3BpbmcgZGVsYXkgdGhhdCBkZWNyZWFzZXMgaW5cbiAgICogIHZvbHVtZSBieSA1MCUgZWFjaCByZXBlYXQuIEEgZmlsdGVyIHdpbGwgY3V0IG91dCB0aGUgaGlnaFxuICAgKiAgZnJlcXVlbmNpZXMgc28gdGhhdCB0aGUgZGVsYXkgZG9lcyBub3Qgc291bmQgYXMgcGllcmNpbmcgYXMgdGhlXG4gICAqICBvcmlnaW5hbCBzb3VyY2UuXG4gICAqXG4gICAqXG4gICAqICBUaGlzIGNsYXNzIGV4dGVuZHMgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdFwiPnA1LkVmZmVjdDwvYT4uXG4gICAqICBNZXRob2RzIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvYW1wXCI+YW1wKCk8L2E+LCA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2NoYWluXCI+Y2hhaW4oKTwvYT4sXG4gICAqICA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2RyeXdldFwiPmRyeXdldCgpPC9hPiwgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9jb25uZWN0XCI+Y29ubmVjdCgpPC9hPiwgYW5kXG4gICAqICA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2Rpc2Nvbm5lY3RcIj5kaXNjb25uZWN0KCk8L2E+IGFyZSBhdmFpbGFibGUuXG4gICAqICBAY2xhc3MgcDUuRGVsYXlcbiAgICogIEBleHRlbmRzIHA1LkVmZmVjdFxuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBvc2M7XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dEFsaWduKENFTlRFUik7XG4gICAqICAgIHRleHQoJ3RhcCB0byBwbGF5Jywgd2lkdGgvMiwgaGVpZ2h0LzIpO1xuICAgKlxuICAgKiAgICBvc2MgPSBuZXcgcDUuT3NjaWxsYXRvcignc3F1YXJlJyk7XG4gICAqICAgIG9zYy5hbXAoMC41KTtcbiAgICogICAgZGVsYXkgPSBuZXcgcDUuRGVsYXkoKTtcbiAgICpcbiAgICogICAgLy8gZGVsYXkucHJvY2VzcygpIGFjY2VwdHMgNCBwYXJhbWV0ZXJzOlxuICAgKiAgICAvLyBzb3VyY2UsIGRlbGF5VGltZSAoaW4gc2Vjb25kcyksIGZlZWRiYWNrLCBmaWx0ZXIgZnJlcXVlbmN5XG4gICAqICAgIGRlbGF5LnByb2Nlc3Mob3NjLCAwLjEyLCAuNywgMjMwMCk7XG4gICAqXG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQob3NjU3RhcnQpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gb3NjU3RhcnQoKSB7XG4gICAqICAgIG9zYy5zdGFydCgpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gbW91c2VSZWxlYXNlZCgpIHtcbiAgICogICAgb3NjLnN0b3AoKTtcbiAgICogIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5EZWxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICBFZmZlY3QuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9zcGxpdCA9IHRoaXMuYWMuY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKDIpO1xuICAgIHRoaXMuX21lcmdlID0gdGhpcy5hYy5jcmVhdGVDaGFubmVsTWVyZ2VyKDIpO1xuICAgIHRoaXMuX2xlZnRHYWluID0gdGhpcy5hYy5jcmVhdGVHYWluKCk7XG4gICAgdGhpcy5fcmlnaHRHYWluID0gdGhpcy5hYy5jcmVhdGVHYWluKCk7XG4gICAgLyoqXG4gICAgICogIFRoZSBwNS5EZWxheSBpcyBidWlsdCB3aXRoIHR3b1xuICAgICAqICA8YSBocmVmPVwiaHR0cDovL3d3dy53My5vcmcvVFIvd2ViYXVkaW8vI0RlbGF5Tm9kZVwiPlxuICAgICAqICBXZWIgQXVkaW8gRGVsYXkgTm9kZXM8L2E+LCBvbmUgZm9yIGVhY2ggc3RlcmVvIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiAgQGZvciBwNS5EZWxheVxuICAgICAqICBAcHJvcGVydHkge0RlbGF5Tm9kZX0gbGVmdERlbGF5XG4gICAgICovXG5cbiAgICB0aGlzLmxlZnREZWxheSA9IHRoaXMuYWMuY3JlYXRlRGVsYXkoKTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHA1LkRlbGF5IGlzIGJ1aWx0IHdpdGggdHdvXG4gICAgICogIDxhIGhyZWY9XCJodHRwOi8vd3d3LnczLm9yZy9UUi93ZWJhdWRpby8jRGVsYXlOb2RlXCI+XG4gICAgICogIFdlYiBBdWRpbyBEZWxheSBOb2RlczwvYT4sIG9uZSBmb3IgZWFjaCBzdGVyZW8gY2hhbm5lbC5cbiAgICAgKiAgQGZvciBwNS5EZWxheVxuICAgICAqICBAcHJvcGVydHkge0RlbGF5Tm9kZX0gcmlnaHREZWxheVxuICAgICAqL1xuXG4gICAgdGhpcy5yaWdodERlbGF5ID0gdGhpcy5hYy5jcmVhdGVEZWxheSgpO1xuICAgIHRoaXMuX2xlZnRGaWx0ZXIgPSBuZXcgRmlsdGVyKCk7XG4gICAgdGhpcy5fcmlnaHRGaWx0ZXIgPSBuZXcgRmlsdGVyKCk7XG5cbiAgICB0aGlzLl9sZWZ0RmlsdGVyLmRpc2Nvbm5lY3QoKTtcblxuICAgIHRoaXMuX3JpZ2h0RmlsdGVyLmRpc2Nvbm5lY3QoKTtcblxuICAgIHRoaXMuX2xlZnRGaWx0ZXIuYmlxdWFkLmZyZXF1ZW5jeS5zZXRWYWx1ZUF0VGltZSgxMjAwLCB0aGlzLmFjLmN1cnJlbnRUaW1lKTtcblxuICAgIHRoaXMuX3JpZ2h0RmlsdGVyLmJpcXVhZC5mcmVxdWVuY3kuc2V0VmFsdWVBdFRpbWUoMTIwMCwgdGhpcy5hYy5jdXJyZW50VGltZSk7XG5cbiAgICB0aGlzLl9sZWZ0RmlsdGVyLmJpcXVhZC5RLnNldFZhbHVlQXRUaW1lKDAuMywgdGhpcy5hYy5jdXJyZW50VGltZSk7XG5cbiAgICB0aGlzLl9yaWdodEZpbHRlci5iaXF1YWQuUS5zZXRWYWx1ZUF0VGltZSgwLjMsIHRoaXMuYWMuY3VycmVudFRpbWUpOyBcblxuXG4gICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuX3NwbGl0KTtcbiAgICB0aGlzLmxlZnREZWxheS5jb25uZWN0KHRoaXMuX2xlZnRHYWluKTtcbiAgICB0aGlzLnJpZ2h0RGVsYXkuY29ubmVjdCh0aGlzLl9yaWdodEdhaW4pO1xuXG4gICAgdGhpcy5fbGVmdEdhaW4uY29ubmVjdCh0aGlzLl9sZWZ0RmlsdGVyLmlucHV0KTtcblxuICAgIHRoaXMuX3JpZ2h0R2Fpbi5jb25uZWN0KHRoaXMuX3JpZ2h0RmlsdGVyLmlucHV0KTtcblxuICAgIHRoaXMuX21lcmdlLmNvbm5lY3QodGhpcy53ZXQpO1xuXG4gICAgdGhpcy5fbGVmdEZpbHRlci5iaXF1YWQuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgxLCB0aGlzLmFjLmN1cnJlbnRUaW1lKTtcblxuICAgIHRoaXMuX3JpZ2h0RmlsdGVyLmJpcXVhZC5nYWluLnNldFZhbHVlQXRUaW1lKDEsIHRoaXMuYWMuY3VycmVudFRpbWUpOyBcblxuXG4gICAgdGhpcy5zZXRUeXBlKDApO1xuICAgIHRoaXMuX21heERlbGF5ID0gdGhpcy5sZWZ0RGVsYXkuZGVsYXlUaW1lLm1heFZhbHVlOyBcblxuICAgIHRoaXMuZmVlZGJhY2soMC41KTtcbiAgfTtcblxuICBwNS5EZWxheS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVmZmVjdC5wcm90b3R5cGUpO1xuICAvKipcbiAgICogIEFkZCBkZWxheSB0byBhbiBhdWRpbyBzaWduYWwgYWNjb3JkaW5nIHRvIGEgc2V0XG4gICAqICBvZiBkZWxheSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgcHJvY2Vzc1xuICAgKiAgQGZvciBwNS5EZWxheVxuICAgKiAgQHBhcmFtICB7T2JqZWN0fSBTaWduYWwgIEFuIG9iamVjdCB0aGF0IG91dHB1dHMgYXVkaW9cbiAgICogIEBwYXJhbSAge051bWJlcn0gW2RlbGF5VGltZV0gVGltZSAoaW4gc2Vjb25kcykgb2YgdGhlIGRlbGF5L2VjaG8uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNvbWUgYnJvd3NlcnMgbGltaXQgZGVsYXlUaW1lIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEgc2Vjb25kLlxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbZmVlZGJhY2tdICBzZW5kcyB0aGUgZGVsYXkgYmFjayB0aHJvdWdoIGl0c2VsZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBhIGxvb3AgdGhhdCBkZWNyZWFzZXMgaW4gdm9sdW1lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2ggdGltZS5cbiAgICogIEBwYXJhbSAge051bWJlcn0gW2xvd1Bhc3NdICAgQ3V0b2ZmIGZyZXF1ZW5jeS4gT25seSBmcmVxdWVuY2llc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWxvdyB0aGUgbG93UGFzcyB3aWxsIGJlIHBhcnQgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5LlxuICAgKi9cblxuICBwNS5EZWxheS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChzcmMsIF9kZWxheVRpbWUsIF9mZWVkYmFjaywgX2ZpbHRlcikge1xuICAgIHZhciBmZWVkYmFjayA9IF9mZWVkYmFjayB8fCAwO1xuICAgIHZhciBkZWxheVRpbWUgPSBfZGVsYXlUaW1lIHx8IDA7XG5cbiAgICBpZiAoZmVlZGJhY2sgPj0gMS4wKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZlZWRiYWNrIHZhbHVlIHdpbGwgZm9yY2UgYSBwb3NpdGl2ZSBmZWVkYmFjayBsb29wLicpO1xuICAgIH1cblxuICAgIGlmIChkZWxheVRpbWUgPj0gdGhpcy5fbWF4RGVsYXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGVsYXkgVGltZSBleGNlZWRzIG1heGltdW0gZGVsYXkgdGltZSBvZiAnICsgdGhpcy5fbWF4RGVsYXkgKyAnIHNlY29uZC4nKTtcbiAgICB9XG5cbiAgICBzcmMuY29ubmVjdCh0aGlzLmlucHV0KTtcbiAgICB0aGlzLmxlZnREZWxheS5kZWxheVRpbWUuc2V0VmFsdWVBdFRpbWUoZGVsYXlUaW1lLCB0aGlzLmFjLmN1cnJlbnRUaW1lKTtcbiAgICB0aGlzLnJpZ2h0RGVsYXkuZGVsYXlUaW1lLnNldFZhbHVlQXRUaW1lKGRlbGF5VGltZSwgdGhpcy5hYy5jdXJyZW50VGltZSk7XG4gICAgdGhpcy5fbGVmdEdhaW4uZ2Fpbi52YWx1ZSA9IGZlZWRiYWNrO1xuICAgIHRoaXMuX3JpZ2h0R2Fpbi5nYWluLnZhbHVlID0gZmVlZGJhY2s7XG5cbiAgICBpZiAoX2ZpbHRlcikge1xuICAgICAgdGhpcy5fbGVmdEZpbHRlci5mcmVxKF9maWx0ZXIpO1xuXG4gICAgICB0aGlzLl9yaWdodEZpbHRlci5mcmVxKF9maWx0ZXIpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBTZXQgdGhlIGRlbGF5IChlY2hvKSB0aW1lLCBpbiBzZWNvbmRzLiBVc3VhbGx5IHRoaXMgdmFsdWUgd2lsbCBiZVxuICAgKiAgYSBmbG9hdGluZyBwb2ludCBudW1iZXIgYmV0d2VlbiAwLjAgYW5kIDEuMC5cbiAgICpcbiAgICogIEBtZXRob2QgIGRlbGF5VGltZVxuICAgKiAgQGZvciBwNS5EZWxheVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IGRlbGF5VGltZSBUaW1lIChpbiBzZWNvbmRzKSBvZiB0aGUgZGVsYXlcbiAgICovXG5cblxuICBwNS5EZWxheS5wcm90b3R5cGUuZGVsYXlUaW1lID0gZnVuY3Rpb24gKHQpIHtcbiAgICBpZiAodHlwZW9mIHQgIT09ICdudW1iZXInKSB7XG4gICAgICB0LmNvbm5lY3QodGhpcy5sZWZ0RGVsYXkuZGVsYXlUaW1lKTtcbiAgICAgIHQuY29ubmVjdCh0aGlzLnJpZ2h0RGVsYXkuZGVsYXlUaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sZWZ0RGVsYXkuZGVsYXlUaW1lLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLmFjLmN1cnJlbnRUaW1lKTtcbiAgICAgIHRoaXMucmlnaHREZWxheS5kZWxheVRpbWUuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuYWMuY3VycmVudFRpbWUpO1xuICAgICAgdGhpcy5sZWZ0RGVsYXkuZGVsYXlUaW1lLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHQsIHRoaXMuYWMuY3VycmVudFRpbWUpO1xuICAgICAgdGhpcy5yaWdodERlbGF5LmRlbGF5VGltZS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0LCB0aGlzLmFjLmN1cnJlbnRUaW1lKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgRmVlZGJhY2sgb2NjdXJzIHdoZW4gRGVsYXkgc2VuZHMgaXRzIHNpZ25hbCBiYWNrIHRocm91Z2ggaXRzIGlucHV0XG4gICAqICBpbiBhIGxvb3AuIFRoZSBmZWVkYmFjayBhbW91bnQgZGV0ZXJtaW5lcyBob3cgbXVjaCBzaWduYWwgdG8gc2VuZCBlYWNoXG4gICAqICB0aW1lIHRocm91Z2ggdGhlIGxvb3AuIEEgZmVlZGJhY2sgZ3JlYXRlciB0aGFuIDEuMCBpcyBub3QgZGVzaXJhYmxlIGJlY2F1c2VcbiAgICogIGl0IHdpbGwgaW5jcmVhc2UgdGhlIG92ZXJhbGwgb3V0cHV0IGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLFxuICAgKiAgY3JlYXRpbmcgYW4gaW5maW5pdGUgZmVlZGJhY2sgbG9vcC4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMC41XG4gICAqXG4gICAqICBAbWV0aG9kICBmZWVkYmFja1xuICAgKiAgQGZvciBwNS5EZWxheVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBmZWVkYmFjayAwLjAgdG8gMS4wLCBvciBhbiBvYmplY3Qgc3VjaCBhcyBhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPc2NpbGxhdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxhdGUgdGhpcyBwYXJhbVxuICAgKiAgQHJldHVybnMge051bWJlcn0gRmVlZGJhY2sgdmFsdWVcbiAgICpcbiAgICovXG5cblxuICBwNS5EZWxheS5wcm90b3R5cGUuZmVlZGJhY2sgPSBmdW5jdGlvbiAoZikge1xuICAgIGlmIChmICYmIHR5cGVvZiBmICE9PSAnbnVtYmVyJykge1xuICAgICAgZi5jb25uZWN0KHRoaXMuX2xlZnRHYWluLmdhaW4pO1xuICAgICAgZi5jb25uZWN0KHRoaXMuX3JpZ2h0R2Fpbi5nYWluKTtcbiAgICB9IGVsc2UgaWYgKGYgPj0gMS4wKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZlZWRiYWNrIHZhbHVlIHdpbGwgZm9yY2UgYSBwb3NpdGl2ZSBmZWVkYmFjayBsb29wLicpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGYgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLl9sZWZ0R2Fpbi5nYWluLnZhbHVlID0gZjtcbiAgICAgIHRoaXMuX3JpZ2h0R2Fpbi5nYWluLnZhbHVlID0gZjtcbiAgICB9IFxuXG5cbiAgICByZXR1cm4gdGhpcy5fbGVmdEdhaW4uZ2Fpbi52YWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqICBTZXQgYSBsb3dwYXNzIGZpbHRlciBmcmVxdWVuY3kgZm9yIHRoZSBkZWxheS4gQSBsb3dwYXNzIGZpbHRlclxuICAgKiAgd2lsbCBjdXQgb2ZmIGFueSBmcmVxdWVuY2llcyBoaWdoZXIgdGhhbiB0aGUgZmlsdGVyIGZyZXF1ZW5jeS5cbiAgICpcbiAgICogIEBtZXRob2QgIGZpbHRlclxuICAgKiAgQGZvciBwNS5EZWxheVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBjdXRvZmZGcmVxICBBIGxvd3Bhc3MgZmlsdGVyIHdpbGwgY3V0IG9mZiBhbnlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmVxdWVuY2llcyBoaWdoZXIgdGhhbiB0aGUgZmlsdGVyIGZyZXF1ZW5jeS5cbiAgICogIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gcmVzICBSZXNvbmFuY2Ugb2YgdGhlIGZpbHRlciBmcmVxdWVuY3lcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXRvZmYsIG9yIGFuIG9iamVjdCAoaS5lLiBhIHA1Lk9zY2lsbGF0b3IpXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCBjYW4gYmUgdXNlZCB0byBtb2R1bGF0ZSB0aGlzIHBhcmFtZXRlci5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIaWdoIG51bWJlcnMgKGkuZS4gMTUpIHdpbGwgcHJvZHVjZSBhIHJlc29uYW5jZSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3cgbnVtYmVycyAoaS5lLiAuMikgd2lsbCBwcm9kdWNlIGEgc2xvcGUuXG4gICAqL1xuXG5cbiAgcDUuRGVsYXkucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmcmVxLCBxKSB7XG4gICAgdGhpcy5fbGVmdEZpbHRlci5zZXQoZnJlcSwgcSk7XG5cbiAgICB0aGlzLl9yaWdodEZpbHRlci5zZXQoZnJlcSwgcSk7XG4gIH07XG4gIC8qKlxuICAgKiAgQ2hvb3NlIGEgcHJlc2V0IHR5cGUgb2YgZGVsYXkuICdwaW5nUG9uZycgYm91bmNlcyB0aGUgc2lnbmFsXG4gICAqICBmcm9tIHRoZSBsZWZ0IHRvIHRoZSByaWdodCBjaGFubmVsIHRvIHByb2R1Y2UgYSBzdGVyZW8gZWZmZWN0LlxuICAgKiAgQW55IG90aGVyIHBhcmFtZXRlciB3aWxsIHJldmVydCB0byB0aGUgZGVmYXVsdCBkZWxheSBzZXR0aW5nLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgc2V0VHlwZVxuICAgKiAgQGZvciBwNS5EZWxheVxuICAgKiAgQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB0eXBlICdwaW5nUG9uZycgKDEpIG9yICdkZWZhdWx0JyAoMClcbiAgICovXG5cblxuICBwNS5EZWxheS5wcm90b3R5cGUuc2V0VHlwZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgaWYgKHQgPT09IDEpIHtcbiAgICAgIHQgPSAncGluZ1BvbmcnO1xuICAgIH1cblxuICAgIHRoaXMuX3NwbGl0LmRpc2Nvbm5lY3QoKTtcblxuICAgIHRoaXMuX2xlZnRGaWx0ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgdGhpcy5fcmlnaHRGaWx0ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgdGhpcy5fc3BsaXQuY29ubmVjdCh0aGlzLmxlZnREZWxheSwgMCk7XG5cbiAgICB0aGlzLl9zcGxpdC5jb25uZWN0KHRoaXMucmlnaHREZWxheSwgMSk7XG5cbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIGNhc2UgJ3BpbmdQb25nJzpcbiAgICAgICAgdGhpcy5fcmlnaHRGaWx0ZXIuc2V0VHlwZSh0aGlzLl9sZWZ0RmlsdGVyLmJpcXVhZC50eXBlKTtcblxuICAgICAgICB0aGlzLl9sZWZ0RmlsdGVyLm91dHB1dC5jb25uZWN0KHRoaXMuX21lcmdlLCAwLCAwKTtcblxuICAgICAgICB0aGlzLl9yaWdodEZpbHRlci5vdXRwdXQuY29ubmVjdCh0aGlzLl9tZXJnZSwgMCwgMSk7XG5cbiAgICAgICAgdGhpcy5fbGVmdEZpbHRlci5vdXRwdXQuY29ubmVjdCh0aGlzLnJpZ2h0RGVsYXkpO1xuXG4gICAgICAgIHRoaXMuX3JpZ2h0RmlsdGVyLm91dHB1dC5jb25uZWN0KHRoaXMubGVmdERlbGF5KTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5fbGVmdEZpbHRlci5vdXRwdXQuY29ubmVjdCh0aGlzLl9tZXJnZSwgMCwgMCk7XG5cbiAgICAgICAgdGhpcy5fcmlnaHRGaWx0ZXIub3V0cHV0LmNvbm5lY3QodGhpcy5fbWVyZ2UsIDAsIDEpO1xuXG4gICAgICAgIHRoaXMuX2xlZnRGaWx0ZXIub3V0cHV0LmNvbm5lY3QodGhpcy5sZWZ0RGVsYXkpO1xuXG4gICAgICAgIHRoaXMuX3JpZ2h0RmlsdGVyLm91dHB1dC5jb25uZWN0KHRoaXMucmlnaHREZWxheSk7XG5cbiAgICB9XG4gIH07IFxuXG4gIC8qKlxuICAgKiAgU2V0IHRoZSBvdXRwdXQgbGV2ZWwgb2YgdGhlIGRlbGF5IGVmZmVjdC5cbiAgICpcbiAgICogIEBtZXRob2QgIGFtcFxuICAgKiAgQGZvciBwNS5EZWxheVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSB2b2x1bWUgYW1wbGl0dWRlIGJldHdlZW4gMCBhbmQgMS4wXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3JhbXBUaW1lXSBjcmVhdGUgYSBmYWRlIHRoYXQgbGFzdHMgcmFtcFRpbWVcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbdGltZUZyb21Ob3ddIHNjaGVkdWxlIHRoaXMgZXZlbnQgdG8gaGFwcGVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRzIGZyb20gbm93XG4gICAqL1xuXG4gIC8qKlxuICAgKiAgU2VuZCBvdXRwdXQgdG8gYSBwNS5zb3VuZCBvciB3ZWIgYXVkaW8gb2JqZWN0XG4gICAqXG4gICAqICBAbWV0aG9kICBjb25uZWN0XG4gICAqICBAZm9yIHA1LkRlbGF5XG4gICAqICBAcGFyYW0gIHtPYmplY3R9IHVuaXRcbiAgICovXG5cbiAgLyoqXG4gICAqICBEaXNjb25uZWN0IGFsbCBvdXRwdXQuXG4gICAqXG4gICAqICBAbWV0aG9kIGRpc2Nvbm5lY3RcbiAgICogIEBmb3IgcDUuRGVsYXlcbiAgICovXG5cblxuICBwNS5EZWxheS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBFZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuYXBwbHkodGhpcyk7XG5cbiAgICB0aGlzLl9zcGxpdC5kaXNjb25uZWN0KCk7XG5cbiAgICB0aGlzLl9sZWZ0RmlsdGVyLmRpc3Bvc2UoKTtcblxuICAgIHRoaXMuX3JpZ2h0RmlsdGVyLmRpc3Bvc2UoKTtcblxuICAgIHRoaXMuX21lcmdlLmRpc2Nvbm5lY3QoKTtcblxuICAgIHRoaXMuX2xlZnRHYWluLmRpc2Nvbm5lY3QoKTtcblxuICAgIHRoaXMuX3JpZ2h0R2Fpbi5kaXNjb25uZWN0KCk7XG5cbiAgICB0aGlzLmxlZnREZWxheS5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5yaWdodERlbGF5LmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLl9zcGxpdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9sZWZ0RmlsdGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JpZ2h0RmlsdGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21lcmdlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2xlZnRHYWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JpZ2h0R2FpbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnREZWxheSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0RGVsYXkgPSB1bmRlZmluZWQ7XG4gIH07XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgdmFyIEN1c3RvbUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbiAgdmFyIEVmZmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG4gIC8qKlxuICAgKiAgUmV2ZXJiIGFkZHMgZGVwdGggdG8gYSBzb3VuZCB0aHJvdWdoIGEgbGFyZ2UgbnVtYmVyIG9mIGRlY2F5aW5nXG4gICAqICBlY2hvZXMuIEl0IGNyZWF0ZXMgdGhlIHBlcmNlcHRpb24gdGhhdCBzb3VuZCBpcyBvY2N1cnJpbmcgaW4gYVxuICAgKiAgcGh5c2ljYWwgc3BhY2UuIFRoZSBwNS5SZXZlcmIgaGFzIHBhcmFtdGVycyBmb3IgVGltZSAoaG93IGxvbmcgZG9lcyB0aGVcbiAgICogIHJldmVyYiBsYXN0KSBhbmQgZGVjYXlSYXRlIChob3cgbXVjaCB0aGUgc291bmQgZGVjYXlzIHdpdGggZWFjaCBlY2hvKVxuICAgKiAgdGhhdCBjYW4gYmUgc2V0IHdpdGggdGhlIC5zZXQoKSBvciAucHJvY2VzcygpIG1ldGhvZHMuIFRoZSBwNS5Db252b2x2ZXJcbiAgICogIGV4dGVuZHMgcDUuUmV2ZXJiIGFsbG93aW5nIHlvdSB0byByZWNyZWF0ZSB0aGUgc291bmQgb2YgYWN0dWFsIHBoeXNpY2FsXG4gICAqICBzcGFjZXMgdGhyb3VnaCBjb252b2x1dGlvbi5cbiAgICpcbiAgICogIFRoaXMgY2xhc3MgZXh0ZW5kcyA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0XCI+cDUuRWZmZWN0PC9hPi5cbiAgICogIE1ldGhvZHMgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9hbXBcIj5hbXAoKTwvYT4sIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvY2hhaW5cIj5jaGFpbigpPC9hPixcbiAgICogIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvZHJ5d2V0XCI+ZHJ5d2V0KCk8L2E+LCA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2Nvbm5lY3RcIj5jb25uZWN0KCk8L2E+LCBhbmRcbiAgICogIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvZGlzY29ubmVjdFwiPmRpc2Nvbm5lY3QoKTwvYT4gYXJlIGF2YWlsYWJsZS5cbiAgICpcbiAgICogIEBjbGFzcyBwNS5SZXZlcmJcbiAgICogIEBleHRlbmRzIHA1LkVmZmVjdFxuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBzb3VuZEZpbGUsIHJldmVyYjtcbiAgICogIGZ1bmN0aW9uIHByZWxvYWQoKSB7XG4gICAqICAgIHNvdW5kRmlsZSA9IGxvYWRTb3VuZCgnYXNzZXRzL0RhbXNjcmF5X0RhbmNpbmdUaWdlci5tcDMnKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChwbGF5U291bmQpO1xuICAgKlxuICAgKiAgICByZXZlcmIgPSBuZXcgcDUuUmV2ZXJiKCk7XG4gICAqICAgIHNvdW5kRmlsZS5kaXNjb25uZWN0KCk7IC8vIHNvIHdlJ2xsIG9ubHkgaGVhciByZXZlcmIuLi5cbiAgICpcbiAgICogICAgLy8gY29ubmVjdCBzb3VuZEZpbGUgdG8gcmV2ZXJiLCBwcm9jZXNzIHcvXG4gICAqICAgIC8vIDMgc2Vjb25kIHJldmVyYlRpbWUsIGRlY2F5UmF0ZSBvZiAyJVxuICAgKiAgICByZXZlcmIucHJvY2Vzcyhzb3VuZEZpbGUsIDMsIDIpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gZHJhdygpIHtcbiAgICogICAgbGV0IGRyeVdldCA9IGNvbnN0cmFpbihtYXAobW91c2VYLCAwLCB3aWR0aCwgMCwgMSksIDAsIDEpO1xuICAgKiAgICAvLyAxID0gYWxsIHJldmVyYiwgMCA9IG5vIHJldmVyYlxuICAgKiAgICByZXZlcmIuZHJ5d2V0KGRyeVdldCk7XG4gICAqXG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCAxMCwgMjApO1xuICAgKiAgICB0ZXh0KCdkcnkvd2V0OiAnICsgcm91bmQoZHJ5V2V0ICogMTAwKSArICclJywgMTAsIGhlaWdodCAtIDIwKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHBsYXlTb3VuZCgpIHtcbiAgICogICAgc291bmRGaWxlLnBsYXkoKTtcbiAgICogIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5SZXZlcmIgPSBmdW5jdGlvbiAoKSB7XG4gICAgRWZmZWN0LmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9pbml0Q29udm9sdmVyTm9kZSgpOyBcblxuXG4gICAgdGhpcy5pbnB1dC5nYWluLnZhbHVlID0gMC41OyBcblxuICAgIHRoaXMuX3NlY29uZHMgPSAzO1xuICAgIHRoaXMuX2RlY2F5ID0gMjtcbiAgICB0aGlzLl9yZXZlcnNlID0gZmFsc2U7XG5cbiAgICB0aGlzLl9idWlsZEltcHVsc2UoKTtcbiAgfTtcblxuICBwNS5SZXZlcmIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFZmZlY3QucHJvdG90eXBlKTtcblxuICBwNS5SZXZlcmIucHJvdG90eXBlLl9pbml0Q29udm9sdmVyTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbnZvbHZlck5vZGUgPSB0aGlzLmFjLmNyZWF0ZUNvbnZvbHZlcigpO1xuICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLmNvbnZvbHZlck5vZGUpO1xuICAgIHRoaXMuY29udm9sdmVyTm9kZS5jb25uZWN0KHRoaXMud2V0KTtcbiAgfTtcblxuICBwNS5SZXZlcmIucHJvdG90eXBlLl90ZWFyZG93bkNvbnZvbHZlck5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY29udm9sdmVyTm9kZSkge1xuICAgICAgdGhpcy5jb252b2x2ZXJOb2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbnZvbHZlck5vZGU7XG4gICAgfVxuICB9O1xuXG4gIHA1LlJldmVyYi5wcm90b3R5cGUuX3NldEJ1ZmZlciA9IGZ1bmN0aW9uIChhdWRpb0J1ZmZlcikge1xuICAgIHRoaXMuX3RlYXJkb3duQ29udm9sdmVyTm9kZSgpO1xuXG4gICAgdGhpcy5faW5pdENvbnZvbHZlck5vZGUoKTtcblxuICAgIHRoaXMuY29udm9sdmVyTm9kZS5idWZmZXIgPSBhdWRpb0J1ZmZlcjtcbiAgfTtcbiAgLyoqXG4gICAqICBDb25uZWN0IGEgc291cmNlIHRvIHRoZSByZXZlcmIsIGFuZCBhc3NpZ24gcmV2ZXJiIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqICBAbWV0aG9kICBwcm9jZXNzXG4gICAqICBAZm9yIHA1LlJldmVyYlxuICAgKiAgQHBhcmFtICB7T2JqZWN0fSBzcmMgICAgIHA1LnNvdW5kIC8gV2ViIEF1ZGlvIG9iamVjdCB3aXRoIGEgc291bmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFtzZWNvbmRzXSBEdXJhdGlvbiBvZiB0aGUgcmV2ZXJiLCBpbiBzZWNvbmRzLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE1pbjogMCwgTWF4OiAxMC4gRGVmYXVsdHMgdG8gMy5cbiAgICogIEBwYXJhbSAge051bWJlcn0gW2RlY2F5UmF0ZV0gUGVyY2VudGFnZSBvZiBkZWNheSB3aXRoIGVhY2ggZWNoby5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgTWluOiAwLCBNYXg6IDEwMC4gRGVmYXVsdHMgdG8gMi5cbiAgICogIEBwYXJhbSAge0Jvb2xlYW59IFtyZXZlcnNlXSBQbGF5IHRoZSByZXZlcmIgYmFja3dhcmRzIG9yIGZvcndhcmRzLlxuICAgKi9cblxuXG4gIHA1LlJldmVyYi5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChzcmMsIHNlY29uZHMsIGRlY2F5UmF0ZSwgcmV2ZXJzZSkge1xuICAgIHNyYy5jb25uZWN0KHRoaXMuaW5wdXQpO1xuICAgIHZhciByZWJ1aWxkID0gZmFsc2U7XG5cbiAgICBpZiAoc2Vjb25kcykge1xuICAgICAgdGhpcy5fc2Vjb25kcyA9IHNlY29uZHM7XG4gICAgICByZWJ1aWxkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZGVjYXlSYXRlKSB7XG4gICAgICB0aGlzLl9kZWNheSA9IGRlY2F5UmF0ZTtcbiAgICB9XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgdGhpcy5fcmV2ZXJzZSA9IHJldmVyc2U7XG4gICAgfVxuXG4gICAgaWYgKHJlYnVpbGQpIHtcbiAgICAgIHRoaXMuX2J1aWxkSW1wdWxzZSgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBTZXQgdGhlIHJldmVyYiBzZXR0aW5ncy4gU2ltaWxhciB0byAucHJvY2VzcygpLCBidXQgd2l0aG91dFxuICAgKiAgYXNzaWduaW5nIGEgbmV3IGlucHV0LlxuICAgKlxuICAgKiAgQG1ldGhvZCAgc2V0XG4gICAqICBAZm9yIHA1LlJldmVyYlxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbc2Vjb25kc10gRHVyYXRpb24gb2YgdGhlIHJldmVyYiwgaW4gc2Vjb25kcy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBNaW46IDAsIE1heDogMTAuIERlZmF1bHRzIHRvIDMuXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFtkZWNheVJhdGVdIFBlcmNlbnRhZ2Ugb2YgZGVjYXkgd2l0aCBlYWNoIGVjaG8uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1pbjogMCwgTWF4OiAxMDAuIERlZmF1bHRzIHRvIDIuXG4gICAqICBAcGFyYW0gIHtCb29sZWFufSBbcmV2ZXJzZV0gUGxheSB0aGUgcmV2ZXJiIGJhY2t3YXJkcyBvciBmb3J3YXJkcy5cbiAgICovXG5cblxuICBwNS5SZXZlcmIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChzZWNvbmRzLCBkZWNheVJhdGUsIHJldmVyc2UpIHtcbiAgICB2YXIgcmVidWlsZCA9IGZhbHNlO1xuXG4gICAgaWYgKHNlY29uZHMpIHtcbiAgICAgIHRoaXMuX3NlY29uZHMgPSBzZWNvbmRzO1xuICAgICAgcmVidWlsZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGRlY2F5UmF0ZSkge1xuICAgICAgdGhpcy5fZGVjYXkgPSBkZWNheVJhdGU7XG4gICAgfVxuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHRoaXMuX3JldmVyc2UgPSByZXZlcnNlO1xuICAgIH1cblxuICAgIGlmIChyZWJ1aWxkKSB7XG4gICAgICB0aGlzLl9idWlsZEltcHVsc2UoKTtcbiAgICB9XG4gIH07IFxuXG4gIC8qKlxuICAgKiAgU2V0IHRoZSBvdXRwdXQgbGV2ZWwgb2YgdGhlIHJldmVyYiBlZmZlY3QuXG4gICAqXG4gICAqICBAbWV0aG9kICBhbXBcbiAgICogIEBmb3IgcDUuUmV2ZXJiXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IHZvbHVtZSBhbXBsaXR1ZGUgYmV0d2VlbiAwIGFuZCAxLjBcbiAgICogIEBwYXJhbSAge051bWJlcn0gW3JhbXBUaW1lXSBjcmVhdGUgYSBmYWRlIHRoYXQgbGFzdHMgcmFtcFRpbWVcbiAgICogIEBwYXJhbSAge051bWJlcn0gW3RpbWVGcm9tTm93XSBzY2hlZHVsZSB0aGlzIGV2ZW50IHRvIGhhcHBlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyBmcm9tIG5vd1xuICAgKi9cblxuICAvKipcbiAgICogIFNlbmQgb3V0cHV0IHRvIGEgcDUuc291bmQgb3Igd2ViIGF1ZGlvIG9iamVjdFxuICAgKlxuICAgKiAgQG1ldGhvZCAgY29ubmVjdFxuICAgKiAgQGZvciBwNS5SZXZlcmJcbiAgICogIEBwYXJhbSAge09iamVjdH0gdW5pdFxuICAgKi9cblxuICAvKipcbiAgICogIERpc2Nvbm5lY3QgYWxsIG91dHB1dC5cbiAgICpcbiAgICogIEBtZXRob2QgZGlzY29ubmVjdFxuICAgKiAgQGZvciBwNS5SZXZlcmJcbiAgICovXG5cbiAgLyoqXG4gICAqICBJbnNwaXJlZCBieSBTaW1wbGUgUmV2ZXJiIGJ5IEpvcmRhbiBTYW50ZWxsXG4gICAqICBodHRwczovL2dpdGh1Yi5jb20vd2ViLWF1ZGlvLWNvbXBvbmVudHMvc2ltcGxlLXJldmVyYi9ibG9iL21hc3Rlci9pbmRleC5qc1xuICAgKlxuICAgKiAgVXRpbGl0eSBmdW5jdGlvbiBmb3IgYnVpbGRpbmcgYW4gaW1wdWxzZSByZXNwb25zZVxuICAgKiAgYmFzZWQgb24gdGhlIG1vZHVsZSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiAgQHByaXZhdGVcbiAgICovXG5cblxuICBwNS5SZXZlcmIucHJvdG90eXBlLl9idWlsZEltcHVsc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJhdGUgPSB0aGlzLmFjLnNhbXBsZVJhdGU7XG4gICAgdmFyIGxlbmd0aCA9IHJhdGUgKiB0aGlzLl9zZWNvbmRzO1xuICAgIHZhciBkZWNheSA9IHRoaXMuX2RlY2F5O1xuICAgIHZhciBpbXB1bHNlID0gdGhpcy5hYy5jcmVhdGVCdWZmZXIoMiwgbGVuZ3RoLCByYXRlKTtcbiAgICB2YXIgaW1wdWxzZUwgPSBpbXB1bHNlLmdldENoYW5uZWxEYXRhKDApO1xuICAgIHZhciBpbXB1bHNlUiA9IGltcHVsc2UuZ2V0Q2hhbm5lbERhdGEoMSk7XG4gICAgdmFyIG4sIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gPSB0aGlzLl9yZXZlcnNlID8gbGVuZ3RoIC0gaSA6IGk7XG4gICAgICBpbXB1bHNlTFtpXSA9IChNYXRoLnJhbmRvbSgpICogMiAtIDEpICogTWF0aC5wb3coMSAtIG4gLyBsZW5ndGgsIGRlY2F5KTtcbiAgICAgIGltcHVsc2VSW2ldID0gKE1hdGgucmFuZG9tKCkgKiAyIC0gMSkgKiBNYXRoLnBvdygxIC0gbiAvIGxlbmd0aCwgZGVjYXkpO1xuICAgIH1cblxuICAgIHRoaXMuX3NldEJ1ZmZlcihpbXB1bHNlKTtcbiAgfTtcblxuICBwNS5SZXZlcmIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmFwcGx5KHRoaXMpO1xuXG4gICAgdGhpcy5fdGVhcmRvd25Db252b2x2ZXJOb2RlKCk7XG4gIH07IFxuXG4gIC8qKlxuICAgKiAgPHA+cDUuQ29udm9sdmVyIGV4dGVuZHMgcDUuUmV2ZXJiLiBJdCBjYW4gZW11bGF0ZSB0aGUgc291bmQgb2YgcmVhbFxuICAgKiAgcGh5c2ljYWwgc3BhY2VzIHRocm91Z2ggYSBwcm9jZXNzIGNhbGxlZCA8YSBocmVmPVwiXG4gICAqICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db252b2x1dGlvbl9yZXZlcmIjUmVhbF9zcGFjZV9zaW11bGF0aW9uXCI+XG4gICAqICBjb252b2x1dGlvbjwvYT4uPC9wPlxuICAgKlxuICAgKiAgPHA+Q29udm9sdXRpb24gbXVsdGlwbGllcyBhbnkgYXVkaW8gaW5wdXQgYnkgYW4gXCJpbXB1bHNlIHJlc3BvbnNlXCJcbiAgICogIHRvIHNpbXVsYXRlIHRoZSBkaXNwZXJzaW9uIG9mIHNvdW5kIG92ZXIgdGltZS4gVGhlIGltcHVsc2UgcmVzcG9uc2UgaXNcbiAgICogIGdlbmVyYXRlZCBmcm9tIGFuIGF1ZGlvIGZpbGUgdGhhdCB5b3UgcHJvdmlkZS4gT25lIHdheSB0b1xuICAgKiAgZ2VuZXJhdGUgYW4gaW1wdWxzZSByZXNwb25zZSBpcyB0byBwb3AgYSBiYWxsb29uIGluIGEgcmV2ZXJiZXJhbnQgc3BhY2VcbiAgICogIGFuZCByZWNvcmQgdGhlIGVjaG8uIENvbnZvbHV0aW9uIGNhbiBhbHNvIGJlIHVzZWQgdG8gZXhwZXJpbWVudCB3aXRoXG4gICAqICBzb3VuZC48L3A+XG4gICAqXG4gICAqICA8cD5Vc2UgdGhlIG1ldGhvZCA8Y29kZT5jcmVhdGVDb252b2x1dGlvbihwYXRoKTwvY29kZT4gdG8gaW5zdGFudGlhdGUgYVxuICAgKiAgcDUuQ29udm9sdmVyIHdpdGggYSBwYXRoIHRvIHlvdXIgaW1wdWxzZSByZXNwb25zZSBhdWRpbyBmaWxlLjwvcD5cbiAgICpcbiAgICogIEBjbGFzcyBwNS5Db252b2x2ZXJcbiAgICogIEBleHRlbmRzIHA1LkVmZmVjdFxuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAcGFyYW0gIHtTdHJpbmd9ICAgcGF0aCAgICAgcGF0aCB0byBhIHNvdW5kIGZpbGVcbiAgICogIEBwYXJhbSAge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBsb2FkaW5nIHN1Y2NlZWRzXG4gICAqICBAcGFyYW0gIHtGdW5jdGlvbn0gW2Vycm9yQ2FsbGJhY2tdIGZ1bmN0aW9uIHRvIGNhbGwgaWYgbG9hZGluZyBmYWlscy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgYW4gZXJyb3Igb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0IHdpdGggaW5mb3JtYXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvdXQgd2hhdCB3ZW50IHdyb25nLlxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgY1ZlcmIsIHNvdW5kO1xuICAgKiAgZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICogICAgLy8gV2UgaGF2ZSBib3RoIE1QMyBhbmQgT0dHIHZlcnNpb25zIG9mIGFsbCBzb3VuZCBhc3NldHNcbiAgICogICAgc291bmRGb3JtYXRzKCdvZ2cnLCAnbXAzJyk7XG4gICAqXG4gICAqICAgIC8vIFRyeSByZXBsYWNpbmcgJ2J4LXNwcmluZycgd2l0aCBvdGhlciBzb3VuZGZpbGVzIGxpa2VcbiAgICogICAgLy8gJ2NvbmNyZXRlLXR1bm5lbCcgJ3NtYWxsLXBsYXRlJyAnZHJ1bScgJ2JlYXRib3gnXG4gICAqICAgIGNWZXJiID0gY3JlYXRlQ29udm9sdmVyKCdhc3NldHMvYngtc3ByaW5nLm1wMycpO1xuICAgKlxuICAgKiAgICAvLyBUcnkgcmVwbGFjaW5nICdEYW1zY3JheV9EYW5jaW5nVGlnZXInIHdpdGhcbiAgICogICAgLy8gJ2JlYXQnLCAnZG9vcmJlbGwnLCBsdWNreV9kcmFnb25zXy1fcG93ZXJfbWVsb2R5J1xuICAgKiAgICBzb3VuZCA9IGxvYWRTb3VuZCgnYXNzZXRzL0RhbXNjcmF5X0RhbmNpbmdUaWdlci5tcDMnKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChwbGF5U291bmQpO1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ3RhcCB0byBwbGF5JywgMjAsIDIwKTtcbiAgICpcbiAgICogICAgLy8gZGlzY29ubmVjdCBmcm9tIG1hc3RlciBvdXRwdXQuLi5cbiAgICogICAgc291bmQuZGlzY29ubmVjdCgpO1xuICAgKlxuICAgKiAgICAvLyAuLi5hbmQgcHJvY2VzcyB3aXRoIGNWZXJiXG4gICAqICAgIC8vIHNvIHRoYXQgd2Ugb25seSBoZWFyIHRoZSBjb252b2x1dGlvblxuICAgKiAgICBjVmVyYi5wcm9jZXNzKHNvdW5kKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHBsYXlTb3VuZCgpIHtcbiAgICogICAgc291bmQucGxheSgpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LkNvbnZvbHZlciA9IGZ1bmN0aW9uIChwYXRoLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgIHA1LlJldmVyYi5jYWxsKHRoaXMpO1xuICAgIC8qKlxuICAgICAqICBJbnRlcm5hbGx5LCB0aGUgcDUuQ29udm9sdmVyIHVzZXMgdGhlIGFcbiAgICAgKiAgPGEgaHJlZj1cImh0dHA6Ly93d3cudzMub3JnL1RSL3dlYmF1ZGlvLyNDb252b2x2ZXJOb2RlXCI+XG4gICAgICogIFdlYiBBdWRpbyBDb252b2x2ZXIgTm9kZTwvYT4uXG4gICAgICpcbiAgICAgKiAgQHByb3BlcnR5IHtDb252b2x2ZXJOb2RlfSBjb252b2x2ZXJOb2RlXG4gICAgICovXG5cbiAgICB0aGlzLl9pbml0Q29udm9sdmVyTm9kZSgpOyBcblxuXG4gICAgdGhpcy5pbnB1dC5nYWluLnZhbHVlID0gMC41O1xuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHRoaXMuaW1wdWxzZXMgPSBbXTtcblxuICAgICAgdGhpcy5fbG9hZEJ1ZmZlcihwYXRoLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NlY29uZHMgPSAzO1xuICAgICAgdGhpcy5fZGVjYXkgPSAyO1xuICAgICAgdGhpcy5fcmV2ZXJzZSA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl9idWlsZEltcHVsc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgcDUuQ29udm9sdmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocDUuUmV2ZXJiLnByb3RvdHlwZSk7XG4gIHA1LnByb3RvdHlwZS5yZWdpc3RlclByZWxvYWRNZXRob2QoJ2NyZWF0ZUNvbnZvbHZlcicsIHA1LnByb3RvdHlwZSk7XG4gIC8qKlxuICAgKiAgQ3JlYXRlIGEgcDUuQ29udm9sdmVyLiBBY2NlcHRzIGEgcGF0aCB0byBhIHNvdW5kZmlsZVxuICAgKiAgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZ2VuZXJhdGUgYW4gaW1wdWxzZSByZXNwb25zZS5cbiAgICpcbiAgICogIEBtZXRob2QgIGNyZWF0ZUNvbnZvbHZlclxuICAgKiAgQGZvciBwNVxuICAgKiAgQHBhcmFtICB7U3RyaW5nfSAgIHBhdGggICAgIHBhdGggdG8gYSBzb3VuZCBmaWxlXG4gICAqICBAcGFyYW0gIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBmdW5jdGlvbiB0byBjYWxsIGlmIGxvYWRpbmcgaXMgc3VjY2Vzc2Z1bC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgaW4gYXMgdGhlIGFyZ3VtZW50XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqICBAcGFyYW0gIHtGdW5jdGlvbn0gW2Vycm9yQ2FsbGJhY2tdIGZ1bmN0aW9uIHRvIGNhbGwgaWYgbG9hZGluZyBpcyBub3Qgc3VjY2Vzc2Z1bC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgY3VzdG9tIGVycm9yIHdpbGwgYmUgcGFzc2VkIGluIGFzIHRoZSBhcmd1bWVudFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiAgQHJldHVybiB7cDUuQ29udm9sdmVyfVxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgY1ZlcmIsIHNvdW5kO1xuICAgKiAgZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICogICAgLy8gV2UgaGF2ZSBib3RoIE1QMyBhbmQgT0dHIHZlcnNpb25zIG9mIGFsbCBzb3VuZCBhc3NldHNcbiAgICogICAgc291bmRGb3JtYXRzKCdvZ2cnLCAnbXAzJyk7XG4gICAqXG4gICAqICAgIC8vIFRyeSByZXBsYWNpbmcgJ2J4LXNwcmluZycgd2l0aCBvdGhlciBzb3VuZGZpbGVzIGxpa2VcbiAgICogICAgLy8gJ2NvbmNyZXRlLXR1bm5lbCcgJ3NtYWxsLXBsYXRlJyAnZHJ1bScgJ2JlYXRib3gnXG4gICAqICAgIGNWZXJiID0gY3JlYXRlQ29udm9sdmVyKCdhc3NldHMvYngtc3ByaW5nLm1wMycpO1xuICAgKlxuICAgKiAgICAvLyBUcnkgcmVwbGFjaW5nICdEYW1zY3JheV9EYW5jaW5nVGlnZXInIHdpdGhcbiAgICogICAgLy8gJ2JlYXQnLCAnZG9vcmJlbGwnLCBsdWNreV9kcmFnb25zXy1fcG93ZXJfbWVsb2R5J1xuICAgKiAgICBzb3VuZCA9IGxvYWRTb3VuZCgnYXNzZXRzL0RhbXNjcmF5X0RhbmNpbmdUaWdlci5tcDMnKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChwbGF5U291bmQpO1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ3RhcCB0byBwbGF5JywgMjAsIDIwKTtcbiAgICpcbiAgICogICAgLy8gZGlzY29ubmVjdCBmcm9tIG1hc3RlciBvdXRwdXQuLi5cbiAgICogICAgc291bmQuZGlzY29ubmVjdCgpO1xuICAgKlxuICAgKiAgICAvLyAuLi5hbmQgcHJvY2VzcyB3aXRoIGNWZXJiXG4gICAqICAgIC8vIHNvIHRoYXQgd2Ugb25seSBoZWFyIHRoZSBjb252b2x1dGlvblxuICAgKiAgICBjVmVyYi5wcm9jZXNzKHNvdW5kKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHBsYXlTb3VuZCgpIHtcbiAgICogICAgc291bmQucGxheSgpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuICBwNS5wcm90b3R5cGUuY3JlYXRlQ29udm9sdmVyID0gZnVuY3Rpb24gKHBhdGgsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4uaW5kZXhPZignZmlsZTovLycpID4gLTEgJiYgd2luZG93LmNvcmRvdmEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBhbGVydCgnVGhpcyBza2V0Y2ggbWF5IHJlcXVpcmUgYSBzZXJ2ZXIgdG8gbG9hZCBleHRlcm5hbCBmaWxlcy4gUGxlYXNlIHNlZSBodHRwOi8vYml0Lmx5LzFxY0lud1MnKTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNSZXZlcmIgPSBuZXcgcDUuQ29udm9sdmVyKHBhdGgsIGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2soYnVmZmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzZWxmLl9kZWNyZW1lbnRQcmVsb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHNlbGYuX2RlY3JlbWVudFByZWxvYWQoKTtcbiAgICAgIH1cbiAgICB9LCBlcnJvckNhbGxiYWNrKTtcbiAgICBjUmV2ZXJiLmltcHVsc2VzID0gW107XG4gICAgcmV0dXJuIGNSZXZlcmI7XG4gIH07XG4gIC8qKlxuICAgKiAgUHJpdmF0ZSBtZXRob2QgdG8gbG9hZCBhIGJ1ZmZlciBhcyBhbiBJbXB1bHNlIFJlc3BvbnNlLFxuICAgKiAgYXNzaWduIGl0IHRvIHRoZSBjb252b2x2ZXJOb2RlLCBhbmQgYWRkIHRvIHRoZSBBcnJheSBvZiAuaW1wdWxzZXMuXG4gICAqXG4gICAqICBAcGFyYW0gICB7U3RyaW5nfSAgIHBhdGhcbiAgICogIEBwYXJhbSAgIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogIEBwYXJhbSAgIHtGdW5jdGlvbn0gZXJyb3JDYWxsYmFja1xuICAgKiAgQHByaXZhdGVcbiAgICovXG5cblxuICBwNS5Db252b2x2ZXIucHJvdG90eXBlLl9sb2FkQnVmZmVyID0gZnVuY3Rpb24gKHBhdGgsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIHBhdGggPSBwNS5wcm90b3R5cGUuX2NoZWNrRmlsZUZvcm1hdHMocGF0aCk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVycm9yVHJhY2UgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICB2YXIgYWMgPSBwNS5wcm90b3R5cGUuZ2V0QXVkaW9Db250ZXh0KCk7XG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHBhdGgsIHRydWUpO1xuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcblxuICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgYWMuZGVjb2RlQXVkaW9EYXRhKHJlcXVlc3QucmVzcG9uc2UsIGZ1bmN0aW9uIChidWZmKSB7XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IHt9O1xuICAgICAgICAgIHZhciBjaHVua3MgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgICAgICAgYnVmZmVyLm5hbWUgPSBjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGJ1ZmZlci5hdWRpb0J1ZmZlciA9IGJ1ZmY7XG4gICAgICAgICAgc2VsZi5pbXB1bHNlcy5wdXNoKGJ1ZmZlcik7XG5cbiAgICAgICAgICBzZWxmLl9zZXRCdWZmZXIoYnVmZmVyLmF1ZGlvQnVmZmVyKTtcblxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soYnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBDdXN0b21FcnJvcignZGVjb2RlQXVkaW9EYXRhJywgZXJyb3JUcmFjZSwgc2VsZi51cmwpO1xuICAgICAgICAgIHZhciBtc2cgPSAnQXVkaW9Db250ZXh0IGVycm9yIGF0IGRlY29kZUF1ZGlvRGF0YSBmb3IgJyArIHNlbGYudXJsO1xuXG4gICAgICAgICAgaWYgKGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIGVyci5tc2cgPSBtc2c7XG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnICsgJ1xcbiBUaGUgZXJyb3Igc3RhY2sgdHJhY2UgaW5jbHVkZXM6IFxcbicgKyBlcnIuc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IFxuICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBDdXN0b21FcnJvcignbG9hZENvbnZvbHZlcicsIGVycm9yVHJhY2UsIHNlbGYudXJsKTtcbiAgICAgICAgICB2YXIgbXNnID0gJ1VuYWJsZSB0byBsb2FkICcgKyBzZWxmLnVybCArICcuIFRoZSByZXF1ZXN0IHN0YXR1cyB3YXM6ICcgKyByZXF1ZXN0LnN0YXR1cyArICcgKCcgKyByZXF1ZXN0LnN0YXR1c1RleHQgKyAnKSc7XG5cbiAgICAgICAgICBpZiAoZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBtc2c7XG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnICsgJ1xcbiBUaGUgZXJyb3Igc3RhY2sgdHJhY2UgaW5jbHVkZXM6IFxcbicgKyBlcnIuc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07IFxuXG5cbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEN1c3RvbUVycm9yKCdsb2FkQ29udm9sdmVyJywgZXJyb3JUcmFjZSwgc2VsZi51cmwpO1xuICAgICAgdmFyIG1zZyA9ICdUaGVyZSB3YXMgbm8gcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyIGF0ICcgKyBzZWxmLnVybCArICcuIENoZWNrIHRoZSB1cmwgYW5kIGludGVybmV0IGNvbm5lY3Rpdml0eS4nO1xuXG4gICAgICBpZiAoZXJyb3JDYWxsYmFjaykge1xuICAgICAgICBlcnIubWVzc2FnZSA9IG1zZztcbiAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cgKyAnXFxuIFRoZSBlcnJvciBzdGFjayB0cmFjZSBpbmNsdWRlczogXFxuJyArIGVyci5zdGFjayk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJlcXVlc3Quc2VuZCgpO1xuICB9O1xuXG4gIHA1LkNvbnZvbHZlci5wcm90b3R5cGUuc2V0ID0gbnVsbDtcbiAgLyoqXG4gICAqICBDb25uZWN0IGEgc291cmNlIHRvIHRoZSBjb252b2x2ZXIuXG4gICAqXG4gICAqICBAbWV0aG9kICBwcm9jZXNzXG4gICAqICBAZm9yIHA1LkNvbnZvbHZlclxuICAgKiAgQHBhcmFtICB7T2JqZWN0fSBzcmMgICAgIHA1LnNvdW5kIC8gV2ViIEF1ZGlvIG9iamVjdCB3aXRoIGEgc291bmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBjVmVyYiwgc291bmQ7XG4gICAqICBmdW5jdGlvbiBwcmVsb2FkKCkge1xuICAgKiAgICAvLyBXZSBoYXZlIGJvdGggTVAzIGFuZCBPR0cgdmVyc2lvbnMgb2YgYWxsIHNvdW5kIGFzc2V0c1xuICAgKiAgICBzb3VuZEZvcm1hdHMoJ29nZycsICdtcDMnKTtcbiAgICpcbiAgICogICAgLy8gVHJ5IHJlcGxhY2luZyAnYngtc3ByaW5nJyB3aXRoIG90aGVyIHNvdW5kZmlsZXMgbGlrZVxuICAgKiAgICAvLyAnY29uY3JldGUtdHVubmVsJyAnc21hbGwtcGxhdGUnICdkcnVtJyAnYmVhdGJveCdcbiAgICogICAgY1ZlcmIgPSBjcmVhdGVDb252b2x2ZXIoJ2Fzc2V0cy9ieC1zcHJpbmcubXAzJyk7XG4gICAqXG4gICAqICAgIC8vIFRyeSByZXBsYWNpbmcgJ0RhbXNjcmF5X0RhbmNpbmdUaWdlcicgd2l0aFxuICAgKiAgICAvLyAnYmVhdCcsICdkb29yYmVsbCcsIGx1Y2t5X2RyYWdvbnNfLV9wb3dlcl9tZWxvZHknXG4gICAqICAgIHNvdW5kID0gbG9hZFNvdW5kKCdhc3NldHMvRGFtc2NyYXlfRGFuY2luZ1RpZ2VyLm1wMycpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHBsYXlTb3VuZCk7XG4gICAqICAgIGJhY2tncm91bmQoMjIwKTtcbiAgICogICAgdGV4dCgndGFwIHRvIHBsYXknLCAyMCwgMjApO1xuICAgKlxuICAgKiAgICAvLyBkaXNjb25uZWN0IGZyb20gbWFzdGVyIG91dHB1dC4uLlxuICAgKiAgICBzb3VuZC5kaXNjb25uZWN0KCk7XG4gICAqXG4gICAqICAgIC8vIC4uLmFuZCBwcm9jZXNzIHdpdGggY1ZlcmJcbiAgICogICAgLy8gc28gdGhhdCB3ZSBvbmx5IGhlYXIgdGhlIGNvbnZvbHV0aW9uXG4gICAqICAgIGNWZXJiLnByb2Nlc3Moc291bmQpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gcGxheVNvdW5kKCkge1xuICAgKiAgICBzb3VuZC5wbGF5KCk7XG4gICAqICB9XG4gICAqXG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG4gIHA1LkNvbnZvbHZlci5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICBzcmMuY29ubmVjdCh0aGlzLmlucHV0KTtcbiAgfTtcbiAgLyoqXG4gICAqICBJZiB5b3UgbG9hZCBtdWx0aXBsZSBpbXB1bHNlIGZpbGVzIHVzaW5nIHRoZSAuYWRkSW1wdWxzZSBtZXRob2QsXG4gICAqICB0aGV5IHdpbGwgYmUgc3RvcmVkIGFzIE9iamVjdHMgaW4gdGhpcyBBcnJheS4gVG9nZ2xlIGJldHdlZW4gdGhlbVxuICAgKiAgd2l0aCB0aGUgPGNvZGU+dG9nZ2xlSW1wdWxzZShpZCk8L2NvZGU+IG1ldGhvZC5cbiAgICpcbiAgICogIEBwcm9wZXJ0eSB7QXJyYXl9IGltcHVsc2VzXG4gICAqICBAZm9yIHA1LkNvbnZvbHZlclxuICAgKi9cblxuXG4gIHA1LkNvbnZvbHZlci5wcm90b3R5cGUuaW1wdWxzZXMgPSBbXTtcbiAgLyoqXG4gICAqICBMb2FkIGFuZCBhc3NpZ24gYSBuZXcgSW1wdWxzZSBSZXNwb25zZSB0byB0aGUgcDUuQ29udm9sdmVyLlxuICAgKiAgVGhlIGltcHVsc2UgaXMgYWRkZWQgdG8gdGhlIDxjb2RlPi5pbXB1bHNlczwvY29kZT4gYXJyYXkuIFByZXZpb3VzXG4gICAqICBpbXB1bHNlcyBjYW4gYmUgYWNjZXNzZWQgd2l0aCB0aGUgPGNvZGU+LnRvZ2dsZUltcHVsc2UoaWQpPC9jb2RlPlxuICAgKiAgbWV0aG9kLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgYWRkSW1wdWxzZVxuICAgKiAgQGZvciBwNS5Db252b2x2ZXJcbiAgICogIEBwYXJhbSAge1N0cmluZ30gICBwYXRoICAgICBwYXRoIHRvIGEgc291bmQgZmlsZVxuICAgKiAgQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIChvcHRpb25hbClcbiAgICogIEBwYXJhbSAge0Z1bmN0aW9ufSBlcnJvckNhbGxiYWNrIGZ1bmN0aW9uIChvcHRpb25hbClcbiAgICovXG5cbiAgcDUuQ29udm9sdmVyLnByb3RvdHlwZS5hZGRJbXB1bHNlID0gZnVuY3Rpb24gKHBhdGgsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4uaW5kZXhPZignZmlsZTovLycpID4gLTEgJiYgd2luZG93LmNvcmRvdmEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBhbGVydCgnVGhpcyBza2V0Y2ggbWF5IHJlcXVpcmUgYSBzZXJ2ZXIgdG8gbG9hZCBleHRlcm5hbCBmaWxlcy4gUGxlYXNlIHNlZSBodHRwOi8vYml0Lmx5LzFxY0lud1MnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9sb2FkQnVmZmVyKHBhdGgsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbiAgfTtcbiAgLyoqXG4gICAqICBTaW1pbGFyIHRvIC5hZGRJbXB1bHNlLCBleGNlcHQgdGhhdCB0aGUgPGNvZGU+LmltcHVsc2VzPC9jb2RlPlxuICAgKiAgQXJyYXkgaXMgcmVzZXQgdG8gc2F2ZSBtZW1vcnkuIEEgbmV3IDxjb2RlPi5pbXB1bHNlczwvY29kZT5cbiAgICogIGFycmF5IGlzIGNyZWF0ZWQgd2l0aCB0aGlzIGltcHVsc2UgYXMgdGhlIG9ubHkgaXRlbS5cbiAgICpcbiAgICogIEBtZXRob2QgIHJlc2V0SW1wdWxzZVxuICAgKiAgQGZvciBwNS5Db252b2x2ZXJcbiAgICogIEBwYXJhbSAge1N0cmluZ30gICBwYXRoICAgICBwYXRoIHRvIGEgc291bmQgZmlsZVxuICAgKiAgQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIChvcHRpb25hbClcbiAgICogIEBwYXJhbSAge0Z1bmN0aW9ufSBlcnJvckNhbGxiYWNrIGZ1bmN0aW9uIChvcHRpb25hbClcbiAgICovXG5cblxuICBwNS5Db252b2x2ZXIucHJvdG90eXBlLnJlc2V0SW1wdWxzZSA9IGZ1bmN0aW9uIChwYXRoLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgIGlmICh3aW5kb3cubG9jYXRpb24ub3JpZ2luLmluZGV4T2YoJ2ZpbGU6Ly8nKSA+IC0xICYmIHdpbmRvdy5jb3Jkb3ZhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgYWxlcnQoJ1RoaXMgc2tldGNoIG1heSByZXF1aXJlIGEgc2VydmVyIHRvIGxvYWQgZXh0ZXJuYWwgZmlsZXMuIFBsZWFzZSBzZWUgaHR0cDovL2JpdC5seS8xcWNJbndTJyk7XG4gICAgfVxuXG4gICAgdGhpcy5pbXB1bHNlcyA9IFtdO1xuXG4gICAgdGhpcy5fbG9hZEJ1ZmZlcihwYXRoLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG4gIH07XG4gIC8qKlxuICAgKiAgSWYgeW91IGhhdmUgdXNlZCA8Y29kZT4uYWRkSW1wdWxzZSgpPC9jb2RlPiB0byBhZGQgbXVsdGlwbGUgaW1wdWxzZXNcbiAgICogIHRvIGEgcDUuQ29udm9sdmVyLCB0aGVuIHlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kIHRvIHRvZ2dsZSBiZXR3ZWVuXG4gICAqICB0aGUgaXRlbXMgaW4gdGhlIDxjb2RlPi5pbXB1bHNlczwvY29kZT4gQXJyYXkuIEFjY2VwdHMgYSBwYXJhbWV0ZXJcbiAgICogIHRvIGlkZW50aWZ5IHdoaWNoIGltcHVsc2UgeW91IHdpc2ggdG8gdXNlLCBpZGVudGlmaWVkIGVpdGhlciBieSBpdHNcbiAgICogIG9yaWdpbmFsIGZpbGVuYW1lIChTdHJpbmcpIG9yIGJ5IGl0cyBwb3NpdGlvbiBpbiB0aGUgPGNvZGU+LmltcHVsc2VzXG4gICAqICA8L2NvZGU+IEFycmF5IChOdW1iZXIpLjxici8+XG4gICAqICBZb3UgY2FuIGFjY2VzcyB0aGUgb2JqZWN0cyBpbiB0aGUgLmltcHVsc2VzIEFycmF5IGRpcmVjdGx5LiBFYWNoXG4gICAqICBPYmplY3QgaGFzIHR3byBhdHRyaWJ1dGVzOiBhbiA8Y29kZT4uYXVkaW9CdWZmZXI8L2NvZGU+ICh0eXBlOlxuICAgKiAgV2ViIEF1ZGlvIDxhIGhyZWY9XCJcbiAgICogIGh0dHA6Ly93ZWJhdWRpby5naXRodWIuaW8vd2ViLWF1ZGlvLWFwaS8jdGhlLWF1ZGlvYnVmZmVyLWludGVyZmFjZVwiPlxuICAgKiAgQXVkaW9CdWZmZXIpPC9hPiBhbmQgYSA8Y29kZT4ubmFtZTwvY29kZT4sIGEgU3RyaW5nIHRoYXQgY29ycmVzcG9uZHNcbiAgICogIHdpdGggdGhlIG9yaWdpbmFsIGZpbGVuYW1lLlxuICAgKlxuICAgKiAgQG1ldGhvZCB0b2dnbGVJbXB1bHNlXG4gICAqICBAZm9yIHA1LkNvbnZvbHZlclxuICAgKiAgQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpZCBJZGVudGlmeSB0aGUgaW1wdWxzZSBieSBpdHMgb3JpZ2luYWwgZmlsZW5hbWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgKFN0cmluZyksIG9yIGJ5IGl0cyBwb3NpdGlvbiBpbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNvZGU+LmltcHVsc2VzPC9jb2RlPiBBcnJheSAoTnVtYmVyKS5cbiAgICovXG5cblxuICBwNS5Db252b2x2ZXIucHJvdG90eXBlLnRvZ2dsZUltcHVsc2UgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICBpZiAodHlwZW9mIGlkID09PSAnbnVtYmVyJyAmJiBpZCA8IHRoaXMuaW1wdWxzZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zZXRCdWZmZXIodGhpcy5pbXB1bHNlc1tpZF0uYXVkaW9CdWZmZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW1wdWxzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuaW1wdWxzZXNbaV0ubmFtZSA9PT0gaWQpIHtcbiAgICAgICAgICB0aGlzLl9zZXRCdWZmZXIodGhpcy5pbXB1bHNlc1tpXS5hdWRpb0J1ZmZlcik7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwNS5Db252b2x2ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcDUuUmV2ZXJiLnByb3RvdHlwZS5kaXNwb3NlLmFwcGx5KHRoaXMpOyBcblxuICAgIGZvciAodmFyIGkgaW4gdGhpcy5pbXB1bHNlcykge1xuICAgICAgaWYgKHRoaXMuaW1wdWxzZXNbaV0pIHtcbiAgICAgICAgdGhpcy5pbXB1bHNlc1tpXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gIHZhciBwNXNvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTsgXG5cblxuICB2YXIgQ2xvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxuICBwNS5NZXRybyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNsb2NrID0gbmV3IENsb2NrKHtcbiAgICAgICdjYWxsYmFjayc6IHRoaXMub250aWNrLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLnN5bmNlZFBhcnRzID0gW107XG4gICAgdGhpcy5icG0gPSAxMjA7IFxuXG4gICAgdGhpcy5faW5pdCgpO1xuXG4gICAgdGhpcy5wcmV2VGljayA9IDA7XG4gICAgdGhpcy50YXR1bVRpbWUgPSAwO1xuXG4gICAgdGhpcy50aWNrQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgfTtcblxuICBwNS5NZXRyby5wcm90b3R5cGUub250aWNrID0gZnVuY3Rpb24gKHRpY2tUaW1lKSB7XG4gICAgdmFyIGVsYXBzZWRUaW1lID0gdGlja1RpbWUgLSB0aGlzLnByZXZUaWNrO1xuICAgIHZhciBzZWNvbmRzRnJvbU5vdyA9IHRpY2tUaW1lIC0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG5cbiAgICBpZiAoZWxhcHNlZFRpbWUgLSB0aGlzLnRhdHVtVGltZSA8PSAtMC4wMikge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZXZUaWNrID0gdGlja1RpbWU7IFxuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLnN5bmNlZFBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHRoaXNQYXJ0KSB7XG4gICAgICAgIGlmICghdGhpc1BhcnQuaXNQbGF5aW5nKSByZXR1cm47XG4gICAgICAgIHRoaXNQYXJ0LmluY3JlbWVudFN0ZXAoc2Vjb25kc0Zyb21Ob3cpOyBcblxuICAgICAgICB0aGlzUGFydC5waHJhc2VzLmZvckVhY2goZnVuY3Rpb24gKHRoaXNQaHJhc2UpIHtcbiAgICAgICAgICB2YXIgcGhyYXNlQXJyYXkgPSB0aGlzUGhyYXNlLnNlcXVlbmNlO1xuICAgICAgICAgIHZhciBiTnVtID0gc2VsZi5tZXRyb1RpY2tzICUgcGhyYXNlQXJyYXkubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKHBocmFzZUFycmF5W2JOdW1dICE9PSAwICYmIChzZWxmLm1ldHJvVGlja3MgPCBwaHJhc2VBcnJheS5sZW5ndGggfHwgIXRoaXNQaHJhc2UubG9vcGluZykpIHtcbiAgICAgICAgICAgIHRoaXNQaHJhc2UuY2FsbGJhY2soc2Vjb25kc0Zyb21Ob3csIHBocmFzZUFycmF5W2JOdW1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1ldHJvVGlja3MgKz0gMTtcbiAgICAgIHRoaXMudGlja0NhbGxiYWNrKHNlY29uZHNGcm9tTm93KTtcbiAgICB9XG4gIH07XG5cbiAgcDUuTWV0cm8ucHJvdG90eXBlLnNldEJQTSA9IGZ1bmN0aW9uIChicG0sIHJhbXBUaW1lKSB7XG4gICAgdmFyIGJlYXRUaW1lID0gNjAgLyAoYnBtICogdGhpcy50YXR1bXMpO1xuICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICB0aGlzLnRhdHVtVGltZSA9IGJlYXRUaW1lO1xuICAgIHZhciByYW1wVGltZSA9IHJhbXBUaW1lIHx8IDA7XG4gICAgdGhpcy5jbG9jay5mcmVxdWVuY3kuc2V0VmFsdWVBdFRpbWUodGhpcy5jbG9jay5mcmVxdWVuY3kudmFsdWUsIG5vdyk7XG4gICAgdGhpcy5jbG9jay5mcmVxdWVuY3kubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoYnBtLCBub3cgKyByYW1wVGltZSk7XG4gICAgdGhpcy5icG0gPSBicG07XG4gIH07XG5cbiAgcDUuTWV0cm8ucHJvdG90eXBlLmdldEJQTSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9jay5nZXRSYXRlKCkgLyB0aGlzLnRhdHVtcyAqIDYwO1xuICB9O1xuXG4gIHA1Lk1ldHJvLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm1ldHJvVGlja3MgPSAwOyBcbiAgfTsgXG5cblxuICBwNS5NZXRyby5wcm90b3R5cGUucmVzZXRTeW5jID0gZnVuY3Rpb24gKHBhcnQpIHtcbiAgICB0aGlzLnN5bmNlZFBhcnRzID0gW3BhcnRdO1xuICB9OyBcblxuXG4gIHA1Lk1ldHJvLnByb3RvdHlwZS5wdXNoU3luYyA9IGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgdGhpcy5zeW5jZWRQYXJ0cy5wdXNoKHBhcnQpO1xuICB9O1xuXG4gIHA1Lk1ldHJvLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICh0aW1lRnJvbU5vdykge1xuICAgIHZhciB0ID0gdGltZUZyb21Ob3cgfHwgMDtcbiAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG4gICAgdGhpcy5jbG9jay5zdGFydChub3cgKyB0KTtcbiAgICB0aGlzLnNldEJQTSh0aGlzLmJwbSk7XG4gIH07XG5cbiAgcDUuTWV0cm8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZUZyb21Ob3cpIHtcbiAgICB2YXIgdCA9IHRpbWVGcm9tTm93IHx8IDA7XG4gICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgIHRoaXMuY2xvY2suc3RvcChub3cgKyB0KTtcbiAgfTtcblxuICBwNS5NZXRyby5wcm90b3R5cGUuYmVhdExlbmd0aCA9IGZ1bmN0aW9uICh0YXR1bXMpIHtcbiAgICB0aGlzLnRhdHVtcyA9IDEgLyB0YXR1bXMgLyA0OyBcbiAgfTtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMCksX193ZWJwYWNrX3JlcXVpcmVfXygyNCksX193ZWJwYWNrX3JlcXVpcmVfXyg4KV0sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO3JldHVybiB0LlRpbWVsaW5lU3RhdGU9ZnVuY3Rpb24oZSl7dC5UaW1lbGluZS5jYWxsKHRoaXMpLHRoaXMuX2luaXRpYWw9ZX0sdC5leHRlbmQodC5UaW1lbGluZVN0YXRlLHQuVGltZWxpbmUpLHQuVGltZWxpbmVTdGF0ZS5wcm90b3R5cGUuZ2V0VmFsdWVBdFRpbWU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5nZXQoZSk7cmV0dXJuIG51bGwhPT10P3Quc3RhdGU6dGhpcy5faW5pdGlhbH0sdC5UaW1lbGluZVN0YXRlLnByb3RvdHlwZS5zZXRTdGF0ZUF0VGltZT1mdW5jdGlvbihlLHQpe3RoaXMuYWRkKHtzdGF0ZTplLHRpbWU6dH0pfSx0LlRpbWVsaW5lU3RhdGV9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICB2YXIgcDVzb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIEJQTSA9IDEyMDtcbiAgLyoqXG4gICAqICBTZXQgdGhlIGdsb2JhbCB0ZW1wbywgaW4gYmVhdHMgcGVyIG1pbnV0ZSwgZm9yIGFsbFxuICAgKiAgcDUuUGFydHMuIFRoaXMgbWV0aG9kIHdpbGwgaW1wYWN0IGFsbCBhY3RpdmUgcDUuUGFydHMuXG4gICAqXG4gICAqICBAbWV0aG9kIHNldEJQTVxuICAgKiAgQGZvciBwNVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IEJQTSAgICAgIEJlYXRzIFBlciBNaW51dGVcbiAgICogIEBwYXJhbSB7TnVtYmVyfSByYW1wVGltZSBTZWNvbmRzIGZyb20gbm93XG4gICAqL1xuXG4gIHA1LnByb3RvdHlwZS5zZXRCUE0gPSBmdW5jdGlvbiAoYnBtLCByYW1wVGltZSkge1xuICAgIEJQTSA9IGJwbTtcblxuICAgIGZvciAodmFyIGkgaW4gcDVzb3VuZC5wYXJ0cykge1xuICAgICAgaWYgKHA1c291bmQucGFydHNbaV0pIHtcbiAgICAgICAgcDVzb3VuZC5wYXJ0c1tpXS5zZXRCUE0oYnBtLCByYW1wVGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIDxwPkEgcGhyYXNlIGlzIGEgcGF0dGVybiBvZiBtdXNpY2FsIGV2ZW50cyBvdmVyIHRpbWUsIGkuZS5cbiAgICogIGEgc2VyaWVzIG9mIG5vdGVzIGFuZCByZXN0cy48L3A+XG4gICAqXG4gICAqICA8cD5QaHJhc2VzIG11c3QgYmUgYWRkZWQgdG8gYSBwNS5QYXJ0IGZvciBwbGF5YmFjaywgYW5kXG4gICAqICBlYWNoIHBhcnQgY2FuIHBsYXkgbXVsdGlwbGUgcGhyYXNlcyBhdCB0aGUgc2FtZSB0aW1lLlxuICAgKiAgRm9yIGV4YW1wbGUsIG9uZSBQaHJhc2UgbWlnaHQgYmUgYSBraWNrIGRydW0sIGFub3RoZXJcbiAgICogIGNvdWxkIGJlIGEgc25hcmUsIGFuZCBhbm90aGVyIGNvdWxkIGJlIHRoZSBiYXNzbGluZS48L3A+XG4gICAqXG4gICAqICA8cD5UaGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgbmFtZSBzbyB0aGF0IHRoZSBwaHJhc2UgY2FuIGJlXG4gICAqICBtb2RpZmllZCBvciBkZWxldGVkIGxhdGVyLiBUaGUgY2FsbGJhY2sgaXMgYSBhIGZ1bmN0aW9uIHRoYXRcbiAgICogIHRoaXMgcGhyYXNlIHdpbGwgY2FsbCBhdCBldmVyeSBzdGVw4oCUZm9yIGV4YW1wbGUgaXQgbWlnaHQgYmVcbiAgICogIGNhbGxlZCA8Y29kZT5wbGF5Tm90ZSh2YWx1ZSl7fTwvY29kZT4uIFRoZSBhcnJheSBkZXRlcm1pbmVzXG4gICAqICB3aGljaCB2YWx1ZSBpcyBwYXNzZWQgaW50byB0aGUgY2FsbGJhY2sgYXQgZWFjaCBzdGVwIG9mIHRoZVxuICAgKiAgcGhyYXNlLiBJdCBjYW4gYmUgbnVtYmVycywgYW4gb2JqZWN0IHdpdGggbXVsdGlwbGUgbnVtYmVycyxcbiAgICogIG9yIGEgemVybyAoMCkgaW5kaWNhdGVzIGEgcmVzdCBzbyB0aGUgY2FsbGJhY2sgd29uJ3QgYmUgY2FsbGVkKS48L3A+XG4gICAqXG4gICAqICBAY2xhc3MgcDUuUGhyYXNlXG4gICAqICBAY29uc3RydWN0b3JcbiAgICogIEBwYXJhbSB7U3RyaW5nfSAgIG5hbWUgICAgIE5hbWUgc28gdGhhdCB5b3UgY2FuIGFjY2VzcyB0aGUgUGhyYXNlLlxuICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIG5hbWUgb2YgYSBmdW5jdGlvbiB0aGF0IHRoaXMgcGhyYXNlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGNhbGwuIFR5cGljYWxseSBpdCB3aWxsIHBsYXkgYSBzb3VuZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBhY2NlcHQgdHdvIHBhcmFtZXRlcnM6IGEgdGltZSBhdCB3aGljaFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gcGxheSB0aGUgc291bmQgKGluIHNlY29uZHMgZnJvbSBub3cpLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIGEgdmFsdWUgZnJvbSB0aGUgc2VxdWVuY2UgYXJyYXkuIFRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZSBzaG91bGQgYmUgcGFzc2VkIGludG8gdGhlIHBsYXkoKSBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQoKSBtZXRob2QgdG8gZW5zdXJlIHByZWNpc2lvbi5cbiAgICogIEBwYXJhbSB7QXJyYXl9ICAgc2VxdWVuY2UgICAgQXJyYXkgb2YgdmFsdWVzIHRvIHBhc3MgaW50byB0aGUgY2FsbGJhY2tcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYXQgZWFjaCBzdGVwIG9mIHRoZSBwaHJhc2UuXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBteVNvdW5kLCBteVBocmFzZSwgbXlQYXJ0O1xuICAgKiAgbGV0IHBhdHRlcm4gPSBbMSwwLDAsMiwwLDIsMCwwXTtcbiAgICpcbiAgICogIGZ1bmN0aW9uIHByZWxvYWQoKSB7XG4gICAqICAgIG15U291bmQgPSBsb2FkU291bmQoJ2Fzc2V0cy9iZWF0Ym94Lm1wMycpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHBsYXlNeVBhcnQpO1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHQoJ3RhcCB0byBwbGF5Jywgd2lkdGgvMiwgaGVpZ2h0LzIpO1xuICAgKiAgICB0ZXh0QWxpZ24oQ0VOVEVSLCBDRU5URVIpO1xuICAgKlxuICAgKiAgICBteVBocmFzZSA9IG5ldyBwNS5QaHJhc2UoJ2Jib3gnLCBvbkVhY2hTdGVwLCBwYXR0ZXJuKTtcbiAgICogICAgbXlQYXJ0ID0gbmV3IHA1LlBhcnQoKTtcbiAgICogICAgbXlQYXJ0LmFkZFBocmFzZShteVBocmFzZSk7XG4gICAqICAgIG15UGFydC5zZXRCUE0oNjApO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gb25FYWNoU3RlcCh0aW1lLCBwbGF5YmFja1JhdGUpIHtcbiAgICogICAgbXlTb3VuZC5yYXRlKHBsYXliYWNrUmF0ZSk7XG4gICAqICAgIG15U291bmQucGxheSh0aW1lKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHBsYXlNeVBhcnQoKSB7XG4gICAqICAgIHVzZXJTdGFydEF1ZGlvKCk7XG4gICAqICAgIG15UGFydC5zdGFydCgpO1xuICAgKiAgfVxuICAgKiAgPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LlBocmFzZSA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaywgc2VxdWVuY2UpIHtcbiAgICB0aGlzLnBocmFzZVN0ZXAgPSAwO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHZhbHVlcyB0byBwYXNzIGludG8gdGhlIGNhbGxiYWNrXG4gICAgICogYXQgZWFjaCBzdGVwIG9mIHRoZSBwaHJhc2UuIERlcGVuZGluZyBvbiB0aGUgY2FsbGJhY2tcbiAgICAgKiBmdW5jdGlvbidzIHJlcXVpcmVtZW50cywgdGhlc2UgdmFsdWVzIG1heSBiZSBudW1iZXJzLFxuICAgICAqIHN0cmluZ3MsIG9yIGFuIG9iamVjdCB3aXRoIG11bHRpcGxlIHBhcmFtZXRlcnMuXG4gICAgICogWmVybyAoMCkgaW5kaWNhdGVzIGEgcmVzdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHNlcXVlbmNlXG4gICAgICovXG5cbiAgICB0aGlzLnNlcXVlbmNlID0gc2VxdWVuY2U7XG4gIH07XG4gIC8qKlxuICAgKiAgPHA+QSBwNS5QYXJ0IHBsYXlzIGJhY2sgb25lIG9yIG1vcmUgcDUuUGhyYXNlcy4gSW5zdGFudGlhdGUgYSBwYXJ0XG4gICAqICB3aXRoIHN0ZXBzIGFuZCB0YXR1bXMuIEJ5IGRlZmF1bHQsIGVhY2ggc3RlcCByZXByZXNlbnRzIGEgMS8xNnRoIG5vdGUuPC9wPlxuICAgKlxuICAgKiAgPHA+U2VlIHA1LlBocmFzZSBmb3IgbW9yZSBhYm91dCBtdXNpY2FsIHRpbWluZy48L3A+XG4gICAqXG4gICAqICBAY2xhc3MgcDUuUGFydFxuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAcGFyYW0ge051bWJlcn0gW3N0ZXBzXSAgIFN0ZXBzIGluIHRoZSBwYXJ0XG4gICAqICBAcGFyYW0ge051bWJlcn0gW3RhdHVtc10gRGl2aXNpb25zIG9mIGEgYmVhdCwgZS5nLiB1c2UgMS80LCBvciAwLjI1IGZvciBhIHF1YXRlciBub3RlIChkZWZhdWx0IGlzIDEvMTYsIGEgc2l4dGVlbnRoIG5vdGUpXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIGxldCBib3gsIGRydW0sIG15UGFydDtcbiAgICogIGxldCBib3hQYXQgPSBbMSwwLDAsMiwwLDIsMCwwXTtcbiAgICogIGxldCBkcnVtUGF0ID0gWzAsMSwxLDAsMiwwLDEsMF07XG4gICAqXG4gICAqICBmdW5jdGlvbiBwcmVsb2FkKCkge1xuICAgKiAgICBib3ggPSBsb2FkU291bmQoJ2Fzc2V0cy9iZWF0Ym94Lm1wMycpO1xuICAgKiAgICBkcnVtID0gbG9hZFNvdW5kKCdhc3NldHMvZHJ1bS5tcDMnKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChwbGF5TXlQYXJ0KTtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0QWxpZ24oQ0VOVEVSLCBDRU5URVIpO1xuICAgKiAgICB0ZXh0KCd0YXAgdG8gcGxheScsIHdpZHRoLzIsIGhlaWdodC8yKTtcbiAgICpcbiAgICogICAgbGV0IGJveFBocmFzZSA9IG5ldyBwNS5QaHJhc2UoJ2JveCcsIHBsYXlCb3gsIGJveFBhdCk7XG4gICAqICAgIGxldCBkcnVtUGhyYXNlID0gbmV3IHA1LlBocmFzZSgnZHJ1bScsIHBsYXlEcnVtLCBkcnVtUGF0KTtcbiAgICogICAgbXlQYXJ0ID0gbmV3IHA1LlBhcnQoKTtcbiAgICogICAgbXlQYXJ0LmFkZFBocmFzZShib3hQaHJhc2UpO1xuICAgKiAgICBteVBhcnQuYWRkUGhyYXNlKGRydW1QaHJhc2UpO1xuICAgKiAgICBteVBhcnQuc2V0QlBNKDYwKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHBsYXlCb3godGltZSwgcGxheWJhY2tSYXRlKSB7XG4gICAqICAgIGJveC5yYXRlKHBsYXliYWNrUmF0ZSk7XG4gICAqICAgIGJveC5wbGF5KHRpbWUpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gcGxheURydW0odGltZSwgcGxheWJhY2tSYXRlKSB7XG4gICAqICAgIGRydW0ucmF0ZShwbGF5YmFja1JhdGUpO1xuICAgKiAgICBkcnVtLnBsYXkodGltZSk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBwbGF5TXlQYXJ0KCkge1xuICAgKiAgICB1c2VyU3RhcnRBdWRpbygpO1xuICAgKlxuICAgKiAgICBteVBhcnQuc3RhcnQoKTtcbiAgICogIH1cbiAgICogIDwvY29kZT48L2Rpdj5cbiAgICovXG5cblxuICBwNS5QYXJ0ID0gZnVuY3Rpb24gKHN0ZXBzLCBiTGVuZ3RoKSB7XG4gICAgdGhpcy5sZW5ndGggPSBzdGVwcyB8fCAwOyBcblxuICAgIHRoaXMucGFydFN0ZXAgPSAwO1xuICAgIHRoaXMucGhyYXNlcyA9IFtdO1xuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5ub0xvb3AoKTtcbiAgICB0aGlzLnRhdHVtcyA9IGJMZW5ndGggfHwgMC4wNjI1OyBcblxuICAgIHRoaXMubWV0cm8gPSBuZXcgcDUuTWV0cm8oKTtcblxuICAgIHRoaXMubWV0cm8uX2luaXQoKTtcblxuICAgIHRoaXMubWV0cm8uYmVhdExlbmd0aCh0aGlzLnRhdHVtcyk7XG4gICAgdGhpcy5tZXRyby5zZXRCUE0oQlBNKTtcbiAgICBwNXNvdW5kLnBhcnRzLnB1c2godGhpcyk7XG5cbiAgICB0aGlzLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gIH07XG4gIC8qKlxuICAgKiAgU2V0IHRoZSB0ZW1wbyBvZiB0aGlzIHBhcnQsIGluIEJlYXRzIFBlciBNaW51dGUuXG4gICAqXG4gICAqICBAbWV0aG9kICBzZXRCUE1cbiAgICogIEBmb3IgcDUuUGFydFxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IEJQTSAgICAgIEJlYXRzIFBlciBNaW51dGVcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbcmFtcFRpbWVdIFNlY29uZHMgZnJvbSBub3dcbiAgICovXG5cblxuICBwNS5QYXJ0LnByb3RvdHlwZS5zZXRCUE0gPSBmdW5jdGlvbiAodGVtcG8sIHJhbXBUaW1lKSB7XG4gICAgdGhpcy5tZXRyby5zZXRCUE0odGVtcG8sIHJhbXBUaW1lKTtcbiAgfTtcbiAgLyoqXG4gICAqICBSZXR1cm5zIHRoZSB0ZW1wbywgaW4gQmVhdHMgUGVyIE1pbnV0ZSwgb2YgdGhpcyBwYXJ0LlxuICAgKlxuICAgKiAgQG1ldGhvZCBnZXRCUE1cbiAgICogIEBmb3IgcDUuUGFydFxuICAgKiAgQHJldHVybiB7TnVtYmVyfVxuICAgKi9cblxuXG4gIHA1LlBhcnQucHJvdG90eXBlLmdldEJQTSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRyby5nZXRCUE0oKTtcbiAgfTtcbiAgLyoqXG4gICAqICBTdGFydCBwbGF5YmFjayBvZiB0aGlzIHBhcnQuIEl0IHdpbGwgcGxheVxuICAgKiAgdGhyb3VnaCBhbGwgb2YgaXRzIHBocmFzZXMgYXQgYSBzcGVlZFxuICAgKiAgZGV0ZXJtaW5lZCBieSBzZXRCUE0uXG4gICAqXG4gICAqICBAbWV0aG9kICBzdGFydFxuICAgKiAgQGZvciBwNS5QYXJ0XG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFt0aW1lXSBzZWNvbmRzIGZyb20gbm93XG4gICAqL1xuXG5cbiAgcDUuUGFydC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuICAgIGlmICghdGhpcy5pc1BsYXlpbmcpIHtcbiAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMubWV0cm8ucmVzZXRTeW5jKHRoaXMpO1xuICAgICAgdmFyIHQgPSB0aW1lIHx8IDA7XG4gICAgICB0aGlzLm1ldHJvLnN0YXJ0KHQpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBMb29wIHBsYXliYWNrIG9mIHRoaXMgcGFydC4gSXQgd2lsbCBiZWdpblxuICAgKiAgbG9vcGluZyB0aHJvdWdoIGFsbCBvZiBpdHMgcGhyYXNlcyBhdCBhIHNwZWVkXG4gICAqICBkZXRlcm1pbmVkIGJ5IHNldEJQTS5cbiAgICpcbiAgICogIEBtZXRob2QgIGxvb3BcbiAgICogIEBmb3IgcDUuUGFydFxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbdGltZV0gc2Vjb25kcyBmcm9tIG5vd1xuICAgKi9cblxuXG4gIHA1LlBhcnQucHJvdG90eXBlLmxvb3AgPSBmdW5jdGlvbiAodGltZSkge1xuICAgIHRoaXMubG9vcGluZyA9IHRydWU7IFxuXG4gICAgdGhpcy5vbmVuZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wYXJ0U3RlcCA9IDA7XG4gICAgfTtcblxuICAgIHZhciB0ID0gdGltZSB8fCAwO1xuICAgIHRoaXMuc3RhcnQodCk7XG4gIH07XG4gIC8qKlxuICAgKiAgVGVsbCB0aGUgcGFydCB0byBzdG9wIGxvb3BpbmcuXG4gICAqXG4gICAqICBAbWV0aG9kICBub0xvb3BcbiAgICogIEBmb3IgcDUuUGFydFxuICAgKi9cblxuXG4gIHA1LlBhcnQucHJvdG90eXBlLm5vTG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxvb3BpbmcgPSBmYWxzZTsgXG5cbiAgICB0aGlzLm9uZW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICB9O1xuICB9O1xuICAvKipcbiAgICogIFN0b3AgdGhlIHBhcnQgYW5kIGN1ZSBpdCB0byBzdGVwIDAuIFBsYXliYWNrIHdpbGwgcmVzdW1lIGZyb20gdGhlIGJlZ2luaW5nIG9mIHRoZSBQYXJ0IHdoZW4gaXQgaXMgcGxheWVkIGFnYWluLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgc3RvcFxuICAgKiAgQGZvciBwNS5QYXJ0XG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9IFt0aW1lXSBzZWNvbmRzIGZyb20gbm93XG4gICAqL1xuXG5cbiAgcDUuUGFydC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgdGhpcy5wYXJ0U3RlcCA9IDA7XG4gICAgdGhpcy5wYXVzZSh0aW1lKTtcbiAgfTtcbiAgLyoqXG4gICAqICBQYXVzZSB0aGUgcGFydC4gUGxheWJhY2sgd2lsbCByZXN1bWVcbiAgICogIGZyb20gdGhlIGN1cnJlbnQgc3RlcC5cbiAgICpcbiAgICogIEBtZXRob2QgIHBhdXNlXG4gICAqICBAZm9yIHA1LlBhcnRcbiAgICogIEBwYXJhbSAge051bWJlcn0gdGltZSBzZWNvbmRzIGZyb20gbm93XG4gICAqL1xuXG5cbiAgcDUuUGFydC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAodGltZSkge1xuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgdmFyIHQgPSB0aW1lIHx8IDA7XG4gICAgdGhpcy5tZXRyby5zdG9wKHQpO1xuICB9O1xuICAvKipcbiAgICogIEFkZCBhIHA1LlBocmFzZSB0byB0aGlzIFBhcnQuXG4gICAqXG4gICAqICBAbWV0aG9kICBhZGRQaHJhc2VcbiAgICogIEBmb3IgcDUuUGFydFxuICAgKiAgQHBhcmFtIHtwNS5QaHJhc2V9ICAgcGhyYXNlICAgcmVmZXJlbmNlIHRvIGEgcDUuUGhyYXNlXG4gICAqL1xuXG5cbiAgcDUuUGFydC5wcm90b3R5cGUuYWRkUGhyYXNlID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrLCBhcnJheSkge1xuICAgIHZhciBwO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHAgPSBuZXcgcDUuUGhyYXNlKG5hbWUsIGNhbGxiYWNrLCBhcnJheSk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBwNS5QaHJhc2UpIHtcbiAgICAgIHAgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93ICdpbnZhbGlkIGlucHV0LiBhZGRQaHJhc2UgYWNjZXB0cyBuYW1lLCBjYWxsYmFjaywgYXJyYXkgb3IgYSBwNS5QaHJhc2UnO1xuICAgIH1cblxuICAgIHRoaXMucGhyYXNlcy5wdXNoKHApOyBcblxuICAgIGlmIChwLnNlcXVlbmNlLmxlbmd0aCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IHAuc2VxdWVuY2UubGVuZ3RoO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBSZW1vdmUgYSBwaHJhc2UgZnJvbSB0aGlzIHBhcnQsIGJhc2VkIG9uIHRoZSBuYW1lIGl0IHdhc1xuICAgKiAgZ2l2ZW4gd2hlbiBpdCB3YXMgY3JlYXRlZC5cbiAgICpcbiAgICogIEBtZXRob2QgIHJlbW92ZVBocmFzZVxuICAgKiAgQGZvciBwNS5QYXJ0XG4gICAqICBAcGFyYW0gIHtTdHJpbmd9IHBocmFzZU5hbWVcbiAgICovXG5cblxuICBwNS5QYXJ0LnByb3RvdHlwZS5yZW1vdmVQaHJhc2UgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5waHJhc2VzKSB7XG4gICAgICBpZiAodGhpcy5waHJhc2VzW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgdGhpcy5waHJhc2VzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgR2V0IGEgcGhyYXNlIGZyb20gdGhpcyBwYXJ0LCBiYXNlZCBvbiB0aGUgbmFtZSBpdCB3YXNcbiAgICogIGdpdmVuIHdoZW4gaXQgd2FzIGNyZWF0ZWQuIE5vdyB5b3UgY2FuIG1vZGlmeSBpdHMgYXJyYXkuXG4gICAqXG4gICAqICBAbWV0aG9kICBnZXRQaHJhc2VcbiAgICogIEBmb3IgcDUuUGFydFxuICAgKiAgQHBhcmFtICB7U3RyaW5nfSBwaHJhc2VOYW1lXG4gICAqL1xuXG5cbiAgcDUuUGFydC5wcm90b3R5cGUuZ2V0UGhyYXNlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBmb3IgKHZhciBpIGluIHRoaXMucGhyYXNlcykge1xuICAgICAgaWYgKHRoaXMucGhyYXNlc1tpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBocmFzZXNbaV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogIEZpbmQgYWxsIHNlcXVlbmNlcyB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSwgYW5kIHJlcGxhY2UgdGhlaXIgcGF0dGVybnMgd2l0aCB0aGUgc3BlY2lmaWVkIGFycmF5LlxuICAgKlxuICAgKiAgQG1ldGhvZCAgcmVwbGFjZVNlcXVlbmNlXG4gICAqICBAZm9yIHA1LlBhcnRcbiAgICogIEBwYXJhbSAge1N0cmluZ30gcGhyYXNlTmFtZVxuICAgKiAgQHBhcmFtICB7QXJyYXl9IHNlcXVlbmNlICBBcnJheSBvZiB2YWx1ZXMgdG8gcGFzcyBpbnRvIHRoZSBjYWxsYmFja1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdCBlYWNoIHN0ZXAgb2YgdGhlIHBocmFzZS5cbiAgICovXG5cblxuICBwNS5QYXJ0LnByb3RvdHlwZS5yZXBsYWNlU2VxdWVuY2UgPSBmdW5jdGlvbiAobmFtZSwgYXJyYXkpIHtcbiAgICBmb3IgKHZhciBpIGluIHRoaXMucGhyYXNlcykge1xuICAgICAgaWYgKHRoaXMucGhyYXNlc1tpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHRoaXMucGhyYXNlc1tpXS5zZXF1ZW5jZSA9IGFycmF5O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwNS5QYXJ0LnByb3RvdHlwZS5pbmNyZW1lbnRTdGVwID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICBpZiAodGhpcy5wYXJ0U3RlcCA8IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5jYWxsYmFjayh0aW1lKTtcbiAgICAgIHRoaXMucGFydFN0ZXAgKz0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLmxvb3BpbmcgJiYgdGhpcy5wYXJ0U3RlcCA9PT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMub25lbmRlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBTZXQgdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgYXQgZXZlcnkgc3RlcC4gVGhpcyB3aWxsIGNsZWFyIHRoZSBwcmV2aW91cyBmdW5jdGlvbi5cbiAgICpcbiAgICogIEBtZXRob2Qgb25TdGVwXG4gICAqICBAZm9yIHA1LlBhcnRcbiAgICogIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgbmFtZSBvZiB0aGUgY2FsbGJhY2tcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5b3Ugd2FudCB0byBmaXJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb24gZXZlcnkgYmVhdC90YXR1bS5cbiAgICovXG5cblxuICBwNS5QYXJ0LnByb3RvdHlwZS5vblN0ZXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH07IFxuXG4gIC8qKlxuICAgKiAgQSBTY29yZSBjb25zaXN0cyBvZiBhIHNlcmllcyBvZiBQYXJ0cy4gVGhlIHBhcnRzIHdpbGxcbiAgICogIGJlIHBsYXllZCBiYWNrIGluIG9yZGVyLiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGhhdmUgYW5cbiAgICogIEEgcGFydCwgYSBCIHBhcnQsIGFuZCBhIEMgcGFydCwgYW5kIHBsYXkgdGhlbSBiYWNrIGluIHRoaXMgb3JkZXJcbiAgICogIDxjb2RlPm5ldyBwNS5TY29yZShhLCBhLCBiLCBhLCBjKTwvY29kZT5cbiAgICpcbiAgICogIEBjbGFzcyBwNS5TY29yZVxuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAcGFyYW0ge3A1LlBhcnR9IFsuLi5wYXJ0c10gT25lIG9yIG11bHRpcGxlIHBhcnRzLCB0byBiZSBwbGF5ZWQgaW4gc2VxdWVuY2UuXG4gICAqL1xuXG5cbiAgcDUuU2NvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wYXJ0cyA9IFtdO1xuICAgIHRoaXMuY3VycmVudFBhcnQgPSAwO1xuICAgIHZhciB0aGlzU2NvcmUgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSBpbiBhcmd1bWVudHMpIHtcbiAgICAgIGlmIChhcmd1bWVudHNbaV0gJiYgdGhpcy5wYXJ0c1tpXSkge1xuICAgICAgICB0aGlzLnBhcnRzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB0aGlzLnBhcnRzW2ldLm5leHRQYXJ0ID0gdGhpcy5wYXJ0c1tpICsgMV07XG5cbiAgICAgICAgdGhpcy5wYXJ0c1tpXS5vbmVuZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXNTY29yZS5yZXNldFBhcnQoaSk7XG4gICAgICAgICAgcGxheU5leHRQYXJ0KHRoaXNTY29yZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sb29waW5nID0gZmFsc2U7XG4gIH07XG5cbiAgcDUuU2NvcmUucHJvdG90eXBlLm9uZW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubG9vcGluZykge1xuICAgICAgdGhpcy5wYXJ0c1swXS5zdGFydCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcnRzW3RoaXMucGFydHMubGVuZ3RoIC0gMV0ub25lbmRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHRoaXMucmVzZXRQYXJ0cygpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRQYXJ0ID0gMDtcbiAgfTtcbiAgLyoqXG4gICAqICBTdGFydCBwbGF5YmFjayBvZiB0aGUgc2NvcmUuXG4gICAqXG4gICAqICBAbWV0aG9kICBzdGFydFxuICAgKiAgQGZvciBwNS5TY29yZVxuICAgKi9cblxuXG4gIHA1LlNjb3JlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBhcnRzW3RoaXMuY3VycmVudFBhcnRdLnN0YXJ0KCk7XG4gICAgdGhpcy5zY29yZVN0ZXAgPSAwO1xuICB9O1xuICAvKipcbiAgICogIFN0b3AgcGxheWJhY2sgb2YgdGhlIHNjb3JlLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgc3RvcFxuICAgKiAgQGZvciBwNS5TY29yZVxuICAgKi9cblxuXG4gIHA1LlNjb3JlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucGFydHNbdGhpcy5jdXJyZW50UGFydF0uc3RvcCgpO1xuICAgIHRoaXMuY3VycmVudFBhcnQgPSAwO1xuICAgIHRoaXMuc2NvcmVTdGVwID0gMDtcbiAgfTtcbiAgLyoqXG4gICAqICBQYXVzZSBwbGF5YmFjayBvZiB0aGUgc2NvcmUuXG4gICAqXG4gICAqICBAbWV0aG9kICBwYXVzZVxuICAgKiAgQGZvciBwNS5TY29yZVxuICAgKi9cblxuXG4gIHA1LlNjb3JlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBhcnRzW3RoaXMuY3VycmVudFBhcnRdLnN0b3AoKTtcbiAgfTtcbiAgLyoqXG4gICAqICBMb29wIHBsYXliYWNrIG9mIHRoZSBzY29yZS5cbiAgICpcbiAgICogIEBtZXRob2QgIGxvb3BcbiAgICogIEBmb3IgcDUuU2NvcmVcbiAgICovXG5cblxuICBwNS5TY29yZS5wcm90b3R5cGUubG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxvb3BpbmcgPSB0cnVlO1xuICAgIHRoaXMuc3RhcnQoKTtcbiAgfTtcbiAgLyoqXG4gICAqICBTdG9wIGxvb3BpbmcgcGxheWJhY2sgb2YgdGhlIHNjb3JlLiBJZiBpdFxuICAgKiAgaXMgY3VycmVudGx5IHBsYXlpbmcsIHRoaXMgd2lsbCBnbyBpbnRvIGVmZmVjdFxuICAgKiAgYWZ0ZXIgdGhlIGN1cnJlbnQgcm91bmQgb2YgcGxheWJhY2sgY29tcGxldGVzLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgbm9Mb29wXG4gICAqICBAZm9yIHA1LlNjb3JlXG4gICAqL1xuXG5cbiAgcDUuU2NvcmUucHJvdG90eXBlLm5vTG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxvb3BpbmcgPSBmYWxzZTtcbiAgfTtcblxuICBwNS5TY29yZS5wcm90b3R5cGUucmVzZXRQYXJ0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5wYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICBzZWxmLnJlc2V0UGFydHNbcGFydF07XG4gICAgfSk7XG4gIH07XG5cbiAgcDUuU2NvcmUucHJvdG90eXBlLnJlc2V0UGFydCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgdGhpcy5wYXJ0c1tpXS5zdG9wKCk7XG4gICAgdGhpcy5wYXJ0c1tpXS5wYXJ0U3RlcCA9IDA7XG5cbiAgICBmb3IgKHZhciBwIGluIHRoaXMucGFydHNbaV0ucGhyYXNlcykge1xuICAgICAgaWYgKHRoaXMucGFydHNbaV0pIHtcbiAgICAgICAgdGhpcy5wYXJ0c1tpXS5waHJhc2VzW3BdLnBocmFzZVN0ZXAgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBTZXQgdGhlIHRlbXBvIGZvciBhbGwgcGFydHMgaW4gdGhlIHNjb3JlXG4gICAqXG4gICAqICBAbWV0aG9kIHNldEJQTVxuICAgKiAgQGZvciBwNS5TY29yZVxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IEJQTSAgICAgIEJlYXRzIFBlciBNaW51dGVcbiAgICogIEBwYXJhbSB7TnVtYmVyfSByYW1wVGltZSBTZWNvbmRzIGZyb20gbm93XG4gICAqL1xuXG5cbiAgcDUuU2NvcmUucHJvdG90eXBlLnNldEJQTSA9IGZ1bmN0aW9uIChicG0sIHJhbXBUaW1lKSB7XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLnBhcnRzKSB7XG4gICAgICBpZiAodGhpcy5wYXJ0c1tpXSkge1xuICAgICAgICB0aGlzLnBhcnRzW2ldLnNldEJQTShicG0sIHJhbXBUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gcGxheU5leHRQYXJ0KGFTY29yZSkge1xuICAgIGFTY29yZS5jdXJyZW50UGFydCsrO1xuXG4gICAgaWYgKGFTY29yZS5jdXJyZW50UGFydCA+PSBhU2NvcmUucGFydHMubGVuZ3RoKSB7XG4gICAgICBhU2NvcmUuc2NvcmVTdGVwID0gMDtcbiAgICAgIGFTY29yZS5vbmVuZGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFTY29yZS5zY29yZVN0ZXAgPSAwO1xuICAgICAgYVNjb3JlLnBhcnRzW2FTY29yZS5jdXJyZW50UGFydCAtIDFdLnN0b3AoKTtcbiAgICAgIGFTY29yZS5wYXJ0c1thU2NvcmUuY3VycmVudFBhcnRdLnN0YXJ0KCk7XG4gICAgfVxuICB9XG59KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuIH0pLFxuIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cbiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgdmFyIHA1c291bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBDbG9jayA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuICAvKipcbiAgICogU291bmRMb29wXG4gICAqXG4gICAqIEBjbGFzcyBwNS5Tb3VuZExvb3BcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgb24gZWFjaCBpdGVyYXRpb24gb2YgdGhlbG9vcFxuICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtpbnRlcnZhbF0gYW1vdW50IG9mIHRpbWUgKGlmIGEgbnVtYmVyKSBvciBiZWF0cyAoaWYgYSBzdHJpbmcsIGZvbGxvd2luZyA8YSBocmVmID0gXCJodHRwczovL2dpdGh1Yi5jb20vVG9uZWpzL1RvbmUuanMvd2lraS9UaW1lXCI+VG9uZS5UaW1lPC9hPiBjb252ZW50aW9uKSBmb3IgZWFjaCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuIERlZmF1bHRzIHRvIDEgc2Vjb25kLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiA8ZGl2Pjxjb2RlPlxuICAgKiAgbGV0IHN5bnRoLCBzb3VuZExvb3A7XG4gICAqICBsZXQgbm90ZVBhdHRlcm4gPSBbNjAsIDYyLCA2NCwgNjcsIDY5LCA3Ml07XG4gICAqXG4gICAqICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICogICAgbGV0IGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAqICAgIGNudi5tb3VzZVByZXNzZWQoY2FudmFzUHJlc3NlZCk7XG4gICAqICAgIGNvbG9yTW9kZShIU0IpO1xuICAgKiAgICBiYWNrZ3JvdW5kKDAsIDAsIDg2KTtcbiAgICogICAgdGV4dCgndGFwIHRvIHN0YXJ0L3N0b3AnLCAxMCwgMjApO1xuICAgKlxuICAgKiAgICAvL3RoZSBsb29wZXIncyBjYWxsYmFjayBpcyBwYXNzZWQgdGhlIHRpbWVGcm9tTm93XG4gICAqICAgIC8vdGhpcyB2YWx1ZSBzaG91bGQgYmUgdXNlZCBhcyBhIHJlZmVyZW5jZSBwb2ludCBmcm9tXG4gICAqICAgIC8vd2hpY2ggdG8gc2NoZWR1bGUgc291bmRzXG4gICAqICAgIGxldCBpbnRlcnZhbEluU2Vjb25kcyA9IDAuMjtcbiAgICogICAgc291bmRMb29wID0gbmV3IHA1LlNvdW5kTG9vcChvblNvdW5kTG9vcCwgaW50ZXJ2YWxJblNlY29uZHMpO1xuICAgKlxuICAgKiAgICBzeW50aCA9IG5ldyBwNS5Nb25vU3ludGgoKTtcbiAgICogfVxuICAgKlxuICAgKiBmdW5jdGlvbiBjYW52YXNQcmVzc2VkKCkge1xuICAgKiAgIC8vIGVuc3VyZSBhdWRpbyBpcyBlbmFibGVkXG4gICAqICAgdXNlclN0YXJ0QXVkaW8oKTtcbiAgICpcbiAgICogICBpZiAoc291bmRMb29wLmlzUGxheWluZykge1xuICAgKiAgICAgc291bmRMb29wLnN0b3AoKTtcbiAgICogICB9IGVsc2Uge1xuICAgKiAgICAgLy8gc3RhcnQgdGhlIGxvb3BcbiAgICogICAgIHNvdW5kTG9vcC5zdGFydCgpO1xuICAgKiAgIH1cbiAgICogfVxuICAgKlxuICAgKiBmdW5jdGlvbiBvblNvdW5kTG9vcCh0aW1lRnJvbU5vdykge1xuICAgKiAgIGxldCBub3RlSW5kZXggPSAoc291bmRMb29wLml0ZXJhdGlvbnMgLSAxKSAlIG5vdGVQYXR0ZXJuLmxlbmd0aDtcbiAgICogICBsZXQgbm90ZSA9IG1pZGlUb0ZyZXEobm90ZVBhdHRlcm5bbm90ZUluZGV4XSk7XG4gICAqICAgc3ludGgucGxheShub3RlLCAwLjUsIHRpbWVGcm9tTm93KTtcbiAgICogICBiYWNrZ3JvdW5kKG5vdGVJbmRleCAqIDM2MCAvIG5vdGVQYXR0ZXJuLmxlbmd0aCwgNTAsIDEwMCk7XG4gICAqIH1cbiAgICogPC9jb2RlPjwvZGl2PlxuICAgKi9cblxuXG4gIHA1LlNvdW5kTG9vcCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgaW50ZXJ2YWwpIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgLyoqXG4gICAgICogbXVzaWNhbFRpbWVNb2RlIHVzZXMgPGEgaHJlZiA9IFwiaHR0cHM6Ly9naXRodWIuY29tL1RvbmVqcy9Ub25lLmpzL3dpa2kvVGltZVwiPlRvbmUuVGltZTwvYT4gY29udmVudGlvblxuICAgICAqIHRydWUgaWYgc3RyaW5nLCBmYWxzZSBpZiBudW1iZXJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IG11c2ljYWxUaW1lTW9kZVxuICAgICAqL1xuXG4gICAgdGhpcy5tdXNpY2FsVGltZU1vZGUgPSB0eXBlb2YgdGhpcy5faW50ZXJ2YWwgPT09ICdudW1iZXInID8gZmFsc2UgOiB0cnVlO1xuICAgIHRoaXMuX2ludGVydmFsID0gaW50ZXJ2YWwgfHwgMTtcbiAgICAvKipcbiAgICAgKiBtdXNpY2FsVGltZU1vZGUgdmFyaWFibGVzXG4gICAgICogbW9kaWZ5IHRoZXNlIG9ubHkgd2hlbiB0aGUgaW50ZXJ2YWwgaXMgc3BlY2lmaWVkIGluIG11c2ljYWxUaW1lIGZvcm1hdCBhcyBhIHN0cmluZ1xuICAgICAqL1xuXG4gICAgdGhpcy5fdGltZVNpZ25hdHVyZSA9IDQ7XG4gICAgdGhpcy5fYnBtID0gNjA7XG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBTZXQgYSBsaW1pdCB0byB0aGUgbnVtYmVyIG9mIGxvb3BzIHRvIHBsYXkuIGRlZmF1bHRzIHRvIEluZmluaXR5XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG1heEl0ZXJhdGlvbnNcbiAgICAgKi9cblxuICAgIHRoaXMubWF4SXRlcmF0aW9ucyA9IEluZmluaXR5O1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmNsb2NrID0gbmV3IENsb2NrKHtcbiAgICAgICdjYWxsYmFjayc6IGZ1bmN0aW9uIGNhbGxiYWNrKHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWVGcm9tTm93ID0gdGltZSAtIHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgICAvKipcbiAgICAgICAgICogRG8gbm90IGluaXRpYXRlIHRoZSBjYWxsYmFjayBpZiB0aW1lRnJvbU5vdyBpcyA8IDBcbiAgICAgICAgICogVGhpcyB1c3VzdWFsbHkgb2NjdXJzIGZvciBhIGZldyBtaWxsaXNlY29uZHMgd2hlbiB0aGUgcGFnZVxuICAgICAgICAgKiBpcyBub3QgZnVsbHkgbG9hZGVkXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBjYWxsYmFjayBzaG91bGQgb25seSBiZSBjYWxsZWQgdW50aWwgbWF4SXRlcmF0aW9ucyBpcyByZWFjaGVkXG4gICAgICAgICAqL1xuXG4gICAgICAgIGlmICh0aW1lRnJvbU5vdyA+IDAgJiYgc2VsZi5pdGVyYXRpb25zIDw9IHNlbGYubWF4SXRlcmF0aW9ucykge1xuICAgICAgICAgIHNlbGYuY2FsbGJhY2sodGltZUZyb21Ob3cpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ2ZyZXF1ZW5jeSc6IHRoaXMuX2NhbGNGcmVxKClcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBsb29wXG4gICAqIEBtZXRob2QgIHN0YXJ0XG4gICAqIEBmb3IgcDUuU291bmRMb29wXG4gICAqIEBwYXJhbSAge051bWJlcn0gW3RpbWVGcm9tTm93XSBzY2hlZHVsZSBhIHN0YXJ0aW5nIHRpbWVcbiAgICovXG5cblxuICBwNS5Tb3VuZExvb3AucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWVGcm9tTm93KSB7XG4gICAgdmFyIHQgPSB0aW1lRnJvbU5vdyB8fCAwO1xuICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcblxuICAgIGlmICghdGhpcy5pc1BsYXlpbmcpIHtcbiAgICAgIHRoaXMuY2xvY2suc3RhcnQobm93ICsgdCk7XG4gICAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogU3RvcCB0aGUgbG9vcFxuICAgKiBAbWV0aG9kICBzdG9wXG4gICAqIEBmb3IgcDUuU291bmRMb29wXG4gICAqIEBwYXJhbSAge051bWJlcn0gW3RpbWVGcm9tTm93XSBzY2hlZHVsZSBhIHN0b3BwaW5nIHRpbWVcbiAgICovXG5cblxuICBwNS5Tb3VuZExvb3AucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZUZyb21Ob3cpIHtcbiAgICB2YXIgdCA9IHRpbWVGcm9tTm93IHx8IDA7XG4gICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuXG4gICAgaWYgKHRoaXMuaXNQbGF5aW5nKSB7XG4gICAgICB0aGlzLmNsb2NrLnN0b3Aobm93ICsgdCk7XG4gICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBsb29wXG4gICAqIEBtZXRob2QgcGF1c2VcbiAgICogQGZvciBwNS5Tb3VuZExvb3BcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbdGltZUZyb21Ob3ddIHNjaGVkdWxlIGEgcGF1c2luZyB0aW1lXG4gICAqL1xuXG5cbiAgcDUuU291bmRMb29wLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICh0aW1lRnJvbU5vdykge1xuICAgIHZhciB0ID0gdGltZUZyb21Ob3cgfHwgMDtcbiAgICB2YXIgbm93ID0gcDVzb3VuZC5hdWRpb2NvbnRleHQuY3VycmVudFRpbWU7XG5cbiAgICBpZiAodGhpcy5pc1BsYXlpbmcpIHtcbiAgICAgIHRoaXMuY2xvY2sucGF1c2Uobm93ICsgdCk7XG4gICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFN5bmNocm9uaXplIGxvb3BzLiBVc2UgdGhpcyBtZXRob2QgdG8gc3RhcnQgdHdvIG1vcmUgbW9yZSBsb29wcyBpbiBzeW5jaHJvbml6YXRpb25cbiAgICogb3IgdG8gc3RhcnQgYSBsb29wIGluIHN5bmNocm9uaXphdGlvbiB3aXRoIGEgbG9vcCB0aGF0IGlzIGFscmVhZHkgcGxheWluZ1xuICAgKiBUaGlzIG1ldGhvZCB3aWxsIHNjaGVkdWxlIHRoZSBpbXBsaWNpdCBsb29wIGluIHN5bmMgd2l0aCB0aGUgZXhwbGljaXQgbWFzdGVyIGxvb3BcbiAgICogaS5lLiBsb29wVG9TdGFydC5zeW5jZWRTdGFydChsb29wVG9TeW5jV2l0aClcbiAgICpcbiAgICogQG1ldGhvZCAgc3luY2VkU3RhcnRcbiAgICogQGZvciBwNS5Tb3VuZExvb3BcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvdGhlckxvb3AgICBhIHA1LlNvdW5kTG9vcCB0byBzeW5jIHdpdGhcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbdGltZUZyb21Ob3ddIFN0YXJ0IHRoZSBsb29wcyBpbiBzeW5jIGFmdGVyIHRpbWVGcm9tTm93IHNlY29uZHNcbiAgICovXG5cblxuICBwNS5Tb3VuZExvb3AucHJvdG90eXBlLnN5bmNlZFN0YXJ0ID0gZnVuY3Rpb24gKG90aGVyTG9vcCwgdGltZUZyb21Ob3cpIHtcbiAgICB2YXIgdCA9IHRpbWVGcm9tTm93IHx8IDA7XG4gICAgdmFyIG5vdyA9IHA1c291bmQuYXVkaW9jb250ZXh0LmN1cnJlbnRUaW1lO1xuXG4gICAgaWYgKCFvdGhlckxvb3AuaXNQbGF5aW5nKSB7XG4gICAgICBvdGhlckxvb3AuY2xvY2suc3RhcnQobm93ICsgdCk7XG4gICAgICBvdGhlckxvb3AuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2xvY2suc3RhcnQobm93ICsgdCk7XG4gICAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChvdGhlckxvb3AuaXNQbGF5aW5nKSB7XG4gICAgICB2YXIgdGltZSA9IG90aGVyTG9vcC5jbG9jay5fbmV4dFRpY2sgLSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICAgIHRoaXMuY2xvY2suc3RhcnQobm93ICsgdGltZSk7XG4gICAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogVXBkYXRlcyBmcmVxdWVuY3kgdmFsdWUsIHJlZmxlY3RlZCBpbiBuZXh0IGNhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqIEBmb3IgcDUuU291bmRMb29wXG4gICAqIEBtZXRob2QgIF91cGRhdGVcbiAgICovXG5cblxuICBwNS5Tb3VuZExvb3AucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbG9jay5mcmVxdWVuY3kudmFsdWUgPSB0aGlzLl9jYWxjRnJlcSgpO1xuICB9O1xuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBmcmVxdWVuY3kgb2YgdGhlIGNsb2NrJ3MgY2FsbGJhY2sgYmFzZWQgb24gYnBtLCBpbnRlcnZhbCwgYW5kIHRpbWVzaWduYXR1cmVcbiAgICogQHByaXZhdGVcbiAgICogQGZvciBwNS5Tb3VuZExvb3BcbiAgICogQG1ldGhvZCAgX2NhbGNGcmVxXG4gICAqIEByZXR1cm4ge051bWJlcn0gbmV3IGNsb2NrIGZyZXF1ZW5jeSB2YWx1ZVxuICAgKi9cblxuXG4gIHA1LlNvdW5kTG9vcC5wcm90b3R5cGUuX2NhbGNGcmVxID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5faW50ZXJ2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLm11c2ljYWxUaW1lTW9kZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIDEgLyB0aGlzLl9pbnRlcnZhbDtcbiAgICB9IFxuICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pbnRlcnZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5tdXNpY2FsVGltZU1vZGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5fYnBtIC8gNjAgLyB0aGlzLl9jb252ZXJ0Tm90YXRpb24odGhpcy5faW50ZXJ2YWwpICogKHRoaXMuX3RpbWVTaWduYXR1cmUgLyA0KTtcbiAgICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnQgbm90YXRpb24gZnJvbSBtdXNpY2FsIHRpbWUgZm9ybWF0IHRvIHNlY29uZHNcbiAgICogVXNlcyA8YSBocmVmID0gXCJodHRwczovL2dpdGh1Yi5jb20vVG9uZWpzL1RvbmUuanMvd2lraS9UaW1lXCI+VG9uZS5UaW1lPC9hPiBjb252ZW50aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEBmb3IgcDUuU291bmRMb29wXG4gICAqIEBtZXRob2QgX2NvbnZlcnROb3RhdGlvblxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHZhbHVlIHZhbHVlIHRvIGJlIGNvbnZlcnRlZFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgIGNvbnZlcnRlZCB2YWx1ZSBpbiBzZWNvbmRzXG4gICAqL1xuXG5cbiAgcDUuU291bmRMb29wLnByb3RvdHlwZS5fY29udmVydE5vdGF0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSB2YWx1ZS5zbGljZSgtMSk7XG4gICAgdmFsdWUgPSBOdW1iZXIodmFsdWUuc2xpY2UoMCwgLTEpKTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnbSc6XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWFzdXJlKHZhbHVlKTtcblxuICAgICAgY2FzZSAnbic6XG4gICAgICAgIHJldHVybiB0aGlzLl9ub3RlKHZhbHVlKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKCdTcGVjaWZpZWQgaW50ZXJ2YWwgaXMgbm90IGZvcm1hdHRlZCBjb3JyZWN0bHkuIFNlZSBUb25lLmpzICcgKyAndGltaW5nIHJlZmVyZW5jZSBmb3IgbW9yZSBpbmZvOiBodHRwczovL2dpdGh1Yi5jb20vVG9uZWpzL1RvbmUuanMvd2lraS9UaW1lJyk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogSGVscGVyIGNvbnZlcnNpb24gbWV0aG9kcyBvZiBtZWFzdXJlIGFuZCBub3RlXG4gICAqIEBwcml2YXRlXG4gICAqIEBmb3IgcDUuU291bmRMb29wXG4gICAqIEBtZXRob2QgIF9tZWFzdXJlXG4gICAqL1xuXG5cbiAgcDUuU291bmRMb29wLnByb3RvdHlwZS5fbWVhc3VyZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAqIHRoaXMuX3RpbWVTaWduYXR1cmU7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kICBfbm90ZVxuICAgKiBAZm9yIHA1LlNvdW5kTG9vcFxuICAgKi9cblxuXG4gIHA1LlNvdW5kTG9vcC5wcm90b3R5cGUuX25vdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZVNpZ25hdHVyZSAvIHZhbHVlO1xuICB9O1xuICAvKipcbiAgICogR2V0dGVycyBhbmQgU2V0dGVycywgc2V0dGluZyBhbnkgcGFyYW10ZXIgd2lsbCByZXN1bHQgaW4gYSBjaGFuZ2UgaW4gdGhlIGNsb2NrJ3NcbiAgICogZnJlcXVlbmN5LCB0aGF0IHdpbGwgYmUgcmVmbGVjdGVkIGFmdGVyIHRoZSBuZXh0IGNhbGxiYWNrXG4gICAqIGJlYXRzIHBlciBtaW51dGUgKGRlZmF1bHRzIHRvIDYwKVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gYnBtXG4gICAqIEBmb3IgcDUuU291bmRMb29wXG4gICAqL1xuXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHA1LlNvdW5kTG9vcC5wcm90b3R5cGUsICdicG0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYnBtO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoYnBtKSB7XG4gICAgICBpZiAoIXRoaXMubXVzaWNhbFRpbWVNb2RlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ2hhbmdpbmcgdGhlIEJQTSBpbiBcInNlY29uZHNcIiBtb2RlIGhhcyBubyBlZmZlY3QuICcgKyAnQlBNIGlzIG9ubHkgcmVsZXZhbnQgaW4gbXVzaWNhbFRpbWVNb2RlICcgKyAnd2hlbiB0aGUgaW50ZXJ2YWwgaXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nICcgKyAnKFwiMm5cIiwgXCI0blwiLCBcIjFtXCIuLi5ldGMpJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2JwbSA9IGJwbTtcblxuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIG51bWJlciBvZiBxdWFydGVyIG5vdGVzIGluIGEgbWVhc3VyZSAoZGVmYXVsdHMgdG8gNClcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHRpbWVTaWduYXR1cmVcbiAgICogQGZvciBwNS5Tb3VuZExvb3BcbiAgICovXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHA1LlNvdW5kTG9vcC5wcm90b3R5cGUsICd0aW1lU2lnbmF0dXJlJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RpbWVTaWduYXR1cmU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0aW1lU2lnKSB7XG4gICAgICBpZiAoIXRoaXMubXVzaWNhbFRpbWVNb2RlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ2hhbmdpbmcgdGhlIHRpbWVTaWduYXR1cmUgaW4gXCJzZWNvbmRzXCIgbW9kZSBoYXMgbm8gZWZmZWN0LiAnICsgJ0JQTSBpcyBvbmx5IHJlbGV2YW50IGluIG11c2ljYWxUaW1lTW9kZSAnICsgJ3doZW4gdGhlIGludGVydmFsIGlzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAnICsgJyhcIjJuXCIsIFwiNG5cIiwgXCIxbVwiLi4uZXRjKScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl90aW1lU2lnbmF0dXJlID0gdGltZVNpZztcblxuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIGxlbmd0aCBvZiB0aGUgbG9vcHMgaW50ZXJ2YWxcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ8U3RyaW5nfSBpbnRlcnZhbFxuICAgKiBAZm9yIHA1LlNvdW5kTG9vcFxuICAgKi9cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocDUuU291bmRMb29wLnByb3RvdHlwZSwgJ2ludGVydmFsJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ludGVydmFsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoaW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMubXVzaWNhbFRpbWVNb2RlID0gdHlwZW9mIGludGVydmFsID09PSAnTnVtYmVyJyA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgIHRoaXMuX2ludGVydmFsID0gaW50ZXJ2YWw7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBob3cgbWFueSB0aW1lcyB0aGUgY2FsbGJhY2sgaGFzIGJlZW4gY2FsbGVkIHNvIGZhclxuICAgKiBAcHJvcGVydHkge051bWJlcn0gaXRlcmF0aW9uc1xuICAgKiBAZm9yIHA1LlNvdW5kTG9vcFxuICAgKiBAcmVhZG9ubHlcbiAgICovXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHA1LlNvdW5kTG9vcC5wcm90b3R5cGUsICdpdGVyYXRpb25zJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvY2sudGlja3M7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHA1LlNvdW5kTG9vcDtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHA1c291bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4gIHZhciBFZmZlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG4gIHZhciBDdXN0b21FcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuICAvKipcbiAgICogQ29tcHJlc3NvciBpcyBhbiBhdWRpbyBlZmZlY3QgY2xhc3MgdGhhdCBwZXJmb3JtcyBkeW5hbWljcyBjb21wcmVzc2lvblxuICAgKiBvbiBhbiBhdWRpbyBpbnB1dCBzb3VyY2UuIFRoaXMgaXMgYSB2ZXJ5IGNvbW1vbmx5IHVzZWQgdGVjaG5pcXVlIGluIG11c2ljXG4gICAqIGFuZCBzb3VuZCBwcm9kdWN0aW9uLiBDb21wcmVzc2lvbiBjcmVhdGVzIGFuIG92ZXJhbGwgbG91ZGVyLCByaWNoZXIsXG4gICAqIGFuZCBmdWxsZXIgc291bmQgYnkgbG93ZXJpbmcgdGhlIHZvbHVtZSBvZiBsb3VkcyBhbmQgcmFpc2luZyB0aGF0IG9mIHNvZnRzLlxuICAgKiBDb21wcmVzc2lvbiBjYW4gYmUgdXNlZCB0byBhdm9pZCBjbGlwcGluZyAoc291bmQgZGlzdG9ydGlvbiBkdWUgdG9cbiAgICogcGVha3MgaW4gdm9sdW1lKSBhbmQgaXMgZXNwZWNpYWxseSB1c2VmdWwgd2hlbiBtYW55IHNvdW5kcyBhcmUgcGxheWVkXG4gICAqIGF0IG9uY2UuIENvbXByZXNzaW9uIGNhbiBiZSB1c2VkIG9uIGluZGl2dWRhbCBzb3VuZCBzb3VyY2VzIGluIGFkZGl0aW9uXG4gICAqIHRvIHRoZSBtYXN0ZXIgb3V0cHV0LlxuICAgKlxuICAgKiBUaGlzIGNsYXNzIGV4dGVuZHMgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdFwiPnA1LkVmZmVjdDwvYT4uXG4gICAqIE1ldGhvZHMgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9hbXBcIj5hbXAoKTwvYT4sIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvY2hhaW5cIj5jaGFpbigpPC9hPixcbiAgICogPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9kcnl3ZXRcIj5kcnl3ZXQoKTwvYT4sIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvY29ubmVjdFwiPmNvbm5lY3QoKTwvYT4sIGFuZFxuICAgKiA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2Rpc2Nvbm5lY3RcIj5kaXNjb25uZWN0KCk8L2E+IGFyZSBhdmFpbGFibGUuXG4gICAqXG4gICAqIEBjbGFzcyBwNS5Db21wcmVzc29yXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBwNS5FZmZlY3RcbiAgICpcbiAgICpcbiAgICovXG5cblxuICBwNS5Db21wcmVzc29yID0gZnVuY3Rpb24gKCkge1xuICAgIEVmZmVjdC5jYWxsKHRoaXMpO1xuICAgIC8qKlxuICAgICAqIFRoZSBwNS5Db21wcmVzc29yIGlzIGJ1aWx0IHdpdGggYSA8YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1ZGlvLyN0aGUtZHluYW1pY3Njb21wcmVzc29ybm9kZS1pbnRlcmZhY2VcIlxuICAgICogICB0YXJnZXQ9XCJfYmxhbmtcIiB0aXRsZT1cIlczIHNwZWMgZm9yIER5bmFtaWNzIENvbXByZXNzb3IgTm9kZVwiPldlYiBBdWRpbyBEeW5hbWljcyBDb21wcmVzc29yIE5vZGVcbiAgICAqICAgPC9hPlxuICAgICAqIEBwcm9wZXJ0eSB7QXVkaW9Ob2RlfSBjb21wcmVzc29yXG4gICAgICovXG5cbiAgICB0aGlzLmNvbXByZXNzb3IgPSB0aGlzLmFjLmNyZWF0ZUR5bmFtaWNzQ29tcHJlc3NvcigpO1xuICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLmNvbXByZXNzb3IpO1xuICAgIHRoaXMuY29tcHJlc3Nvci5jb25uZWN0KHRoaXMud2V0KTtcbiAgfTtcblxuICBwNS5Db21wcmVzc29yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRWZmZWN0LnByb3RvdHlwZSk7XG4gIC8qKlxuICAgKiBQZXJmb3JtcyB0aGUgc2FtZSBmdW5jdGlvbiBhcyAuY29ubmVjdCwgYnV0IGFsc28gYWNjZXB0c1xuICAgKiBvcHRpb25hbCBwYXJhbWV0ZXJzIHRvIHNldCBjb21wcmVzc29yJ3MgYXVkaW9QYXJhbXNcbiAgICogQG1ldGhvZCBwcm9jZXNzXG4gICAqIEBmb3IgcDUuQ29tcHJlc3NvclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjICAgICAgICAgU291bmQgc291cmNlIHRvIGJlIGNvbm5lY3RlZFxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2F0dGFja10gICAgIFRoZSBhbW91bnQgb2YgdGltZSAoaW4gc2Vjb25kcykgdG8gcmVkdWNlIHRoZSBnYWluIGJ5IDEwZEIsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgPSAuMDAzLCByYW5nZSAwIC0gMVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2tuZWVdICAgICAgIEEgZGVjaWJlbCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHJhbmdlIGFib3ZlIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGQgd2hlcmUgdGhlIGN1cnZlIHNtb290aGx5IHRyYW5zaXRpb25zIHRvIHRoZSBcInJhdGlvXCIgcG9ydGlvbi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA9IDMwLCByYW5nZSAwIC0gNDBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYXRpb10gICAgICBUaGUgYW1vdW50IG9mIGRCIGNoYW5nZSBpbiBpbnB1dCBmb3IgYSAxIGRCIGNoYW5nZSBpbiBvdXRwdXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA9IDEyLCByYW5nZSAxIC0gMjBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aHJlc2hvbGRdICBUaGUgZGVjaWJlbCB2YWx1ZSBhYm92ZSB3aGljaCB0aGUgY29tcHJlc3Npb24gd2lsbCBzdGFydCB0YWtpbmcgZWZmZWN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgPSAtMjQsIHJhbmdlIC0xMDAgLSAwXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcmVsZWFzZV0gICAgVGhlIGFtb3VudCBvZiB0aW1lIChpbiBzZWNvbmRzKSB0byBpbmNyZWFzZSB0aGUgZ2FpbiBieSAxMGRCXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgPSAuMjUsIHJhbmdlIDAgLSAxXG4gICAqL1xuXG4gIHA1LkNvbXByZXNzb3IucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoc3JjLCBhdHRhY2ssIGtuZWUsIHJhdGlvLCB0aHJlc2hvbGQsIHJlbGVhc2UpIHtcbiAgICBzcmMuY29ubmVjdCh0aGlzLmlucHV0KTtcbiAgICB0aGlzLnNldChhdHRhY2ssIGtuZWUsIHJhdGlvLCB0aHJlc2hvbGQsIHJlbGVhc2UpO1xuICB9O1xuICAvKipcbiAgICogU2V0IHRoZSBwYXJhbXRlcnMgb2YgYSBjb21wcmVzc29yLlxuICAgKiBAbWV0aG9kICBzZXRcbiAgICogQGZvciBwNS5Db21wcmVzc29yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhdHRhY2sgICAgIFRoZSBhbW91bnQgb2YgdGltZSAoaW4gc2Vjb25kcykgdG8gcmVkdWNlIHRoZSBnYWluIGJ5IDEwZEIsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgPSAuMDAzLCByYW5nZSAwIC0gMVxuICAgKiBAcGFyYW0ge051bWJlcn0ga25lZSAgICAgICBBIGRlY2liZWwgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSByYW5nZSBhYm92ZSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkIHdoZXJlIHRoZSBjdXJ2ZSBzbW9vdGhseSB0cmFuc2l0aW9ucyB0byB0aGUgXCJyYXRpb1wiIHBvcnRpb24uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgPSAzMCwgcmFuZ2UgMCAtIDQwXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByYXRpbyAgICAgIFRoZSBhbW91bnQgb2YgZEIgY2hhbmdlIGluIGlucHV0IGZvciBhIDEgZEIgY2hhbmdlIGluIG91dHB1dFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0ID0gMTIsIHJhbmdlIDEgLSAyMFxuICAgKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkICBUaGUgZGVjaWJlbCB2YWx1ZSBhYm92ZSB3aGljaCB0aGUgY29tcHJlc3Npb24gd2lsbCBzdGFydCB0YWtpbmcgZWZmZWN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgPSAtMjQsIHJhbmdlIC0xMDAgLSAwXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByZWxlYXNlICAgIFRoZSBhbW91bnQgb2YgdGltZSAoaW4gc2Vjb25kcykgdG8gaW5jcmVhc2UgdGhlIGdhaW4gYnkgMTBkQlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0ID0gLjI1LCByYW5nZSAwIC0gMVxuICAgKi9cblxuXG4gIHA1LkNvbXByZXNzb3IucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChhdHRhY2ssIGtuZWUsIHJhdGlvLCB0aHJlc2hvbGQsIHJlbGVhc2UpIHtcbiAgICBpZiAodHlwZW9mIGF0dGFjayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuYXR0YWNrKGF0dGFjayk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBrbmVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5rbmVlKGtuZWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmF0aW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnJhdGlvKHJhdGlvKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRocmVzaG9sZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMudGhyZXNob2xkKHRocmVzaG9sZCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZWxlYXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5yZWxlYXNlKHJlbGVhc2UpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IGF0dGFjayBvciBzZXQgdmFsdWUgdy8gdGltZSByYW1wXG4gICAqXG4gICAqXG4gICAqIEBtZXRob2QgYXR0YWNrXG4gICAqIEBmb3IgcDUuQ29tcHJlc3NvclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2F0dGFja10gQXR0YWNrIGlzIHRoZSBhbW91bnQgb2YgdGltZSAoaW4gc2Vjb25kcykgdG8gcmVkdWNlIHRoZSBnYWluIGJ5IDEwZEIsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0ID0gLjAwMywgcmFuZ2UgMCAtIDFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lXSAgQXNzaWduIHRpbWUgdmFsdWUgdG8gc2NoZWR1bGUgdGhlIGNoYW5nZSBpbiB2YWx1ZVxuICAgKi9cblxuXG4gIHA1LkNvbXByZXNzb3IucHJvdG90eXBlLmF0dGFjayA9IGZ1bmN0aW9uIChhdHRhY2ssIHRpbWUpIHtcbiAgICB2YXIgdCA9IHRpbWUgfHwgMDtcblxuICAgIGlmICh0eXBlb2YgYXR0YWNrID09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmNvbXByZXNzb3IuYXR0YWNrLnZhbHVlID0gYXR0YWNrO1xuICAgICAgdGhpcy5jb21wcmVzc29yLmF0dGFjay5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDEgKyB0KTtcbiAgICAgIHRoaXMuY29tcHJlc3Nvci5hdHRhY2subGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoYXR0YWNrLCB0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMiArIHQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGF0dGFjayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGF0dGFjay5jb25uZWN0KHRoaXMuY29tcHJlc3Nvci5hdHRhY2spO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXByZXNzb3IuYXR0YWNrLnZhbHVlO1xuICB9O1xuICAvKipcbiAgICAqIEdldCBjdXJyZW50IGtuZWUgb3Igc2V0IHZhbHVlIHcvIHRpbWUgcmFtcFxuICAgICpcbiAgICAqIEBtZXRob2Qga25lZVxuICAgICogQGZvciBwNS5Db21wcmVzc29yXG4gICAgKiBAcGFyYW0ge051bWJlcn0gW2tuZWVdIEEgZGVjaWJlbCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHJhbmdlIGFib3ZlIHRoZVxuICAgICogICAgICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGQgd2hlcmUgdGhlIGN1cnZlIHNtb290aGx5IHRyYW5zaXRpb25zIHRvIHRoZSBcInJhdGlvXCIgcG9ydGlvbi5cbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA9IDMwLCByYW5nZSAwIC0gNDBcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZV0gIEFzc2lnbiB0aW1lIHZhbHVlIHRvIHNjaGVkdWxlIHRoZSBjaGFuZ2UgaW4gdmFsdWVcbiAgICAqL1xuXG5cbiAgcDUuQ29tcHJlc3Nvci5wcm90b3R5cGUua25lZSA9IGZ1bmN0aW9uIChrbmVlLCB0aW1lKSB7XG4gICAgdmFyIHQgPSB0aW1lIHx8IDA7XG5cbiAgICBpZiAodHlwZW9mIGtuZWUgPT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuY29tcHJlc3Nvci5rbmVlLnZhbHVlID0ga25lZTtcbiAgICAgIHRoaXMuY29tcHJlc3Nvci5rbmVlLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMSArIHQpO1xuICAgICAgdGhpcy5jb21wcmVzc29yLmtuZWUubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoa25lZSwgdGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDIgKyB0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBrbmVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAga25lZS5jb25uZWN0KHRoaXMuY29tcHJlc3Nvci5rbmVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb21wcmVzc29yLmtuZWUudmFsdWU7XG4gIH07XG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCByYXRpbyBvciBzZXQgdmFsdWUgdy8gdGltZSByYW1wXG4gICAqIEBtZXRob2QgcmF0aW9cbiAgICogQGZvciBwNS5Db21wcmVzc29yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcmF0aW9dICAgICAgVGhlIGFtb3VudCBvZiBkQiBjaGFuZ2UgaW4gaW5wdXQgZm9yIGEgMSBkQiBjaGFuZ2UgaW4gb3V0cHV0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgPSAxMiwgcmFuZ2UgMSAtIDIwXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZV0gIEFzc2lnbiB0aW1lIHZhbHVlIHRvIHNjaGVkdWxlIHRoZSBjaGFuZ2UgaW4gdmFsdWVcbiAgICovXG5cblxuICBwNS5Db21wcmVzc29yLnByb3RvdHlwZS5yYXRpbyA9IGZ1bmN0aW9uIChyYXRpbywgdGltZSkge1xuICAgIHZhciB0ID0gdGltZSB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZiByYXRpbyA9PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5jb21wcmVzc29yLnJhdGlvLnZhbHVlID0gcmF0aW87XG4gICAgICB0aGlzLmNvbXByZXNzb3IucmF0aW8uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAxICsgdCk7XG4gICAgICB0aGlzLmNvbXByZXNzb3IucmF0aW8ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUocmF0aW8sIHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAyICsgdCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmF0aW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByYXRpby5jb25uZWN0KHRoaXMuY29tcHJlc3Nvci5yYXRpbyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29tcHJlc3Nvci5yYXRpby52YWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IHRocmVzaG9sZCBvciBzZXQgdmFsdWUgdy8gdGltZSByYW1wXG4gICAqIEBtZXRob2QgdGhyZXNob2xkXG4gICAqIEBmb3IgcDUuQ29tcHJlc3NvclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkICBUaGUgZGVjaWJlbCB2YWx1ZSBhYm92ZSB3aGljaCB0aGUgY29tcHJlc3Npb24gd2lsbCBzdGFydCB0YWtpbmcgZWZmZWN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgPSAtMjQsIHJhbmdlIC0xMDAgLSAwXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZV0gIEFzc2lnbiB0aW1lIHZhbHVlIHRvIHNjaGVkdWxlIHRoZSBjaGFuZ2UgaW4gdmFsdWVcbiAgICovXG5cblxuICBwNS5Db21wcmVzc29yLnByb3RvdHlwZS50aHJlc2hvbGQgPSBmdW5jdGlvbiAodGhyZXNob2xkLCB0aW1lKSB7XG4gICAgdmFyIHQgPSB0aW1lIHx8IDA7XG5cbiAgICBpZiAodHlwZW9mIHRocmVzaG9sZCA9PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5jb21wcmVzc29yLnRocmVzaG9sZC52YWx1ZSA9IHRocmVzaG9sZDtcbiAgICAgIHRoaXMuY29tcHJlc3Nvci50aHJlc2hvbGQuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRoaXMuYWMuY3VycmVudFRpbWUgKyAwLjAxICsgdCk7XG4gICAgICB0aGlzLmNvbXByZXNzb3IudGhyZXNob2xkLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRocmVzaG9sZCwgdGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDIgKyB0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJlc2hvbGQuY29ubmVjdCh0aGlzLmNvbXByZXNzb3IudGhyZXNob2xkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb21wcmVzc29yLnRocmVzaG9sZC52YWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IHJlbGVhc2Ugb3Igc2V0IHZhbHVlIHcvIHRpbWUgcmFtcFxuICAgKiBAbWV0aG9kIHJlbGVhc2VcbiAgICogQGZvciBwNS5Db21wcmVzc29yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByZWxlYXNlICAgIFRoZSBhbW91bnQgb2YgdGltZSAoaW4gc2Vjb25kcykgdG8gaW5jcmVhc2UgdGhlIGdhaW4gYnkgMTBkQlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0ID0gLjI1LCByYW5nZSAwIC0gMVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVdICBBc3NpZ24gdGltZSB2YWx1ZSB0byBzY2hlZHVsZSB0aGUgY2hhbmdlIGluIHZhbHVlXG4gICAqL1xuXG5cbiAgcDUuQ29tcHJlc3Nvci5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uIChyZWxlYXNlLCB0aW1lKSB7XG4gICAgdmFyIHQgPSB0aW1lIHx8IDA7XG5cbiAgICBpZiAodHlwZW9mIHJlbGVhc2UgPT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuY29tcHJlc3Nvci5yZWxlYXNlLnZhbHVlID0gcmVsZWFzZTtcbiAgICAgIHRoaXMuY29tcHJlc3Nvci5yZWxlYXNlLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLmFjLmN1cnJlbnRUaW1lICsgMC4wMSArIHQpO1xuICAgICAgdGhpcy5jb21wcmVzc29yLnJlbGVhc2UubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUocmVsZWFzZSwgdGhpcy5hYy5jdXJyZW50VGltZSArIDAuMDIgKyB0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBudW1iZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZWxlYXNlLmNvbm5lY3QodGhpcy5jb21wcmVzc29yLnJlbGVhc2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXByZXNzb3IucmVsZWFzZS52YWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3VycmVudCByZWR1Y3Rpb24gdmFsdWVcbiAgICpcbiAgICogQG1ldGhvZCByZWR1Y3Rpb25cbiAgICogQGZvciBwNS5Db21wcmVzc29yXG4gICAqIEByZXR1cm4ge051bWJlcn0gVmFsdWUgb2YgdGhlIGFtb3VudCBvZiBnYWluIHJlZHVjdGlvbiB0aGF0IGlzIGFwcGxpZWQgdG8gdGhlIHNpZ25hbFxuICAgKi9cblxuXG4gIHA1LkNvbXByZXNzb3IucHJvdG90eXBlLnJlZHVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wcmVzc29yLnJlZHVjdGlvbi52YWx1ZTtcbiAgfTtcblxuICBwNS5Db21wcmVzc29yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIEVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5hcHBseSh0aGlzKTtcblxuICAgIGlmICh0aGlzLmNvbXByZXNzb3IpIHtcbiAgICAgIHRoaXMuY29tcHJlc3Nvci5kaXNjb25uZWN0KCk7XG4gICAgICBkZWxldGUgdGhpcy5jb21wcmVzc29yO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gcDUuQ29tcHJlc3Nvcjtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICB2YXIgcDVzb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbiAgdmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KSxcbiAgICAgIGNvbnZlcnRUb1dhdiA9IF9yZXF1aXJlLmNvbnZlcnRUb1dhdixcbiAgICAgIHNhZmVCdWZmZXJTaXplID0gX3JlcXVpcmUuc2FmZUJ1ZmZlclNpemU7XG5cbiAgdmFyIHByb2Nlc3Nvck5hbWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbiAgdmFyIGFjID0gcDVzb3VuZC5hdWRpb2NvbnRleHQ7XG4gIC8qKlxuICAgKiAgPHA+UmVjb3JkIHNvdW5kcyBmb3IgcGxheWJhY2sgYW5kL29yIHRvIHNhdmUgYXMgYSAud2F2IGZpbGUuXG4gICAqICBUaGUgcDUuU291bmRSZWNvcmRlciByZWNvcmRzIGFsbCBzb3VuZCBvdXRwdXQgZnJvbSB5b3VyIHNrZXRjaCxcbiAgICogIG9yIGNhbiBiZSBhc3NpZ25lZCBhIHNwZWNpZmljIHNvdXJjZSB3aXRoIHNldElucHV0KCkuPC9wPlxuICAgKiAgPHA+VGhlIHJlY29yZCgpIG1ldGhvZCBhY2NlcHRzIGEgcDUuU291bmRGaWxlIGFzIGEgcGFyYW1ldGVyLlxuICAgKiAgV2hlbiBwbGF5YmFjayBpcyBzdG9wcGVkIChlaXRoZXIgYWZ0ZXIgdGhlIGdpdmVuIGFtb3VudCBvZiB0aW1lLFxuICAgKiAgb3Igd2l0aCB0aGUgc3RvcCgpIG1ldGhvZCksIHRoZSBwNS5Tb3VuZFJlY29yZGVyIHdpbGwgc2VuZCBpdHNcbiAgICogIHJlY29yZGluZyB0byB0aGF0IHA1LlNvdW5kRmlsZSBmb3IgcGxheWJhY2suPC9wPlxuICAgKlxuICAgKiAgQGNsYXNzIHA1LlNvdW5kUmVjb3JkZXJcbiAgICogIEBjb25zdHJ1Y3RvclxuICAgKiAgQGV4YW1wbGVcbiAgICogIDxkaXY+PGNvZGU+XG4gICAqICBsZXQgbWljLCByZWNvcmRlciwgc291bmRGaWxlO1xuICAgKiAgbGV0IHN0YXRlID0gMDtcbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBsZXQgY252ID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICogICAgY252Lm1vdXNlUHJlc3NlZChjYW52YXNQcmVzc2VkKTtcbiAgICogICAgYmFja2dyb3VuZCgyMjApO1xuICAgKiAgICB0ZXh0QWxpZ24oQ0VOVEVSLCBDRU5URVIpO1xuICAgKlxuICAgKiAgICAvLyBjcmVhdGUgYW4gYXVkaW8gaW5cbiAgICogICAgbWljID0gbmV3IHA1LkF1ZGlvSW4oKTtcbiAgICpcbiAgICogICAgLy8gcHJvbXB0cyB1c2VyIHRvIGVuYWJsZSB0aGVpciBicm93c2VyIG1pY1xuICAgKiAgICBtaWMuc3RhcnQoKTtcbiAgICpcbiAgICogICAgLy8gY3JlYXRlIGEgc291bmQgcmVjb3JkZXJcbiAgICogICAgcmVjb3JkZXIgPSBuZXcgcDUuU291bmRSZWNvcmRlcigpO1xuICAgKlxuICAgKiAgICAvLyBjb25uZWN0IHRoZSBtaWMgdG8gdGhlIHJlY29yZGVyXG4gICAqICAgIHJlY29yZGVyLnNldElucHV0KG1pYyk7XG4gICAqXG4gICAqICAgIC8vIHRoaXMgc291bmQgZmlsZSB3aWxsIGJlIHVzZWQgdG9cbiAgICogICAgLy8gcGxheWJhY2sgJiBzYXZlIHRoZSByZWNvcmRpbmdcbiAgICogICAgc291bmRGaWxlID0gbmV3IHA1LlNvdW5kRmlsZSgpO1xuICAgKlxuICAgKiAgICB0ZXh0KCd0YXAgdG8gcmVjb3JkJywgd2lkdGgvMiwgaGVpZ2h0LzIpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gY2FudmFzUHJlc3NlZCgpIHtcbiAgICogICAgLy8gZW5zdXJlIGF1ZGlvIGlzIGVuYWJsZWRcbiAgICogICAgdXNlclN0YXJ0QXVkaW8oKTtcbiAgICpcbiAgICogICAgLy8gbWFrZSBzdXJlIHVzZXIgZW5hYmxlZCB0aGUgbWljXG4gICAqICAgIGlmIChzdGF0ZSA9PT0gMCAmJiBtaWMuZW5hYmxlZCkge1xuICAgKlxuICAgKiAgICAgIC8vIHJlY29yZCB0byBvdXIgcDUuU291bmRGaWxlXG4gICAqICAgICAgcmVjb3JkZXIucmVjb3JkKHNvdW5kRmlsZSk7XG4gICAqXG4gICAqICAgICAgYmFja2dyb3VuZCgyNTUsMCwwKTtcbiAgICogICAgICB0ZXh0KCdSZWNvcmRpbmchJywgd2lkdGgvMiwgaGVpZ2h0LzIpO1xuICAgKiAgICAgIHN0YXRlKys7XG4gICAqICAgIH1cbiAgICogICAgZWxzZSBpZiAoc3RhdGUgPT09IDEpIHtcbiAgICogICAgICBiYWNrZ3JvdW5kKDAsMjU1LDApO1xuICAgKlxuICAgKiAgICAgIC8vIHN0b3AgcmVjb3JkZXIgYW5kXG4gICAqICAgICAgLy8gc2VuZCByZXN1bHQgdG8gc291bmRGaWxlXG4gICAqICAgICAgcmVjb3JkZXIuc3RvcCgpO1xuICAgKlxuICAgKiAgICAgIHRleHQoJ0RvbmUhIFRhcCB0byBwbGF5IGFuZCBkb3dubG9hZCcsIHdpZHRoLzIsIGhlaWdodC8yLCB3aWR0aCAtIDIwKTtcbiAgICogICAgICBzdGF0ZSsrO1xuICAgKiAgICB9XG4gICAqXG4gICAqICAgIGVsc2UgaWYgKHN0YXRlID09PSAyKSB7XG4gICAqICAgICAgc291bmRGaWxlLnBsYXkoKTsgLy8gcGxheSB0aGUgcmVzdWx0IVxuICAgKiAgICAgIHNhdmUoc291bmRGaWxlLCAnbXlTb3VuZC53YXYnKTtcbiAgICogICAgICBzdGF0ZSsrO1xuICAgKiAgICB9XG4gICAqICB9XG4gICAqICA8L2Rpdj48L2NvZGU+XG4gICAqL1xuXG4gIHA1LlNvdW5kUmVjb3JkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pbnB1dCA9IGFjLmNyZWF0ZUdhaW4oKTtcbiAgICB0aGlzLm91dHB1dCA9IGFjLmNyZWF0ZUdhaW4oKTtcbiAgICB0aGlzLl9pbnB1dENoYW5uZWxzID0gMjtcbiAgICB0aGlzLl9vdXRwdXRDaGFubmVscyA9IDI7IFxuXG4gICAgdmFyIHdvcmtsZXRCdWZmZXJTaXplID0gc2FmZUJ1ZmZlclNpemUoMTAyNCk7XG4gICAgdGhpcy5fd29ya2xldE5vZGUgPSBuZXcgQXVkaW9Xb3JrbGV0Tm9kZShhYywgcHJvY2Vzc29yTmFtZXMucmVjb3JkZXJQcm9jZXNzb3IsIHtcbiAgICAgIG91dHB1dENoYW5uZWxDb3VudDogW3RoaXMuX291dHB1dENoYW5uZWxzXSxcbiAgICAgIHByb2Nlc3Nvck9wdGlvbnM6IHtcbiAgICAgICAgbnVtSW5wdXRDaGFubmVsczogdGhpcy5faW5wdXRDaGFubmVscyxcbiAgICAgICAgYnVmZmVyU2l6ZTogd29ya2xldEJ1ZmZlclNpemVcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX3dvcmtsZXROb2RlLnBvcnQub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZGF0YS5uYW1lID09PSAnYnVmZmVycycpIHtcbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSBbbmV3IEZsb2F0MzJBcnJheShldmVudC5kYXRhLmxlZnRCdWZmZXIpLCBuZXcgRmxvYXQzMkFycmF5KGV2ZW50LmRhdGEucmlnaHRCdWZmZXIpXTtcblxuICAgICAgICB0aGlzLl9jYWxsYmFjayhidWZmZXJzKTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG4gICAgLyoqXG4gICAgICogIGNhbGxiYWNrIGludm9rZWQgd2hlbiB0aGUgcmVjb3JkaW5nIGlzIG92ZXJcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKiAgQHR5cGUgRnVuY3Rpb24oRmxvYXQzMkFycmF5KVxuICAgICAqL1xuXG5cbiAgICB0aGlzLl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9OyBcblxuXG4gICAgdGhpcy5fd29ya2xldE5vZGUuY29ubmVjdChwNS5zb3VuZE91dC5fc2lsZW50Tm9kZSk7XG5cbiAgICB0aGlzLnNldElucHV0KCk7IFxuXG4gICAgcDVzb3VuZC5zb3VuZEFycmF5LnB1c2godGhpcyk7XG4gIH07XG4gIC8qKlxuICAgKiAgQ29ubmVjdCBhIHNwZWNpZmljIGRldmljZSB0byB0aGUgcDUuU291bmRSZWNvcmRlci5cbiAgICogIElmIG5vIHBhcmFtZXRlciBpcyBnaXZlbiwgcDUuU291bmRSZWNvcmVyIHdpbGwgcmVjb3JkXG4gICAqICBhbGwgYXVkaWJsZSBwNS5zb3VuZCBmcm9tIHlvdXIgc2tldGNoLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgc2V0SW5wdXRcbiAgICogIEBmb3IgcDUuU291bmRSZWNvcmRlclxuICAgKiAgQHBhcmFtIHtPYmplY3R9IFt1bml0XSBwNS5zb3VuZCBvYmplY3Qgb3IgYSB3ZWIgYXVkaW8gdW5pdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0IG91dHB1dHMgc291bmRcbiAgICovXG5cblxuICBwNS5Tb3VuZFJlY29yZGVyLnByb3RvdHlwZS5zZXRJbnB1dCA9IGZ1bmN0aW9uICh1bml0KSB7XG4gICAgdGhpcy5pbnB1dC5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5pbnB1dCA9IG51bGw7XG4gICAgdGhpcy5pbnB1dCA9IGFjLmNyZWF0ZUdhaW4oKTtcbiAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fd29ya2xldE5vZGUpO1xuICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cbiAgICBpZiAodW5pdCkge1xuICAgICAgdW5pdC5jb25uZWN0KHRoaXMuaW5wdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwNS5zb3VuZE91dC5vdXRwdXQuY29ubmVjdCh0aGlzLmlucHV0KTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgU3RhcnQgcmVjb3JkaW5nLiBUbyBhY2Nlc3MgdGhlIHJlY29yZGluZywgcHJvdmlkZVxuICAgKiAgYSBwNS5Tb3VuZEZpbGUgYXMgdGhlIGZpcnN0IHBhcmFtZXRlci4gVGhlIHA1LlNvdW5kUmVjb3JkZXJcbiAgICogIHdpbGwgc2VuZCBpdHMgcmVjb3JkaW5nIHRvIHRoYXQgcDUuU291bmRGaWxlIGZvciBwbGF5YmFjayBvbmNlXG4gICAqICByZWNvcmRpbmcgaXMgY29tcGxldGUuIE9wdGlvbmFsIHBhcmFtZXRlcnMgaW5jbHVkZSBkdXJhdGlvblxuICAgKiAgKGluIHNlY29uZHMpIG9mIHRoZSByZWNvcmRpbmcsIGFuZCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXRcbiAgICogIHdpbGwgYmUgY2FsbGVkIG9uY2UgdGhlIGNvbXBsZXRlIHJlY29yZGluZyBoYXMgYmVlblxuICAgKiAgdHJhbnNmZXJlZCB0byB0aGUgcDUuU291bmRGaWxlLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgcmVjb3JkXG4gICAqICBAZm9yIHA1LlNvdW5kUmVjb3JkZXJcbiAgICogIEBwYXJhbSAge3A1LlNvdW5kRmlsZX0gICBzb3VuZEZpbGUgICAgcDUuU291bmRGaWxlXG4gICAqICBAcGFyYW0gIHtOdW1iZXJ9ICAgW2R1cmF0aW9uXSBUaW1lIChpbiBzZWNvbmRzKVxuICAgKiAgQHBhcmFtICB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIG5hbWUgb2YgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlZCBvbmNlIHRoZSByZWNvcmRpbmcgY29tcGxldGVzXG4gICAqL1xuXG5cbiAgcDUuU291bmRSZWNvcmRlci5wcm90b3R5cGUucmVjb3JkID0gZnVuY3Rpb24gKHNGaWxlLCBkdXJhdGlvbiwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl93b3JrbGV0Tm9kZS5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgIG5hbWU6ICdzdGFydCcsXG4gICAgICBkdXJhdGlvbjogZHVyYXRpb25cbiAgICB9KTtcblxuICAgIGlmIChzRmlsZSAmJiBjYWxsYmFjaykge1xuICAgICAgdGhpcy5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIHNGaWxlLnNldEJ1ZmZlcihidWZmZXIpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHNGaWxlKSB7XG4gICAgICB0aGlzLl9jYWxsYmFjayA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgc0ZpbGUuc2V0QnVmZmVyKGJ1ZmZlcik7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBTdG9wIHRoZSByZWNvcmRpbmcuIE9uY2UgdGhlIHJlY29yZGluZyBpcyBzdG9wcGVkLFxuICAgKiAgdGhlIHJlc3VsdHMgd2lsbCBiZSBzZW50IHRvIHRoZSBwNS5Tb3VuZEZpbGUgdGhhdFxuICAgKiAgd2FzIGdpdmVuIG9uIC5yZWNvcmQoKSwgYW5kIGlmIGEgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICogIHdhcyBwcm92aWRlZCBvbiByZWNvcmQsIHRoYXQgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQuXG4gICAqXG4gICAqICBAbWV0aG9kICBzdG9wXG4gICAqICBAZm9yIHA1LlNvdW5kUmVjb3JkZXJcbiAgICovXG5cblxuICBwNS5Tb3VuZFJlY29yZGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3dvcmtsZXROb2RlLnBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgbmFtZTogJ3N0b3AnXG4gICAgfSk7XG4gIH07XG5cbiAgcDUuU291bmRSZWNvcmRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5kZXggPSBwNXNvdW5kLnNvdW5kQXJyYXkuaW5kZXhPZih0aGlzKTtcbiAgICBwNXNvdW5kLnNvdW5kQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIHRoaXMuX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG5cbiAgICBpZiAodGhpcy5pbnB1dCkge1xuICAgICAgdGhpcy5pbnB1dC5kaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbnB1dCA9IG51bGw7XG4gICAgdGhpcy5fd29ya2xldE5vZGUgPSBudWxsO1xuICB9O1xuICAvKipcbiAgICogU2F2ZSBhIHA1LlNvdW5kRmlsZSBhcyBhIC53YXYgZmlsZS4gVGhlIGJyb3dzZXIgd2lsbCBwcm9tcHQgdGhlIHVzZXJcbiAgICogdG8gZG93bmxvYWQgdGhlIGZpbGUgdG8gdGhlaXIgZGV2aWNlLlxuICAgKiBGb3IgdXBsb2FkaW5nIGF1ZGlvIHRvIGEgc2VydmVyLCB1c2VcbiAgICogPGEgaHJlZj1cIi9kb2NzL3JlZmVyZW5jZS8jL3A1LlNvdW5kRmlsZS9zYXZlQmxvYlwiPmBwNS5Tb3VuZEZpbGUuc2F2ZUJsb2JgPC9hPi5cbiAgICpcbiAgICogIEBmb3IgcDVcbiAgICogIEBtZXRob2Qgc2F2ZVNvdW5kXG4gICAqICBAcGFyYW0gIHtwNS5Tb3VuZEZpbGV9IHNvdW5kRmlsZSBwNS5Tb3VuZEZpbGUgdGhhdCB5b3Ugd2lzaCB0byBzYXZlXG4gICAqICBAcGFyYW0gIHtTdHJpbmd9IGZpbGVOYW1lICAgICAgbmFtZSBvZiB0aGUgcmVzdWx0aW5nIC53YXYgZmlsZS5cbiAgICovXG5cblxuICBwNS5wcm90b3R5cGUuc2F2ZVNvdW5kID0gZnVuY3Rpb24gKHNvdW5kRmlsZSwgZmlsZU5hbWUpIHtcbiAgICB2YXIgZGF0YVZpZXcgPSBjb252ZXJ0VG9XYXYoc291bmRGaWxlLmJ1ZmZlcik7XG4gICAgcDUucHJvdG90eXBlLndyaXRlRmlsZShbZGF0YVZpZXddLCBmaWxlTmFtZSwgJ3dhdicpO1xuICB9O1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqICA8cD5QZWFrRGV0ZWN0IHdvcmtzIGluIGNvbmp1bmN0aW9uIHdpdGggcDUuRkZUIHRvXG4gICAqICBsb29rIGZvciBvbnNldHMgaW4gc29tZSBvciBhbGwgb2YgdGhlIGZyZXF1ZW5jeSBzcGVjdHJ1bS5cbiAgICogIDwvcD5cbiAgICogIDxwPlxuICAgKiAgVG8gdXNlIHA1LlBlYWtEZXRlY3QsIGNhbGwgPGNvZGU+dXBkYXRlPC9jb2RlPiBpbiB0aGUgZHJhdyBsb29wXG4gICAqICBhbmQgcGFzcyBpbiBhIHA1LkZGVCBvYmplY3QuXG4gICAqICA8L3A+XG4gICAqICA8cD5cbiAgICogIFlvdSBjYW4gbGlzdGVuIGZvciBhIHNwZWNpZmljIHBhcnQgb2YgdGhlIGZyZXF1ZW5jeSBzcGVjdHJ1bSBieVxuICAgKiAgc2V0dGluZyB0aGUgcmFuZ2UgYmV0d2VlbiA8Y29kZT5mcmVxMTwvY29kZT4gYW5kIDxjb2RlPmZyZXEyPC9jb2RlPi5cbiAgICogIDwvcD5cbiAgICpcbiAgICogIDxwPjxjb2RlPnRocmVzaG9sZDwvY29kZT4gaXMgdGhlIHRocmVzaG9sZCBmb3IgZGV0ZWN0aW5nIGEgcGVhayxcbiAgICogIHNjYWxlZCBiZXR3ZWVuIDAgYW5kIDEuIEl0IGlzIGxvZ2FyaXRobWljLCBzbyAwLjEgaXMgaGFsZiBhcyBsb3VkXG4gICAqICBhcyAxLjAuPC9wPlxuICAgKlxuICAgKiAgPHA+XG4gICAqICBUaGUgdXBkYXRlIG1ldGhvZCBpcyBtZWFudCB0byBiZSBydW4gaW4gdGhlIGRyYXcgbG9vcCwgYW5kXG4gICAqICA8Yj5mcmFtZXM8L2I+IGRldGVybWluZXMgaG93IG1hbnkgbG9vcHMgbXVzdCBwYXNzIGJlZm9yZVxuICAgKiAgYW5vdGhlciBwZWFrIGNhbiBiZSBkZXRlY3RlZC5cbiAgICogIEZvciBleGFtcGxlLCBpZiB0aGUgZnJhbWVSYXRlKCkgPSA2MCwgeW91IGNvdWxkIGRldGVjdCB0aGUgYmVhdCBvZiBhXG4gICAqICAxMjAgYmVhdC1wZXItbWludXRlIHNvbmcgd2l0aCB0aGlzIGVxdWF0aW9uOlxuICAgKiAgPGNvZGU+IGZyYW1lc1BlclBlYWsgPSA2MCAvIChlc3RpbWF0ZWRCUE0gLyA2MCApOzwvY29kZT5cbiAgICogIDwvcD5cbiAgICpcbiAgICogIDxwPlxuICAgKiAgQmFzZWQgb24gZXhhbXBsZSBjb250cmlidHVlZCBieSBAYjJyZW5nZXIsIGFuZCBhIHNpbXBsZSBiZWF0IGRldGVjdGlvblxuICAgKiAgZXhwbGFuYXRpb24gYnkgPGFcbiAgICogIGhyZWY9XCJodHRwOi8vd3d3LmFpcnRpZ2h0aW50ZXJhY3RpdmUuY29tLzIwMTMvMTAvbWFraW5nLWF1ZGlvLXJlYWN0aXZlLXZpc3VhbHMvXCJcbiAgICogIHRhcmdldD1cIl9ibGFua1wiPkZlbGl4IFR1cm5lcjwvYT4uXG4gICAqICA8L3A+XG4gICAqXG4gICAqICBAY2xhc3MgIHA1LlBlYWtEZXRlY3RcbiAgICogIEBjb25zdHJ1Y3RvclxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtmcmVxMV0gICAgIGxvd0ZyZXF1ZW5jeSAtIGRlZmF1bHRzIHRvIDIwSHpcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbZnJlcTJdICAgICBoaWdoRnJlcXVlbmN5IC0gZGVmYXVsdHMgdG8gMjAwMDAgSHpcbiAgICogIEBwYXJhbSB7TnVtYmVyfSBbdGhyZXNob2xkXSBUaHJlc2hvbGQgZm9yIGRldGVjdGluZyBhIGJlYXQgYmV0d2VlbiAwIGFuZCAxXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlZCBsb2dhcml0aG1pY2FsbHkgd2hlcmUgMC4xIGlzIDEvMiB0aGUgbG91ZG5lc3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgMS4wLiBEZWZhdWx0cyB0byAwLjM1LlxuICAgKiAgQHBhcmFtIHtOdW1iZXJ9IFtmcmFtZXNQZXJQZWFrXSAgICAgRGVmYXVsdHMgdG8gMjAuXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICpcbiAgICogIHZhciBjbnYsIHNvdW5kRmlsZSwgZmZ0LCBwZWFrRGV0ZWN0O1xuICAgKiAgdmFyIGVsbGlwc2VXaWR0aCA9IDEwO1xuICAgKlxuICAgKiAgZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICogICAgc291bmRGaWxlID0gbG9hZFNvdW5kKCdhc3NldHMvYmVhdC5tcDMnKTtcbiAgICogIH1cbiAgICpcbiAgICogIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgKiAgICBiYWNrZ3JvdW5kKDApO1xuICAgKiAgICBub1N0cm9rZSgpO1xuICAgKiAgICBmaWxsKDI1NSk7XG4gICAqICAgIHRleHRBbGlnbihDRU5URVIpO1xuICAgKlxuICAgKiAgICAvLyBwNS5QZWFrRGV0ZWN0IHJlcXVpcmVzIGEgcDUuRkZUXG4gICAqICAgIGZmdCA9IG5ldyBwNS5GRlQoKTtcbiAgICogICAgcGVha0RldGVjdCA9IG5ldyBwNS5QZWFrRGV0ZWN0KCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBkcmF3KCkge1xuICAgKiAgICBiYWNrZ3JvdW5kKDApO1xuICAgKiAgICB0ZXh0KCdjbGljayB0byBwbGF5L3BhdXNlJywgd2lkdGgvMiwgaGVpZ2h0LzIpO1xuICAgKlxuICAgKiAgICAvLyBwZWFrRGV0ZWN0IGFjY2VwdHMgYW4gZmZ0IHBvc3QtYW5hbHlzaXNcbiAgICogICAgZmZ0LmFuYWx5emUoKTtcbiAgICogICAgcGVha0RldGVjdC51cGRhdGUoZmZ0KTtcbiAgICpcbiAgICogICAgaWYgKCBwZWFrRGV0ZWN0LmlzRGV0ZWN0ZWQgKSB7XG4gICAqICAgICAgZWxsaXBzZVdpZHRoID0gNTA7XG4gICAqICAgIH0gZWxzZSB7XG4gICAqICAgICAgZWxsaXBzZVdpZHRoICo9IDAuOTU7XG4gICAqICAgIH1cbiAgICpcbiAgICogICAgZWxsaXBzZSh3aWR0aC8yLCBoZWlnaHQvMiwgZWxsaXBzZVdpZHRoLCBlbGxpcHNlV2lkdGgpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgLy8gdG9nZ2xlIHBsYXkvc3RvcCB3aGVuIGNhbnZhcyBpcyBjbGlja2VkXG4gICAqICBmdW5jdGlvbiBtb3VzZUNsaWNrZWQoKSB7XG4gICAqICAgIGlmIChtb3VzZVggPiAwICYmIG1vdXNlWCA8IHdpZHRoICYmIG1vdXNlWSA+IDAgJiYgbW91c2VZIDwgaGVpZ2h0KSB7XG4gICAqICAgICAgaWYgKHNvdW5kRmlsZS5pc1BsYXlpbmcoKSApIHtcbiAgICogICAgICAgIHNvdW5kRmlsZS5zdG9wKCk7XG4gICAqICAgICAgfSBlbHNlIHtcbiAgICogICAgICAgIHNvdW5kRmlsZS5wbGF5KCk7XG4gICAqICAgICAgfVxuICAgKiAgICB9XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuICBwNS5QZWFrRGV0ZWN0ID0gZnVuY3Rpb24gKGZyZXExLCBmcmVxMiwgdGhyZXNob2xkLCBfZnJhbWVzUGVyUGVhaykge1xuICAgIHRoaXMuZnJhbWVzUGVyUGVhayA9IF9mcmFtZXNQZXJQZWFrIHx8IDIwO1xuICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0UGVhayA9IDA7XG4gICAgdGhpcy5kZWNheVJhdGUgPSAwLjk1O1xuICAgIHRoaXMudGhyZXNob2xkID0gdGhyZXNob2xkIHx8IDAuMzU7XG4gICAgdGhpcy5jdXRvZmYgPSAwOyBcblxuICAgIHRoaXMuY3V0b2ZmTXVsdCA9IDEuNTtcbiAgICB0aGlzLmVuZXJneSA9IDA7XG4gICAgdGhpcy5wZW5lcmd5ID0gMDsgXG5cbiAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IDA7XG4gICAgLyoqXG4gICAgICogIGlzRGV0ZWN0ZWQgaXMgc2V0IHRvIHRydWUgd2hlbiBhIHBlYWsgaXMgZGV0ZWN0ZWQuXG4gICAgICpcbiAgICAgKiAgQGF0dHJpYnV0ZSBpc0RldGVjdGVkIHtCb29sZWFufVxuICAgICAqICBAZGVmYXVsdCAgZmFsc2VcbiAgICAgKi9cblxuICAgIHRoaXMuaXNEZXRlY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuZjEgPSBmcmVxMSB8fCA0MDtcbiAgICB0aGlzLmYyID0gZnJlcTIgfHwgMjAwMDA7IFxuXG4gICAgdGhpcy5fb25QZWFrID0gZnVuY3Rpb24gKCkge307XG4gIH07XG4gIC8qKlxuICAgKiAgVGhlIHVwZGF0ZSBtZXRob2QgaXMgcnVuIGluIHRoZSBkcmF3IGxvb3AuXG4gICAqXG4gICAqICBBY2NlcHRzIGFuIEZGVCBvYmplY3QuIFlvdSBtdXN0IGNhbGwgLmFuYWx5emUoKVxuICAgKiAgb24gdGhlIEZGVCBvYmplY3QgcHJpb3IgdG8gdXBkYXRpbmcgdGhlIHBlYWtEZXRlY3RcbiAgICogIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGEgY29tcGxldGVkIEZGVCBhbmFseXNpcy5cbiAgICpcbiAgICogIEBtZXRob2QgIHVwZGF0ZVxuICAgKiAgQHBhcmFtICB7cDUuRkZUfSBmZnRPYmplY3QgQSBwNS5GRlQgb2JqZWN0XG4gICAqL1xuXG5cbiAgcDUuUGVha0RldGVjdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGZmdE9iamVjdCkge1xuICAgIHZhciBucmcgPSB0aGlzLmVuZXJneSA9IGZmdE9iamVjdC5nZXRFbmVyZ3kodGhpcy5mMSwgdGhpcy5mMikgLyAyNTU7XG5cbiAgICBpZiAobnJnID4gdGhpcy5jdXRvZmYgJiYgbnJnID4gdGhpcy50aHJlc2hvbGQgJiYgbnJnIC0gdGhpcy5wZW5lcmd5ID4gMCkge1xuICAgICAgdGhpcy5fb25QZWFrKCk7XG5cbiAgICAgIHRoaXMuaXNEZXRlY3RlZCA9IHRydWU7IFxuXG4gICAgICB0aGlzLmN1dG9mZiA9IG5yZyAqIHRoaXMuY3V0b2ZmTXVsdDtcbiAgICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0UGVhayA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNEZXRlY3RlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5mcmFtZXNTaW5jZUxhc3RQZWFrIDw9IHRoaXMuZnJhbWVzUGVyUGVhaykge1xuICAgICAgICB0aGlzLmZyYW1lc1NpbmNlTGFzdFBlYWsrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY3V0b2ZmICo9IHRoaXMuZGVjYXlSYXRlO1xuICAgICAgICB0aGlzLmN1dG9mZiA9IE1hdGgubWF4KHRoaXMuY3V0b2ZmLCB0aGlzLnRocmVzaG9sZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50VmFsdWUgPSBucmc7XG4gICAgdGhpcy5wZW5lcmd5ID0gbnJnO1xuICB9O1xuICAvKipcbiAgICogIG9uUGVhayBhY2NlcHRzIHR3byBhcmd1bWVudHM6IGEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuXG4gICAqICBhIHBlYWsgaXMgZGV0ZWN0ZWQuIFRoZSB2YWx1ZSBvZiB0aGUgcGVhayxcbiAgICogIGJldHdlZW4gMC4wIGFuZCAxLjAsIGlzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2suXG4gICAqXG4gICAqICBAbWV0aG9kICBvblBlYWtcbiAgICogIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayBOYW1lIG9mIGEgZnVuY3Rpb24gdGhhdCB3aWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgY2FsbGVkIHdoZW4gYSBwZWFrIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWQuXG4gICAqICBAcGFyYW0gIHtPYmplY3R9ICAgW3ZhbF0gICAgT3B0aW9uYWwgdmFsdWUgdG8gcGFzc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludG8gdGhlIGZ1bmN0aW9uIHdoZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIHBlYWsgaXMgZGV0ZWN0ZWQuXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICogIHZhciBjbnYsIHNvdW5kRmlsZSwgZmZ0LCBwZWFrRGV0ZWN0O1xuICAgKiAgdmFyIGVsbGlwc2VXaWR0aCA9IDA7XG4gICAqXG4gICAqICBmdW5jdGlvbiBwcmVsb2FkKCkge1xuICAgKiAgICBzb3VuZEZpbGUgPSBsb2FkU291bmQoJ2Fzc2V0cy9iZWF0Lm1wMycpO1xuICAgKiAgfVxuICAgKlxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGNudiA9IGNyZWF0ZUNhbnZhcygxMDAsMTAwKTtcbiAgICogICAgdGV4dEFsaWduKENFTlRFUik7XG4gICAqXG4gICAqICAgIGZmdCA9IG5ldyBwNS5GRlQoKTtcbiAgICogICAgcGVha0RldGVjdCA9IG5ldyBwNS5QZWFrRGV0ZWN0KCk7XG4gICAqXG4gICAqICAgIHNldHVwU291bmQoKTtcbiAgICpcbiAgICogICAgLy8gd2hlbiBhIGJlYXQgaXMgZGV0ZWN0ZWQsIGNhbGwgdHJpZ2dlckJlYXQoKVxuICAgKiAgICBwZWFrRGV0ZWN0Lm9uUGVhayh0cmlnZ2VyQmVhdCk7XG4gICAqICB9XG4gICAqXG4gICAqICBmdW5jdGlvbiBkcmF3KCkge1xuICAgKiAgICBiYWNrZ3JvdW5kKDApO1xuICAgKiAgICBmaWxsKDI1NSk7XG4gICAqICAgIHRleHQoJ2NsaWNrIHRvIHBsYXknLCB3aWR0aC8yLCBoZWlnaHQvMik7XG4gICAqXG4gICAqICAgIGZmdC5hbmFseXplKCk7XG4gICAqICAgIHBlYWtEZXRlY3QudXBkYXRlKGZmdCk7XG4gICAqXG4gICAqICAgIGVsbGlwc2VXaWR0aCAqPSAwLjk1O1xuICAgKiAgICBlbGxpcHNlKHdpZHRoLzIsIGhlaWdodC8yLCBlbGxpcHNlV2lkdGgsIGVsbGlwc2VXaWR0aCk7XG4gICAqICB9XG4gICAqXG4gICAqICAvLyB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBwZWFrRGV0ZWN0Lm9uUGVha1xuICAgKiAgZnVuY3Rpb24gdHJpZ2dlckJlYXQoKSB7XG4gICAqICAgIGVsbGlwc2VXaWR0aCA9IDUwO1xuICAgKiAgfVxuICAgKlxuICAgKiAgLy8gbW91c2VjbGljayBzdGFydHMvc3RvcHMgc291bmRcbiAgICogIGZ1bmN0aW9uIHNldHVwU291bmQoKSB7XG4gICAqICAgIGNudi5tb3VzZUNsaWNrZWQoIGZ1bmN0aW9uKCkge1xuICAgKiAgICAgIGlmIChzb3VuZEZpbGUuaXNQbGF5aW5nKCkgKSB7XG4gICAqICAgICAgICBzb3VuZEZpbGUuc3RvcCgpO1xuICAgKiAgICAgIH0gZWxzZSB7XG4gICAqICAgICAgICBzb3VuZEZpbGUucGxheSgpO1xuICAgKiAgICAgIH1cbiAgICogICAgfSk7XG4gICAqICB9XG4gICAqICA8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuUGVha0RldGVjdC5wcm90b3R5cGUub25QZWFrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB2YWwpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBzZWxmLl9vblBlYWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhzZWxmLmVuZXJneSwgdmFsKTtcbiAgICB9O1xuICB9O1xufSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbiB9KSxcbiAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gIHZhciBwNXNvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbiAgLyoqXG4gICAqICBBIGdhaW4gbm9kZSBpcyB1c2VmdWxsIHRvIHNldCB0aGUgcmVsYXRpdmUgdm9sdW1lIG9mIHNvdW5kLlxuICAgKiAgSXQncyB0eXBpY2FsbHkgdXNlZCB0byBidWlsZCBtaXhlcnMuXG4gICAqXG4gICAqICBAY2xhc3MgcDUuR2FpblxuICAgKiAgQGNvbnN0cnVjdG9yXG4gICAqICBAZXhhbXBsZVxuICAgKiAgPGRpdj48Y29kZT5cbiAgICpcbiAgICogIC8vIGxvYWQgdHdvIHNvdW5kZmlsZSBhbmQgY3Jvc3NmYWRlIGJlZXR3ZWVuIHRoZW1cbiAgICogIGxldCBzb3VuZDEsc291bmQyO1xuICAgKiAgbGV0IHNvdW5kMUdhaW4sIHNvdW5kMkdhaW4sIG1hc3RlckdhaW47XG4gICAqICBmdW5jdGlvbiBwcmVsb2FkKCl7XG4gICAqICAgIHNvdW5kRm9ybWF0cygnb2dnJywgJ21wMycpO1xuICAgKiAgICBzb3VuZDEgPSBsb2FkU291bmQoJ2Fzc2V0cy9EYW1zY3JheV8tX0RhbmNpbmdfVGlnZXJfMDEnKTtcbiAgICogICAgc291bmQyID0gbG9hZFNvdW5kKCdhc3NldHMvYmVhdCcpO1xuICAgKiAgfVxuICAgKiAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAqICAgIGxldCBjbnYgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgKiAgICBjbnYubW91c2VQcmVzc2VkKHN0YXJ0U291bmQpO1xuICAgKiAgICAvLyBjcmVhdGUgYSAnbWFzdGVyJyBnYWluIHRvIHdoaWNoIHdlIHdpbGwgY29ubmVjdCBib3RoIHNvdW5kZmlsZXNcbiAgICogICAgbWFzdGVyR2FpbiA9IG5ldyBwNS5HYWluKCk7XG4gICAqICAgIG1hc3RlckdhaW4uY29ubmVjdCgpO1xuICAgKiAgICBzb3VuZDEuZGlzY29ubmVjdCgpOyAvLyBkaWNvbm5lY3QgZnJvbSBwNSBvdXRwdXRcbiAgICogICAgc291bmQxR2FpbiA9IG5ldyBwNS5HYWluKCk7IC8vIHNldHVwIGEgZ2FpbiBub2RlXG4gICAqICAgIHNvdW5kMUdhaW4uc2V0SW5wdXQoc291bmQxKTsgLy8gY29ubmVjdCB0aGUgZmlyc3Qgc291bmQgdG8gaXRzIGlucHV0XG4gICAqICAgIHNvdW5kMUdhaW4uY29ubmVjdChtYXN0ZXJHYWluKTsgLy8gY29ubmVjdCBpdHMgb3V0cHV0IHRvIHRoZSAnbWFzdGVyJ1xuICAgKiAgICBzb3VuZDIuZGlzY29ubmVjdCgpO1xuICAgKiAgICBzb3VuZDJHYWluID0gbmV3IHA1LkdhaW4oKTtcbiAgICogICAgc291bmQyR2Fpbi5zZXRJbnB1dChzb3VuZDIpO1xuICAgKiAgICBzb3VuZDJHYWluLmNvbm5lY3QobWFzdGVyR2Fpbik7XG4gICAqICB9XG4gICAqICBmdW5jdGlvbiBzdGFydFNvdW5kKCkge1xuICAgKiAgICBzb3VuZDEubG9vcCgpO1xuICAgKiAgICBzb3VuZDIubG9vcCgpO1xuICAgKiAgICBsb29wKCk7XG4gICAqICB9XG4gICAqICBmdW5jdGlvbiBtb3VzZVJlbGVhc2VkKCkge1xuICAgKiAgICBzb3VuZDEuc3RvcCgpO1xuICAgKiAgICBzb3VuZDIuc3RvcCgpO1xuICAgKiAgfVxuICAgKiAgZnVuY3Rpb24gZHJhdygpe1xuICAgKiAgICBiYWNrZ3JvdW5kKDIyMCk7XG4gICAqICAgIHRleHRBbGlnbihDRU5URVIpO1xuICAgKiAgICB0ZXh0U2l6ZSgxMSk7XG4gICAqICAgIGZpbGwoMCk7XG4gICAqICAgIGlmICghc291bmQxLmlzUGxheWluZygpKSB7XG4gICAqICAgICAgdGV4dCgndGFwIGFuZCBkcmFnIHRvIHBsYXknLCB3aWR0aC8yLCBoZWlnaHQvMik7XG4gICAqICAgICAgcmV0dXJuO1xuICAgKiAgICB9XG4gICAqICAgIC8vIG1hcCB0aGUgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgbW91c2UgdG8gdmFsdWVzIHVzZWFibGUgZm9yIHZvbHVtZSAgICAqICBjb250cm9sIG9mIHNvdW5kMVxuICAgKiAgICB2YXIgc291bmQxVm9sdW1lID0gY29uc3RyYWluKG1hcChtb3VzZVgsd2lkdGgsMCwwLDEpLCAwLCAxKTtcbiAgICogICAgdmFyIHNvdW5kMlZvbHVtZSA9IDEtc291bmQxVm9sdW1lO1xuICAgKiAgICBzb3VuZDFHYWluLmFtcChzb3VuZDFWb2x1bWUpO1xuICAgKiAgICBzb3VuZDJHYWluLmFtcChzb3VuZDJWb2x1bWUpO1xuICAgKiAgICAvLyBtYXAgdGhlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBtb3VzZSB0byB2YWx1ZXMgdXNlYWJsZSBmb3IgJ21hc3RlciAgICAqICB2b2x1bWUgY29udHJvbCdcbiAgICogICAgdmFyIG1hc3RlclZvbHVtZSA9IGNvbnN0cmFpbihtYXAobW91c2VZLGhlaWdodCwwLDAsMSksIDAsIDEpO1xuICAgKiAgICBtYXN0ZXJHYWluLmFtcChtYXN0ZXJWb2x1bWUpO1xuICAgKiAgICB0ZXh0KCdtYXN0ZXInLCB3aWR0aC8yLCBoZWlnaHQgLSBtYXN0ZXJWb2x1bWUgKiBoZWlnaHQgKiAwLjkpXG4gICAqICAgIGZpbGwoMjU1LCAwLCAyNTUpO1xuICAgKiAgICB0ZXh0QWxpZ24oTEVGVCk7XG4gICAqICAgIHRleHQoJ3NvdW5kMScsIDUsIGhlaWdodCAtIHNvdW5kMVZvbHVtZSAqIGhlaWdodCAqIDAuOSk7XG4gICAqICAgIHRleHRBbGlnbihSSUdIVCk7XG4gICAqICAgIHRleHQoJ3NvdW5kMicsIHdpZHRoIC0gNSwgaGVpZ2h0IC0gc291bmQyVm9sdW1lICogaGVpZ2h0ICogMC45KTtcbiAgICogIH1cbiAgICo8L2NvZGU+PC9kaXY+XG4gICAqL1xuXG5cbiAgcDUuR2FpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFjID0gcDVzb3VuZC5hdWRpb2NvbnRleHQ7XG4gICAgdGhpcy5pbnB1dCA9IHRoaXMuYWMuY3JlYXRlR2FpbigpO1xuICAgIHRoaXMub3V0cHV0ID0gdGhpcy5hYy5jcmVhdGVHYWluKCk7IFxuXG4gICAgdGhpcy5pbnB1dC5nYWluLnZhbHVlID0gMC41O1xuICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLm91dHB1dCk7IFxuXG4gICAgcDVzb3VuZC5zb3VuZEFycmF5LnB1c2godGhpcyk7XG4gIH07XG4gIC8qKlxuICAgKiAgQ29ubmVjdCBhIHNvdXJjZSB0byB0aGUgZ2FpbiBub2RlLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgc2V0SW5wdXRcbiAgICogIEBmb3IgcDUuR2FpblxuICAgKiAgQHBhcmFtICB7T2JqZWN0fSBzcmMgICAgIHA1LnNvdW5kIC8gV2ViIEF1ZGlvIG9iamVjdCB3aXRoIGEgc291bmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuXG4gICAqL1xuXG5cbiAgcDUuR2Fpbi5wcm90b3R5cGUuc2V0SW5wdXQgPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgc3JjLmNvbm5lY3QodGhpcy5pbnB1dCk7XG4gIH07XG4gIC8qKlxuICAgKiAgU2VuZCBvdXRwdXQgdG8gYSBwNS5zb3VuZCBvciB3ZWIgYXVkaW8gb2JqZWN0XG4gICAqXG4gICAqICBAbWV0aG9kICBjb25uZWN0XG4gICAqICBAZm9yIHA1LkdhaW5cbiAgICogIEBwYXJhbSAge09iamVjdH0gdW5pdFxuICAgKi9cblxuXG4gIHA1LkdhaW4ucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAodW5pdCkge1xuICAgIHZhciB1ID0gdW5pdCB8fCBwNS5zb3VuZE91dC5pbnB1dDtcbiAgICB0aGlzLm91dHB1dC5jb25uZWN0KHUuaW5wdXQgPyB1LmlucHV0IDogdSk7XG4gIH07XG4gIC8qKlxuICAgKiAgRGlzY29ubmVjdCBhbGwgb3V0cHV0LlxuICAgKlxuICAgKiAgQG1ldGhvZCBkaXNjb25uZWN0XG4gICAqICBAZm9yIHA1LkdhaW5cbiAgICovXG5cblxuICBwNS5HYWluLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm91dHB1dCkge1xuICAgICAgdGhpcy5vdXRwdXQuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqICBTZXQgdGhlIG91dHB1dCBsZXZlbCBvZiB0aGUgZ2FpbiBub2RlLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgYW1wXG4gICAqICBAZm9yIHA1LkdhaW5cbiAgICogIEBwYXJhbSAge051bWJlcn0gdm9sdW1lIGFtcGxpdHVkZSBiZXR3ZWVuIDAgYW5kIDEuMFxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbcmFtcFRpbWVdIGNyZWF0ZSBhIGZhZGUgdGhhdCBsYXN0cyByYW1wVGltZVxuICAgKiAgQHBhcmFtICB7TnVtYmVyfSBbdGltZUZyb21Ob3ddIHNjaGVkdWxlIHRoaXMgZXZlbnQgdG8gaGFwcGVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRzIGZyb20gbm93XG4gICAqL1xuXG5cbiAgcDUuR2Fpbi5wcm90b3R5cGUuYW1wID0gZnVuY3Rpb24gKHZvbCwgcmFtcFRpbWUsIHRGcm9tTm93KSB7XG4gICAgdmFyIHJhbXBUaW1lID0gcmFtcFRpbWUgfHwgMDtcbiAgICB2YXIgdEZyb21Ob3cgPSB0RnJvbU5vdyB8fCAwO1xuICAgIHZhciBub3cgPSBwNXNvdW5kLmF1ZGlvY29udGV4dC5jdXJyZW50VGltZTtcbiAgICB2YXIgY3VycmVudFZvbCA9IHRoaXMub3V0cHV0LmdhaW4udmFsdWU7XG4gICAgdGhpcy5vdXRwdXQuZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMobm93KTtcbiAgICB0aGlzLm91dHB1dC5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKGN1cnJlbnRWb2wsIG5vdyArIHRGcm9tTm93KTtcbiAgICB0aGlzLm91dHB1dC5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZvbCwgbm93ICsgdEZyb21Ob3cgKyByYW1wVGltZSk7XG4gIH07XG5cbiAgcDUuR2Fpbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5kZXggPSBwNXNvdW5kLnNvdW5kQXJyYXkuaW5kZXhPZih0aGlzKTtcbiAgICBwNXNvdW5kLnNvdW5kQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIGlmICh0aGlzLm91dHB1dCkge1xuICAgICAgdGhpcy5vdXRwdXQuZGlzY29ubmVjdCgpO1xuICAgICAgZGVsZXRlIHRoaXMub3V0cHV0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlucHV0KSB7XG4gICAgICB0aGlzLmlucHV0LmRpc2Nvbm5lY3QoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmlucHV0O1xuICAgIH1cbiAgfTtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSksXG4gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXztcblxuIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAocmVxdWlyZSkge1xuICB2YXIgRWZmZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuXG4gIGZ1bmN0aW9uIG1ha2VEaXN0b3J0aW9uQ3VydmUoYW1vdW50KSB7XG4gICAgdmFyIGsgPSB0eXBlb2YgYW1vdW50ID09PSAnbnVtYmVyJyA/IGFtb3VudCA6IDUwO1xuICAgIHZhciBudW1TYW1wbGVzID0gNDQxMDA7XG4gICAgdmFyIGN1cnZlID0gbmV3IEZsb2F0MzJBcnJheShudW1TYW1wbGVzKTtcbiAgICB2YXIgZGVnID0gTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHg7XG5cbiAgICBmb3IgKDsgaSA8IG51bVNhbXBsZXM7ICsraSkge1xuICAgICAgeCA9IGkgKiAyIC8gbnVtU2FtcGxlcyAtIDE7XG4gICAgICBjdXJ2ZVtpXSA9ICgzICsgaykgKiB4ICogMjAgKiBkZWcgLyAoTWF0aC5QSSArIGsgKiBNYXRoLmFicyh4KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnZlO1xuICB9XG4gIC8qKlxuICAgKiBBIERpc3RvcnRpb24gZWZmZWN0IGNyZWF0ZWQgd2l0aCBhIFdhdmVzaGFwZXIgTm9kZSxcbiAgICogd2l0aCBhbiBhcHByb2FjaCBhZGFwdGVkIGZyb21cbiAgICogW0tldmluIEVubmlzXShodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIyMzEyODQxL3dhdmVzaGFwZXItbm9kZS1pbi13ZWJhdWRpby1ob3ctdG8tZW11bGF0ZS1kaXN0b3J0aW9uKVxuICAgKlxuICAgKiBUaGlzIGNsYXNzIGV4dGVuZHMgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdFwiPnA1LkVmZmVjdDwvYT4uXG4gICAqIE1ldGhvZHMgPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9hbXBcIj5hbXAoKTwvYT4sIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvY2hhaW5cIj5jaGFpbigpPC9hPixcbiAgICogPGEgaHJlZiA9IFwiL3JlZmVyZW5jZS8jL3A1LkVmZmVjdC9kcnl3ZXRcIj5kcnl3ZXQoKTwvYT4sIDxhIGhyZWYgPSBcIi9yZWZlcmVuY2UvIy9wNS5FZmZlY3QvY29ubmVjdFwiPmNvbm5lY3QoKTwvYT4sIGFuZFxuICAgKiA8YSBocmVmID0gXCIvcmVmZXJlbmNlLyMvcDUuRWZmZWN0L2Rpc2Nvbm5lY3RcIj5kaXNjb25uZWN0KCk8L2E+IGFyZSBhdmFpbGFibGUuXG4gICAqXG4gICAqIEBjbGFzcyBwNS5EaXN0b3J0aW9uXG4gICAqIEBleHRlbmRzIHA1LkVmZmVjdFxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFthbW91bnQ9MC4yNV0gVW5ib3VuZGVkIGRpc3RvcnRpb24gYW1vdW50LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTm9ybWFsIHZhbHVlcyByYW5nZSBmcm9tIDAtMS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvdmVyc2FtcGxlPSdub25lJ10gJ25vbmUnLCAnMngnLCBvciAnNHgnLlxuICAgKlxuICAgKi9cblxuXG4gIHA1LkRpc3RvcnRpb24gPSBmdW5jdGlvbiAoYW1vdW50LCBvdmVyc2FtcGxlKSB7XG4gICAgRWZmZWN0LmNhbGwodGhpcyk7XG5cbiAgICBpZiAodHlwZW9mIGFtb3VudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGFtb3VudCA9IDAuMjU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhbW91bnQgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Ftb3VudCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvdmVyc2FtcGxlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb3ZlcnNhbXBsZSA9ICcyeCc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvdmVyc2FtcGxlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdmVyc2FtcGxlIG11c3QgYmUgYSBTdHJpbmcnKTtcbiAgICB9XG5cbiAgICB2YXIgY3VydmVBbW91bnQgPSBwNS5wcm90b3R5cGUubWFwKGFtb3VudCwgMC4wLCAxLjAsIDAsIDIwMDApO1xuICAgIC8qKlxuICAgICAqICBUaGUgcDUuRGlzdG9ydGlvbiBpcyBidWlsdCB3aXRoIGFcbiAgICAgKiAgPGEgaHJlZj1cImh0dHA6Ly93d3cudzMub3JnL1RSL3dlYmF1ZGlvLyNXYXZlU2hhcGVyTm9kZVwiPlxuICAgICAqICBXZWIgQXVkaW8gV2F2ZVNoYXBlciBOb2RlPC9hPi5cbiAgICAgKlxuICAgICAqICBAcHJvcGVydHkge0F1ZGlvTm9kZX0gV2F2ZVNoYXBlck5vZGVcbiAgICAgKi9cblxuICAgIHRoaXMud2F2ZVNoYXBlck5vZGUgPSB0aGlzLmFjLmNyZWF0ZVdhdmVTaGFwZXIoKTtcbiAgICB0aGlzLmFtb3VudCA9IGN1cnZlQW1vdW50O1xuICAgIHRoaXMud2F2ZVNoYXBlck5vZGUuY3VydmUgPSBtYWtlRGlzdG9ydGlvbkN1cnZlKGN1cnZlQW1vdW50KTtcbiAgICB0aGlzLndhdmVTaGFwZXJOb2RlLm92ZXJzYW1wbGUgPSBvdmVyc2FtcGxlO1xuICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLndhdmVTaGFwZXJOb2RlKTtcbiAgICB0aGlzLndhdmVTaGFwZXJOb2RlLmNvbm5lY3QodGhpcy53ZXQpO1xuICB9O1xuXG4gIHA1LkRpc3RvcnRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFZmZlY3QucHJvdG90eXBlKTtcbiAgLyoqXG4gICAqIFByb2Nlc3MgYSBzb3VuZCBzb3VyY2UsIG9wdGlvbmFsbHkgc3BlY2lmeSBhbW91bnQgYW5kIG92ZXJzYW1wbGUgdmFsdWVzLlxuICAgKlxuICAgKiBAbWV0aG9kIHByb2Nlc3NcbiAgICogQGZvciBwNS5EaXN0b3J0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbYW1vdW50PTAuMjVdIFVuYm91bmRlZCBkaXN0b3J0aW9uIGFtb3VudC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5vcm1hbCB2YWx1ZXMgcmFuZ2UgZnJvbSAwLTEuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3ZlcnNhbXBsZT0nbm9uZSddICdub25lJywgJzJ4Jywgb3IgJzR4Jy5cbiAgICovXG5cbiAgcDUuRGlzdG9ydGlvbi5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChzcmMsIGFtb3VudCwgb3ZlcnNhbXBsZSkge1xuICAgIHNyYy5jb25uZWN0KHRoaXMuaW5wdXQpO1xuICAgIHRoaXMuc2V0KGFtb3VudCwgb3ZlcnNhbXBsZSk7XG4gIH07XG4gIC8qKlxuICAgKiBTZXQgdGhlIGFtb3VudCBhbmQgb3ZlcnNhbXBsZSBvZiB0aGUgd2F2ZXNoYXBlciBkaXN0b3J0aW9uLlxuICAgKlxuICAgKiBAbWV0aG9kIHNldFxuICAgKiBAZm9yIHA1LkRpc3RvcnRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFthbW91bnQ9MC4yNV0gVW5ib3VuZGVkIGRpc3RvcnRpb24gYW1vdW50LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTm9ybWFsIHZhbHVlcyByYW5nZSBmcm9tIDAtMS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvdmVyc2FtcGxlPSdub25lJ10gJ25vbmUnLCAnMngnLCBvciAnNHgnLlxuICAgKi9cblxuXG4gIHA1LkRpc3RvcnRpb24ucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChhbW91bnQsIG92ZXJzYW1wbGUpIHtcbiAgICBpZiAoYW1vdW50KSB7XG4gICAgICB2YXIgY3VydmVBbW91bnQgPSBwNS5wcm90b3R5cGUubWFwKGFtb3VudCwgMC4wLCAxLjAsIDAsIDIwMDApO1xuICAgICAgdGhpcy5hbW91bnQgPSBjdXJ2ZUFtb3VudDtcbiAgICAgIHRoaXMud2F2ZVNoYXBlck5vZGUuY3VydmUgPSBtYWtlRGlzdG9ydGlvbkN1cnZlKGN1cnZlQW1vdW50KTtcbiAgICB9XG5cbiAgICBpZiAob3ZlcnNhbXBsZSkge1xuICAgICAgdGhpcy53YXZlU2hhcGVyTm9kZS5vdmVyc2FtcGxlID0gb3ZlcnNhbXBsZTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiAgUmV0dXJuIHRoZSBkaXN0b3J0aW9uIGFtb3VudCwgdHlwaWNhbGx5IGJldHdlZW4gMC0xLlxuICAgKlxuICAgKiAgQG1ldGhvZCAgZ2V0QW1vdW50XG4gICAqICBAZm9yIHA1LkRpc3RvcnRpb25cbiAgICogIEByZXR1cm4ge051bWJlcn0gVW5ib3VuZGVkIGRpc3RvcnRpb24gYW1vdW50LlxuICAgKiAgICAgICAgICAgICAgICAgICBOb3JtYWwgdmFsdWVzIHJhbmdlIGZyb20gMC0xLlxuICAgKi9cblxuXG4gIHA1LkRpc3RvcnRpb24ucHJvdG90eXBlLmdldEFtb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5hbW91bnQ7XG4gIH07XG4gIC8qKlxuICAgKiAgUmV0dXJuIHRoZSBvdmVyc2FtcGxpbmcuXG4gICAqXG4gICAqICBAbWV0aG9kIGdldE92ZXJzYW1wbGVcbiAgICogIEBmb3IgcDUuRGlzdG9ydGlvblxuICAgKiAgQHJldHVybiB7U3RyaW5nfSBPdmVyc2FtcGxlIGNhbiBlaXRoZXIgYmUgJ25vbmUnLCAnMngnLCBvciAnNHgnLlxuICAgKi9cblxuXG4gIHA1LkRpc3RvcnRpb24ucHJvdG90eXBlLmdldE92ZXJzYW1wbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMud2F2ZVNoYXBlck5vZGUub3ZlcnNhbXBsZTtcbiAgfTtcblxuICBwNS5EaXN0b3J0aW9uLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIEVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5hcHBseSh0aGlzKTtcblxuICAgIGlmICh0aGlzLndhdmVTaGFwZXJOb2RlKSB7XG4gICAgICB0aGlzLndhdmVTaGFwZXJOb2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMud2F2ZVNoYXBlck5vZGUgPSBudWxsO1xuICAgIH1cbiAgfTtcbn0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4gfSlcbiBdKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/p5/lib/addons/p5.sound.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Fmichelangelo%2FDocuments%2FIngesoft%2F2023-1S_IngSoftware-PPC%2Fsrc%2Fpages%2Fsketch.tsx&page=%2Fsketch!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);